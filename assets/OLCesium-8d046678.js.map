{"version":3,"file":"OLCesium-8d046678.js","sources":["../../node_modules/ol/Overlay.js","../../node_modules/olcs/util.js","../../node_modules/ol/source/static.js","../../node_modules/ol/source/ImageStatic.js","../../node_modules/ol/source/TileWMS.js","../../node_modules/ol/source/Cluster.js","../../node_modules/olcs/core/OLImageryProvider.js","../../node_modules/olcs/MVTImageryProvider.js","../../node_modules/olcs/core.js","../../node_modules/olcs/AutoRenderLoop.js","../../node_modules/olcs/math.js","../../node_modules/olcs/Camera.js","../../node_modules/olcs/core/VectorLayerCounterpart.js","../../node_modules/olcs/AbstractSynchronizer.js","../../node_modules/olcs/RasterSynchronizer.js","../../node_modules/olcs/FeatureConverter.js","../../node_modules/olcs/VectorSynchronizer.js","../../node_modules/olcs/SynchronizedOverlay.js","../../node_modules/olcs/OverlaySynchronizer.js","../../node_modules/olcs/OLCesium.js"],"sourcesContent":["/**\n * @module ol/Overlay\n */\nimport BaseObject from './Object.js';\nimport MapEventType from './MapEventType.js';\nimport {CLASS_SELECTABLE} from './css.js';\nimport {containsExtent} from './extent.js';\nimport {listen, unlistenByKey} from './events.js';\nimport {outerHeight, outerWidth, removeChildren, removeNode} from './dom.js';\n\n/**\n * @typedef {'bottom-left' | 'bottom-center' | 'bottom-right' | 'center-left' | 'center-center' | 'center-right' | 'top-left' | 'top-center' | 'top-right'} Positioning\n * The overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, or `'top-right'`.\n */\n\n/**\n * @typedef {Object} Options\n * @property {number|string} [id] Set the overlay id. The overlay id can be used\n * with the {@link module:ol/Map~Map#getOverlayById} method.\n * @property {HTMLElement} [element] The overlay element.\n * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning\n * the overlay. The first element in the\n * array is the horizontal offset. A positive value shifts the overlay right.\n * The second element in the array is the vertical offset. A positive value\n * shifts the overlay down.\n * @property {import(\"./coordinate.js\").Coordinate} [position] The overlay position\n * in map projection.\n * @property {Positioning} [positioning='top-left'] Defines how\n * the overlay is actually positioned with respect to its `position` property.\n * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,\n * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,\n * `'top-center'`, and `'top-right'`.\n * @property {boolean} [stopEvent=true] Whether event propagation to the map\n * viewport should be stopped. If `true` the overlay is placed in the same\n * container as that of the controls (CSS class name\n * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container\n * with CSS class name specified by the `className` property.\n * @property {boolean} [insertFirst=true] Whether the overlay is inserted first\n * in the overlay container, or appended. If the overlay is placed in the same\n * container as that of the controls (see the `stopEvent` option) you will\n * probably set `insertFirst` to `true` so the overlay is displayed below the\n * controls.\n * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling\n * `setPosition`, so that the overlay is entirely visible in the current viewport.\n * @property {string} [className='ol-overlay-container ol-selectable'] CSS class\n * name.\n */\n\n/**\n * @typedef {Object} PanOptions\n * @property {number} [duration=1000] The duration of the animation in\n * milliseconds.\n * @property {function(number):number} [easing] The easing function to use. Can\n * be one from {@link module:ol/easing} or a custom function.\n * Default is {@link module:ol/easing.inAndOut}.\n */\n\n/**\n * @typedef {Object} PanIntoViewOptions\n * @property {PanOptions} [animation={}] The animation parameters for the pan\n * @property {number} [margin=20] The margin (in pixels) between the\n * overlay and the borders of the map when panning into view.\n */\n\n/**\n * @enum {string}\n * @protected\n */\nconst Property = {\n  ELEMENT: 'element',\n  MAP: 'map',\n  OFFSET: 'offset',\n  POSITION: 'position',\n  POSITIONING: 'positioning',\n};\n\n/**\n * @typedef {import(\"./ObjectEventType\").Types|'change:element'|'change:map'|'change:offset'|'change:position'|\n *   'change:positioning'} OverlayObjectEventTypes\n */\n\n/***\n * @template Return\n * @typedef {import(\"./Observable\").OnSignature<import(\"./Observable\").EventTypes, import(\"./events/Event.js\").default, Return> &\n *   import(\"./Observable\").OnSignature<OverlayObjectEventTypes, import(\"./Object\").ObjectEvent, Return> &\n *   import(\"./Observable\").CombinedOnSignature<import(\"./Observable\").EventTypes|OverlayObjectEventTypes, Return>} OverlayOnSignature\n */\n\n/**\n * @classdesc\n * An element to be displayed over the map and attached to a single map\n * location.  Like {@link module:ol/control/Control~Control}, Overlays are\n * visible widgets. Unlike Controls, they are not in a fixed position on the\n * screen, but are tied to a geographical coordinate, so panning the map will\n * move an Overlay but not a Control.\n *\n * Example:\n *\n *     import Overlay from 'ol/Overlay.js';\n *\n *     // ...\n *     const popup = new Overlay({\n *       element: document.getElementById('popup'),\n *     });\n *     popup.setPosition(coordinate);\n *     map.addOverlay(popup);\n *\n * @api\n */\nclass Overlay extends BaseObject {\n  /**\n   * @param {Options} options Overlay options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {OverlayOnSignature<import(\"./events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {OverlayOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @protected\n     * @type {Options}\n     */\n    this.options = options;\n\n    /**\n     * @protected\n     * @type {number|string|undefined}\n     */\n    this.id = options.id;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.insertFirst =\n      options.insertFirst !== undefined ? options.insertFirst : true;\n\n    /**\n     * @protected\n     * @type {boolean}\n     */\n    this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.element = document.createElement('div');\n    this.element.className =\n      options.className !== undefined\n        ? options.className\n        : 'ol-overlay-container ' + CLASS_SELECTABLE;\n    this.element.style.position = 'absolute';\n    this.element.style.pointerEvents = 'auto';\n\n    /**\n     * @protected\n     * @type {PanIntoViewOptions|undefined}\n     */\n    this.autoPan = options.autoPan === true ? {} : options.autoPan || undefined;\n\n    /**\n     * @protected\n     * @type {{transform_: string,\n     *         visible: boolean}}\n     */\n    this.rendered = {\n      transform_: '',\n      visible: true,\n    };\n\n    /**\n     * @protected\n     * @type {?import(\"./events.js\").EventsKey}\n     */\n    this.mapPostrenderListenerKey = null;\n\n    this.addChangeListener(Property.ELEMENT, this.handleElementChanged);\n    this.addChangeListener(Property.MAP, this.handleMapChanged);\n    this.addChangeListener(Property.OFFSET, this.handleOffsetChanged);\n    this.addChangeListener(Property.POSITION, this.handlePositionChanged);\n    this.addChangeListener(Property.POSITIONING, this.handlePositioningChanged);\n\n    if (options.element !== undefined) {\n      this.setElement(options.element);\n    }\n\n    this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);\n\n    this.setPositioning(options.positioning || 'top-left');\n\n    if (options.position !== undefined) {\n      this.setPosition(options.position);\n    }\n  }\n\n  /**\n   * Get the DOM element of this overlay.\n   * @return {HTMLElement|undefined} The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  getElement() {\n    return /** @type {HTMLElement|undefined} */ (this.get(Property.ELEMENT));\n  }\n\n  /**\n   * Get the overlay identifier which is set on constructor.\n   * @return {number|string|undefined} Id.\n   * @api\n   */\n  getId() {\n    return this.id;\n  }\n\n  /**\n   * Get the map associated with this overlay.\n   * @return {import(\"./Map.js\").default|null} The map that the\n   * overlay is part of.\n   * @observable\n   * @api\n   */\n  getMap() {\n    return /** @type {import(\"./Map.js\").default|null} */ (\n      this.get(Property.MAP) || null\n    );\n  }\n\n  /**\n   * Get the offset of this overlay.\n   * @return {Array<number>} The offset.\n   * @observable\n   * @api\n   */\n  getOffset() {\n    return /** @type {Array<number>} */ (this.get(Property.OFFSET));\n  }\n\n  /**\n   * Get the current position of this overlay.\n   * @return {import(\"./coordinate.js\").Coordinate|undefined} The spatial point that the overlay is\n   *     anchored at.\n   * @observable\n   * @api\n   */\n  getPosition() {\n    return /** @type {import(\"./coordinate.js\").Coordinate|undefined} */ (\n      this.get(Property.POSITION)\n    );\n  }\n\n  /**\n   * Get the current positioning of this overlay.\n   * @return {Positioning} How the overlay is positioned\n   *     relative to its point on the map.\n   * @observable\n   * @api\n   */\n  getPositioning() {\n    return /** @type {Positioning} */ (this.get(Property.POSITIONING));\n  }\n\n  /**\n   * @protected\n   */\n  handleElementChanged() {\n    removeChildren(this.element);\n    const element = this.getElement();\n    if (element) {\n      this.element.appendChild(element);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  handleMapChanged() {\n    if (this.mapPostrenderListenerKey) {\n      removeNode(this.element);\n      unlistenByKey(this.mapPostrenderListenerKey);\n      this.mapPostrenderListenerKey = null;\n    }\n    const map = this.getMap();\n    if (map) {\n      this.mapPostrenderListenerKey = listen(\n        map,\n        MapEventType.POSTRENDER,\n        this.render,\n        this\n      );\n      this.updatePixelPosition();\n      const container = this.stopEvent\n        ? map.getOverlayContainerStopEvent()\n        : map.getOverlayContainer();\n      if (this.insertFirst) {\n        container.insertBefore(this.element, container.childNodes[0] || null);\n      } else {\n        container.appendChild(this.element);\n      }\n      this.performAutoPan();\n    }\n  }\n\n  /**\n   * @protected\n   */\n  render() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * @protected\n   */\n  handleOffsetChanged() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * @protected\n   */\n  handlePositionChanged() {\n    this.updatePixelPosition();\n    this.performAutoPan();\n  }\n\n  /**\n   * @protected\n   */\n  handlePositioningChanged() {\n    this.updatePixelPosition();\n  }\n\n  /**\n   * Set the DOM element to be associated with this overlay.\n   * @param {HTMLElement|undefined} element The Element containing the overlay.\n   * @observable\n   * @api\n   */\n  setElement(element) {\n    this.set(Property.ELEMENT, element);\n  }\n\n  /**\n   * Set the map to be associated with this overlay.\n   * @param {import(\"./Map.js\").default|null} map The map that the\n   * overlay is part of. Pass `null` to just remove the overlay from the current map.\n   * @observable\n   * @api\n   */\n  setMap(map) {\n    this.set(Property.MAP, map);\n  }\n\n  /**\n   * Set the offset for this overlay.\n   * @param {Array<number>} offset Offset.\n   * @observable\n   * @api\n   */\n  setOffset(offset) {\n    this.set(Property.OFFSET, offset);\n  }\n\n  /**\n   * Set the position for this overlay. If the position is `undefined` the\n   * overlay is hidden.\n   * @param {import(\"./coordinate.js\").Coordinate|undefined} position The spatial point that the overlay\n   *     is anchored at.\n   * @observable\n   * @api\n   */\n  setPosition(position) {\n    this.set(Property.POSITION, position);\n  }\n\n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary) using the configured autoPan parameters\n   * @protected\n   */\n  performAutoPan() {\n    if (this.autoPan) {\n      this.panIntoView(this.autoPan);\n    }\n  }\n\n  /**\n   * Pan the map so that the overlay is entirely visible in the current viewport\n   * (if necessary).\n   * @param {PanIntoViewOptions} [panIntoViewOptions] Options for the pan action\n   * @api\n   */\n  panIntoView(panIntoViewOptions) {\n    const map = this.getMap();\n\n    if (!map || !map.getTargetElement() || !this.get(Property.POSITION)) {\n      return;\n    }\n\n    const mapRect = this.getRect(map.getTargetElement(), map.getSize());\n    const element = this.getElement();\n    const overlayRect = this.getRect(element, [\n      outerWidth(element),\n      outerHeight(element),\n    ]);\n\n    panIntoViewOptions = panIntoViewOptions || {};\n\n    const myMargin =\n      panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;\n    if (!containsExtent(mapRect, overlayRect)) {\n      // the overlay is not completely inside the viewport, so pan the map\n      const offsetLeft = overlayRect[0] - mapRect[0];\n      const offsetRight = mapRect[2] - overlayRect[2];\n      const offsetTop = overlayRect[1] - mapRect[1];\n      const offsetBottom = mapRect[3] - overlayRect[3];\n\n      const delta = [0, 0];\n      if (offsetLeft < 0) {\n        // move map to the left\n        delta[0] = offsetLeft - myMargin;\n      } else if (offsetRight < 0) {\n        // move map to the right\n        delta[0] = Math.abs(offsetRight) + myMargin;\n      }\n      if (offsetTop < 0) {\n        // move map up\n        delta[1] = offsetTop - myMargin;\n      } else if (offsetBottom < 0) {\n        // move map down\n        delta[1] = Math.abs(offsetBottom) + myMargin;\n      }\n\n      if (delta[0] !== 0 || delta[1] !== 0) {\n        const center = /** @type {import(\"./coordinate.js\").Coordinate} */ (\n          map.getView().getCenterInternal()\n        );\n        const centerPx = map.getPixelFromCoordinateInternal(center);\n        if (!centerPx) {\n          return;\n        }\n        const newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];\n\n        const panOptions = panIntoViewOptions.animation || {};\n        map.getView().animateInternal({\n          center: map.getCoordinateFromPixelInternal(newCenterPx),\n          duration: panOptions.duration,\n          easing: panOptions.easing,\n        });\n      }\n    }\n  }\n\n  /**\n   * Get the extent of an element relative to the document\n   * @param {HTMLElement} element The element.\n   * @param {import(\"./size.js\").Size} size The size of the element.\n   * @return {import(\"./extent.js\").Extent} The extent.\n   * @protected\n   */\n  getRect(element, size) {\n    const box = element.getBoundingClientRect();\n    const offsetX = box.left + window.pageXOffset;\n    const offsetY = box.top + window.pageYOffset;\n    return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];\n  }\n\n  /**\n   * Set the positioning for this overlay.\n   * @param {Positioning} positioning how the overlay is\n   *     positioned relative to its point on the map.\n   * @observable\n   * @api\n   */\n  setPositioning(positioning) {\n    this.set(Property.POSITIONING, positioning);\n  }\n\n  /**\n   * Modify the visibility of the element.\n   * @param {boolean} visible Element visibility.\n   * @protected\n   */\n  setVisible(visible) {\n    if (this.rendered.visible !== visible) {\n      this.element.style.display = visible ? '' : 'none';\n      this.rendered.visible = visible;\n    }\n  }\n\n  /**\n   * Update pixel position.\n   * @protected\n   */\n  updatePixelPosition() {\n    const map = this.getMap();\n    const position = this.getPosition();\n    if (!map || !map.isRendered() || !position) {\n      this.setVisible(false);\n      return;\n    }\n\n    const pixel = map.getPixelFromCoordinate(position);\n    const mapSize = map.getSize();\n    this.updateRenderedPosition(pixel, mapSize);\n  }\n\n  /**\n   * @param {import(\"./pixel.js\").Pixel} pixel The pixel location.\n   * @param {import(\"./size.js\").Size|undefined} mapSize The map size.\n   * @protected\n   */\n  updateRenderedPosition(pixel, mapSize) {\n    const style = this.element.style;\n    const offset = this.getOffset();\n\n    const positioning = this.getPositioning();\n\n    this.setVisible(true);\n\n    const x = Math.round(pixel[0] + offset[0]) + 'px';\n    const y = Math.round(pixel[1] + offset[1]) + 'px';\n    let posX = '0%';\n    let posY = '0%';\n    if (\n      positioning == 'bottom-right' ||\n      positioning == 'center-right' ||\n      positioning == 'top-right'\n    ) {\n      posX = '-100%';\n    } else if (\n      positioning == 'bottom-center' ||\n      positioning == 'center-center' ||\n      positioning == 'top-center'\n    ) {\n      posX = '-50%';\n    }\n    if (\n      positioning == 'bottom-left' ||\n      positioning == 'bottom-center' ||\n      positioning == 'bottom-right'\n    ) {\n      posY = '-100%';\n    } else if (\n      positioning == 'center-left' ||\n      positioning == 'center-center' ||\n      positioning == 'center-right'\n    ) {\n      posY = '-50%';\n    }\n    const transform = `translate(${posX}, ${posY}) translate(${x}, ${y})`;\n    if (this.rendered.transform_ != transform) {\n      this.rendered.transform_ = transform;\n      style.transform = transform;\n    }\n  }\n\n  /**\n   * returns the options this Overlay has been created with\n   * @return {Options} overlay options\n   */\n  getOptions() {\n    return this.options;\n  }\n}\n\nexport default Overlay;\n","/**\n * @module olcs.util\n */\n/**\n * Cast to object.\n * @param {Object} param\n * @return {Object}\n */\nexport function obj(param) {\n    return param;\n}\n/**\n * @type {boolean|undefined}\n * @private\n */\nlet supportsImageRenderingPixelatedResult_ = undefined;\n/**\n * @type {string|undefined}\n * @private\n */\nlet imageRenderingValueResult_ = undefined;\n/**\n * @return {boolean}\n */\nexport function supportsImageRenderingPixelated() {\n    if (supportsImageRenderingPixelatedResult_ === undefined) {\n        const canvas = document.createElement('canvas');\n        canvas.setAttribute('style', 'image-rendering: -moz-crisp-edges; image-rendering: pixelated;');\n        // canvas.style.imageRendering will be undefined, null or an\n        // empty string on unsupported browsers.\n        const tmp = canvas.style['imageRendering']; // non standard\n        supportsImageRenderingPixelatedResult_ = !!tmp;\n        if (supportsImageRenderingPixelatedResult_) {\n            imageRenderingValueResult_ = tmp;\n        }\n    }\n    return supportsImageRenderingPixelatedResult_;\n}\n/**\n * @return {string}\n */\nexport function imageRenderingValue() {\n    supportsImageRenderingPixelated();\n    return imageRenderingValueResult_ || '';\n}\n/**\n * Return the projection of the source that Cesium should use.\n *\n * @param {ol.source.Source} source Source.\n * @returns {ol.proj.Projection} The projection of the source.\n */\nexport function getSourceProjection(source) {\n    return /** @type {ol.proj.Projection} */ (source.get('olcs.projection'))\n        || source.getProjection();\n}\n/**\n * @param {ol.Observable} observable\n * @param {string} type\n * @param {Function} listener\n * @return {!ol.events.EventsKey}\n */\nexport function olcsListen(observable, type, listener) {\n    // See https://github.com/openlayers/openlayers/pull/8481\n    // ol.events.listen is internal so we use `on` instead.\n    // And since `on` as a convoluted API (can return an EventsKey or an array of them)\n    // we use a cast here.\n    return /** @type {!ol.events.EventsKey} */ (observable.on(type, listener));\n}\n/**\n * Counter for getUid.\n * @type {number}\n */\nlet uidCounter_ = 0;\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {number} The unique ID for the object.\n */\nexport function getUid(obj) {\n    return obj.olcs_uid || (obj.olcs_uid = ++uidCounter_);\n}\n/**\n * Sort the passed array such that the relative order of equal elements is preverved.\n * See https://en.wikipedia.org/wiki/Sorting_algorithm#Stability for details.\n * @param {Array<*>} arr The array to sort (modifies original).\n * @param {!function(*, *): number} compareFnc Comparison function.\n */\nexport function stableSort(arr, compareFnc) {\n    const length = arr.length;\n    const tmp = Array(arr.length);\n    for (let i = 0; i < length; i++) {\n        tmp[i] = { index: i, value: arr[i] };\n    }\n    tmp.sort((a, b) => compareFnc(a.value, b.value) || a.index - b.index);\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = tmp[i].value;\n    }\n}\n/**\n * @param {Node} node The node to remove.\n * @returns {Node} The node that was removed or null.\n */\nexport function removeNode(node) {\n    return node && node.parentNode ? node.parentNode.removeChild(node) : null;\n}\n/**\n * @param {Node} node The node to remove the children from.\n */\nexport function removeChildren(node) {\n    while (node.lastChild) {\n        node.removeChild(node.lastChild);\n    }\n}\n/**\n * @param {Cesium.Scene} scene The scene.\n */\nexport function isGroundPolylinePrimitiveSupported(scene) {\n    const obj = Cesium.GroundPolylinePrimitive;\n    return obj && obj.isSupported(scene);\n}\nexport function waitReady(object) {\n    const p = object.readyPromise;\n    if (p) {\n        return p;\n    }\n    if (object.ready !== undefined) {\n        if (object.ready) {\n            return Promise.resolve(object);\n        }\n        return new Promise((resolve, _) => {\n            // FIXME: this is crazy\n            // alternative: intercept _ready = true\n            // altnerative: pass a timeout\n            const stopper = setInterval(() => {\n                if (object.ready) {\n                    clearInterval(stopper);\n                    resolve(object);\n                }\n            }, 20);\n        });\n    }\n    return Promise.reject('Not a readyable object');\n}\n","/**\n * @module ol/source/static\n */\n\nimport {decode} from '../Image.js';\nimport {getHeight, getWidth} from '../extent.js';\n\n/**\n * @typedef {Object} LoaderOptions\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {import(\"../extent.js\").Extent} [imageExtent] Extent of the image in map coordinates.\n * This is the [left, bottom, right, top] map coordinates of your image. When using this loader with an\n * `ol/source/Image`, the same extent must be set as `extent` of the `ol/layer/Image`.\n * @property {string} url Image URL.\n * @property {function(HTMLImageElement, string): Promise<import('../DataTile.js').ImageLike>} [load] Function\n * to perform loading of the image. Receives the created `HTMLImageElement` and the desired `src` as argument and\n * returns a promise resolving to the loaded or decoded image. Default is {@link module:ol/Image.decode}.\n */\n\n/**\n * Creates a loader for static images.\n * @param {LoaderOptions} options Loader options.\n * @return {import(\"../Image.js\").ImageObjectPromiseLoader} Loader.\n * @api\n */\nexport function createLoader(options) {\n  const load = options.load || decode;\n  const extent = options.imageExtent;\n  const image = new Image();\n  if (options.crossOrigin !== null) {\n    image.crossOrigin = options.crossOrigin;\n  }\n\n  return () =>\n    load(image, options.url).then((image) => {\n      const resolutionX = getWidth(extent) / image.width;\n      const resolutionY = getHeight(extent) / image.height;\n      const resolution =\n        resolutionX !== resolutionY ? [resolutionX, resolutionY] : resolutionY;\n      return {image, extent, resolution, pixelRatio: 1};\n    });\n}\n","/**\n * @module ol/source/ImageStatic\n */\n\nimport EventType from '../events/EventType.js';\nimport ImageSource, {defaultImageLoadFunction} from './Image.js';\nimport ImageWrapper, {decode} from '../Image.js';\nimport {createLoader} from './static.js';\nimport {get as getProjection} from '../proj.js';\nimport {intersects} from '../extent.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {import(\"../extent.js\").Extent} imageExtent Extent of the image in map coordinates.\n * This is the [left, bottom, right, top] map coordinates of your image.\n * @property {import(\"../Image.js\").LoadFunction} [imageLoadFunction] Optional function to load an image given a URL.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {string} url Image URL.\n */\n\n/**\n * @classdesc\n * A layer source for displaying a single, static image.\n * @api\n */\nclass Static extends ImageSource {\n  /**\n   * @param {Options} options ImageStatic options.\n   */\n  constructor(options) {\n    const crossOrigin =\n      options.crossOrigin !== undefined ? options.crossOrigin : null;\n\n    const /** @type {import(\"../Image.js\").LoadFunction} */ imageLoadFunction =\n        options.imageLoadFunction !== undefined\n          ? options.imageLoadFunction\n          : defaultImageLoadFunction;\n\n    super({\n      attributions: options.attributions,\n      interpolate: options.interpolate,\n      projection: getProjection(options.projection),\n    });\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.url_ = options.url;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.imageExtent_ = options.imageExtent;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").default}\n     */\n    this.image = null;\n\n    this.image = new ImageWrapper(\n      this.imageExtent_,\n      undefined,\n      1,\n      createLoader({\n        url: options.url,\n        imageExtent: options.imageExtent,\n        crossOrigin,\n        load: (image, src) => {\n          this.image.setImage(image);\n          imageLoadFunction(this.image, src);\n          return decode(image);\n        },\n      })\n    );\n\n    this.image.addEventListener(\n      EventType.CHANGE,\n      this.handleImageChange.bind(this)\n    );\n  }\n\n  /**\n   * Returns the image extent\n   * @return {import(\"../extent.js\").Extent} image extent.\n   * @api\n   */\n  getImageExtent() {\n    return this.imageExtent_;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    if (intersects(extent, this.image.getExtent())) {\n      return this.image;\n    }\n    return null;\n  }\n\n  /**\n   * Return the URL used for this image source.\n   * @return {string} URL.\n   * @api\n   */\n  getUrl() {\n    return this.url_;\n  }\n}\n\nexport default Static;\n","/**\n * @module ol/source/TileWMS\n */\n\nimport TileImage from './TileImage.js';\nimport {DEFAULT_VERSION, getImageSrc, getRequestParams} from './wms.js';\nimport {appendParams} from '../uri.js';\nimport {buffer, createEmpty} from '../extent.js';\nimport {calculateSourceResolution} from '../reproj.js';\nimport {compareVersions} from '../string.js';\nimport {get as getProjection, transform} from '../proj.js';\nimport {modulo} from '../math.js';\nimport {hash as tileCoordHash} from '../tilecoord.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that\n * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.\n * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {Object<string,*>} params WMS request parameters.\n * At least a `LAYERS` param is required. `STYLES` is\n * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`\n * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.\n * @property {number} [gutter=0]\n * The size in pixels of the gutter around image tiles to ignore. By setting\n * this property to a non-zero value, images will be requested that are wider\n * and taller than the tile size by a value of `2 x gutter`.\n * Using a non-zero value allows artifacts of rendering at tile edges to be\n * ignored. If you control the WMS service it is recommended to address\n * \"artifacts at tile edges\" issues by properly configuring the WMS service. For\n * example, MapServer has a `tile_map_edge_buffer` configuration parameter for\n * this. See https://mapserver.org/output/tile_mode.html.\n * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting\n * the image from the remote server.\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection. Default is the view projection.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {typeof import(\"../ImageTile.js\").default} [tileClass] Class used to instantiate image tiles.\n * Default is {@link module:ol/ImageTile~ImageTile}.\n * @property {import(\"../tilegrid/TileGrid.js\").default} [tileGrid] Tile grid. Base this on the resolutions,\n * tilesize and extent supported by the server.\n * If this is not defined, a default grid will be used: if there is a projection\n * extent, the grid will be based on that; if not, a grid based on a global\n * extent with origin at 0,0 will be used.\n * @property {import(\"./wms.js\").ServerType} [serverType] The type of\n * the remote WMS server: `mapserver`, `geoserver`, `carmentaserver`, or `qgis`.\n * Only needed if `hidpi` is `true`.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {string} [url] WMS service URL.\n * @property {Array<string>} [urls] WMS service urls.\n * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * When set to `false`, only one world\n * will be rendered. When `true`, tiles will be requested for one world only,\n * but they will be wrapped horizontally to render multiple worlds.\n * @property {number} [transition] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n\n/**\n * @classdesc\n * Layer source for tile data from WMS servers.\n * @api\n */\nclass TileWMS extends TileImage {\n  /**\n   * @param {Options} [options] Tile WMS options.\n   */\n  constructor(options) {\n    options = options ? options : /** @type {Options} */ ({});\n\n    const params = Object.assign({}, options.params);\n\n    const transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;\n\n    super({\n      attributions: options.attributions,\n      attributionsCollapsible: options.attributionsCollapsible,\n      cacheSize: options.cacheSize,\n      crossOrigin: options.crossOrigin,\n      interpolate: options.interpolate,\n      opaque: !transparent,\n      projection: options.projection,\n      reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n      tileClass: options.tileClass,\n      tileGrid: options.tileGrid,\n      tileLoadFunction: options.tileLoadFunction,\n      url: options.url,\n      urls: options.urls,\n      wrapX: options.wrapX !== undefined ? options.wrapX : true,\n      transition: options.transition,\n      zDirection: options.zDirection,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = options.gutter !== undefined ? options.gutter : 0;\n\n    /**\n     * @private\n     * @type {!Object}\n     */\n    this.params_ = params;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.v13_ = true;\n\n    /**\n     * @private\n     * @type {import(\"./wms.js\").ServerType}\n     */\n    this.serverType_ = options.serverType;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.tmpExtent_ = createEmpty();\n\n    this.updateV13_();\n    this.setKey(this.getKeyForParams_());\n  }\n\n  /**\n   * Return the GetFeatureInfo URL for the passed coordinate, resolution, and\n   * projection. Return `undefined` if the GetFeatureInfo URL cannot be\n   * constructed.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj.js\").ProjectionLike} projection Projection.\n   * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should\n   *     be provided. If `QUERY_LAYERS` is not provided then the layers specified\n   *     in the `LAYERS` parameter will be used. `VERSION` should not be\n   *     specified here.\n   * @return {string|undefined} GetFeatureInfo URL.\n   * @api\n   */\n  getFeatureInfoUrl(coordinate, resolution, projection, params) {\n    const projectionObj = getProjection(projection);\n    const sourceProjectionObj = this.getProjection() || projectionObj;\n\n    let tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(sourceProjectionObj);\n    }\n\n    const sourceProjCoord = transform(\n      coordinate,\n      projectionObj,\n      sourceProjectionObj\n    );\n    const sourceResolution = calculateSourceResolution(\n      sourceProjectionObj,\n      projectionObj,\n      coordinate,\n      resolution\n    );\n\n    const z = tileGrid.getZForResolution(sourceResolution, this.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n    const tileCoord = tileGrid.getTileCoordForCoordAndZ(sourceProjCoord, z);\n\n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return undefined;\n    }\n\n    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\n\n    const gutter = this.gutter_;\n    if (gutter !== 0) {\n      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);\n    }\n\n    const baseParams = {\n      'QUERY_LAYERS': this.params_['LAYERS'],\n    };\n    Object.assign(\n      baseParams,\n      getRequestParams(this.params_, 'GetFeatureInfo'),\n      params\n    );\n\n    const x = Math.floor((sourceProjCoord[0] - tileExtent[0]) / tileResolution);\n    const y = Math.floor((tileExtent[3] - sourceProjCoord[1]) / tileResolution);\n\n    baseParams[this.v13_ ? 'I' : 'X'] = x;\n    baseParams[this.v13_ ? 'J' : 'Y'] = y;\n\n    return this.getRequestUrl_(\n      tileCoord,\n      tileExtent,\n      1,\n      sourceProjectionObj || projectionObj,\n      baseParams\n    );\n  }\n\n  /**\n   * Return the GetLegendGraphic URL, optionally optimized for the passed\n   * resolution and possibly including any passed specific parameters. Returns\n   * `undefined` if the GetLegendGraphic URL cannot be constructed.\n   *\n   * @param {number} [resolution] Resolution. If set to undefined, `SCALE`\n   *     will not be calculated and included in URL.\n   * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the\n   *     request is generated for this wms layer, else it will try to use the\n   *     configured wms layer. Default `FORMAT` is `image/png`.\n   *     `VERSION` should not be specified here.\n   * @return {string|undefined} GetLegendGraphic URL.\n   * @api\n   */\n  getLegendUrl(resolution, params) {\n    if (this.urls[0] === undefined) {\n      return undefined;\n    }\n\n    const baseParams = {\n      'SERVICE': 'WMS',\n      'VERSION': DEFAULT_VERSION,\n      'REQUEST': 'GetLegendGraphic',\n      'FORMAT': 'image/png',\n    };\n\n    if (params === undefined || params['LAYER'] === undefined) {\n      const layers = this.params_.LAYERS;\n      const isSingleLayer = !Array.isArray(layers) || layers.length === 1;\n      if (!isSingleLayer) {\n        return undefined;\n      }\n      baseParams['LAYER'] = layers;\n    }\n\n    if (resolution !== undefined) {\n      const mpu = this.getProjection()\n        ? this.getProjection().getMetersPerUnit()\n        : 1;\n      const pixelSize = 0.00028;\n      baseParams['SCALE'] = (resolution * mpu) / pixelSize;\n    }\n\n    Object.assign(baseParams, params);\n\n    return appendParams(/** @type {string} */ (this.urls[0]), baseParams);\n  }\n\n  /**\n   * @return {number} Gutter.\n   */\n  getGutter() {\n    return this.gutter_;\n  }\n\n  /**\n   * Get the user-provided params, i.e. those passed to the constructor through\n   * the \"params\" option, and possibly updated using the updateParams method.\n   * @return {Object} Params.\n   * @api\n   */\n  getParams() {\n    return this.params_;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n   * @param {import(\"../extent.js\").Extent} tileExtent Tile extent.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @param {Object} params Params.\n   * @return {string|undefined} Request URL.\n   * @private\n   */\n  getRequestUrl_(tileCoord, tileExtent, pixelRatio, projection, params) {\n    const urls = this.urls;\n    if (!urls) {\n      return undefined;\n    }\n    let url;\n    if (urls.length == 1) {\n      url = urls[0];\n    } else {\n      const index = modulo(tileCoordHash(tileCoord), urls.length);\n      url = urls[index];\n    }\n\n    return getImageSrc(\n      tileExtent,\n      (\n        this.tileGrid || this.getTileGridForProjection(projection)\n      ).getResolution(tileCoord[0]),\n      pixelRatio,\n      projection,\n      url,\n      params,\n      this.serverType_\n    );\n  }\n\n  /**\n   * Get the tile pixel ratio for this source.\n   * @param {number} pixelRatio Pixel ratio.\n   * @return {number} Tile pixel ratio.\n   */\n  getTilePixelRatio(pixelRatio) {\n    return !this.hidpi_ || this.serverType_ === undefined ? 1 : pixelRatio;\n  }\n\n  /**\n   * @private\n   * @return {string} The key for the current params.\n   */\n  getKeyForParams_() {\n    let i = 0;\n    const res = [];\n    for (const key in this.params_) {\n      res[i++] = key + '-' + this.params_[key];\n    }\n    return res.join('/');\n  }\n\n  /**\n   * Update the user-provided params.\n   * @param {Object} params Params.\n   * @api\n   */\n  updateParams(params) {\n    Object.assign(this.params_, params);\n    this.updateV13_();\n    this.setKey(this.getKeyForParams_());\n  }\n\n  /**\n   * @private\n   */\n  updateV13_() {\n    const version = this.params_['VERSION'] || DEFAULT_VERSION;\n    this.v13_ = compareVersions(version, '1.3') >= 0;\n  }\n\n  /**\n   * @param {import(\"../tilecoord.js\").TileCoord} tileCoord The tile coordinate\n   * @param {number} pixelRatio The pixel ratio\n   * @param {import(\"../proj/Projection.js\").default} projection The projection\n   * @return {string|undefined} The tile URL\n   * @override\n   */\n  tileUrlFunction(tileCoord, pixelRatio, projection) {\n    let tileGrid = this.getTileGrid();\n    if (!tileGrid) {\n      tileGrid = this.getTileGridForProjection(projection);\n    }\n\n    if (tileGrid.getResolutions().length <= tileCoord[0]) {\n      return undefined;\n    }\n\n    if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {\n      pixelRatio = 1;\n    }\n\n    const tileResolution = tileGrid.getResolution(tileCoord[0]);\n    let tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);\n\n    const gutter = this.gutter_;\n    if (gutter !== 0) {\n      tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);\n    }\n\n    const baseParams = Object.assign(\n      {},\n      getRequestParams(this.params_, 'GetMap')\n    );\n\n    return this.getRequestUrl_(\n      tileCoord,\n      tileExtent,\n      pixelRatio,\n      projection,\n      baseParams\n    );\n  }\n}\n\nexport default TileWMS;\n","/**\n * @module ol/source/Cluster\n */\n\nimport EventType from '../events/EventType.js';\nimport Feature from '../Feature.js';\nimport Point from '../geom/Point.js';\nimport VectorSource from './Vector.js';\nimport {add as addCoordinate, scale as scaleCoordinate} from '../coordinate.js';\nimport {assert} from '../asserts.js';\nimport {\n  buffer,\n  createEmpty,\n  createOrUpdateFromCoordinate,\n  getCenter,\n} from '../extent.js';\nimport {getUid} from '../util.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {number} [distance=20] Distance in pixels within which features will\n * be clustered together.\n * @property {number} [minDistance=0] Minimum distance in pixels between clusters.\n * Will be capped at the configured distance.\n * By default no minimum distance is guaranteed. This config can be used to avoid\n * overlapping icons. As a tradoff, the cluster feature's position will no longer be\n * the center of all its features.\n * @property {function(Feature):Point} [geometryFunction]\n * Function that takes an {@link module:ol/Feature~Feature} as argument and returns an\n * {@link module:ol/geom/Point~Point} as cluster calculation point for the feature. When a\n * feature should not be considered for clustering, the function should return\n * `null`. The default, which works when the underlying source contains point\n * features only, is\n * ```js\n * function(feature) {\n *   return feature.getGeometry();\n * }\n * ```\n * See {@link module:ol/geom/Polygon~Polygon#getInteriorPoint} for a way to get a cluster\n * calculation point for polygons.\n * @property {function(Point, Array<Feature>):Feature} [createCluster]\n * Function that takes the cluster's center {@link module:ol/geom/Point~Point} and an array\n * of {@link module:ol/Feature~Feature} included in this cluster. Must return a\n * {@link module:ol/Feature~Feature} that will be used to render. Default implementation is:\n * ```js\n * function(point, features) {\n *   return new Feature({\n *     geometry: point,\n *     features: features\n *   });\n * }\n * ```\n * @property {VectorSource} [source=null] Source.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n */\n\n/**\n * @classdesc\n * Layer source to cluster vector data. Works out of the box with point\n * geometries. For other geometry types, or if not all geometries should be\n * considered for clustering, a custom `geometryFunction` can be defined.\n *\n * If the instance is disposed without also disposing the underlying\n * source `setSource(null)` has to be called to remove the listener reference\n * from the wrapped source.\n * @api\n */\nclass Cluster extends VectorSource {\n  /**\n   * @param {Options} options Cluster options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      wrapX: options.wrapX,\n    });\n\n    /**\n     * @type {number|undefined}\n     * @protected\n     */\n    this.resolution = undefined;\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.distance = options.distance !== undefined ? options.distance : 20;\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.minDistance = options.minDistance || 0;\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.interpolationRatio = 0;\n\n    /**\n     * @type {Array<Feature>}\n     * @protected\n     */\n    this.features = [];\n\n    /**\n     * @param {Feature} feature Feature.\n     * @return {Point} Cluster calculation point.\n     * @protected\n     */\n    this.geometryFunction =\n      options.geometryFunction ||\n      function (feature) {\n        const geometry = /** @type {Point} */ (feature.getGeometry());\n        assert(\n          !geometry || geometry.getType() === 'Point',\n          'The default `geometryFunction` can only handle `Point` or null geometries'\n        );\n        return geometry;\n      };\n\n    /**\n     * @type {function(Point, Array<Feature>):Feature}\n     * @private\n     */\n    this.createCustomCluster_ = options.createCluster;\n\n    /**\n     * @type {VectorSource|null}\n     * @protected\n     */\n    this.source = null;\n\n    /**\n     * @private\n     */\n    this.boundRefresh_ = this.refresh.bind(this);\n\n    this.updateDistance(this.distance, this.minDistance);\n    this.setSource(options.source || null);\n  }\n\n  /**\n   * Remove all features from the source.\n   * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/VectorEventType~VectorEventType#removefeature} events.\n   * @api\n   */\n  clear(fast) {\n    this.features.length = 0;\n    super.clear(fast);\n  }\n\n  /**\n   * Get the distance in pixels between clusters.\n   * @return {number} Distance.\n   * @api\n   */\n  getDistance() {\n    return this.distance;\n  }\n\n  /**\n   * Get a reference to the wrapped source.\n   * @return {VectorSource|null} Source.\n   * @api\n   */\n  getSource() {\n    return this.source;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   */\n  loadFeatures(extent, resolution, projection) {\n    this.source.loadFeatures(extent, resolution, projection);\n    if (resolution !== this.resolution) {\n      this.resolution = resolution;\n      this.refresh();\n    }\n  }\n\n  /**\n   * Set the distance within which features will be clusterd together.\n   * @param {number} distance The distance in pixels.\n   * @api\n   */\n  setDistance(distance) {\n    this.updateDistance(distance, this.minDistance);\n  }\n\n  /**\n   * Set the minimum distance between clusters. Will be capped at the\n   * configured distance.\n   * @param {number} minDistance The minimum distance in pixels.\n   * @api\n   */\n  setMinDistance(minDistance) {\n    this.updateDistance(this.distance, minDistance);\n  }\n\n  /**\n   * The configured minimum distance between clusters.\n   * @return {number} The minimum distance in pixels.\n   * @api\n   */\n  getMinDistance() {\n    return this.minDistance;\n  }\n\n  /**\n   * Replace the wrapped source.\n   * @param {VectorSource|null} source The new source for this instance.\n   * @api\n   */\n  setSource(source) {\n    if (this.source) {\n      this.source.removeEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.source = source;\n    if (source) {\n      source.addEventListener(EventType.CHANGE, this.boundRefresh_);\n    }\n    this.refresh();\n  }\n\n  /**\n   * Handle the source changing.\n   */\n  refresh() {\n    this.clear();\n    this.cluster();\n    this.addFeatures(this.features);\n  }\n\n  /**\n   * Update the distances and refresh the source if necessary.\n   * @param {number} distance The new distance.\n   * @param {number} minDistance The new minimum distance.\n   */\n  updateDistance(distance, minDistance) {\n    const ratio =\n      distance === 0 ? 0 : Math.min(minDistance, distance) / distance;\n    const changed =\n      distance !== this.distance || this.interpolationRatio !== ratio;\n    this.distance = distance;\n    this.minDistance = minDistance;\n    this.interpolationRatio = ratio;\n    if (changed) {\n      this.refresh();\n    }\n  }\n\n  /**\n   * @protected\n   */\n  cluster() {\n    if (this.resolution === undefined || !this.source) {\n      return;\n    }\n    const extent = createEmpty();\n    const mapDistance = this.distance * this.resolution;\n    const features = this.source.getFeatures();\n\n    /** @type {Object<string, true>} */\n    const clustered = {};\n\n    for (let i = 0, ii = features.length; i < ii; i++) {\n      const feature = features[i];\n      if (!(getUid(feature) in clustered)) {\n        const geometry = this.geometryFunction(feature);\n        if (geometry) {\n          const coordinates = geometry.getCoordinates();\n          createOrUpdateFromCoordinate(coordinates, extent);\n          buffer(extent, mapDistance, extent);\n\n          const neighbors = this.source\n            .getFeaturesInExtent(extent)\n            .filter(function (neighbor) {\n              const uid = getUid(neighbor);\n              if (uid in clustered) {\n                return false;\n              }\n              clustered[uid] = true;\n              return true;\n            });\n          this.features.push(this.createCluster(neighbors, extent));\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Array<Feature>} features Features\n   * @param {import(\"../extent.js\").Extent} extent The searched extent for these features.\n   * @return {Feature} The cluster feature.\n   * @protected\n   */\n  createCluster(features, extent) {\n    const centroid = [0, 0];\n    for (let i = features.length - 1; i >= 0; --i) {\n      const geometry = this.geometryFunction(features[i]);\n      if (geometry) {\n        addCoordinate(centroid, geometry.getCoordinates());\n      } else {\n        features.splice(i, 1);\n      }\n    }\n    scaleCoordinate(centroid, 1 / features.length);\n    const searchCenter = getCenter(extent);\n    const ratio = this.interpolationRatio;\n    const geometry = new Point([\n      centroid[0] * (1 - ratio) + searchCenter[0] * ratio,\n      centroid[1] * (1 - ratio) + searchCenter[1] * ratio,\n    ]);\n    if (this.createCustomCluster_) {\n      return this.createCustomCluster_(geometry, features);\n    }\n    return new Feature({\n      geometry,\n      features,\n    });\n  }\n}\n\nexport default Cluster;\n","/**\n * @module olcs.core.OLImageryProvider\n */\nimport { getSourceProjection } from '../util.js';\nimport { Tile as TileSource } from 'ol/source.js';\nimport { attributionsFunctionToCredits } from '../core.js';\nconst olUseNewCoordinates = (function () {\n    const tileSource = new TileSource({\n        projection: 'EPSG:3857',\n        wrapX: true\n    });\n    const tileCoord = tileSource.getTileCoordForTileUrlFunction([6, -31, 22]);\n    return tileCoord && tileCoord[1] === 33 && tileCoord[2] === 22;\n    // See b/test/spec/ol/source/tile.test.js\n    // of e9a30c5cb7e3721d9370025fbe5472c322847b35 in OpenLayers repository\n})();\nclass OLImageryProvider /* should not extend Cesium.ImageryProvider */ {\n    /**\n     * Special class derived from Cesium.ImageryProvider\n     * that is connected to the given ol.source.TileImage.\n     * @param {!ol.Map} olMap\n     * @param {!ol.source.TileImage} source\n     * @param {ol.proj.Projection=} opt_fallbackProj Projection to assume if the\n     *                                               projection of the source is not defined.\n     * @constructor\n     * @extends {Cesium.ImageryProvider}\n     */\n    constructor(olMap, source, opt_fallbackProj) {\n        // Do not extend or call super constructor from\n        // Cesium.ImageryProvider since this particular function is a\n        // 'non instanciable interface' which throws on instanciation.\n        /**\n         * @type {!ol.source.TileImage}\n         * @private\n         */\n        this.source_ = source;\n        /**\n         * @type {?ol.proj.Projection}\n         * @private\n         */\n        this.projection_ = null;\n        /**\n         * @type {?ol.proj.Projection}\n         * @private\n         */\n        this.fallbackProj_ = opt_fallbackProj || null;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.ready_ = false;\n        /**\n         * @type {?Cesium.TilingScheme}\n         * @private\n         */\n        this.tilingScheme_ = new Cesium.WebMercatorTilingScheme(); // cesium v107+ don't wait for ready anymore\n        /**\n         * @type {?Cesium.Rectangle}\n         * @private\n         */\n        this.rectangle_ = null;\n        /**\n         * @type {!ol.Map}\n         * @private\n         */\n        this.map_ = olMap;\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.shouldRequestNextLevel = false;\n        const proxy = this.source_.get('olcs.proxy');\n        if (proxy) {\n            if (typeof proxy === 'function') {\n                this.proxy_ = {\n                    'getURL': proxy\n                };\n            }\n            else if (typeof proxy === 'string') {\n                this.proxy_ = new Cesium.DefaultProxy(proxy);\n            }\n        }\n        this.errorEvent_ = new Cesium.Event();\n        this.emptyCanvas_ = document.createElement('canvas');\n        this.emptyCanvas_.width = 1;\n        this.emptyCanvas_.height = 1;\n        this.source_.on('change', (e) => {\n            this.handleSourceChanged_();\n        });\n        this.handleSourceChanged_();\n    }\n    /**\n     * Checks if the underlying source is ready and cached required data.\n     * @private\n     */\n    handleSourceChanged_(frameState) {\n        if (!this.ready_ && this.source_.getState() == 'ready') {\n            this.projection_ = getSourceProjection(this.source_) || this.fallbackProj_;\n            const options = { numberOfLevelZeroTilesX: 1, numberOfLevelZeroTilesY: 1 };\n            if (this.source_.tileGrid !== null) {\n                // Get the number of tiles at level 0 if it is defined\n                this.source_.tileGrid.forEachTileCoord(this.projection_.getExtent(), 0, ([zoom, xIndex, yIndex]) => {\n                    options.numberOfLevelZeroTilesX = xIndex + 1;\n                    options.numberOfLevelZeroTilesY = yIndex + 1;\n                });\n            }\n            if (this.projection_.getCode() === 'EPSG:4326') {\n                // Cesium zoom level 0 is OpenLayers zoom level 1 for layer in EPSG:4326 with a single tile on level 0\n                this.shouldRequestNextLevel = options.numberOfLevelZeroTilesX === 1 && options.numberOfLevelZeroTilesY === 1;\n                this.tilingScheme_ = new Cesium.GeographicTilingScheme(options);\n            }\n            else if (this.projection_.getCode() === 'EPSG:3857') {\n                this.shouldRequestNextLevel = false;\n                this.tilingScheme_ = new Cesium.WebMercatorTilingScheme(options);\n            }\n            else {\n                return;\n            }\n            this.rectangle_ = this.tilingScheme_.rectangle;\n            this.ready_ = true;\n        }\n    }\n    /**\n     * Generates the proper attributions for a given position and zoom\n     * level.\n     * @export\n     * @override\n     */\n    getTileCredits(x, y, level) {\n        const attributionsFunction = this.source_.getAttributions();\n        if (!attributionsFunction) {\n            return [];\n        }\n        const extent = this.map_.getView().calculateExtent(this.map_.getSize());\n        const center = this.map_.getView().getCenter();\n        const zoom = this.shouldRequestNextLevel ? level + 1 : level;\n        return attributionsFunctionToCredits(attributionsFunction, zoom, center, extent);\n    }\n    /**\n     * @export\n     * @override\n     */\n    requestImage(x, y, level) {\n        const tileUrlFunction = this.source_.getTileUrlFunction();\n        if (tileUrlFunction && this.projection_) {\n            const z_ = this.shouldRequestNextLevel ? level + 1 : level;\n            let y_ = y;\n            if (!olUseNewCoordinates) {\n                // OpenLayers version 3 to 5 tile coordinates increase from bottom to top\n                y_ = -y - 1;\n            }\n            let url = tileUrlFunction.call(this.source_, [z_, x, y_], 1, this.projection_);\n            if (this.proxy_) {\n                url = this.proxy_.getURL(url);\n            }\n            return url ? Cesium.ImageryProvider.loadImage(this, url) : this.emptyCanvas_;\n        }\n        else {\n            // return empty canvas to stop Cesium from retrying later\n            return this.emptyCanvas_;\n        }\n    }\n}\n// definitions of getters that are required to be present\n// in the Cesium.ImageryProvider instance:\nObject.defineProperties(OLImageryProvider.prototype, {\n    'ready': {\n        'get': /** @this {olcs.core.OLImageryProvider} */ function () { return this.ready_; }\n    },\n    '_ready': {\n        'get': /** @this {olcs.core.OLImageryProvider} */ function () { return this.ready_; }\n    },\n    'rectangle': {\n        'get': /** @this {olcs.core.OLImageryProvider} */ function () { return this.rectangle_; }\n    },\n    'tileWidth': {\n        'get': /** @this {olcs.core.OLImageryProvider} */ function () {\n            const tg = this.source_.getTileGrid();\n            return tg ? (Array.isArray(tg.getTileSize(0)) ? tg.getTileSize(0)[0] : tg.getTileSize(0)) : 256;\n        }\n    },\n    'tileHeight': {\n        'get': /** @this {olcs.core.OLImageryProvider} */ function () {\n            const tg = this.source_.getTileGrid();\n            return tg ? (Array.isArray(tg.getTileSize(0)) ? tg.getTileSize(0)[1] : tg.getTileSize(0)) : 256;\n        }\n    },\n    'maximumLevel': {\n        'get': /** @this {olcs.core.OLImageryProvider} */ function () {\n            const tg = this.source_.getTileGrid();\n            return tg ? tg.getMaxZoom() : 18;\n        }\n    },\n    'minimumLevel': {\n        'get': /** @this {olcs.core.OLImageryProvider} */ function () {\n            // WARNING: Do not use the minimum level (at least until the extent is\n            // properly set). Cesium assumes the minimumLevel to contain only\n            // a few tiles and tries to load them all at once -- this can\n            // freeze and/or crash the browser !\n            return 0;\n            //var tg = this.source_.getTileGrid();\n            //return tg ? tg.getMinZoom() : 0;\n        }\n    },\n    'tilingScheme': {\n        'get': /** @this {olcs.core.OLImageryProvider} */ function () { return this.tilingScheme_; }\n    },\n    'tileDiscardPolicy': {\n        'get': function () { return undefined; }\n    },\n    'errorEvent': {\n        'get': /** @this {olcs.core.OLImageryProvider} */ function () { return this.errorEvent_; }\n    },\n    'proxy': {\n        'get': /** @this {olcs.core.OLImageryProvider} */ function () { return this.proxy_; }\n    },\n    'hasAlphaChannel': {\n        'get': function () { return true; }\n    },\n    'pickFeatures': {\n        'get': function () { return undefined; }\n    }\n});\nexport default OLImageryProvider;\n","import MVT from 'ol/format/MVT.js';\nimport Style from 'ol/style/Style.js';\nimport Stroke from 'ol/style/Stroke.js';\nimport { toContext } from 'ol/render.js';\nimport { get as getProjection } from 'ol/proj.js';\nimport { VERSION as OL_VERSION } from 'ol/util.js';\nimport LRUCache from 'ol/structs/LRUCache.js';\nimport { getForProjection as getTilegridForProjection } from 'ol/tilegrid.js';\nimport { createFromTemplates as createTileUrlFunctions } from 'ol/tileurlfunction.js';\nconst format = new MVT();\nconst styles = [new Style({\n        stroke: new Stroke({\n            color: 'blue',\n            width: 2\n        })\n    })];\nexport default class MVTImageryProvider {\n    constructor(options) {\n        this.urls = options.urls;\n        this.ready = true;\n        this.readyPromise = Promise.resolve(true);\n        this.tileWidth = 256;\n        this.tileHeight = 256;\n        this.maximumLevel = options.maximumLevel || 20;\n        this.minimumLevel = options.minimumLevel || 0;\n        this.tilingScheme = new Cesium.WebMercatorTilingScheme;\n        this.rectangle = options.rectangle || this.tilingScheme.rectangle;\n        this.errorEvent = new Cesium.Event();\n        this.credit = options.credit;\n        this.hasAlphaChannel = true;\n        this.styleFunction_ = options.styleFunction || (() => styles);\n        this.projection_ = getProjection('EPSG:3857');\n        this.emptyCanvas_ = document.createElement('canvas');\n        this.emptyCanvas_.width = 1;\n        this.emptyCanvas_.height = 1;\n        this.tileRectangle_ = new Cesium.Rectangle();\n        const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 50;\n        this.tileCache = new LRUCache(cacheSize);\n        this.featureCache = options.featureCache || new LRUCache(cacheSize);\n        // to avoid too frequent cache grooming we allow x2 capacity\n        const tileGrid = getTilegridForProjection(this.projection_);\n        this.tileFunction_ = createTileUrlFunctions(this.urls, tileGrid);\n    }\n    getTileCredits() {\n        return [];\n    }\n    pickFeatures() {\n    }\n    getTileFeatures(z, x, y) {\n        const cacheKey = this.getCacheKey_(z, x, y);\n        let promise;\n        if (this.featureCache.containsKey(cacheKey)) {\n            promise = this.featureCache.get(cacheKey);\n        }\n        if (!promise) {\n            const url = this.getUrl_(z, x, y);\n            promise = fetch(url)\n                .then(r => (r.ok ? r : Promise.reject(r)))\n                .then(r => r.arrayBuffer())\n                .then(buffer => this.readFeaturesFromBuffer(buffer));\n            this.featureCache.set(cacheKey, promise);\n            if (this.featureCache.getCount() > 2 * this.featureCache.highWaterMark) {\n                while (this.featureCache.canExpireCache()) {\n                    this.featureCache.pop();\n                }\n            }\n        }\n        return promise;\n    }\n    readFeaturesFromBuffer(buffer) {\n        let options;\n        if (OL_VERSION <= '6.4.4') {\n            // See https://github.com/openlayers/openlayers/pull/11540\n            options = {\n                extent: [0, 0, 4096, 4096],\n                dataProjection: format.dataProjection,\n                featureProjection: format.dataProjection\n            };\n        }\n        const features = format.readFeatures(buffer, options);\n        const scaleFactor = this.tileWidth / 4096;\n        features.forEach((f) => {\n            const flatCoordinates = f.getFlatCoordinates();\n            let flip = false;\n            for (let i = 0; i < flatCoordinates.length; ++i) {\n                flatCoordinates[i] *= scaleFactor;\n                if (flip) {\n                    // FIXME: why do we need this now?\n                    flatCoordinates[i] = this.tileWidth - flatCoordinates[i];\n                }\n                if (OL_VERSION <= '6.4.4') {\n                    flip = !flip;\n                }\n            }\n        });\n        return features;\n    }\n    getUrl_(z, x, y) {\n        const url = this.tileFunction_([z, x, y]);\n        return url;\n    }\n    getCacheKey_(z, x, y) {\n        return `${z}_${x}_${y}`;\n    }\n    requestImage(x, y, z, request) {\n        if (z < this.minimumLevel) {\n            return this.emptyCanvas_;\n        }\n        try {\n            const cacheKey = this.getCacheKey_(z, x, y);\n            let promise;\n            if (this.tileCache.containsKey(cacheKey)) {\n                promise = this.tileCache.get(cacheKey);\n            }\n            if (!promise) {\n                promise = this.getTileFeatures(z, x, y)\n                    .then((features) => {\n                    // FIXME: here we suppose the 2D projection is in meters\n                    this.tilingScheme.tileXYToNativeRectangle(x, y, z, this.tileRectangle_);\n                    const resolution = (this.tileRectangle_.east - this.tileRectangle_.west) / this.tileWidth;\n                    return this.rasterizeFeatures(features, this.styleFunction_, resolution);\n                });\n                this.tileCache.set(cacheKey, promise);\n                if (this.tileCache.getCount() > 2 * this.tileCache.highWaterMark) {\n                    while (this.tileCache.canExpireCache()) {\n                        this.tileCache.pop();\n                    }\n                }\n            }\n            return promise;\n        }\n        catch (e) {\n            console.trace(e);\n            this.raiseEvent('could not render pbf to tile', e);\n        }\n    }\n    rasterizeFeatures(features, styleFunction, resolution) {\n        const canvas = document.createElement('canvas');\n        const vectorContext = toContext(canvas.getContext('2d'), { size: [this.tileWidth, this.tileHeight] });\n        features.forEach((f) => {\n            const styles = styleFunction(f, resolution);\n            if (styles) {\n                styles.forEach((style) => {\n                    vectorContext.setStyle(style);\n                    vectorContext.drawGeometry(f);\n                });\n            }\n        });\n        return canvas;\n    }\n}\n","/**\n * @module olcs.core\n */\nimport { linear as linearEasing } from 'ol/easing.js';\nimport olLayerTile from 'ol/layer/Tile.js';\nimport olLayerImage from 'ol/layer/Image.js';\nimport { get as getProjection, transformExtent } from 'ol/proj.js';\nimport olSourceImageStatic from 'ol/source/ImageStatic.js';\nimport olSourceImageWMS from 'ol/source/ImageWMS.js';\nimport olSourceTileImage from 'ol/source/TileImage.js';\nimport olSourceTileWMS from 'ol/source/TileWMS.js';\nimport olSourceVectorTile from 'ol/source/VectorTile.js';\nimport { defaultImageLoadFunction } from 'ol/source/Image.js';\nimport olcsCoreOLImageryProvider from './core/OLImageryProvider.js';\nimport { getSourceProjection } from './util.js';\nimport MVTImageryProvider from './MVTImageryProvider.js';\nimport VectorTileLayer from 'ol/layer/VectorTile.js';\nimport { getCenter as getExtentCenter } from 'ol/extent.js';\nimport BaseLayer from 'ol/layer/Base.js';\nimport LayerGroup from 'ol/layer/Group.js';\nimport Geometry from 'ol/geom/Geometry.js';\nimport Source from 'ol/source/Source.js';\nimport Map from 'ol/Map.js';\nimport Projection from 'ol/proj/Projection.js';\nimport View from 'ol/View.js';\n/**\n * Compute the pixel width and height of a point in meters using the\n * camera frustum.\n */\nexport function computePixelSizeAtCoordinate(scene, target) {\n    const camera = scene.camera;\n    const canvas = scene.canvas;\n    const frustum = camera.frustum;\n    const distance = Cesium.Cartesian3.magnitude(Cesium.Cartesian3.subtract(camera.position, target, new Cesium.Cartesian3()));\n    // @ts-ignore TS2341\n    return frustum.getPixelDimensions(canvas.clientWidth, canvas.clientHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());\n}\n/**\n * Compute bounding box around a target point.\n * @param {!Cesium.Scene} scene\n * @param {!Cesium.Cartesian3} target\n * @param {number} amount Half the side of the box, in pixels.\n * @return {Array<Cesium.Cartographic>} bottom left and top right\n * coordinates of the box\n */\nexport function computeBoundingBoxAtTarget(scene, target, amount) {\n    const pixelSize = computePixelSizeAtCoordinate(scene, target);\n    const transform = Cesium.Transforms.eastNorthUpToFixedFrame(target);\n    const bottomLeft = Cesium.Matrix4.multiplyByPoint(transform, new Cesium.Cartesian3(-pixelSize.x * amount, -pixelSize.y * amount, 0), new Cesium.Cartesian3());\n    const topRight = Cesium.Matrix4.multiplyByPoint(transform, new Cesium.Cartesian3(pixelSize.x * amount, pixelSize.y * amount, 0), new Cesium.Cartesian3());\n    return Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray([bottomLeft, topRight]);\n}\nexport function applyHeightOffsetToGeometry(geometry, height) {\n    geometry.applyTransform((input, output, stride) => {\n        console.assert(input === output);\n        if (stride !== undefined && stride >= 3) {\n            for (let i = 0; i < output.length; i += stride) {\n                output[i + 2] = output[i + 2] + height;\n            }\n        }\n        return output;\n    });\n}\nexport function createMatrixAtCoordinates(coordinates, rotation = 0, translation = Cesium.Cartesian3.ZERO, scale = new Cesium.Cartesian3(1, 1, 1)) {\n    const position = ol4326CoordinateToCesiumCartesian(coordinates);\n    const rawMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);\n    const quaternion = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Z, -rotation);\n    const rotationMatrix = Cesium.Matrix4.fromTranslationQuaternionRotationScale(translation, quaternion, scale);\n    return Cesium.Matrix4.multiply(rawMatrix, rotationMatrix, new Cesium.Matrix4());\n}\nexport function rotateAroundAxis(camera, angle, axis, transform, opt_options) {\n    const clamp = Cesium.Math.clamp;\n    const defaultValue = Cesium.defaultValue;\n    const options = opt_options;\n    const duration = defaultValue(options?.duration, 500); // ms\n    const easing = defaultValue(options?.easing, linearEasing);\n    const callback = options?.callback;\n    let lastProgress = 0;\n    const oldTransform = new Cesium.Matrix4();\n    const start = Date.now();\n    const step = function () {\n        const timestamp = Date.now();\n        const timeDifference = timestamp - start;\n        const progress = easing(clamp(timeDifference / duration, 0, 1));\n        console.assert(progress >= lastProgress);\n        camera.transform.clone(oldTransform);\n        const stepAngle = (progress - lastProgress) * angle;\n        lastProgress = progress;\n        camera.lookAtTransform(transform);\n        camera.rotate(axis, stepAngle);\n        camera.lookAtTransform(oldTransform);\n        if (progress < 1) {\n            window.requestAnimationFrame(step);\n        }\n        else {\n            if (callback) {\n                callback();\n            }\n        }\n    };\n    window.requestAnimationFrame(step);\n}\nexport function setHeadingUsingBottomCenter(scene, heading, bottomCenter, options) {\n    const camera = scene.camera;\n    // Compute the camera position to zenith quaternion\n    const angleToZenith = computeAngleToZenith(scene, bottomCenter);\n    const axis = camera.right;\n    const quaternion = Cesium.Quaternion.fromAxisAngle(axis, angleToZenith);\n    const rotation = Cesium.Matrix3.fromQuaternion(quaternion);\n    // Get the zenith point from the rotation of the position vector\n    const vector = new Cesium.Cartesian3();\n    Cesium.Cartesian3.subtract(camera.position, bottomCenter, vector);\n    const zenith = new Cesium.Cartesian3();\n    Cesium.Matrix3.multiplyByVector(rotation, vector, zenith);\n    Cesium.Cartesian3.add(zenith, bottomCenter, zenith);\n    // Actually rotate around the zenith normal\n    const transform = Cesium.Matrix4.fromTranslation(zenith);\n    rotateAroundAxis(camera, heading, zenith, transform, options);\n}\n/**\n * Get the 3D position of the given pixel of the canvas.\n */\nexport function pickOnTerrainOrEllipsoid(scene, pixel) {\n    const ray = scene.camera.getPickRay(pixel);\n    const target = scene.globe.pick(ray, scene);\n    return target || scene.camera.pickEllipsoid(pixel);\n}\n/**\n * Get the 3D position of the point at the bottom-center of the screen.\n */\nexport function pickBottomPoint(scene) {\n    const canvas = scene.canvas;\n    const bottom = new Cesium.Cartesian2(canvas.clientWidth / 2, canvas.clientHeight);\n    return pickOnTerrainOrEllipsoid(scene, bottom);\n}\n/**\n * Get the 3D position of the point at the center of the screen.\n */\nexport function pickCenterPoint(scene) {\n    const canvas = scene.canvas;\n    const center = new Cesium.Cartesian2(canvas.clientWidth / 2, canvas.clientHeight / 2);\n    return pickOnTerrainOrEllipsoid(scene, center);\n}\n/**\n * Compute the signed tilt angle on globe, between the opposite of the\n * camera direction and the target normal. Return undefined if there is no\n */\nexport function computeSignedTiltAngleOnGlobe(scene) {\n    const camera = scene.camera;\n    const ray = new Cesium.Ray(camera.position, camera.direction);\n    let target = scene.globe.pick(ray, scene);\n    if (!target) {\n        // no tiles in the area were loaded?\n        const ellipsoid = Cesium.Ellipsoid.WGS84;\n        const obj = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);\n        if (obj) {\n            target = Cesium.Ray.getPoint(ray, obj.start);\n        }\n    }\n    if (!target) {\n        return undefined;\n    }\n    const normal = new Cesium.Cartesian3();\n    Cesium.Ellipsoid.WGS84.geocentricSurfaceNormal(target, normal);\n    const angleBetween = signedAngleBetween;\n    const angle = angleBetween(camera.direction, normal, camera.right) - Math.PI;\n    return Cesium.Math.convertLongitudeRange(angle);\n}\n/**\n * Compute the ray from the camera to the bottom-center of the screen.\n */\nexport function bottomFovRay(scene) {\n    const camera = scene.camera;\n    // @ts-ignore TS2341\n    const fovy2 = camera.frustum.fovy / 2;\n    const direction = camera.direction;\n    const rotation = Cesium.Quaternion.fromAxisAngle(camera.right, fovy2);\n    const matrix = Cesium.Matrix3.fromQuaternion(rotation);\n    const vector = new Cesium.Cartesian3();\n    Cesium.Matrix3.multiplyByVector(matrix, direction, vector);\n    return new Cesium.Ray(camera.position, vector);\n}\n/**\n * Compute the angle between two Cartesian3.\n */\nexport function signedAngleBetween(first, second, normal) {\n    // We are using the dot for the angle.\n    // Then the cross and the dot for the sign.\n    const a = new Cesium.Cartesian3();\n    const b = new Cesium.Cartesian3();\n    const c = new Cesium.Cartesian3();\n    Cesium.Cartesian3.normalize(first, a);\n    Cesium.Cartesian3.normalize(second, b);\n    Cesium.Cartesian3.cross(a, b, c);\n    const cosine = Cesium.Cartesian3.dot(a, b);\n    const sine = Cesium.Cartesian3.magnitude(c);\n    // Sign of the vector product and the orientation normal\n    const sign = Cesium.Cartesian3.dot(normal, c);\n    const angle = Math.atan2(sine, cosine);\n    return sign >= 0 ? angle : -angle;\n}\n/**\n * Compute the rotation angle around a given point, needed to reach the\n * zenith position.\n * At a zenith position, the camera direction is going througth the earth\n * center and the frustrum bottom ray is going through the chosen pivot\n * point.\n * The bottom-center of the screen is a good candidate for the pivot point.\n */\nexport function computeAngleToZenith(scene, pivot) {\n    // This angle is the sum of the angles 'fy' and 'a', which are defined\n    // using the pivot point and its surface normal.\n    //        Zenith |    camera\n    //           \\   |   /\n    //            \\fy|  /\n    //             \\ |a/\n    //              \\|/pivot\n    const camera = scene.camera;\n    // @ts-ignore TS2341\n    const fy = camera.frustum.fovy / 2;\n    const ray = bottomFovRay(scene);\n    const direction = Cesium.Cartesian3.clone(ray.direction);\n    Cesium.Cartesian3.negate(direction, direction);\n    const normal = new Cesium.Cartesian3();\n    Cesium.Ellipsoid.WGS84.geocentricSurfaceNormal(pivot, normal);\n    const left = new Cesium.Cartesian3();\n    Cesium.Cartesian3.negate(camera.right, left);\n    const a = signedAngleBetween(normal, direction, left);\n    return a + fy;\n}\n/**\n * Convert an OpenLayers extent to a Cesium rectangle.\n * @param {ol.Extent} extent Extent.\n * @param {ol.ProjectionLike} projection Extent projection.\n * @return {Cesium.Rectangle} The corresponding Cesium rectangle.\n */\nexport function extentToRectangle(extent, projection) {\n    if (extent && projection) {\n        const ext = transformExtent(extent, projection, 'EPSG:4326');\n        return Cesium.Rectangle.fromDegrees(ext[0], ext[1], ext[2], ext[3]);\n    }\n    else {\n        return null;\n    }\n}\nexport function sourceToImageryProvider(olMap, source, viewProj, olLayer) {\n    const skip = source.get('olcs_skip');\n    if (skip) {\n        return null;\n    }\n    let provider = null;\n    // Convert ImageWMS to TileWMS\n    if (source instanceof olSourceImageWMS && source.getUrl() &&\n        source.getImageLoadFunction() === defaultImageLoadFunction) {\n        const sourceProps = {\n            'olcs.proxy': source.get('olcs.proxy'),\n            'olcs.extent': source.get('olcs.extent'),\n            'olcs.projection': source.get('olcs.projection'),\n            'olcs.imagesource': source\n        };\n        source = new olSourceTileWMS({\n            url: source.getUrl(),\n            attributions: source.getAttributions(),\n            projection: source.getProjection(),\n            params: source.getParams()\n        });\n        source.setProperties(sourceProps);\n    }\n    if (source instanceof olSourceTileImage) {\n        let projection = getSourceProjection(source);\n        if (!projection) {\n            // if not explicit, assume the same projection as view\n            projection = viewProj;\n        }\n        if (isCesiumProjection(projection)) {\n            provider = new olcsCoreOLImageryProvider(olMap, source, viewProj);\n        }\n        // Projection not supported by Cesium\n        else {\n            return null;\n        }\n    }\n    else if (source instanceof olSourceImageStatic) {\n        let projection = getSourceProjection(source);\n        if (!projection) {\n            projection = viewProj;\n        }\n        if (isCesiumProjection(projection)) {\n            const rectangle = Cesium.Rectangle.fromDegrees(source.getImageExtent()[0], source.getImageExtent()[1], source.getImageExtent()[2], source.getImageExtent()[3], new Cesium.Rectangle());\n            provider = new Cesium.SingleTileImageryProvider({\n                url: source.getUrl(),\n                rectangle\n            });\n        }\n        // Projection not supported by Cesium\n        else {\n            return null;\n        }\n    }\n    else if (source instanceof olSourceVectorTile && olLayer instanceof VectorTileLayer) {\n        let projection = getSourceProjection(source);\n        if (!projection) {\n            projection = viewProj;\n        }\n        if (skip === false) {\n            // MVT is experimental, it should be whitelisted to be synchronized\n            const fromCode = projection.getCode().split(':')[1];\n            // @ts-ignore TS2341\n            const urls = source.urls.map(u => u.replace(fromCode, '3857'));\n            const extent = olLayer.getExtent();\n            const rectangle = extentToRectangle(extent, projection);\n            const minimumLevel = source.get('olcs_minimumLevel');\n            const attributionsFunction = source.getAttributions();\n            const styleFunction = olLayer.getStyleFunction();\n            let credit;\n            if (extent && attributionsFunction) {\n                const center = getExtentCenter(extent);\n                credit = attributionsFunctionToCredits(attributionsFunction, 0, center, extent)[0];\n            }\n            provider = new MVTImageryProvider({\n                credit,\n                rectangle,\n                minimumLevel,\n                styleFunction,\n                urls\n            });\n            return provider;\n        }\n        return null; // FIXME: it is disabled by default right now\n    }\n    else {\n        // sources other than TileImage|Imageexport function are currently not supported\n        return null;\n    }\n    return provider;\n}\n/**\n * Creates Cesium.ImageryLayer best corresponding to the given ol.layer.Layer.\n * Only supports raster layers and export function images\n */\nexport function tileLayerToImageryLayer(olMap, olLayer, viewProj) {\n    if (!(olLayer instanceof olLayerTile) && !(olLayer instanceof olLayerImage) &&\n        !(olLayer instanceof VectorTileLayer)) {\n        return null;\n    }\n    const source = olLayer.getSource();\n    if (!source) {\n        return null;\n    }\n    let provider = source.get('olcs_provider');\n    if (!provider) {\n        provider = sourceToImageryProvider(olMap, source, viewProj, olLayer);\n    }\n    if (!provider) {\n        return null;\n    }\n    const layerOptions = {};\n    const forcedExtent = (olLayer.get('olcs.extent'));\n    const ext = forcedExtent || olLayer.getExtent();\n    if (ext) {\n        layerOptions.rectangle = extentToRectangle(ext, viewProj);\n    }\n    const cesiumLayer = new Cesium.ImageryLayer(provider, layerOptions);\n    return cesiumLayer;\n}\n/**\n * Synchronizes the layer rendering properties (opacity, visible)\n * to the given Cesium ImageryLayer.\n */\nexport function updateCesiumLayerProperties(olLayerWithParents, csLayer) {\n    let opacity = 1;\n    let visible = true;\n    [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach((olLayer) => {\n        const layerOpacity = olLayer.getOpacity();\n        if (layerOpacity !== undefined) {\n            opacity *= layerOpacity;\n        }\n        const layerVisible = olLayer.getVisible();\n        if (layerVisible !== undefined) {\n            visible = visible && layerVisible;\n        }\n    });\n    csLayer.alpha = opacity;\n    csLayer.show = visible;\n}\n/**\n * Convert a 2D or 3D OpenLayers coordinate to Cesium.\n */\nexport function ol4326CoordinateToCesiumCartesian(coordinate) {\n    const coo = coordinate;\n    return coo.length > 2 ?\n        Cesium.Cartesian3.fromDegrees(coo[0], coo[1], coo[2]) :\n        Cesium.Cartesian3.fromDegrees(coo[0], coo[1]);\n}\n/**\n * Convert an array of 2D or 3D OpenLayers coordinates to Cesium.\n */\nexport function ol4326CoordinateArrayToCsCartesians(coordinates) {\n    console.assert(coordinates !== null);\n    const toCartesian = ol4326CoordinateToCesiumCartesian;\n    const cartesians = [];\n    for (let i = 0; i < coordinates.length; ++i) {\n        cartesians.push(toCartesian(coordinates[i]));\n    }\n    return cartesians;\n}\n/**\n * Reproject an OpenLayers geometry to EPSG:4326 if needed.\n * The geometry will be cloned only when original projection is not EPSG:4326\n * and the properties will be shallow copied.\n */\nexport function olGeometryCloneTo4326(geometry, projection) {\n    console.assert(projection);\n    const proj4326 = getProjection('EPSG:4326');\n    const proj = getProjection(projection);\n    if (proj.getCode() !== proj4326.getCode()) {\n        const properties = geometry.getProperties();\n        geometry = geometry.clone();\n        geometry.transform(proj, proj4326);\n        geometry.setProperties(properties);\n    }\n    return geometry;\n}\n/**\n * Convert an OpenLayers color to Cesium.\n */\nexport function convertColorToCesium(olColor) {\n    olColor = olColor || 'black';\n    if (Array.isArray(olColor)) {\n        return new Cesium.Color(Cesium.Color.byteToFloat(olColor[0]), Cesium.Color.byteToFloat(olColor[1]), Cesium.Color.byteToFloat(olColor[2]), olColor[3]);\n    }\n    else if (typeof olColor == 'string') {\n        return Cesium.Color.fromCssColorString(olColor);\n    }\n    else if (olColor instanceof CanvasPattern || olColor instanceof CanvasGradient) {\n        // Render the CanvasPattern/CanvasGradient into a canvas that will be sent to Cesium as material\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.width = canvas.height = 256;\n        ctx.fillStyle = olColor;\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        return new Cesium.ImageMaterialProperty({\n            image: canvas\n        });\n    }\n    console.assert(false, 'impossible');\n}\n/**\n * Convert an OpenLayers url to Cesium.\n */\nexport function convertUrlToCesium(url) {\n    let subdomains = '';\n    const re = /\\{(\\d|[a-z])-(\\d|[a-z])\\}/;\n    const match = re.exec(url);\n    if (match) {\n        url = url.replace(re, '{s}');\n        const startCharCode = match[1].charCodeAt(0);\n        const stopCharCode = match[2].charCodeAt(0);\n        let charCode;\n        for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n            subdomains += String.fromCharCode(charCode);\n        }\n    }\n    return {\n        url,\n        subdomains\n    };\n}\n/**\n * Animate the return to a top-down view from the zenith.\n * The camera is rotated to orient to the North.\n */\nexport function resetToNorthZenith(map, scene) {\n    return new Promise((resolve, reject) => {\n        const camera = scene.camera;\n        const pivot = pickBottomPoint(scene);\n        if (!pivot) {\n            reject('Could not get bottom pivot');\n            return;\n        }\n        const currentHeading = map.getView().getRotation();\n        if (currentHeading === undefined) {\n            reject('The view is not initialized');\n            return;\n        }\n        const angle = computeAngleToZenith(scene, pivot);\n        // Point to North\n        setHeadingUsingBottomCenter(scene, currentHeading, pivot);\n        // Go to zenith\n        const transform = Cesium.Matrix4.fromTranslation(pivot);\n        const axis = camera.right;\n        const options = {\n            callback: () => {\n                const view = map.getView();\n                normalizeView(view);\n                resolve(undefined);\n            }\n        };\n        rotateAroundAxis(camera, -angle, axis, transform, options);\n    });\n}\n/**\n * @param {!Cesium.Scene} scene\n * @param {number} angle in radian\n * @return {Promise<undefined>}\n * @api\n */\nexport function rotateAroundBottomCenter(scene, angle) {\n    return new Promise((resolve, reject) => {\n        const camera = scene.camera;\n        const pivot = pickBottomPoint(scene);\n        if (!pivot) {\n            reject('could not get bottom pivot');\n            return;\n        }\n        const options = { callback: () => resolve(undefined) };\n        const transform = Cesium.Matrix4.fromTranslation(pivot);\n        const axis = camera.right;\n        rotateAroundAxis(camera, -angle, axis, transform, options);\n    });\n}\n/**\n * Set the OpenLayers view to a specific rotation and\n * the nearest resolution.\n */\nexport function normalizeView(view, angle = 0) {\n    const resolution = view.getResolution();\n    view.setRotation(angle);\n    // @ts-ignore TS2341\n    if (view.constrainResolution) {\n        // @ts-ignore TS2341\n        view.setResolution(view.constrainResolution(resolution));\n    }\n    else {\n        view.setResolution(view.getConstrainedResolution(resolution));\n    }\n}\n/**\n * Check if the given projection is managed by Cesium (WGS84 or Mercator Spheric)\n */\nexport function isCesiumProjection(projection) {\n    const is3857 = projection.getCode() === 'EPSG:3857';\n    const is4326 = projection.getCode() === 'EPSG:4326';\n    return is3857 || is4326;\n}\nexport function attributionsFunctionToCredits(attributionsFunction, zoom, center, extent) {\n    if (!attributionsFunction) {\n        return [];\n    }\n    let attributions = attributionsFunction({\n        viewState: { zoom, center, projection: undefined, resolution: undefined, rotation: undefined },\n        extent,\n    });\n    if (!Array.isArray(attributions)) {\n        attributions = [attributions];\n    }\n    return attributions.map(html => new Cesium.Credit(html, true));\n}\n/**\n * calculate the distance between camera and centerpoint based on the resolution and latitude value\n */\nexport function calcDistanceForResolution(resolution, latitude, scene, projection) {\n    const canvas = scene.canvas;\n    const camera = scene.camera;\n    // @ts-ignore TS2341\n    const fovy = camera.frustum.fovy; // vertical field of view\n    console.assert(!isNaN(fovy));\n    const metersPerUnit = projection.getMetersPerUnit();\n    // number of \"map units\" visible in 2D (vertically)\n    const visibleMapUnits = resolution * canvas.clientHeight;\n    // The metersPerUnit does not take latitude into account, but it should\n    // be lower with increasing latitude -- we have to compensate.\n    // In 3D it is not possible to maintain the resolution at more than one point,\n    // so it only makes sense to use the latitude of the \"target\" point.\n    const relativeCircumference = Math.cos(Math.abs(latitude));\n    // how many meters should be visible in 3D\n    const visibleMeters = visibleMapUnits * metersPerUnit * relativeCircumference;\n    // distance required to view the calculated length in meters\n    //\n    //  fovy/2\n    //    |\\\n    //  x | \\\n    //    |--\\\n    // visibleMeters/2\n    const requiredDistance = (visibleMeters / 2) / Math.tan(fovy / 2);\n    // NOTE: This calculation is not absolutely precise, because metersPerUnit\n    // is a great simplification. It does not take ellipsoid/terrain into account.\n    return requiredDistance;\n}\n/**\n * calculate the resolution based on a distance(camera to position) and latitude value\n */\nexport function calcResolutionForDistance(distance, latitude, scene, projection) {\n    // See the reverse calculation (calcDistanceForResolution) for details\n    const canvas = scene.canvas;\n    const camera = scene.camera;\n    // @ts-ignore TS2341\n    const fovy = camera.frustum.fovy; // vertical field of view\n    console.assert(!isNaN(fovy));\n    const metersPerUnit = projection.getMetersPerUnit();\n    const visibleMeters = 2 * distance * Math.tan(fovy / 2);\n    const relativeCircumference = Math.cos(Math.abs(latitude));\n    const visibleMapUnits = visibleMeters / metersPerUnit / relativeCircumference;\n    const resolution = visibleMapUnits / canvas.clientHeight;\n    return resolution;\n}\n/**\n * Constrain the camera so that it stays close to the bounding sphere of the map extent.\n * Near the ground the allowed distance is shorter.\n */\nexport function limitCameraToBoundingSphere(camera, boundingSphere, ratio) {\n    let blockLimiter = false;\n    return function () {\n        if (!blockLimiter) {\n            const position = camera.position;\n            const carto = Cesium.Cartographic.fromCartesian(position);\n            if (Cesium.Cartesian3.distance(boundingSphere.center, position) > boundingSphere.radius * ratio(carto.height)) {\n                // @ts-ignore TS2339: FIXME, there is no flying property in Camera\n                const currentlyFlying = camera.flying;\n                if (currentlyFlying === true) {\n                    // There is a flying property and its value is true\n                    return;\n                }\n                else {\n                    blockLimiter = true;\n                    const unblockLimiter = () => (blockLimiter = false);\n                    camera.flyToBoundingSphere(boundingSphere, {\n                        complete: unblockLimiter,\n                        cancel: unblockLimiter,\n                    });\n                }\n            }\n        }\n    };\n}\n","/**\n * @module olcs.AutoRenderLoop\n */\nclass AutoRenderLoop {\n    /**\n     * @constructor\n     * @param {olcs.OLCesium} ol3d\n     */\n    constructor(ol3d) {\n        this.ol3d = ol3d;\n        this.scene_ = ol3d.getCesiumScene();\n        this.canvas_ = this.scene_.canvas;\n        this._boundNotifyRepaintRequired = this.notifyRepaintRequired.bind(this);\n        this.repaintEventNames_ = [\n            'mousemove', 'mousedown', 'mouseup',\n            'touchstart', 'touchend', 'touchmove',\n            'pointerdown', 'pointerup', 'pointermove',\n            'wheel'\n        ];\n        this.enable();\n    }\n    /**\n     * Enable.\n     */\n    enable() {\n        this.scene_.requestRenderMode = true;\n        this.scene_.maximumRenderTimeChange = 1000;\n        for (const repaintKey of this.repaintEventNames_) {\n            this.canvas_.addEventListener(repaintKey, this._boundNotifyRepaintRequired, false);\n        }\n        window.addEventListener('resize', this._boundNotifyRepaintRequired, false);\n        // Listen for changes on the layer group\n        this.ol3d.getOlMap().getLayerGroup().on('change', this._boundNotifyRepaintRequired);\n    }\n    /**\n     * Disable.\n     */\n    disable() {\n        for (const repaintKey of this.repaintEventNames_) {\n            this.canvas_.removeEventListener(repaintKey, this._boundNotifyRepaintRequired, false);\n        }\n        window.removeEventListener('resize', this._boundNotifyRepaintRequired, false);\n        this.ol3d.getOlMap().getLayerGroup().un('change', this._boundNotifyRepaintRequired);\n        this.scene_.requestRenderMode = false;\n    }\n    /**\n     * Restart render loop.\n     * Force a restart of the render loop.\n     * @api\n     */\n    restartRenderLoop() {\n        this.notifyRepaintRequired();\n    }\n    notifyRepaintRequired() {\n        this.scene_.requestRender();\n    }\n}\nexport default AutoRenderLoop;\n","/**\n * Converts radians to to degrees.\n *\n * @param {number} angleInRadians Angle in radians.\n * @return {number} Angle in degrees.\n */\nexport function toDegrees(angleInRadians) {\n    return angleInRadians * 180 / Math.PI;\n}\n/**\n * Converts degrees to radians.\n *\n * @param {number} angleInDegrees Angle in degrees.\n * @return {number} Angle in radians.\n */\nexport function toRadians(angleInDegrees) {\n    return angleInDegrees * Math.PI / 180;\n}\n","/**\n * @module olcs.Camera\n */\nimport { unByKey as olObservableUnByKey } from 'ol/Observable.js';\nimport { toRadians, toDegrees } from './math.js';\nimport { getTransform } from 'ol/proj.js';\nimport { pickCenterPoint, calcDistanceForResolution, calcResolutionForDistance } from './core.js';\nclass Camera {\n    /**\n     * This object takes care of additional 3d-specific properties of the view and\n     * ensures proper synchronization with the underlying raw Cesium.Camera object.\n     * @param {!Cesium.Scene} scene\n     * @param {!ol.Map} map\n     * @api\n     */\n    constructor(scene, map) {\n        /**\n         * @type {!Cesium.Scene}\n         * @private\n         */\n        this.scene_ = scene;\n        /**\n         * @type {!Cesium.Camera}\n         * @private\n         */\n        this.cam_ = scene.camera;\n        /**\n         * @type {!ol.Map}\n         * @private\n         */\n        this.map_ = map;\n        /**\n         * @type {?ol.View}\n         * @private\n         */\n        this.view_ = null;\n        /**\n         * @type {?ol.EventsKey}\n         * @private\n         */\n        this.viewListenKey_ = null;\n        /**\n         * @type {!ol.TransformFunction}\n         * @private\n         */\n        this.toLonLat_ = Camera.identityProjection;\n        /**\n         * @type {!ol.TransformFunction}\n         * @private\n         */\n        this.fromLonLat_ = Camera.identityProjection;\n        /**\n         * 0 -- topdown, PI/2 -- the horizon\n         * @type {number}\n         * @private\n         */\n        this.tilt_ = 0;\n        /**\n         * @type {number}\n         * @private\n         */\n        this.distance_ = 0;\n        /**\n         * @type {?Cesium.Matrix4}\n         * @private\n         */\n        this.lastCameraViewMatrix_ = null;\n        /**\n         * This is used to discard change events on view caused by updateView method.\n         * @type {boolean}\n         * @private\n         */\n        this.viewUpdateInProgress_ = false;\n        this.map_.on('change:view', (e) => {\n            this.setView_(this.map_.getView());\n        });\n        this.setView_(this.map_.getView());\n    }\n    destroy() {\n        olObservableUnByKey(this.viewListenKey_);\n        this.viewListenKey_ = null;\n    }\n    /**\n     * @param {Array.<number>} input Input coordinate array.\n     * @param {Array.<number>=} opt_output Output array of coordinate values.\n     * @param {number=} opt_dimension Dimension.\n     * @return {Array.<number>} Input coordinate array (same array as input).\n     */\n    static identityProjection(input, opt_output, opt_dimension) {\n        const dim = opt_dimension || input.length;\n        if (opt_output) {\n            for (let i = 0; i < dim; ++i) {\n                opt_output[i] = input[i];\n            }\n        }\n        return input;\n    }\n    /**\n     * @param {?ol.View} view New view to use.\n     * @private\n     */\n    setView_(view) {\n        if (this.view_) {\n            olObservableUnByKey(this.viewListenKey_);\n            this.viewListenKey_ = null;\n        }\n        this.view_ = view;\n        if (view) {\n            const toLonLat = getTransform(view.getProjection(), 'EPSG:4326');\n            const fromLonLat = getTransform('EPSG:4326', view.getProjection());\n            console.assert(toLonLat && fromLonLat);\n            this.toLonLat_ = toLonLat;\n            this.fromLonLat_ = fromLonLat;\n            this.viewListenKey_ = view.on('propertychange', e => this.handleViewEvent_(e));\n            this.readFromView();\n        }\n        else {\n            this.toLonLat_ = Camera.identityProjection;\n            this.fromLonLat_ = Camera.identityProjection;\n        }\n    }\n    /**\n     * @param {?} e\n     * @private\n     */\n    handleViewEvent_(e) {\n        if (!this.viewUpdateInProgress_) {\n            this.readFromView();\n        }\n    }\n    /**\n     * @param {number} heading In radians.\n     * @api\n     */\n    setHeading(heading) {\n        if (!this.view_) {\n            return;\n        }\n        this.view_.setRotation(heading);\n    }\n    /**\n     * @return {number|undefined} Heading in radians.\n     * @api\n     */\n    getHeading() {\n        if (!this.view_) {\n            return undefined;\n        }\n        const rotation = this.view_.getRotation();\n        return rotation || 0;\n    }\n    /**\n     * @param {number} tilt In radians.\n     * @api\n     */\n    setTilt(tilt) {\n        this.tilt_ = tilt;\n        this.updateCamera_();\n    }\n    /**\n     * @return {number} Tilt in radians.\n     * @api\n     */\n    getTilt() {\n        return this.tilt_;\n    }\n    /**\n     * @param {number} distance In meters.\n     * @api\n     */\n    setDistance(distance) {\n        this.distance_ = distance;\n        this.updateCamera_();\n        this.updateView();\n    }\n    /**\n     * @return {number} Distance in meters.\n     * @api\n     */\n    getDistance() {\n        return this.distance_;\n    }\n    /**\n     * Shortcut for ol.View.setCenter().\n     * @param {!ol.Coordinate} center Same projection as the ol.View.\n     * @api\n     */\n    setCenter(center) {\n        if (!this.view_) {\n            return;\n        }\n        this.view_.setCenter(center);\n    }\n    /**\n     * Shortcut for ol.View.getCenter().\n     * @return {ol.Coordinate|undefined} Same projection as the ol.View.\n     * @api\n     */\n    getCenter() {\n        if (!this.view_) {\n            return undefined;\n        }\n        return this.view_.getCenter();\n    }\n    /**\n     * Sets the position of the camera.\n     * @param {!ol.Coordinate} position Same projection as the ol.View.\n     * @api\n     */\n    setPosition(position) {\n        if (!this.toLonLat_) {\n            return;\n        }\n        const ll = this.toLonLat_(position);\n        console.assert(ll);\n        const carto = new Cesium.Cartographic(toRadians(ll[0]), toRadians(ll[1]), this.getAltitude());\n        this.cam_.setView({\n            destination: Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto)\n        });\n        this.updateView();\n    }\n    /**\n     * Calculates position under the camera.\n     * @return {!ol.Coordinate|undefined} Same projection as the ol.View.\n     * @api\n     */\n    getPosition() {\n        if (!this.fromLonLat_) {\n            return undefined;\n        }\n        const carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.cam_.position);\n        const pos = this.fromLonLat_([\n            toDegrees(carto.longitude),\n            toDegrees(carto.latitude)\n        ]);\n        console.assert(pos);\n        return pos;\n    }\n    /**\n     * @param {number} altitude In meters.\n     * @api\n     */\n    setAltitude(altitude) {\n        const carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.cam_.position);\n        carto.height = altitude;\n        this.cam_.position = Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto);\n        this.updateView();\n    }\n    /**\n     * @return {number} Altitude in meters.\n     * @api\n     */\n    getAltitude() {\n        const carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(this.cam_.position);\n        return carto.height;\n    }\n    /**\n     * Updates the state of the underlying Cesium.Camera\n     * according to the current values of the properties.\n     * @private\n     */\n    updateCamera_() {\n        if (!this.view_ || !this.toLonLat_) {\n            return;\n        }\n        const center = this.view_.getCenter();\n        if (!center) {\n            return;\n        }\n        const ll = this.toLonLat_(center);\n        console.assert(ll);\n        const carto = new Cesium.Cartographic(toRadians(ll[0]), toRadians(ll[1]));\n        if (this.scene_.globe) {\n            const height = this.scene_.globe.getHeight(carto);\n            carto.height = height || 0;\n        }\n        const destination = Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto);\n        /** @type {Cesium.optionsOrientation} */\n        const orientation = {\n            pitch: this.tilt_ - Cesium.Math.PI_OVER_TWO,\n            heading: -this.view_.getRotation(),\n            roll: undefined\n        };\n        this.cam_.setView({\n            destination,\n            orientation\n        });\n        this.cam_.moveBackward(this.distance_);\n        this.checkCameraChange(true);\n    }\n    /**\n     * Calculates the values of the properties from the current ol.View state.\n     * @api\n     */\n    readFromView() {\n        if (!this.view_ || !this.toLonLat_) {\n            return;\n        }\n        const center = this.view_.getCenter();\n        if (center === undefined || center === null) {\n            return;\n        }\n        const ll = this.toLonLat_(center);\n        console.assert(ll);\n        const resolution = this.view_.getResolution();\n        this.distance_ = this.calcDistanceForResolution(resolution || 0, toRadians(ll[1]));\n        this.updateCamera_();\n    }\n    /**\n     * Calculates the values of the properties from the current Cesium.Camera state.\n     * Modifies the center, resolution and rotation properties of the view.\n     * @api\n     */\n    updateView() {\n        if (!this.view_ || !this.fromLonLat_) {\n            return;\n        }\n        this.viewUpdateInProgress_ = true;\n        // target & distance\n        const ellipsoid = Cesium.Ellipsoid.WGS84;\n        const scene = this.scene_;\n        const target = pickCenterPoint(scene);\n        let bestTarget = target;\n        if (!bestTarget) {\n            //TODO: how to handle this properly ?\n            const globe = scene.globe;\n            const carto = this.cam_.positionCartographic.clone();\n            const height = globe.getHeight(carto);\n            carto.height = height || 0;\n            bestTarget = Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto);\n        }\n        this.distance_ = Cesium.Cartesian3.distance(bestTarget, this.cam_.position);\n        const bestTargetCartographic = ellipsoid.cartesianToCartographic(bestTarget);\n        this.view_.setCenter(this.fromLonLat_([\n            toDegrees(bestTargetCartographic.longitude),\n            toDegrees(bestTargetCartographic.latitude)\n        ]));\n        // resolution\n        this.view_.setResolution(this.calcResolutionForDistance(this.distance_, bestTargetCartographic ? bestTargetCartographic.latitude : 0));\n        /*\n         * Since we are positioning the target, the values of heading and tilt\n         * need to be calculated _at the target_.\n         */\n        if (target) {\n            const pos = this.cam_.position;\n            // normal to the ellipsoid at the target\n            const targetNormal = new Cesium.Cartesian3();\n            ellipsoid.geocentricSurfaceNormal(target, targetNormal);\n            // vector from the target to the camera\n            const targetToCamera = new Cesium.Cartesian3();\n            Cesium.Cartesian3.subtract(pos, target, targetToCamera);\n            Cesium.Cartesian3.normalize(targetToCamera, targetToCamera);\n            // HEADING\n            const up = this.cam_.up;\n            const right = this.cam_.right;\n            const normal = new Cesium.Cartesian3(-target.y, target.x, 0); // what is it?\n            const heading = Cesium.Cartesian3.angleBetween(right, normal);\n            const cross = Cesium.Cartesian3.cross(target, up, new Cesium.Cartesian3());\n            const orientation = cross.z;\n            this.view_.setRotation((orientation < 0 ? heading : -heading));\n            // TILT\n            const tiltAngle = Math.acos(Cesium.Cartesian3.dot(targetNormal, targetToCamera));\n            this.tilt_ = isNaN(tiltAngle) ? 0 : tiltAngle;\n        }\n        else {\n            // fallback when there is no target\n            this.view_.setRotation(this.cam_.heading);\n            this.tilt_ = -this.cam_.pitch + Math.PI / 2;\n        }\n        this.viewUpdateInProgress_ = false;\n    }\n    /**\n     * Check if the underlying camera state has changed and ensure synchronization.\n     * @param {boolean=} opt_dontSync Do not synchronize the view.\n     */\n    checkCameraChange(opt_dontSync) {\n        const old = this.lastCameraViewMatrix_;\n        const current = this.cam_.viewMatrix;\n        if (!old || !Cesium.Matrix4.equalsEpsilon(old, current, 1e-5)) {\n            this.lastCameraViewMatrix_ = current.clone();\n            if (opt_dontSync !== true) {\n                this.updateView();\n            }\n        }\n    }\n    /**\n     * calculate the distance between camera and centerpoint based on the resolution and latitude value\n     * @param {number} resolution Number of map units per pixel.\n     * @param {number} latitude Latitude in radians.\n     * @return {number} The calculated distance.\n     * @api\n     */\n    calcDistanceForResolution(resolution, latitude) {\n        return calcDistanceForResolution(resolution, latitude, this.scene_, this.view_.getProjection());\n    }\n    /**\n     * calculate the resolution based on a distance(camera to position) and latitude value\n     * @param {number} distance\n     * @param {number} latitude\n     * @return {number} The calculated resolution.\n     * @api\n     */\n    calcResolutionForDistance(distance, latitude) {\n        return calcResolutionForDistance(distance, latitude, this.scene_, this.view_.getProjection());\n    }\n}\nexport default Camera;\n","/**\n * @module olcs.core.VectorLayerCounterpart\n */\nimport { unByKey as olObservableUnByKey } from 'ol/Observable.js';\nclass VectorLayerCounterpart {\n    olListenKeys = [];\n    context;\n    rootCollection_;\n    /**\n    * Result of the conversion of an OpenLayers layer to Cesium.\n    */\n    constructor(layerProjection, scene) {\n        const billboards = new Cesium.BillboardCollection({ scene });\n        const primitives = new Cesium.PrimitiveCollection();\n        this.rootCollection_ = new Cesium.PrimitiveCollection();\n        this.context = {\n            projection: layerProjection,\n            billboards,\n            featureToCesiumMap: {},\n            primitives\n        };\n        this.rootCollection_.add(billboards);\n        this.rootCollection_.add(primitives);\n    }\n    /**\n    * Unlisten.\n    */\n    destroy() {\n        this.olListenKeys.forEach(olObservableUnByKey);\n        this.olListenKeys.length = 0;\n    }\n    getRootPrimitive() {\n        return this.rootCollection_;\n    }\n}\nexport default VectorLayerCounterpart;\n","/**\n * @module olcs.AbstractSynchronizer\n */\nimport { unByKey as olObservableUnByKey } from 'ol/Observable.js';\nimport LayerGroup from 'ol/layer/Group.js';\nimport { getUid, olcsListen } from './util.js';\nimport Map from 'ol/Map.js';\nimport View from 'ol/View.js';\nimport Collection from 'ol/Collection.js';\nimport BaseLayer from 'ol/layer/Base.js';\nimport VectorLayerCounterpart from './core/VectorLayerCounterpart.js';\nclass AbstractSynchronizer {\n    map;\n    view;\n    scene;\n    olLayers;\n    mapLayerGroup;\n    /**\n     * Map of OpenLayers layer ids (from getUid) to the Cesium ImageryLayers.\n     * Null value means, that we are unable to create equivalent layers.\n     */\n    layerMap = {};\n    /**\n     * Map of listen keys for OpenLayers layer layers ids (from getUid).\n     */\n    olLayerListenKeys = {};\n    /**\n     * Map of listen keys for OpenLayers layer groups ids (from getUid).\n     */\n    olGroupListenKeys_ = {};\n    constructor(map, scene) {\n        this.map = map;\n        this.view = map.getView();\n        this.scene = scene;\n        this.olLayers = map.getLayerGroup().getLayers();\n        this.mapLayerGroup = map.getLayerGroup();\n    }\n    /**\n     * Destroy all and perform complete synchronization of the layers.\n     */\n    synchronize() {\n        this.destroyAll();\n        this.addLayers_(this.mapLayerGroup);\n    }\n    /**\n     * Order counterparts using the same algorithm as the Openlayers renderer:\n     * z-index then original sequence order.\n     */\n    orderLayers() {\n        // Ordering logics is handled in subclasses.\n    }\n    /**\n     * Add a layer hierarchy.\n     */\n    addLayers_(root) {\n        const fifo = [{\n                layer: root,\n                parents: []\n            }];\n        while (fifo.length > 0) {\n            const olLayerWithParents = fifo.splice(0, 1)[0];\n            const olLayer = olLayerWithParents.layer;\n            const olLayerId = getUid(olLayer).toString();\n            this.olLayerListenKeys[olLayerId] = [];\n            console.assert(!this.layerMap[olLayerId]);\n            let cesiumObjects = null;\n            if (olLayer instanceof LayerGroup) {\n                this.listenForGroupChanges_(olLayer);\n                if (olLayer !== this.mapLayerGroup) {\n                    cesiumObjects = this.createSingleLayerCounterparts(olLayerWithParents);\n                }\n                if (!cesiumObjects) {\n                    olLayer.getLayers().forEach((l) => {\n                        if (l) {\n                            const newOlLayerWithParents = {\n                                layer: l,\n                                parents: olLayer === this.mapLayerGroup ?\n                                    [] :\n                                    [olLayerWithParents.layer].concat(olLayerWithParents.parents)\n                            };\n                            fifo.push(newOlLayerWithParents);\n                        }\n                    });\n                }\n            }\n            else {\n                cesiumObjects = this.createSingleLayerCounterparts(olLayerWithParents);\n                if (!cesiumObjects) {\n                    // keep an eye on the layers that once failed to be added (might work when the layer is updated)\n                    // for example when a source is set after the layer is added to the map\n                    const layerId = olLayerId;\n                    const layerWithParents = olLayerWithParents;\n                    const onLayerChange = () => {\n                        const cesiumObjs = this.createSingleLayerCounterparts(layerWithParents);\n                        if (cesiumObjs) {\n                            // unsubscribe event listener\n                            layerWithParents.layer.un('change', onLayerChange);\n                            this.addCesiumObjects_(cesiumObjs, layerId, layerWithParents.layer);\n                            this.orderLayers();\n                        }\n                    };\n                    this.olLayerListenKeys[olLayerId].push(olcsListen(layerWithParents.layer, 'change', onLayerChange));\n                }\n            }\n            // add Cesium layers\n            if (cesiumObjects) {\n                this.addCesiumObjects_(cesiumObjects, olLayerId, olLayer);\n            }\n        }\n        this.orderLayers();\n    }\n    /**\n     * Add Cesium objects.\n     */\n    addCesiumObjects_(cesiumObjects, layerId, layer) {\n        this.layerMap[layerId] = cesiumObjects;\n        this.olLayerListenKeys[layerId].push(olcsListen(layer, 'change:zIndex', () => this.orderLayers()));\n        cesiumObjects.forEach((cesiumObject) => {\n            this.addCesiumObject(cesiumObject);\n        });\n    }\n    /**\n     * Remove and destroy a single layer.\n     * @param {ol.layer.Layer} layer\n     * @return {boolean} counterpart destroyed\n     */\n    removeAndDestroySingleLayer_(layer) {\n        const uid = getUid(layer).toString();\n        const counterparts = this.layerMap[uid];\n        if (!!counterparts) {\n            counterparts.forEach((counterpart) => {\n                this.removeSingleCesiumObject(counterpart, false);\n                this.destroyCesiumObject(counterpart);\n            });\n            this.olLayerListenKeys[uid].forEach(olObservableUnByKey);\n            delete this.olLayerListenKeys[uid];\n        }\n        delete this.layerMap[uid];\n        return !!counterparts;\n    }\n    /**\n     * Unlisten a single layer group.\n     */\n    unlistenSingleGroup_(group) {\n        if (group === this.mapLayerGroup) {\n            return;\n        }\n        const uid = getUid(group).toString();\n        const keys = this.olGroupListenKeys_[uid];\n        keys.forEach((key) => {\n            olObservableUnByKey(key);\n        });\n        delete this.olGroupListenKeys_[uid];\n        delete this.layerMap[uid];\n    }\n    /**\n     * Remove layer hierarchy.\n     */\n    removeLayer_(root) {\n        if (!!root) {\n            const fifo = [root];\n            while (fifo.length > 0) {\n                const olLayer = fifo.splice(0, 1)[0];\n                const done = this.removeAndDestroySingleLayer_(olLayer);\n                if (olLayer instanceof LayerGroup) {\n                    this.unlistenSingleGroup_(olLayer);\n                    if (!done) {\n                        // No counterpart for the group itself so removing\n                        // each of the child layers.\n                        olLayer.getLayers().forEach((l) => {\n                            fifo.push(l);\n                        });\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Register listeners for single layer group change.\n     */\n    listenForGroupChanges_(group) {\n        const uuid = getUid(group).toString();\n        console.assert(this.olGroupListenKeys_[uuid] === undefined);\n        const listenKeyArray = [];\n        this.olGroupListenKeys_[uuid] = listenKeyArray;\n        // only the keys that need to be relistened when collection changes\n        let contentKeys = [];\n        const listenAddRemove = (function () {\n            const collection = group.getLayers();\n            if (collection) {\n                contentKeys = [\n                    collection.on('add', (event) => {\n                        this.addLayers_(event.element);\n                    }),\n                    collection.on('remove', (event) => {\n                        this.removeLayer_(event.element);\n                    })\n                ];\n                listenKeyArray.push(...contentKeys);\n            }\n        }).bind(this);\n        listenAddRemove();\n        listenKeyArray.push(group.on('change:layers', (e) => {\n            contentKeys.forEach((el) => {\n                const i = listenKeyArray.indexOf(el);\n                if (i >= 0) {\n                    listenKeyArray.splice(i, 1);\n                }\n                olObservableUnByKey(el);\n            });\n            listenAddRemove();\n        }));\n    }\n    /**\n     * Destroys all the created Cesium objects.\n     */\n    destroyAll() {\n        this.removeAllCesiumObjects(true); // destroy\n        let objKey;\n        for (objKey in this.olGroupListenKeys_) {\n            const keys = this.olGroupListenKeys_[objKey];\n            keys.forEach(olObservableUnByKey);\n        }\n        for (objKey in this.olLayerListenKeys) {\n            this.olLayerListenKeys[objKey].forEach(olObservableUnByKey);\n        }\n        this.olGroupListenKeys_ = {};\n        this.olLayerListenKeys = {};\n        this.layerMap = {};\n    }\n}\nexport default AbstractSynchronizer;\n","/**\n * @module olcs.RasterSynchronizer\n */\nimport Map from 'ol/Map.js';\nimport { getUid, stableSort } from './util.js';\nimport olcsAbstractSynchronizer from './AbstractSynchronizer.js';\nimport { tileLayerToImageryLayer, updateCesiumLayerProperties } from './core.js';\nimport BaseVectorLayer from 'ol/layer/BaseVector.js';\nimport LayerGroup from 'ol/layer/Group.js';\nclass RasterSynchronizer extends olcsAbstractSynchronizer {\n    cesiumLayers_;\n    ourLayers_;\n    /**\n     * This object takes care of one-directional synchronization of\n     * Openlayers raster layers to the given Cesium globe.\n     */\n    constructor(map, scene) {\n        super(map, scene);\n        this.cesiumLayers_ = scene.imageryLayers;\n        this.ourLayers_ = new Cesium.ImageryLayerCollection();\n    }\n    addCesiumObject(object) {\n        this.cesiumLayers_.add(object);\n        this.ourLayers_.add(object);\n    }\n    destroyCesiumObject(object) {\n        object.destroy();\n    }\n    removeSingleCesiumObject(object, destroy) {\n        this.cesiumLayers_.remove(object, destroy);\n        this.ourLayers_.remove(object, false);\n    }\n    removeAllCesiumObjects(destroy) {\n        for (let i = 0; i < this.ourLayers_.length; ++i) {\n            this.cesiumLayers_.remove(this.ourLayers_.get(i), destroy);\n        }\n        this.ourLayers_.removeAll(false);\n    }\n    /**\n     * Creates an array of Cesium.ImageryLayer.\n     * May be overriden by child classes to implement custom behavior.\n     * The default implementation handles tiled imageries in EPSG:4326 or\n     * EPSG:3859.\n     */\n    convertLayerToCesiumImageries(olLayer, viewProj) {\n        const result = tileLayerToImageryLayer(this.map, olLayer, viewProj);\n        return result ? [result] : null;\n    }\n    createSingleLayerCounterparts(olLayerWithParents) {\n        const olLayer = olLayerWithParents.layer;\n        const uid = getUid(olLayer).toString();\n        const viewProj = this.view.getProjection();\n        console.assert(viewProj);\n        const cesiumObjects = this.convertLayerToCesiumImageries(olLayer, viewProj);\n        if (cesiumObjects) {\n            const listenKeyArray = [];\n            [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach((olLayerItem) => {\n                listenKeyArray.push(olLayerItem.on(['change:opacity', 'change:visible'], () => {\n                    // the compiler does not seem to be able to infer this\n                    console.assert(cesiumObjects);\n                    for (let i = 0; i < cesiumObjects.length; ++i) {\n                        updateCesiumLayerProperties(olLayerWithParents, cesiumObjects[i]);\n                    }\n                }));\n            });\n            if (olLayer instanceof BaseVectorLayer) {\n                let previousStyleFunction = olLayer.getStyleFunction();\n                // there is no convenient way to detect a style function change in OL\n                listenKeyArray.push(olLayer.on('change', () => {\n                    const currentStyleFunction = olLayer.getStyleFunction();\n                    if (previousStyleFunction === currentStyleFunction) {\n                        return;\n                    }\n                    previousStyleFunction = currentStyleFunction;\n                    for (let i = 0; i < cesiumObjects.length; ++i) {\n                        const csObj = cesiumObjects[i];\n                        // clear cache and set new style\n                        // @ts-ignore TS2341\n                        if (csObj._imageryCache) {\n                            // @ts-ignore TS2341\n                            csObj._imageryCache = {};\n                        }\n                        const ip = csObj.imageryProvider;\n                        if (ip) {\n                            // @ts-ignore TS2341\n                            ip.tileCache?.clear();\n                            // @ts-ignore TS2341\n                            ip.styleFunction_ = currentStyleFunction;\n                        }\n                    }\n                    this.scene.requestRender();\n                }));\n            }\n            for (let i = 0; i < cesiumObjects.length; ++i) {\n                updateCesiumLayerProperties(olLayerWithParents, cesiumObjects[i]);\n            }\n            // there is no way to modify Cesium layer extent,\n            // we have to recreate when OpenLayers layer extent changes:\n            listenKeyArray.push(olLayer.on('change:extent', (e) => {\n                for (let i = 0; i < cesiumObjects.length; ++i) {\n                    this.cesiumLayers_.remove(cesiumObjects[i], true); // destroy\n                    this.ourLayers_.remove(cesiumObjects[i], false);\n                }\n                delete this.layerMap[getUid(olLayer)]; // invalidate the map entry\n                this.synchronize();\n            }));\n            listenKeyArray.push(olLayer.on('change', (e) => {\n                // when the source changes, re-add the layer to force update\n                for (let i = 0; i < cesiumObjects.length; ++i) {\n                    const position = this.cesiumLayers_.indexOf(cesiumObjects[i]);\n                    if (position >= 0) {\n                        this.cesiumLayers_.remove(cesiumObjects[i], false);\n                        this.cesiumLayers_.add(cesiumObjects[i], position);\n                    }\n                }\n            }));\n            this.olLayerListenKeys[uid].push(...listenKeyArray);\n        }\n        return Array.isArray(cesiumObjects) ? cesiumObjects : null;\n    }\n    /**\n     * Order counterparts using the same algorithm as the Openlayers renderer:\n     * z-index then original sequence order.\n     * @override\n     * @protected\n     */\n    orderLayers() {\n        const layers = [];\n        const zIndices = {};\n        const queue = [this.mapLayerGroup];\n        while (queue.length > 0) {\n            const olLayer = queue.splice(0, 1)[0];\n            layers.push(olLayer);\n            zIndices[getUid(olLayer)] = olLayer.getZIndex() || 0;\n            if (olLayer instanceof LayerGroup) {\n                const sublayers = olLayer.getLayers();\n                if (sublayers) {\n                    // Prepend queue with sublayers in order\n                    queue.unshift(...sublayers.getArray());\n                }\n            }\n        }\n        stableSort(layers, (layer1, layer2) => zIndices[getUid(layer1)] - zIndices[getUid(layer2)]);\n        layers.forEach((olLayer) => {\n            const olLayerId = getUid(olLayer).toString();\n            const cesiumObjects = this.layerMap[olLayerId];\n            if (cesiumObjects) {\n                cesiumObjects.forEach((cesiumObject) => { this.raiseToTop(cesiumObject); });\n            }\n        });\n    }\n    raiseToTop(counterpart) {\n        this.cesiumLayers_.raiseToTop(counterpart);\n    }\n}\nexport default RasterSynchronizer;\n","/**\n * @module olcs.FeatureConverter\n */\nimport olGeomGeometry from 'ol/geom/Geometry.js';\nimport olStyleIcon from 'ol/style/Icon.js';\nimport olSourceVector from 'ol/source/Vector.js';\nimport olSourceCluster from 'ol/source/Cluster.js';\nimport { circular as olCreateCircularPolygon } from 'ol/geom/Polygon.js';\nimport { boundingExtent, getCenter } from 'ol/extent.js';\nimport olGeomSimpleGeometry from 'ol/geom/SimpleGeometry.js';\nimport { convertColorToCesium, olGeometryCloneTo4326, ol4326CoordinateToCesiumCartesian, ol4326CoordinateArrayToCsCartesians } from './core.js';\nimport olcsCoreVectorLayerCounterpart from './core/VectorLayerCounterpart.js';\nimport { obj, getUid, isGroundPolylinePrimitiveSupported, waitReady } from './util.js';\n/**\n * @typedef {Object} ModelStyle\n * @property {Cesium.Matrix4} [debugModelMatrix]\n * @property {Cesium.ModelFromGltfOptions} cesiumOptions\n */\nclass FeatureConverter {\n    /**\n     * Concrete base class for converting from OpenLayers3 vectors to Cesium\n     * primitives.\n     * Extending this class is possible provided that the extending class and\n     * the library are compiled together by the closure compiler.\n     * @param {!Cesium.Scene} scene Cesium scene.\n     * @constructor\n     * @api\n     */\n    constructor(scene) {\n        /**\n         * @protected\n         */\n        this.scene = scene;\n        /**\n         * Bind once to have a unique function for using as a listener\n         * @type {function(ol.source.Vector.Event)}\n         * @private\n         */\n        this.boundOnRemoveOrClearFeatureListener_ = this.onRemoveOrClearFeature_.bind(this);\n        /**\n         * @type {Cesium.Cartesian3}\n         * @private\n         */\n        this.defaultBillboardEyeOffset_ = new Cesium.Cartesian3(0, 0, 10);\n    }\n    /**\n     * @param {ol.source.Vector.Event} evt\n     * @private\n     */\n    onRemoveOrClearFeature_(evt) {\n        const source = evt.target;\n        console.assert(source instanceof olSourceVector);\n        const cancellers = obj(source)['olcs_cancellers'];\n        if (cancellers) {\n            const feature = evt.feature;\n            if (feature) {\n                // remove\n                const id = getUid(feature);\n                const canceller = cancellers[id];\n                if (canceller) {\n                    canceller();\n                    delete cancellers[id];\n                }\n            }\n            else {\n                // clear\n                for (const key in cancellers) {\n                    if (cancellers.hasOwnProperty(key)) {\n                        cancellers[key]();\n                    }\n                }\n                obj(source)['olcs_cancellers'] = {};\n            }\n        }\n    }\n    /**\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature.\n     * @param {!Cesium.Primitive|Cesium.Label|Cesium.Billboard} primitive\n     * @protected\n     */\n    setReferenceForPicking(layer, feature, primitive) {\n        primitive.olLayer = layer;\n        primitive.olFeature = feature;\n    }\n    /**\n     * Basics primitive creation using a color attribute.\n     * Note that Cesium has 'interior' and outline geometries.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature.\n     * @param {!ol.geom.Geometry} olGeometry OpenLayers geometry.\n     * @param {!Cesium.Geometry} geometry\n     * @param {!Cesium.Color} color\n     * @param {number=} opt_lineWidth\n     * @return {Cesium.Primitive}\n     * @protected\n     */\n    createColoredPrimitive(layer, feature, olGeometry, geometry, color, opt_lineWidth) {\n        const createInstance = function (geometry, color) {\n            const instance = new Cesium.GeometryInstance({\n                // always update Cesium externs before adding a property\n                geometry\n            });\n            if (color && !(color instanceof Cesium.ImageMaterialProperty)) {\n                instance.attributes = {\n                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(color)\n                };\n            }\n            return instance;\n        };\n        const options = {\n            // always update Cesium externs before adding a property\n            flat: true,\n            renderState: {\n                depthTest: {\n                    enabled: true\n                }\n            }\n        };\n        if (opt_lineWidth !== undefined) {\n            if (!options.renderState) {\n                options.renderState = {};\n            }\n            options.renderState.lineWidth = opt_lineWidth;\n        }\n        const instances = createInstance(geometry, color);\n        const heightReference = this.getHeightReference(layer, feature, olGeometry);\n        let primitive;\n        if (heightReference === Cesium.HeightReference.CLAMP_TO_GROUND) {\n            const ctor = instances.geometry.constructor;\n            if (ctor && !ctor['createShadowVolume']) {\n                return null;\n            }\n            primitive = new Cesium.GroundPrimitive({\n                geometryInstances: instances\n            });\n        }\n        else {\n            primitive = new Cesium.Primitive({\n                geometryInstances: instances\n            });\n        }\n        if (color instanceof Cesium.ImageMaterialProperty) {\n            const dataUri = color.image.getValue().toDataURL();\n            primitive.appearance = new Cesium.MaterialAppearance({\n                flat: true,\n                renderState: {\n                    depthTest: {\n                        enabled: true,\n                    }\n                },\n                material: new Cesium.Material({\n                    fabric: {\n                        type: 'Image',\n                        uniforms: {\n                            image: dataUri\n                        }\n                    }\n                })\n            });\n        }\n        else {\n            primitive.appearance = new Cesium.MaterialAppearance({\n                ...options,\n                material: new Cesium.Material({\n                    translucent: color.alpha !== 1,\n                    fabric: {\n                        type: 'Color',\n                        uniforms: {\n                            color,\n                        }\n                    }\n                })\n            });\n            if (feature.get('olcs_shadows') || layer.get('olcs_shadows')) {\n                primitive.shadows = 1;\n            }\n        }\n        this.setReferenceForPicking(layer, feature, primitive);\n        return primitive;\n    }\n    /**\n     * Return the fill or stroke color from a plain ol style.\n     * @param {!ol.style.Style|ol.style.Text} style\n     * @param {boolean} outline\n     * @return {!Cesium.Color}\n     * @protected\n     */\n    extractColorFromOlStyle(style, outline) {\n        const fillColor = style.getFill() ? style.getFill().getColor() : null;\n        const strokeColor = style.getStroke() ? style.getStroke().getColor() : null;\n        let olColor = 'black';\n        if (strokeColor && outline) {\n            olColor = strokeColor;\n        }\n        else if (fillColor) {\n            olColor = fillColor;\n        }\n        return convertColorToCesium(olColor);\n    }\n    /**\n     * Return the width of stroke from a plain ol style.\n     * @param {!ol.style.Style|ol.style.Text} style\n     * @return {number}\n     * @protected\n     */\n    extractLineWidthFromOlStyle(style) {\n        // Handling of line width WebGL limitations is handled by Cesium.\n        const width = style.getStroke() ? style.getStroke().getWidth() : undefined;\n        return width !== undefined ? width : 1;\n    }\n    /**\n     * Create a primitive collection out of two Cesium geometries.\n     * Only the OpenLayers style colors will be used.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature.\n     * @param {!ol.geom.Geometry} olGeometry OpenLayers geometry.\n     * @param {!Cesium.Geometry} fillGeometry\n     * @param {!Cesium.Geometry} outlineGeometry\n     * @param {!ol.style.Style} olStyle\n     * @return {!Cesium.PrimitiveCollection}\n     * @protected\n     */\n    wrapFillAndOutlineGeometries(layer, feature, olGeometry, fillGeometry, outlineGeometry, olStyle) {\n        const fillColor = this.extractColorFromOlStyle(olStyle, false);\n        const outlineColor = this.extractColorFromOlStyle(olStyle, true);\n        const primitives = new Cesium.PrimitiveCollection();\n        if (olStyle.getFill()) {\n            const p1 = this.createColoredPrimitive(layer, feature, olGeometry, fillGeometry, fillColor);\n            console.assert(!!p1);\n            primitives.add(p1);\n        }\n        if (olStyle.getStroke() && outlineGeometry) {\n            const width = this.extractLineWidthFromOlStyle(olStyle);\n            const p2 = this.createColoredPrimitive(layer, feature, olGeometry, outlineGeometry, outlineColor, width);\n            if (p2) {\n                // Some outline geometries are not supported by Cesium in clamp to ground\n                // mode. These primitives are skipped.\n                primitives.add(p2);\n            }\n        }\n        return primitives;\n    }\n    // Geometry converters\n    /**\n     * Create a Cesium primitive if style has a text component.\n     * Eventually return a PrimitiveCollection including current primitive.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature..\n     * @param {!ol.geom.Geometry} geometry\n     * @param {!ol.style.Style} style\n     * @param {!Cesium.Primitive} primitive current primitive\n     * @return {!Cesium.PrimitiveCollection}\n     * @protected\n     */\n    addTextStyle(layer, feature, geometry, style, primitive) {\n        let primitives;\n        if (!(primitive instanceof Cesium.PrimitiveCollection)) {\n            primitives = new Cesium.PrimitiveCollection();\n            primitives.add(primitive);\n        }\n        else {\n            primitives = primitive;\n        }\n        if (!style.getText()) {\n            return primitives;\n        }\n        const text = /** @type {!ol.style.Text} */ (style.getText());\n        const label = this.olGeometry4326TextPartToCesium(layer, feature, geometry, text);\n        if (label) {\n            primitives.add(label);\n        }\n        return primitives;\n    }\n    /**\n     * Add a billboard to a Cesium.BillboardCollection.\n     * Overriding this wrapper allows manipulating the billboard options.\n     * @param {!Cesium.BillboardCollection} billboards\n     * @param {!Cesium.optionsBillboardCollectionAdd} bbOptions\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature.\n     * @param {!ol.geom.Geometry} geometry\n     * @param {!ol.style.Style} style\n     * @return {!Cesium.Billboard} newly created billboard\n     * @api\n     */\n    csAddBillboard(billboards, bbOptions, layer, feature, geometry, style) {\n        if (!bbOptions.eyeOffset) {\n            bbOptions.eyeOffset = this.defaultBillboardEyeOffset_;\n        }\n        const bb = billboards.add(bbOptions);\n        this.setReferenceForPicking(layer, feature, bb);\n        return bb;\n    }\n    /**\n     * Convert an OpenLayers circle geometry to Cesium.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature..\n     * @param {!ol.geom.Circle} olGeometry OpenLayers circle geometry.\n     * @param {!ol.ProjectionLike} projection\n     * @param {!ol.style.Style} olStyle\n     * @return {!Cesium.PrimitiveCollection} primitives\n     * @api\n     */\n    olCircleGeometryToCesium(layer, feature, olGeometry, projection, olStyle) {\n        olGeometry = olGeometryCloneTo4326(olGeometry, projection);\n        console.assert(olGeometry.getType() == 'Circle');\n        // ol.Coordinate\n        let center = olGeometry.getCenter();\n        const height = center.length == 3 ? center[2] : 0.0;\n        let point = center.slice();\n        point[0] += olGeometry.getRadius();\n        // Cesium\n        center = ol4326CoordinateToCesiumCartesian(center);\n        point = ol4326CoordinateToCesiumCartesian(point);\n        // Accurate computation of straight distance\n        const radius = Cesium.Cartesian3.distance(center, point);\n        const fillGeometry = new Cesium.CircleGeometry({\n            // always update Cesium externs before adding a property\n            center,\n            radius,\n            height\n        });\n        let outlinePrimitive, outlineGeometry;\n        if (this.getHeightReference(layer, feature, olGeometry) === Cesium.HeightReference.CLAMP_TO_GROUND) {\n            const width = this.extractLineWidthFromOlStyle(olStyle);\n            if (width) {\n                const circlePolygon = olCreateCircularPolygon(olGeometry.getCenter(), radius);\n                const positions = ol4326CoordinateArrayToCsCartesians(circlePolygon.getLinearRing(0).getCoordinates());\n                if (!isGroundPolylinePrimitiveSupported(this.scene)) {\n                    const color = this.extractColorFromOlStyle(olStyle, true);\n                    outlinePrimitive = this.createStackedGroundCorridors(layer, feature, width, color, positions);\n                }\n                else {\n                    outlinePrimitive = new Cesium.GroundPolylinePrimitive({\n                        geometryInstances: new Cesium.GeometryInstance({\n                            geometry: new Cesium.GroundPolylineGeometry({ positions, width }),\n                        }),\n                        appearance: new Cesium.PolylineMaterialAppearance({\n                            material: this.olStyleToCesium(feature, olStyle, true),\n                        }),\n                        classificationType: Cesium.ClassificationType.TERRAIN,\n                    });\n                    waitReady(outlinePrimitive).then(() => {\n                        this.setReferenceForPicking(layer, feature, outlinePrimitive._primitive);\n                    });\n                }\n            }\n        }\n        else {\n            outlineGeometry = new Cesium.CircleOutlineGeometry({\n                // always update Cesium externs before adding a property\n                center,\n                radius,\n                extrudedHeight: height,\n                height\n            });\n        }\n        const primitives = this.wrapFillAndOutlineGeometries(layer, feature, olGeometry, fillGeometry, outlineGeometry, olStyle);\n        if (outlinePrimitive) {\n            primitives.add(outlinePrimitive);\n        }\n        return this.addTextStyle(layer, feature, olGeometry, olStyle, primitives);\n    }\n    /**\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature..\n     * @param {!number} width The width of the line.\n     * @param {!Cesium.Color} color The color of the line.\n     * @param {!Array<Cesium.Cartesian3>|Array<Array<Cesium.Cartesian3>>} positions The vertices of the line(s).\n     * @return {!Cesium.GroundPrimitive} primitive\n     */\n    createStackedGroundCorridors(layer, feature, width, color, positions) {\n        // Convert positions to an Array if it isn't\n        if (!Array.isArray(positions[0])) {\n            positions = [positions];\n        }\n        width = Math.max(3, width); // A <3px width is too small for ground primitives\n        const geometryInstances = [];\n        let previousDistance = 0;\n        // A stack of ground lines with increasing width (in meters) are created.\n        // Only one of these lines is displayed at any time giving a feeling of continuity.\n        // The values for the distance and width factor are more or less arbitrary.\n        // Applications can override this logics by subclassing the FeatureConverter class.\n        for (const distance of [1000, 4000, 16000, 64000, 254000, 1000000, 10000000]) {\n            width *= 2.14;\n            const geometryOptions = {\n                // always update Cesium externs before adding a property\n                width,\n                vertexFormat: Cesium.VertexFormat.POSITION_ONLY\n            };\n            for (const linePositions of positions) {\n                geometryOptions.positions = linePositions;\n                geometryInstances.push(new Cesium.GeometryInstance({\n                    geometry: new Cesium.CorridorGeometry(geometryOptions),\n                    attributes: {\n                        color: Cesium.ColorGeometryInstanceAttribute.fromColor(color),\n                        distanceDisplayCondition: new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(previousDistance, distance - 1)\n                    }\n                }));\n            }\n            previousDistance = distance;\n        }\n        return new Cesium.GroundPrimitive({\n            // always update Cesium externs before adding a property\n            geometryInstances\n        });\n    }\n    /**\n     * Convert an OpenLayers line string geometry to Cesium.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature..\n     * @param {!ol.geom.LineString} olGeometry OpenLayers line string geometry.\n     * @param {!ol.ProjectionLike} projection\n     * @param {!ol.style.Style} olStyle\n     * @return {!Cesium.PrimitiveCollection} primitives\n     * @api\n     */\n    olLineStringGeometryToCesium(layer, feature, olGeometry, projection, olStyle) {\n        olGeometry = olGeometryCloneTo4326(olGeometry, projection);\n        console.assert(olGeometry.getType() == 'LineString');\n        const positions = ol4326CoordinateArrayToCsCartesians(olGeometry.getCoordinates());\n        const width = this.extractLineWidthFromOlStyle(olStyle);\n        let outlinePrimitive;\n        const heightReference = this.getHeightReference(layer, feature, olGeometry);\n        if (heightReference === Cesium.HeightReference.CLAMP_TO_GROUND && !isGroundPolylinePrimitiveSupported(this.scene)) {\n            const color = this.extractColorFromOlStyle(olStyle, true);\n            outlinePrimitive = this.createStackedGroundCorridors(layer, feature, width, color, positions);\n        }\n        else {\n            const appearance = new Cesium.PolylineMaterialAppearance({\n                // always update Cesium externs before adding a property\n                material: this.olStyleToCesium(feature, olStyle, true)\n            });\n            const geometryOptions = {\n                // always update Cesium externs before adding a property\n                positions,\n                width,\n            };\n            const primitiveOptions = {\n                // always update Cesium externs before adding a property\n                appearance\n            };\n            if (heightReference === Cesium.HeightReference.CLAMP_TO_GROUND) {\n                const geometry = new Cesium.GroundPolylineGeometry(geometryOptions);\n                primitiveOptions.geometryInstances = new Cesium.GeometryInstance({\n                    geometry\n                }),\n                    outlinePrimitive = new Cesium.GroundPolylinePrimitive(primitiveOptions);\n                waitReady(outlinePrimitive).then(() => {\n                    this.setReferenceForPicking(layer, feature, outlinePrimitive._primitive);\n                });\n            }\n            else {\n                geometryOptions.vertexFormat = appearance.vertexFormat;\n                const geometry = new Cesium.PolylineGeometry(geometryOptions);\n                primitiveOptions.geometryInstances = new Cesium.GeometryInstance({\n                    geometry\n                }),\n                    outlinePrimitive = new Cesium.Primitive(primitiveOptions);\n            }\n        }\n        this.setReferenceForPicking(layer, feature, outlinePrimitive);\n        return this.addTextStyle(layer, feature, olGeometry, olStyle, outlinePrimitive);\n    }\n    /**\n     * Convert an OpenLayers polygon geometry to Cesium.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature..\n     * @param {!ol.geom.Polygon} olGeometry OpenLayers polygon geometry.\n     * @param {!ol.ProjectionLike} projection\n     * @param {!ol.style.Style} olStyle\n     * @return {!Cesium.PrimitiveCollection} primitives\n     * @api\n     */\n    olPolygonGeometryToCesium(layer, feature, olGeometry, projection, olStyle) {\n        olGeometry = olGeometryCloneTo4326(olGeometry, projection);\n        console.assert(olGeometry.getType() == 'Polygon');\n        const heightReference = this.getHeightReference(layer, feature, olGeometry);\n        let fillGeometry, outlineGeometry, outlinePrimitive;\n        if ((olGeometry.getCoordinates()[0].length == 5) &&\n            (feature.get('olcs.polygon_kind') === 'rectangle')) {\n            // Create a rectangle according to the longitude and latitude curves\n            const coordinates = olGeometry.getCoordinates()[0];\n            // Extract the West, South, East, North coordinates\n            const extent = boundingExtent(coordinates);\n            const rectangle = Cesium.Rectangle.fromDegrees(extent[0], extent[1], extent[2], extent[3]);\n            // Extract the average height of the vertices\n            let maxHeight = 0.0;\n            if (coordinates[0].length == 3) {\n                for (let c = 0; c < coordinates.length; c++) {\n                    maxHeight = Math.max(maxHeight, coordinates[c][2]);\n                }\n            }\n            const featureExtrudedHeight = feature.getProperty('olcs_extruded_height');\n            // Render the cartographic rectangle\n            fillGeometry = new Cesium.RectangleGeometry({\n                ellipsoid: Cesium.Ellipsoid.WGS84,\n                rectangle,\n                height: maxHeight,\n                extrudedHeight: featureExtrudedHeight,\n            });\n            outlineGeometry = new Cesium.RectangleOutlineGeometry({\n                ellipsoid: Cesium.Ellipsoid.WGS84,\n                rectangle,\n                height: maxHeight,\n                extrudedHeight: featureExtrudedHeight,\n            });\n        }\n        else {\n            const rings = olGeometry.getLinearRings();\n            // always update Cesium externs before adding a property\n            const hierarchy = {};\n            const polygonHierarchy = hierarchy;\n            console.assert(rings.length > 0);\n            for (let i = 0; i < rings.length; ++i) {\n                const olPos = rings[i].getCoordinates();\n                const positions = ol4326CoordinateArrayToCsCartesians(olPos);\n                console.assert(positions && positions.length > 0);\n                if (i == 0) {\n                    hierarchy.positions = positions;\n                }\n                else {\n                    if (!hierarchy.holes) {\n                        hierarchy.holes = [];\n                    }\n                    hierarchy.holes.push({\n                        positions\n                    });\n                }\n            }\n            const featureExtrudedHeight = feature.get('olcs_extruded_height');\n            fillGeometry = new Cesium.PolygonGeometry({\n                // always update Cesium externs before adding a property\n                polygonHierarchy,\n                perPositionHeight: true,\n                extrudedHeight: featureExtrudedHeight,\n            });\n            // Since Cesium doesn't yet support Polygon outlines on terrain yet (coming soon...?)\n            // we don't create an outline geometry if clamped, but instead do the polyline method\n            // for each ring. Most of this code should be removeable when Cesium adds\n            // support for Polygon outlines on terrain.\n            if (heightReference === Cesium.HeightReference.CLAMP_TO_GROUND) {\n                const width = this.extractLineWidthFromOlStyle(olStyle);\n                if (width > 0) {\n                    const positions = [hierarchy.positions];\n                    if (hierarchy.holes) {\n                        for (let i = 0; i < hierarchy.holes.length; ++i) {\n                            positions.push(hierarchy.holes[i].positions);\n                        }\n                    }\n                    if (!isGroundPolylinePrimitiveSupported(this.scene)) {\n                        const color = this.extractColorFromOlStyle(olStyle, true);\n                        outlinePrimitive = this.createStackedGroundCorridors(layer, feature, width, color, positions);\n                    }\n                    else {\n                        const appearance = new Cesium.PolylineMaterialAppearance({\n                            // always update Cesium externs before adding a property\n                            material: this.olStyleToCesium(feature, olStyle, true)\n                        });\n                        const geometryInstances = [];\n                        for (const linePositions of positions) {\n                            const polylineGeometry = new Cesium.GroundPolylineGeometry({ positions: linePositions, width });\n                            geometryInstances.push(new Cesium.GeometryInstance({\n                                geometry: polylineGeometry\n                            }));\n                        }\n                        const primitiveOptions = {\n                            // always update Cesium externs before adding a property\n                            appearance,\n                            geometryInstances\n                        };\n                        outlinePrimitive = new Cesium.GroundPolylinePrimitive(primitiveOptions);\n                        waitReady(outlinePrimitive).then(() => {\n                            this.setReferenceForPicking(layer, feature, outlinePrimitive._primitive);\n                        });\n                    }\n                }\n            }\n            else {\n                // Actually do the normal polygon thing. This should end the removable\n                // section of code described above.\n                outlineGeometry = new Cesium.PolygonOutlineGeometry({\n                    // always update Cesium externs before adding a property\n                    polygonHierarchy: hierarchy,\n                    perPositionHeight: true,\n                    extrudedHeight: featureExtrudedHeight,\n                });\n            }\n        }\n        const primitives = this.wrapFillAndOutlineGeometries(layer, feature, olGeometry, fillGeometry, outlineGeometry, olStyle);\n        if (outlinePrimitive) {\n            primitives.add(outlinePrimitive);\n        }\n        return this.addTextStyle(layer, feature, olGeometry, olStyle, primitives);\n    }\n    /**\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {ol.Feature} feature OpenLayers feature..\n     * @param {!ol.geom.Geometry} geometry\n     * @return {!Cesium.HeightReference}\n     * @api\n     */\n    getHeightReference(layer, feature, geometry) {\n        // Read from the geometry\n        let altitudeMode = geometry.get('altitudeMode');\n        // Or from the feature\n        if (altitudeMode === undefined) {\n            altitudeMode = feature.get('altitudeMode');\n        }\n        // Or from the layer\n        if (altitudeMode === undefined) {\n            altitudeMode = layer.get('altitudeMode');\n        }\n        let heightReference = Cesium.HeightReference.NONE;\n        if (altitudeMode === 'clampToGround') {\n            heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;\n        }\n        else if (altitudeMode === 'relativeToGround') {\n            heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;\n        }\n        return heightReference;\n    }\n    /**\n     * Convert a point geometry to a Cesium BillboardCollection.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature..\n     * @param {!ol.geom.Point} olGeometry OpenLayers point geometry.\n     * @param {!ol.ProjectionLike} projection\n     * @param {!ol.style.Style} style\n     * @param {!ol.style.Image} imageStyle\n     * @param {!Cesium.BillboardCollection} billboards\n     * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when the new billboard is added.\n     * @api\n     */\n    createBillboardFromImage(layer, feature, olGeometry, projection, style, imageStyle, billboards, opt_newBillboardCallback) {\n        if (imageStyle instanceof olStyleIcon) {\n            // make sure the image is scheduled for load\n            imageStyle.load();\n        }\n        const image = imageStyle.getImage(1); // get normal density\n        const isImageLoaded = function (image) {\n            return image.src != '' &&\n                image.naturalHeight != 0 &&\n                image.naturalWidth != 0 &&\n                image.complete;\n        };\n        const reallyCreateBillboard = (function () {\n            if (!image) {\n                return;\n            }\n            if (!(image instanceof HTMLCanvasElement ||\n                image instanceof Image ||\n                image instanceof HTMLImageElement)) {\n                return;\n            }\n            const center = olGeometry.getCoordinates();\n            const position = ol4326CoordinateToCesiumCartesian(center);\n            let color;\n            const opacity = imageStyle.getOpacity();\n            if (opacity !== undefined) {\n                color = new Cesium.Color(1.0, 1.0, 1.0, opacity);\n            }\n            const scale = imageStyle.getScale();\n            const heightReference = this.getHeightReference(layer, feature, olGeometry);\n            const bbOptions = /** @type {Cesium.optionsBillboardCollectionAdd} */ ({\n                // always update Cesium externs before adding a property\n                image,\n                color,\n                scale,\n                heightReference,\n                position\n            });\n            // merge in cesium options from openlayers feature\n            Object.assign(bbOptions, feature.get('cesiumOptions'));\n            if (imageStyle instanceof olStyleIcon) {\n                const anchor = imageStyle.getAnchor();\n                if (anchor) {\n                    bbOptions.pixelOffset = new Cesium.Cartesian2((image.width / 2 - anchor[0]) * scale, (image.height / 2 - anchor[1]) * scale);\n                }\n            }\n            const bb = this.csAddBillboard(billboards, bbOptions, layer, feature, olGeometry, style);\n            if (opt_newBillboardCallback) {\n                opt_newBillboardCallback(bb);\n            }\n        }).bind(this);\n        if (image instanceof Image && !isImageLoaded(image)) {\n            // Cesium requires the image to be loaded\n            let cancelled = false;\n            const source = layer.getSource();\n            const canceller = function () {\n                cancelled = true;\n            };\n            source.on(['removefeature', 'clear'], this.boundOnRemoveOrClearFeatureListener_);\n            let cancellers = obj(source)['olcs_cancellers'];\n            if (!cancellers) {\n                cancellers = obj(source)['olcs_cancellers'] = {};\n            }\n            const fuid = getUid(feature);\n            if (cancellers[fuid]) {\n                // When the feature change quickly, a canceller may still be present so\n                // we cancel it here to prevent creation of a billboard.\n                cancellers[fuid]();\n            }\n            cancellers[fuid] = canceller;\n            const listener = function () {\n                image.removeEventListener('load', listener);\n                if (!billboards.isDestroyed() && !cancelled) {\n                    // Create billboard if the feature is still displayed on the map.\n                    reallyCreateBillboard();\n                }\n            };\n            image.addEventListener('load', listener);\n        }\n        else {\n            reallyCreateBillboard();\n        }\n    }\n    /**\n     * Convert a point geometry to a Cesium BillboardCollection.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature..\n     * @param {!ol.geom.Point} olGeometry OpenLayers point geometry.\n     * @param {!ol.ProjectionLike} projection\n     * @param {!ol.style.Style} style\n     * @param {!Cesium.BillboardCollection} billboards\n     * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when\n     * the new billboard is added.\n     * @return {Cesium.Primitive} primitives\n     * @api\n     */\n    olPointGeometryToCesium(layer, feature, olGeometry, projection, style, billboards, opt_newBillboardCallback) {\n        console.assert(olGeometry.getType() == 'Point');\n        olGeometry = olGeometryCloneTo4326(olGeometry, projection);\n        let modelPrimitive = null;\n        const imageStyle = style.getImage();\n        if (imageStyle) {\n            const olcsModelFunction = /** @type {function():olcsx.ModelStyle} */ (olGeometry.get('olcs_model') || feature.get('olcs_model'));\n            if (olcsModelFunction) {\n                modelPrimitive = new Cesium.PrimitiveCollection();\n                const olcsModel = olcsModelFunction();\n                const options = /** @type {Cesium.ModelFromGltfOptions} */ (Object.assign({}, { scene: this.scene }, olcsModel.cesiumOptions));\n                if (Cesium.Model.fromGltf) {\n                    // pre Cesium v107\n                    const model = Cesium.Model.fromGltf(options);\n                    modelPrimitive.add(model);\n                }\n                else {\n                    Cesium.Model.fromGltfAsync(options).then((model) => {\n                        modelPrimitive.add(model);\n                    });\n                }\n                if (olcsModel.debugModelMatrix) {\n                    modelPrimitive.add(new Cesium.DebugModelMatrixPrimitive({\n                        modelMatrix: olcsModel.debugModelMatrix\n                    }));\n                }\n            }\n            else {\n                this.createBillboardFromImage(layer, feature, olGeometry, projection, style, imageStyle, billboards, opt_newBillboardCallback);\n            }\n        }\n        if (style.getText()) {\n            return this.addTextStyle(layer, feature, olGeometry, style, modelPrimitive || new Cesium.Primitive());\n        }\n        else {\n            return modelPrimitive;\n        }\n    }\n    /**\n     * Convert an OpenLayers multi-something geometry to Cesium.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature..\n     * @param {!ol.geom.Geometry} geometry OpenLayers geometry.\n     * @param {!ol.ProjectionLike} projection\n     * @param {!ol.style.Style} olStyle\n     * @param {!Cesium.BillboardCollection} billboards\n     * @param {function(!Cesium.Billboard)=} opt_newBillboardCallback Called when\n     * the new billboard is added.\n     * @return {Cesium.Primitive} primitives\n     * @api\n     */\n    olMultiGeometryToCesium(layer, feature, geometry, projection, olStyle, billboards, opt_newBillboardCallback) {\n        // Do not reproject to 4326 now because it will be done later.\n        // FIXME: would be better to combine all child geometries in one primitive\n        // instead we create n primitives for simplicity.\n        const accumulate = function (geometries, functor) {\n            const primitives = new Cesium.PrimitiveCollection();\n            geometries.forEach((geometry) => {\n                primitives.add(functor(layer, feature, geometry, projection, olStyle));\n            });\n            return primitives;\n        };\n        let subgeos;\n        switch (geometry.getType()) {\n            case 'MultiPoint':\n                geometry = /** @type {!ol.geom.MultiPoint} */ (geometry);\n                subgeos = geometry.getPoints();\n                if (olStyle.getText()) {\n                    const primitives = new Cesium.PrimitiveCollection();\n                    subgeos.forEach((geometry) => {\n                        console.assert(geometry);\n                        const result = this.olPointGeometryToCesium(layer, feature, geometry, projection, olStyle, billboards, opt_newBillboardCallback);\n                        if (result) {\n                            primitives.add(result);\n                        }\n                    });\n                    return primitives;\n                }\n                else {\n                    subgeos.forEach((geometry) => {\n                        console.assert(geometry);\n                        this.olPointGeometryToCesium(layer, feature, geometry, projection, olStyle, billboards, opt_newBillboardCallback);\n                    });\n                    return null;\n                }\n            case 'MultiLineString':\n                geometry = /** @type {!ol.geom.MultiLineString} */ (geometry);\n                subgeos = geometry.getLineStrings();\n                return accumulate(subgeos, this.olLineStringGeometryToCesium.bind(this));\n            case 'MultiPolygon':\n                geometry = /** @type {!ol.geom.MultiPolygon} */ (geometry);\n                subgeos = geometry.getPolygons();\n                return accumulate(subgeos, this.olPolygonGeometryToCesium.bind(this));\n            default:\n                console.assert(false, `Unhandled multi geometry type${geometry.getType()}`);\n        }\n    }\n    /**\n     * Convert an OpenLayers text style to Cesium.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature..\n     * @param {!ol.geom.Geometry} geometry\n     * @param {!ol.style.Text} style\n     * @return {Cesium.LabelCollection} Cesium primitive\n     * @api\n     */\n    olGeometry4326TextPartToCesium(layer, feature, geometry, style) {\n        const text = style.getText();\n        if (!text) {\n            return null;\n        }\n        const labels = new Cesium.LabelCollection({ scene: this.scene });\n        // TODO: export and use the text draw position from OpenLayers .\n        // See src/ol/render/vector.js\n        const extentCenter = getCenter(geometry.getExtent());\n        if (geometry instanceof olGeomSimpleGeometry) {\n            const first = geometry.getFirstCoordinate();\n            extentCenter[2] = first.length == 3 ? first[2] : 0.0;\n        }\n        const options = /** @type {Cesium.optionsLabelCollection} */ ({});\n        options.position = ol4326CoordinateToCesiumCartesian(extentCenter);\n        options.text = text;\n        options.heightReference = this.getHeightReference(layer, feature, geometry);\n        const offsetX = style.getOffsetX();\n        const offsetY = style.getOffsetY();\n        if (offsetX != 0 && offsetY != 0) {\n            const offset = new Cesium.Cartesian2(offsetX, offsetY);\n            options.pixelOffset = offset;\n        }\n        options.font = style.getFont() || '10px sans-serif'; // OpenLayers default\n        let labelStyle = undefined;\n        if (style.getFill()) {\n            options.fillColor = this.extractColorFromOlStyle(style, false);\n            labelStyle = Cesium.LabelStyle.FILL;\n        }\n        if (style.getStroke()) {\n            options.outlineWidth = this.extractLineWidthFromOlStyle(style);\n            options.outlineColor = this.extractColorFromOlStyle(style, true);\n            labelStyle = Cesium.LabelStyle.OUTLINE;\n        }\n        if (style.getFill() && style.getStroke()) {\n            labelStyle = Cesium.LabelStyle.FILL_AND_OUTLINE;\n        }\n        options.style = labelStyle;\n        let horizontalOrigin;\n        switch (style.getTextAlign()) {\n            case 'left':\n                horizontalOrigin = Cesium.HorizontalOrigin.LEFT;\n                break;\n            case 'right':\n                horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;\n                break;\n            case 'center':\n            default:\n                horizontalOrigin = Cesium.HorizontalOrigin.CENTER;\n        }\n        options.horizontalOrigin = horizontalOrigin;\n        if (style.getTextBaseline()) {\n            let verticalOrigin;\n            switch (style.getTextBaseline()) {\n                case 'top':\n                    verticalOrigin = Cesium.VerticalOrigin.TOP;\n                    break;\n                case 'middle':\n                    verticalOrigin = Cesium.VerticalOrigin.CENTER;\n                    break;\n                case 'bottom':\n                    verticalOrigin = Cesium.VerticalOrigin.BOTTOM;\n                    break;\n                case 'alphabetic':\n                    verticalOrigin = Cesium.VerticalOrigin.TOP;\n                    break;\n                case 'hanging':\n                    verticalOrigin = Cesium.VerticalOrigin.BOTTOM;\n                    break;\n                default:\n                    console.assert(false, `unhandled baseline ${style.getTextBaseline()}`);\n            }\n            options.verticalOrigin = verticalOrigin;\n        }\n        const l = labels.add(options);\n        this.setReferenceForPicking(layer, feature, l);\n        return labels;\n    }\n    /**\n     * Convert an OpenLayers style to a Cesium Material.\n     * @param {ol.Feature} feature OpenLayers feature..\n     * @param {!ol.style.Style} style\n     * @param {boolean} outline\n     * @return {Cesium.Material}\n     * @api\n     */\n    olStyleToCesium(feature, style, outline) {\n        const fill = style.getFill();\n        const stroke = style.getStroke();\n        if ((outline && !stroke) || (!outline && !fill)) {\n            return null; // FIXME use a default style? Developer error?\n        }\n        let color = outline ? stroke.getColor() : fill.getColor();\n        color = convertColorToCesium(color);\n        if (outline && stroke.getLineDash()) {\n            return Cesium.Material.fromType('Stripe', {\n                // always update Cesium externs before adding a property\n                horizontal: false,\n                repeat: 500,\n                evenColor: color,\n                oddColor: new Cesium.Color(0, 0, 0, 0) // transparent\n            });\n        }\n        else {\n            return Cesium.Material.fromType('Color', {\n                // always update Cesium externs before adding a property\n                color\n            });\n        }\n    }\n    /**\n     * Compute OpenLayers plain style.\n     * Evaluates style function, blend arrays, get default style.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature\n     * @param {ol.StyleFunction|undefined} fallbackStyleFunction\n     * @param {number} resolution\n     * @return {Array.<!ol.style.Style>} null if no style is available\n     * @api\n     */\n    computePlainStyle(layer, feature, fallbackStyleFunction, resolution) {\n        /**\n         * @type {ol.FeatureStyleFunction|undefined}\n         */\n        const featureStyleFunction = feature.getStyleFunction();\n        /**\n         * @type {ol.style.Style|Array.<ol.style.Style>}\n         */\n        let style = null;\n        if (featureStyleFunction) {\n            style = featureStyleFunction(feature, resolution);\n        }\n        if (!style && fallbackStyleFunction) {\n            style = fallbackStyleFunction(feature, resolution);\n        }\n        if (!style) {\n            // The feature must not be displayed\n            return null;\n        }\n        // FIXME combine materials as in cesium-materials-pack?\n        // then this function must return a custom material\n        // More simply, could blend the colors like described in\n        // http://en.wikipedia.org/wiki/Alpha_compositing\n        return Array.isArray(style) ? style : [style];\n    }\n    /**\n     * @protected\n     * @param {!ol.Feature} feature\n     * @param {!ol.style.Style} style\n     * @param {!ol.geom.Geometry=} opt_geom Geometry to be converted.\n     * @return {ol.geom.Geometry|undefined}\n     */\n    getGeometryFromFeature(feature, style, opt_geom) {\n        if (opt_geom) {\n            return opt_geom;\n        }\n        const geom3d = /** @type {!ol.geom.Geometry} */ (feature.get('olcs.3d_geometry'));\n        if (geom3d && geom3d instanceof olGeomGeometry) {\n            return geom3d;\n        }\n        if (style) {\n            const geomFuncRes = style.getGeometryFunction()(feature);\n            if (geomFuncRes instanceof olGeomGeometry) {\n                return geomFuncRes;\n            }\n        }\n        return feature.getGeometry();\n    }\n    /**\n     * Convert one OpenLayers feature up to a collection of Cesium primitives.\n     * @param {ol.layer.Vector|ol.layer.Image} layer\n     * @param {!ol.Feature} feature OpenLayers feature.\n     * @param {!ol.style.Style} style\n     * @param {!import('olcs/core/VectorLayerConterpart.js').OlFeatureToCesiumContext} context\n     * @param {!ol.geom.Geometry=} opt_geom Geometry to be converted.\n     * @return {Cesium.Primitive} primitives\n     * @api\n     */\n    olFeatureToCesium(layer, feature, style, context, opt_geom) {\n        let geom = this.getGeometryFromFeature(feature, style, opt_geom);\n        if (!geom) {\n            // OpenLayers features may not have a geometry\n            // See http://geojson.org/geojson-spec.html#feature-objects\n            return null;\n        }\n        const proj = context.projection;\n        const newBillboardAddedCallback = function (bb) {\n            const featureBb = context.featureToCesiumMap[getUid(feature)];\n            if (featureBb instanceof Array) {\n                featureBb.push(bb);\n            }\n            else {\n                context.featureToCesiumMap[getUid(feature)] = [bb];\n            }\n        };\n        switch (geom.getType()) {\n            case 'GeometryCollection':\n                const primitives = new Cesium.PrimitiveCollection();\n                const collection = /** @type {!ol.geom.GeometryCollection} */ (geom);\n                // TODO: use getGeometriesArray() instead\n                collection.getGeometries().forEach((geom) => {\n                    if (geom) {\n                        const prims = this.olFeatureToCesium(layer, feature, style, context, geom);\n                        if (prims) {\n                            primitives.add(prims);\n                        }\n                    }\n                });\n                return primitives;\n            case 'Point':\n                geom = /** @type {!ol.geom.Point} */ (geom);\n                const bbs = context.billboards;\n                const result = this.olPointGeometryToCesium(layer, feature, geom, proj, style, bbs, newBillboardAddedCallback);\n                if (!result) {\n                    // no wrapping primitive\n                    return null;\n                }\n                else {\n                    return result;\n                }\n            case 'Circle':\n                geom = /** @type {!ol.geom.Circle} */ (geom);\n                return this.olCircleGeometryToCesium(layer, feature, geom, proj, style);\n            case 'LineString':\n                geom = /** @type {!ol.geom.LineString} */ (geom);\n                return this.olLineStringGeometryToCesium(layer, feature, geom, proj, style);\n            case 'Polygon':\n                geom = /** @type {!ol.geom.Polygon} */ (geom);\n                return this.olPolygonGeometryToCesium(layer, feature, geom, proj, style);\n            case 'MultiPoint':\n            case 'MultiLineString':\n            case 'MultiPolygon':\n                const result2 = this.olMultiGeometryToCesium(layer, feature, geom, proj, style, context.billboards, newBillboardAddedCallback);\n                if (!result2) {\n                    // no wrapping primitive\n                    return null;\n                }\n                else {\n                    return result2;\n                }\n            case 'LinearRing':\n                throw new Error('LinearRing should only be part of polygon.');\n            default:\n                throw new Error(`Ol geom type not handled : ${geom.getType()}`);\n        }\n    }\n    /**\n     * Convert an OpenLayers vector layer to Cesium primitive collection.\n     * For each feature, the associated primitive will be stored in\n     * `featurePrimitiveMap`.\n     * @param {!(ol.layer.Vector|ol.layer.Image)} olLayer\n     * @param {!ol.View} olView\n     * @param {!Object.<number, !Cesium.Primitive>} featurePrimitiveMap\n     * @return {!olcs.core.VectorLayerCounterpart}\n     * @api\n     */\n    olVectorLayerToCesium(olLayer, olView, featurePrimitiveMap) {\n        const proj = olView.getProjection();\n        const resolution = olView.getResolution();\n        if (resolution === undefined || !proj) {\n            console.assert(false, 'View not ready');\n            // an assertion is not enough for closure to assume resolution and proj\n            // are defined\n            throw new Error('View not ready');\n        }\n        let source = olLayer.getSource();\n        if (source instanceof olSourceCluster) {\n            source = source.getSource();\n        }\n        console.assert(source instanceof olSourceVector);\n        const features = source.getFeatures();\n        const counterpart = new olcsCoreVectorLayerCounterpart(proj, this.scene);\n        const context = counterpart.context;\n        for (let i = 0; i < features.length; ++i) {\n            const feature = features[i];\n            if (!feature) {\n                continue;\n            }\n            /**\n             * @type {ol.StyleFunction|undefined}\n             */\n            const layerStyle = olLayer.getStyleFunction();\n            const styles = this.computePlainStyle(olLayer, feature, layerStyle, resolution);\n            if (!styles || !styles.length) {\n                // only 'render' features with a style\n                continue;\n            }\n            /**\n             * @type {Cesium.Primitive|null}\n             */\n            let primitives = null;\n            for (let i = 0; i < styles.length; i++) {\n                const prims = this.olFeatureToCesium(olLayer, feature, styles[i], context);\n                if (prims) {\n                    if (!primitives) {\n                        primitives = prims;\n                    }\n                    else if (prims) {\n                        let i = 0, prim;\n                        while ((prim = prims.get(i))) {\n                            primitives.add(prim);\n                            i++;\n                        }\n                    }\n                }\n            }\n            if (!primitives) {\n                continue;\n            }\n            featurePrimitiveMap[getUid(feature)] = primitives;\n            counterpart.getRootPrimitive().add(primitives);\n        }\n        return counterpart;\n    }\n    /**\n     * Convert an OpenLayers feature to Cesium primitive collection.\n     * @param {!(ol.layer.Vector|ol.layer.Image)} layer\n     * @param {!ol.View} view\n     * @param {!ol.Feature} feature\n     * @param {!import('olcs/core/VectorLayerConterpart.js').OlFeatureToCesiumContext} context\n     * @return {Cesium.Primitive}\n     * @api\n     */\n    convert(layer, view, feature, context) {\n        const proj = view.getProjection();\n        const resolution = view.getResolution();\n        if (resolution == undefined || !proj) {\n            return null;\n        }\n        /**\n         * @type {ol.StyleFunction|undefined}\n         */\n        const layerStyle = layer.getStyleFunction();\n        const styles = this.computePlainStyle(layer, feature, layerStyle, resolution);\n        if (!styles || !styles.length) {\n            // only 'render' features with a style\n            return null;\n        }\n        context.projection = proj;\n        /**\n         * @type {Cesium.Primitive|null}\n         */\n        let primitives = null;\n        for (let i = 0; i < styles.length; i++) {\n            const prims = this.olFeatureToCesium(layer, feature, styles[i], context);\n            if (!primitives) {\n                primitives = prims;\n            }\n            else if (prims) {\n                let i = 0, prim;\n                while ((prim = prims.get(i))) {\n                    primitives.add(prim);\n                    i++;\n                }\n            }\n        }\n        return primitives;\n    }\n}\nexport default FeatureConverter;\n","/**\n * @module olcs.VectorSynchronizer\n */\nimport olSourceVector, { VectorSourceEvent } from 'ol/source/Vector.js';\nimport olLayerLayer from 'ol/layer/Layer.js';\nimport olSourceCluster from 'ol/source/Cluster.js';\nimport { olcsListen, getUid } from './util.js';\nimport olLayerVector from 'ol/layer/Vector.js';\nimport olLayerVectorTile from 'ol/layer/VectorTile.js';\nimport olcsAbstractSynchronizer from './AbstractSynchronizer.js';\nimport olcsFeatureConverter from './FeatureConverter.js';\nimport VectorLayerCounterpart, {} from './core/VectorLayerCounterpart.js';\nimport {} from './core.js';\nimport Feature from 'ol/Feature.js';\nimport BaseLayer from 'ol/layer/Base.js';\nimport { Primitive, PrimitiveCollection, Scene } from 'cesium';\nclass VectorSynchronizer extends olcsAbstractSynchronizer {\n    converter;\n    csAllPrimitives_;\n    /**\n     * Unidirectionally synchronize OpenLayers vector layers to Cesium.\n     */\n    constructor(map, scene, opt_converter) {\n        super(map, scene);\n        this.converter = opt_converter || new olcsFeatureConverter(scene);\n        this.csAllPrimitives_ = new Cesium.PrimitiveCollection();\n        scene.primitives.add(this.csAllPrimitives_);\n        this.csAllPrimitives_.destroyPrimitives = false;\n    }\n    addCesiumObject(counterpart) {\n        console.assert(counterpart);\n        const collection = counterpart.getRootPrimitive();\n        collection.counterpart = counterpart;\n        this.csAllPrimitives_.add(counterpart.getRootPrimitive());\n    }\n    destroyCesiumObject(object) {\n        object.getRootPrimitive().destroy();\n    }\n    removeSingleCesiumObject(object, destroy) {\n        object.destroy();\n        this.csAllPrimitives_.destroyPrimitives = destroy;\n        this.csAllPrimitives_.remove(object.getRootPrimitive());\n        this.csAllPrimitives_.destroyPrimitives = false;\n    }\n    removeAllCesiumObjects(destroy) {\n        this.csAllPrimitives_.destroyPrimitives = destroy;\n        if (destroy) {\n            for (let i = 0; i < this.csAllPrimitives_.length; ++i) {\n                this.csAllPrimitives_.get(i)['counterpart'].destroy();\n            }\n        }\n        this.csAllPrimitives_.removeAll();\n        this.csAllPrimitives_.destroyPrimitives = false;\n    }\n    /**\n     * Synchronizes the layer visibility properties\n     * to the given Cesium Primitive.\n     */\n    updateLayerVisibility(olLayerWithParents, csPrimitive) {\n        let visible = true;\n        [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach((olLayer) => {\n            const layerVisible = olLayer.getVisible();\n            if (layerVisible !== undefined) {\n                visible = visible && layerVisible;\n            }\n            else {\n                visible = false;\n            }\n        });\n        csPrimitive.show = visible;\n    }\n    createSingleLayerCounterparts(olLayerWithParents) {\n        const olLayer = olLayerWithParents.layer;\n        if (!(olLayer instanceof olLayerVector) || olLayer instanceof olLayerVectorTile) {\n            return null;\n        }\n        console.assert(olLayer instanceof olLayerLayer);\n        let source = olLayer.getSource();\n        if (source instanceof olSourceCluster) {\n            source = source.getSource();\n        }\n        if (!source) {\n            return null;\n        }\n        console.assert(source instanceof olSourceVector);\n        console.assert(this.view);\n        const view = this.view;\n        const featurePrimitiveMap = {};\n        const counterpart = this.converter.olVectorLayerToCesium(olLayer, view, featurePrimitiveMap);\n        const csPrimitives = counterpart.getRootPrimitive();\n        const olListenKeys = counterpart.olListenKeys;\n        [olLayerWithParents.layer].concat(olLayerWithParents.parents).forEach((olLayerItem) => {\n            olListenKeys.push(olcsListen(olLayerItem, 'change:visible', () => {\n                this.updateLayerVisibility(olLayerWithParents, csPrimitives);\n            }));\n        });\n        this.updateLayerVisibility(olLayerWithParents, csPrimitives);\n        const onAddFeature = (function (feature) {\n            const context = counterpart.context;\n            const prim = this.converter.convert(olLayer, view, feature, context);\n            if (prim) {\n                featurePrimitiveMap[getUid(feature)] = prim;\n                csPrimitives.add(prim);\n            }\n        }).bind(this);\n        const onRemoveFeature = (function (feature) {\n            const id = getUid(feature);\n            const context = counterpart.context;\n            const bbs = context.featureToCesiumMap[id];\n            if (bbs) {\n                delete context.featureToCesiumMap[id];\n                bbs.forEach((bb) => {\n                    if (bb instanceof Cesium.Billboard) {\n                        context.billboards.remove(bb);\n                    }\n                });\n            }\n            const csPrimitive = featurePrimitiveMap[id];\n            delete featurePrimitiveMap[id];\n            if (csPrimitive) {\n                csPrimitives.remove(csPrimitive);\n            }\n        }).bind(this);\n        olListenKeys.push(olcsListen(source, 'addfeature', (e) => {\n            console.assert(e.feature);\n            onAddFeature(e.feature);\n        }));\n        olListenKeys.push(olcsListen(source, 'removefeature', (e) => {\n            console.assert(e.feature);\n            onRemoveFeature(e.feature);\n        }));\n        olListenKeys.push(olcsListen(source, 'changefeature', (e) => {\n            const feature = e.feature;\n            console.assert(feature);\n            onRemoveFeature(feature);\n            onAddFeature(feature);\n        }));\n        return counterpart ? [counterpart] : null;\n    }\n}\nexport default VectorSynchronizer;\n","/**\n * @module olcs.SynchronizedOverlay\n */\nimport olOverlay from 'ol/Overlay.js';\nimport { transform } from 'ol/proj.js';\nimport { removeNode, removeChildren } from './util.js';\nimport { unByKey as olObservableUnByKey } from 'ol/Observable.js';\n/**\n * Options for SynchronizedOverlay\n * @typedef {Object} SynchronizedOverlayOptions\n * @property {!Cesium.Scene} scene\n * @property {olOverlay} parent\n * @property {!import('olsc/OverlaySynchronizer.js').default} synchronizer\n */\nclass SynchronizedOverlay extends olOverlay {\n    /**\n     * @param {olcsx.SynchronizedOverlayOptions} options SynchronizedOverlay Options.\n     * @api\n     */\n    constructor(options) {\n        const parent = options.parent;\n        super(parent.getOptions());\n        /**\n         * @private\n         * @type {?Function}\n         */\n        this.scenePostRenderListenerRemover_ = null;\n        /**\n         * @private\n         * @type {!Cesium.Scene}\n         */\n        this.scene_ = options.scene;\n        /**\n         * @private\n         * @type {!olcs.OverlaySynchronizer}\n         */\n        this.synchronizer_ = options.synchronizer;\n        /**\n         * @private\n         * @type {!ol.Overlay}\n         */\n        this.parent_ = parent;\n        /**\n         * @private\n         * @type {ol.Coordinate|undefined}\n         */\n        this.positionWGS84_ = undefined;\n        /**\n         * @private\n         * @type {MutationObserver}\n         */\n        this.observer_ = new MutationObserver(this.handleElementChanged.bind(this));\n        /**\n         * @private\n         * @type {Array.<MutationObserver>}\n         */\n        this.attributeObserver_ = [];\n        /**\n         * @private\n         * @type {Array<ol.EventsKey>}\n         */\n        this.listenerKeys_ = [];\n        // synchronize our Overlay with the parent Overlay\n        const setPropertyFromEvent = event => this.setPropertyFromEvent_(event);\n        this.listenerKeys_.push(this.parent_.on('change:position', setPropertyFromEvent));\n        this.listenerKeys_.push(this.parent_.on('change:element', setPropertyFromEvent));\n        this.listenerKeys_.push(this.parent_.on('change:offset', setPropertyFromEvent));\n        this.listenerKeys_.push(this.parent_.on('change:position', setPropertyFromEvent));\n        this.listenerKeys_.push(this.parent_.on('change:positioning', setPropertyFromEvent));\n        this.setProperties(this.parent_.getProperties());\n        this.handleMapChanged();\n        this.handleElementChanged();\n    }\n    /**\n     * @param {Node} target\n     * @private\n     */\n    observeTarget_(target) {\n        if (!this.observer_) {\n            // not ready, skip the event (this occurs on construction)\n            return;\n        }\n        this.observer_.disconnect();\n        this.observer_.observe(target, {\n            attributes: false,\n            childList: true,\n            characterData: true,\n            subtree: true\n        });\n        this.attributeObserver_.forEach((observer) => {\n            observer.disconnect();\n        });\n        this.attributeObserver_.length = 0;\n        for (let i = 0; i < target.childNodes.length; i++) {\n            const node = target.childNodes[i];\n            if (node.nodeType === 1) {\n                const observer = new MutationObserver(this.handleElementChanged.bind(this));\n                observer.observe(node, {\n                    attributes: true,\n                    subtree: true\n                });\n                this.attributeObserver_.push(observer);\n            }\n        }\n    }\n    /**\n     *\n     * @param {ol.Object.Event} event\n     * @private\n     */\n    setPropertyFromEvent_(event) {\n        if (event.target && event.key) {\n            this.set(event.key, event.target.get(event.key));\n        }\n    }\n    /**\n     * Get the scene associated with this overlay.\n     * @see ol.Overlay.prototype.getMap\n     * @return {!Cesium.Scene} The scene that the overlay is part of.\n     * @api\n     */\n    getScene() {\n        return this.scene_;\n    }\n    /**\n     * @override\n     */\n    handleMapChanged() {\n        if (this.scenePostRenderListenerRemover_) {\n            this.scenePostRenderListenerRemover_();\n            removeNode(this.element);\n        }\n        this.scenePostRenderListenerRemover_ = null;\n        const scene = this.getScene();\n        if (scene) {\n            this.scenePostRenderListenerRemover_ = scene.postRender.addEventListener(this.updatePixelPosition.bind(this));\n            this.updatePixelPosition();\n            const container = this.stopEvent ?\n                this.synchronizer_.getOverlayContainerStopEvent() : this.synchronizer_.getOverlayContainer();\n            if (this.insertFirst) {\n                container.insertBefore(this.element, container.childNodes[0] || null);\n            }\n            else {\n                container.appendChild(this.element);\n            }\n        }\n    }\n    /**\n     * @override\n     */\n    handlePositionChanged() {\n        // transform position to WGS84\n        const position = this.getPosition();\n        if (position) {\n            const sourceProjection = this.parent_.getMap().getView().getProjection();\n            this.positionWGS84_ = transform(position, sourceProjection, 'EPSG:4326');\n        }\n        else {\n            this.positionWGS84_ = undefined;\n        }\n        this.updatePixelPosition();\n    }\n    /**\n     * @override\n     */\n    handleElementChanged() {\n        function cloneNode(node, parent) {\n            const clone = node.cloneNode();\n            if (node.nodeName === 'CANVAS') {\n                const ctx = clone.getContext('2d');\n                ctx.drawImage(node, 0, 0);\n            }\n            if (parent) {\n                parent.appendChild(clone);\n            }\n            if (node.nodeType != Node.TEXT_NODE) {\n                clone.addEventListener('click', (event) => {\n                    node.dispatchEvent(new MouseEvent('click', event));\n                    event.stopPropagation();\n                });\n            }\n            const nodes = node.childNodes;\n            for (let i = 0; i < nodes.length; i++) {\n                if (!nodes[i]) {\n                    continue;\n                }\n                cloneNode(nodes[i], clone);\n            }\n            return clone;\n        }\n        removeChildren(this.element);\n        const element = this.getElement();\n        if (element) {\n            if (element.parentNode && element.parentNode.childNodes) {\n                for (const node of element.parentNode.childNodes) {\n                    const clonedNode = cloneNode(node, null);\n                    this.element.appendChild(clonedNode);\n                }\n            }\n        }\n        if (element.parentNode) {\n            // set new Observer\n            this.observeTarget_(element.parentNode);\n        }\n    }\n    /**\n     * @override\n     */\n    updatePixelPosition() {\n        const position = this.positionWGS84_;\n        if (!this.scene_ || !position) {\n            this.setVisible(false);\n            return;\n        }\n        let height = 0;\n        if (position.length === 2) {\n            const globeHeight = this.scene_.globe.getHeight(Cesium.Cartographic.fromDegrees(position[0], position[1]));\n            if (globeHeight && this.scene_.globe.tilesLoaded) {\n                position[2] = globeHeight;\n            }\n            if (globeHeight) {\n                height = globeHeight;\n            }\n        }\n        else {\n            height = position[2];\n        }\n        const cartesian = Cesium.Cartesian3.fromDegrees(position[0], position[1], height);\n        const camera = this.scene_.camera;\n        const ellipsoidBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(), 6356752);\n        const occluder = new Cesium.Occluder(ellipsoidBoundingSphere, camera.position);\n        // check if overlay position is behind the horizon\n        if (!occluder.isPointVisible(cartesian)) {\n            this.setVisible(false);\n            return;\n        }\n        const cullingVolume = camera.frustum.computeCullingVolume(camera.position, camera.direction, camera.up);\n        // check if overlay position is visible from the camera\n        if (cullingVolume.computeVisibility(new Cesium.BoundingSphere(cartesian)) !== 1) {\n            this.setVisible(false);\n            return;\n        }\n        this.setVisible(true);\n        const pixelCartesian = this.scene_.cartesianToCanvasCoordinates(cartesian);\n        const pixel = [pixelCartesian.x, pixelCartesian.y];\n        const mapSize = [this.scene_.canvas.width, this.scene_.canvas.height];\n        this.updateRenderedPosition(pixel, mapSize);\n    }\n    /**\n     * Destroys the overlay, removing all its listeners and elements\n     * @api\n     */\n    destroy() {\n        if (this.scenePostRenderListenerRemover_) {\n            this.scenePostRenderListenerRemover_();\n        }\n        if (this.observer_) {\n            this.observer_.disconnect();\n        }\n        olObservableUnByKey(this.listenerKeys_);\n        this.listenerKeys_.splice(0);\n        if (this.element.removeNode) {\n            this.element.removeNode(true);\n        }\n        else {\n            this.element.remove();\n        }\n        this.element = null;\n    }\n}\nexport default SynchronizedOverlay;\n","/**\n * @module olcs.OverlaySynchronizer\n */\nimport olcsSynchronizedOverlay from './SynchronizedOverlay.js';\nimport { getUid } from './util.js';\nclass OverlaySynchronizer {\n    /**\n    * @param {!ol.Map} map\n    * @param {!Cesium.Scene} scene\n    * @constructor\n    * @template T\n    * @api\n    */\n    constructor(map, scene) {\n        /**\n        * @type {!ol.Map}\n        * @protected\n        */\n        this.map = map;\n        /**\n        * @type {ol.Collection.<ol.Overlay>}\n        * @private\n        */\n        this.overlays_ = this.map.getOverlays();\n        /**\n        * @type {!Cesium.Scene}\n        * @protected\n        */\n        this.scene = scene;\n        /**\n        * @private\n        * @type {!Element}\n        */\n        this.overlayContainerStopEvent_ = document.createElement('DIV');\n        this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';\n        const overlayEvents = ['click', 'dblclick', 'mousedown', 'touchstart', 'pointerdown', 'mousewheel', 'wheel'];\n        overlayEvents.forEach((event) => {\n            this.overlayContainerStopEvent_.addEventListener(event, evt => evt.stopPropagation());\n        });\n        this.scene.canvas.parentElement.appendChild(this.overlayContainerStopEvent_);\n        /**\n        * @private\n        * @type {!Element}\n        */\n        this.overlayContainer_ = document.createElement('DIV');\n        this.overlayContainer_.className = 'ol-overlaycontainer';\n        this.scene.canvas.parentElement.appendChild(this.overlayContainer_);\n        /**\n        * @type {!Object<?,olcs.SynchronizedOverlay>}\n        * @private\n        */\n        this.overlayMap_ = {};\n    }\n    /**\n    * Get the element that serves as a container for overlays that don't allow\n    * event propagation. Elements added to this container won't let mousedown and\n    * touchstart events through to the map, so clicks and gestures on an overlay\n    * don't trigger any {@link ol.MapBrowserEvent}.\n    * @return {!Element} The map's overlay container that stops events.\n    */\n    getOverlayContainerStopEvent() {\n        return this.overlayContainerStopEvent_;\n    }\n    /**\n    * Get the element that serves as a container for overlays.\n    * @return {!Element} The map's overlay container.\n    */\n    getOverlayContainer() {\n        return this.overlayContainer_;\n    }\n    /**\n    * Destroy all and perform complete synchronization of the overlays.\n    * @api\n    */\n    synchronize() {\n        this.destroyAll();\n        this.addOverlays();\n        this.overlays_.on('add', this.addOverlayFromEvent_.bind(this));\n        this.overlays_.on('remove', this.removeOverlayFromEvent_.bind(this));\n    }\n    /**\n    * @param {ol.Collection.Event} event\n    * @private\n    */\n    addOverlayFromEvent_(event) {\n        const overlay = /** @type {ol.Overlay} */ (event.element);\n        this.addOverlay(overlay);\n    }\n    /**\n    * @api\n    */\n    addOverlays() {\n        this.overlays_.forEach((overlay) => { this.addOverlay(overlay); });\n    }\n    /**\n    * @param {ol.Overlay} overlay\n    * @api\n    */\n    addOverlay(overlay) {\n        if (!overlay) {\n            return;\n        }\n        const cesiumOverlay = new olcsSynchronizedOverlay({\n            scene: this.scene,\n            synchronizer: this,\n            parent: overlay\n        });\n        const overlayId = getUid(overlay).toString();\n        this.overlayMap_[overlayId] = cesiumOverlay;\n    }\n    /**\n    * @param {ol.Collection.Event} event\n    * @private\n    */\n    removeOverlayFromEvent_(event) {\n        const removedOverlay = /** @type {ol.Overlay} */ (event.element);\n        this.removeOverlay(removedOverlay);\n    }\n    /**\n    * Removes an overlay from the scene\n    * @param {ol.Overlay} overlay\n    * @api\n    */\n    removeOverlay(overlay) {\n        const overlayId = getUid(overlay).toString();\n        const csOverlay = this.overlayMap_[overlayId];\n        if (csOverlay) {\n            csOverlay.destroy();\n            delete this.overlayMap_[overlayId];\n        }\n    }\n    /**\n    * Destroys all the created Cesium objects.\n    * @protected\n    */\n    destroyAll() {\n        Object.keys(this.overlayMap_).forEach((key) => {\n            const overlay = this.overlayMap_[key];\n            overlay.destroy();\n            delete this.overlayMap_[key];\n        });\n    }\n}\nexport default OverlaySynchronizer;\n","/**\n * @module olcs.OLCesium\n */\nimport olGeomPoint from 'ol/geom/Point.js';\nimport { supportsImageRenderingPixelated, imageRenderingValue } from './util.js';\nimport { ol4326CoordinateToCesiumCartesian } from './core.js';\nimport { getTransform } from 'ol/proj.js';\nimport olcsAutoRenderLoop from './AutoRenderLoop.js';\nimport olcsCamera from './Camera.js';\nimport olcsRasterSynchronizer from './RasterSynchronizer.js';\nimport olcsVectorSynchronizer from './VectorSynchronizer.js';\nimport olcsOverlaySynchronizer from './OverlaySynchronizer.js';\nimport Map from 'ol/Map.js';\nimport Interaction from 'ol/interaction/Interaction.js';\nimport { Group } from 'ol/layer.js';\nimport Feature from 'ol/Feature.js';\nimport View from 'ol/View.js';\n/**\n * Moved from Cesium\n * The state of a BoundingSphere computation being performed by a {@link Visualizer}.\n */\nconst BoundingSphereState = {\n    /**\n     * The BoundingSphere has been computed.\n     */\n    DONE: 0,\n    /**\n     * The BoundingSphere is still being computed.\n     */\n    PENDING: 1,\n    /**\n     * The BoundingSphere does not exist.\n     */\n    FAILED: 2,\n};\n/**\n * @typedef {Object} OLCesiumOptions\n * @property {import('ol/Map.js').default} map The OpenLayers map we want to show on a Cesium scene.\n * @property {Element|string} [target] Target element for the Cesium scene.\n * @property {function(!import('ol/Map.js').default, !Cesium.Scene, !Cesium.DataSourceCollection): Array<import('olcs/AbstractSynchronizer.js').default>}\n *      [createSynchronizers] Callback function which will be called by the {@link olcs.OLCesium}\n *      constructor to create custom synchronizers. Receives an `ol.Map` and a `Cesium.Scene` as arguments,\n *      and needs to return an array of {@link import('olcs/AbstractSynchronizer.js').default}.\n * @property {function(): Cesium.JulianDate} [time] Control the current time used by Cesium.\n * @property {boolean} [stopOpenLayersEventsPropagation] Prevent propagation of mouse/touch events to\n *      OpenLayers when Cesium is active.\n * @property {Cesium.SceneOptions} [sceneOptions] Allows the passing of property value to the\n *      `Cesium.Scene`.\n */\nclass OLCesium {\n    autoRenderLoop_ = null;\n    map_;\n    time_;\n    to4326Transform_;\n    resolutionScale_ = 1.0;\n    canvasClientWidth_ = 0.0;\n    canvasClientHeight_ = 0.0;\n    resolutionScaleChanged_ = true; // force resize\n    container_;\n    isOverMap_;\n    canvas_;\n    enabled_ = false;\n    pausedInteractions_ = [];\n    hiddenRootGroup_ = null;\n    scene_;\n    camera_;\n    globe_;\n    dataSourceCollection_;\n    dataSourceDisplay_;\n    /** Time of the last rendered frame, as returned by `performance.now()`. */\n    lastFrameTime_ = 0;\n    /** The identifier returned by `requestAnimationFrame`. */\n    renderId_;\n    /** Target frame rate for the render loop.  */\n    targetFrameRate_ = Number.POSITIVE_INFINITY;\n    /** If the Cesium render loop is being blocked. */\n    blockCesiumRendering_ = false;\n    /** If the warmup routine is active. */\n    warmingUp_ = false;\n    trackedFeature_ = null;\n    trackedEntity_ = null;\n    entityView_ = null;\n    needTrackedEntityUpdate_ = false;\n    boundingSphereScratch_ = new Cesium.BoundingSphere();\n    synchronizers_;\n    constructor(options) {\n        this.map_ = options.map;\n        this.time_ = options.time || function () {\n            return Cesium.JulianDate.now();\n        };\n        /**\n         * No change of the view projection.\n         */\n        this.to4326Transform_ = getTransform(this.map_.getView().getProjection(), 'EPSG:4326');\n        const fillArea = 'position:absolute;top:0;left:0;width:100%;height:100%;touch-action:none';\n        this.container_ = document.createElement('DIV');\n        const containerAttribute = document.createAttribute('style');\n        containerAttribute.value = `${fillArea}visibility:hidden;`;\n        this.container_.setAttributeNode(containerAttribute);\n        let targetElement = options.target || this.map_.getViewport();\n        if (typeof targetElement === 'string') {\n            targetElement = document.getElementById(targetElement);\n        }\n        targetElement.appendChild(this.container_);\n        /**\n         * Whether the Cesium container is placed over the ol map.\n         * a target => side by side mode\n         * no target => over map mode\n         */\n        this.isOverMap_ = !options.target;\n        if (this.isOverMap_ && options.stopOpenLayersEventsPropagation) {\n            const overlayEvents = ['click', 'dblclick', 'mousedown', 'touchstart', 'pointerdown', 'mousewheel', 'wheel'];\n            for (let i = 0, ii = overlayEvents.length; i < ii; ++i) {\n                this.container_.addEventListener(overlayEvents[i], evt => evt.stopPropagation());\n            }\n        }\n        this.canvas_ = document.createElement('canvas');\n        const canvasAttribute = document.createAttribute('style');\n        canvasAttribute.value = fillArea;\n        this.canvas_.setAttributeNode(canvasAttribute);\n        if (supportsImageRenderingPixelated()) {\n            // non standard CSS4\n            this.canvas_.style['imageRendering'] = imageRenderingValue();\n        }\n        this.canvas_.oncontextmenu = function () {\n            return false;\n        };\n        this.canvas_.onselectstart = function () {\n            return false;\n        };\n        this.container_.appendChild(this.canvas_);\n        const sceneOptions = options.sceneOptions !== undefined ?\n            { ...options.sceneOptions, canvas: this.canvas_, scene3DOnly: true } :\n            { canvas: this.canvas_, scene3DOnly: true };\n        this.scene_ = new Cesium.Scene(sceneOptions);\n        const sscc = this.scene_.screenSpaceCameraController;\n        if (!Array.isArray(sscc.tiltEventTypes)) {\n            console.log('sscc is not an array');\n        }\n        else {\n            sscc.tiltEventTypes.push({\n                'eventType': Cesium.CameraEventType.LEFT_DRAG,\n                'modifier': Cesium.KeyboardEventModifier.SHIFT\n            });\n            sscc.tiltEventTypes.push({\n                'eventType': Cesium.CameraEventType.LEFT_DRAG,\n                'modifier': Cesium.KeyboardEventModifier.ALT\n            });\n        }\n        sscc.enableLook = false;\n        this.scene_.camera.constrainedAxis = Cesium.Cartesian3.UNIT_Z;\n        this.camera_ = new olcsCamera(this.scene_, this.map_);\n        this.globe_ = new Cesium.Globe(Cesium.Ellipsoid.WGS84);\n        this.globe_.baseColor = Cesium.Color.WHITE;\n        this.scene_.globe = this.globe_;\n        this.scene_.skyAtmosphere = new Cesium.SkyAtmosphere();\n        // The first layer of Cesium is special; using a 1x1 transparent image to workaround it.\n        // See https://github.com/AnalyticalGraphicsInc/cesium/issues/1323 for details.\n        const firstImageryProvider = new Cesium.SingleTileImageryProvider({\n            tileHeight: 1,\n            tileWidth: 1,\n            url: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=',\n            rectangle: Cesium.Rectangle.fromDegrees(0, 0, 1, 1) // the Rectangle dimensions are arbitrary\n        });\n        this.globe_.imageryLayers.addImageryProvider(firstImageryProvider, 0);\n        this.dataSourceCollection_ = new Cesium.DataSourceCollection();\n        this.dataSourceDisplay_ = new Cesium.DataSourceDisplay({\n            scene: this.scene_,\n            dataSourceCollection: this.dataSourceCollection_\n        });\n        this.synchronizers_ = options.createSynchronizers ?\n            options.createSynchronizers(this.map_, this.scene_, this.dataSourceCollection_) : [\n            new olcsRasterSynchronizer(this.map_, this.scene_),\n            new olcsVectorSynchronizer(this.map_, this.scene_),\n            new olcsOverlaySynchronizer(this.map_, this.scene_)\n        ];\n        // Assures correct canvas size after initialisation\n        this.handleResize_();\n        for (let i = this.synchronizers_.length - 1; i >= 0; --i) {\n            this.synchronizers_[i].synchronize();\n        }\n        const eventHelper = new Cesium.EventHelper();\n        eventHelper.add(this.scene_.postRender, OLCesium.prototype.updateTrackedEntity_, this);\n    }\n    /**\n     * Destroys the Cesium resources held by this object.\n     */\n    destroy() {\n        cancelAnimationFrame(this.renderId_);\n        this.renderId_ = undefined;\n        this.synchronizers_.forEach(synchronizer => synchronizer.destroyAll());\n        this.camera_.destroy();\n        this.scene_.destroy();\n        // @ts-ignore TS2341\n        this.scene_._postRender = null;\n        this.container_.remove();\n    }\n    /**\n     * Render the Cesium scene.\n     */\n    render_() {\n        // if a call to `requestAnimationFrame` is pending, cancel it\n        if (this.renderId_ !== undefined) {\n            cancelAnimationFrame(this.renderId_);\n            this.renderId_ = undefined;\n        }\n        // only render if Cesium is enabled/warming and rendering hasn't been blocked\n        if ((this.enabled_ || this.warmingUp_) && !this.blockCesiumRendering_) {\n            this.renderId_ = requestAnimationFrame(this.onAnimationFrame_.bind(this));\n        }\n    }\n    /**\n     * Callback for `requestAnimationFrame`.\n     * @param {number} frameTime The frame time, from `performance.now()`.\n     */\n    onAnimationFrame_(frameTime) {\n        this.renderId_ = undefined;\n        // check if a frame was rendered within the target frame rate\n        const interval = 1000.0 / this.targetFrameRate_;\n        const delta = frameTime - this.lastFrameTime_;\n        if (delta < interval) {\n            // too soon, don't render yet\n            this.render_();\n            return;\n        }\n        // time to render a frame, save the time\n        this.lastFrameTime_ = frameTime;\n        const julianDate = this.time_();\n        // initializeFrame private property\n        // @ts-ignore TS2341\n        this.scene_.initializeFrame();\n        this.handleResize_();\n        this.dataSourceDisplay_.update(julianDate);\n        // Update tracked entity\n        if (this.entityView_) {\n            const trackedEntity = this.trackedEntity_;\n            // getBoundingSphere private property\n            // @ts-ignore TS2341\n            const trackedState = this.dataSourceDisplay_.getBoundingSphere(trackedEntity, false, this.boundingSphereScratch_);\n            if (trackedState === BoundingSphereState.DONE) {\n                this.boundingSphereScratch_.radius = 1; // a radius of 1 is enough for tracking points\n                this.entityView_.update(julianDate, this.boundingSphereScratch_);\n            }\n        }\n        this.scene_.render(julianDate);\n        this.camera_.checkCameraChange();\n        // request the next render call after this one completes to ensure the browser doesn't get backed up\n        this.render_();\n    }\n    updateTrackedEntity_() {\n        if (!this.needTrackedEntityUpdate_) {\n            return;\n        }\n        const trackedEntity = this.trackedEntity_;\n        const scene = this.scene_;\n        // getBoundingSphere private property\n        // @ts-ignore TS2341\n        const state = this.dataSourceDisplay_.getBoundingSphere(trackedEntity, false, this.boundingSphereScratch_);\n        if (state === BoundingSphereState.PENDING) {\n            return;\n        }\n        scene.screenSpaceCameraController.enableTilt = false;\n        const bs = state !== BoundingSphereState.FAILED ? this.boundingSphereScratch_ : undefined;\n        if (bs) {\n            bs.radius = 1;\n        }\n        this.entityView_ = new Cesium.EntityView(trackedEntity, scene, scene.mapProjection.ellipsoid);\n        this.entityView_.update(this.time_(), bs);\n        this.needTrackedEntityUpdate_ = false;\n    }\n    handleResize_() {\n        let width = this.canvas_.clientWidth;\n        let height = this.canvas_.clientHeight;\n        if (width === 0 || height === 0) {\n            // The canvas DOM element is not ready yet.\n            return;\n        }\n        if (width === this.canvasClientWidth_ &&\n            height === this.canvasClientHeight_ &&\n            !this.resolutionScaleChanged_) {\n            return;\n        }\n        let resolutionScale = this.resolutionScale_;\n        if (!supportsImageRenderingPixelated()) {\n            resolutionScale *= window.devicePixelRatio || 1.0;\n        }\n        this.resolutionScaleChanged_ = false;\n        this.canvasClientWidth_ = width;\n        this.canvasClientHeight_ = height;\n        width *= resolutionScale;\n        height *= resolutionScale;\n        this.canvas_.width = width;\n        this.canvas_.height = height;\n        this.scene_.camera.frustum.aspectRatio = width / height;\n    }\n    getCamera() {\n        return this.camera_;\n    }\n    getOlMap() {\n        return this.map_;\n    }\n    getOlView() {\n        const view = this.map_.getView();\n        console.assert(view);\n        return view;\n    }\n    getCesiumScene() {\n        return this.scene_;\n    }\n    getDataSources() {\n        return this.dataSourceCollection_;\n    }\n    getDataSourceDisplay() {\n        return this.dataSourceDisplay_;\n    }\n    getEnabled() {\n        return this.enabled_;\n    }\n    /**\n     * Enables/disables the Cesium.\n     * This modifies the visibility style of the container element.\n     */\n    setEnabled(enable) {\n        if (this.enabled_ === enable) {\n            return;\n        }\n        this.enabled_ = enable;\n        // some Cesium operations are operating with canvas.clientWidth,\n        // so we can't remove it from DOM or even make display:none;\n        this.container_.style.visibility = this.enabled_ ? 'visible' : 'hidden';\n        let interactions;\n        if (this.enabled_) {\n            this.throwOnUnitializedMap_();\n            if (this.isOverMap_) {\n                interactions = this.map_.getInteractions();\n                interactions.forEach((el, i, arr) => {\n                    this.pausedInteractions_.push(el);\n                });\n                interactions.clear();\n                this.map_.addInteraction = interaction => this.pausedInteractions_.push(interaction);\n                this.map_.removeInteraction = (interaction) => {\n                    let interactionRemoved = false;\n                    this.pausedInteractions_ = this.pausedInteractions_.filter((i) => {\n                        const removed = i !== interaction;\n                        if (!interactionRemoved)\n                            interactionRemoved = removed;\n                        return removed;\n                    });\n                    return interactionRemoved ? interaction : undefined;\n                };\n                const rootGroup = this.map_.getLayerGroup();\n                if (rootGroup.getVisible()) {\n                    this.hiddenRootGroup_ = rootGroup;\n                    this.hiddenRootGroup_.setVisible(false);\n                }\n                this.map_.getOverlayContainer().classList.add('olcs-hideoverlay');\n            }\n            this.camera_.readFromView();\n            this.render_();\n        }\n        else {\n            if (this.isOverMap_) {\n                interactions = this.map_.getInteractions();\n                this.pausedInteractions_.forEach((interaction) => {\n                    interactions.push(interaction);\n                });\n                this.pausedInteractions_.length = 0;\n                this.map_.addInteraction = interaction => this.map_.getInteractions().push(interaction);\n                this.map_.removeInteraction = interaction => this.map_.getInteractions().remove(interaction);\n                this.map_.getOverlayContainer().classList.remove('olcs-hideoverlay');\n                if (this.hiddenRootGroup_) {\n                    this.hiddenRootGroup_.setVisible(true);\n                    this.hiddenRootGroup_ = null;\n                }\n            }\n            this.camera_.updateView();\n        }\n    }\n    /**\n     * Preload Cesium so that it is ready when transitioning from 2D to 3D.\n     * @param {number} height Target height of the camera\n     * @param {number} timeout Milliseconds after which the warming will stop\n    */\n    warmUp(height, timeout) {\n        if (this.enabled_) {\n            // already enabled\n            return;\n        }\n        this.throwOnUnitializedMap_();\n        this.camera_.readFromView();\n        const ellipsoid = this.globe_.ellipsoid;\n        const csCamera = this.scene_.camera;\n        const position = ellipsoid.cartesianToCartographic(csCamera.position);\n        if (position.height < height) {\n            position.height = height;\n            csCamera.position = ellipsoid.cartographicToCartesian(position);\n        }\n        this.warmingUp_ = true;\n        this.render_();\n        setTimeout(() => {\n            this.warmingUp_ = false;\n        }, timeout);\n    }\n    /**\n     * Block Cesium rendering to save resources.\n     * @param {boolean} block True to block.\n    */\n    setBlockCesiumRendering(block) {\n        if (this.blockCesiumRendering_ !== block) {\n            this.blockCesiumRendering_ = block;\n            // reset the render loop\n            this.render_();\n        }\n    }\n    /**\n     * Render the globe only when necessary in order to save resources.\n     * Experimental.\n     */\n    enableAutoRenderLoop() {\n        if (!this.autoRenderLoop_) {\n            this.autoRenderLoop_ = new olcsAutoRenderLoop(this);\n        }\n    }\n    /**\n     * Get the autorender loop.\n    */\n    getAutoRenderLoop() {\n        return this.autoRenderLoop_;\n    }\n    /**\n     * The 3D Cesium globe is rendered in a canvas with two different dimensions:\n     * clientWidth and clientHeight which are the dimension on the screen and\n     * width and height which are the dimensions of the drawing buffer.\n     *\n     * By using a resolution scale lower than 1.0, it is possible to render the\n     * globe in a buffer smaller than the canvas client dimensions and improve\n     * performance, at the cost of quality.\n     *\n     * Pixel ratio should also be taken into account; by default, a device with\n     * pixel ratio of 2.0 will have a buffer surface 4 times bigger than the client\n     * surface.\n     */\n    setResolutionScale(value) {\n        value = Math.max(0, value);\n        if (value !== this.resolutionScale_) {\n            this.resolutionScale_ = Math.max(0, value);\n            this.resolutionScaleChanged_ = true;\n            if (this.autoRenderLoop_) {\n                this.autoRenderLoop_.restartRenderLoop();\n            }\n        }\n    }\n    /**\n     * Set the target frame rate for the renderer. Set to `Number.POSITIVE_INFINITY`\n     * to render as quickly as possible.\n     * @param {number} value The frame rate, in frames per second.\n     */\n    setTargetFrameRate(value) {\n        if (this.targetFrameRate_ !== value) {\n            this.targetFrameRate_ = value;\n            // reset the render loop\n            this.render_();\n        }\n    }\n    /**\n     * Check if OpenLayers map is not properly initialized.\n     */\n    throwOnUnitializedMap_() {\n        const map = this.map_;\n        const view = map.getView();\n        const center = view.getCenter();\n        if (!view.isDef() || isNaN(center[0]) || isNaN(center[1])) {\n            throw new Error(`The OpenLayers map is not properly initialized: ${center} / ${view.getResolution()}`);\n        }\n    }\n    get trackedFeature() {\n        return this.trackedFeature_;\n    }\n    set trackedFeature(feature) {\n        if (this.trackedFeature_ !== feature) {\n            const scene = this.scene_;\n            //Stop tracking\n            if (!feature || !feature.getGeometry()) {\n                this.needTrackedEntityUpdate_ = false;\n                scene.screenSpaceCameraController.enableTilt = true;\n                if (this.trackedEntity_) {\n                    this.dataSourceDisplay_.defaultDataSource.entities.remove(this.trackedEntity_);\n                }\n                this.trackedEntity_ = null;\n                this.trackedFeature_ = null;\n                this.entityView_ = null;\n                scene.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);\n                return;\n            }\n            this.trackedFeature_ = feature;\n            //We can't start tracking immediately, so we set a flag and start tracking\n            //when the bounding sphere is ready (most likely next frame).\n            this.needTrackedEntityUpdate_ = true;\n            const to4326Transform = this.to4326Transform_;\n            const toCesiumPosition = function () {\n                const geometry = feature.getGeometry();\n                console.assert(geometry instanceof olGeomPoint);\n                const coo = geometry instanceof olGeomPoint ? geometry.getCoordinates() : [];\n                const coo4326 = to4326Transform(coo, undefined, coo.length);\n                return ol4326CoordinateToCesiumCartesian(coo4326);\n            };\n            // Create an invisible point entity for tracking.\n            // It is independent of the primitive/geometry created by the vector synchronizer.\n            const options = {\n                // @ts-ignore according to Cesium types, not possible to pass CallbackProperty\n                position: new Cesium.CallbackProperty((time, result) => toCesiumPosition(), false),\n                point: {\n                    pixelSize: 1,\n                    color: Cesium.Color.TRANSPARENT\n                }\n            };\n            this.trackedEntity_ = this.dataSourceDisplay_.defaultDataSource.entities.add(options);\n        }\n    }\n}\nexport default OLCesium;\n"],"names":["Property","Overlay","BaseObject","options","CLASS_SELECTABLE","removeChildren","element","removeNode","unlistenByKey","map","listen","MapEventType","container","offset","position","panIntoViewOptions","mapRect","overlayRect","outerWidth","outerHeight","myMargin","containsExtent","offsetLeft","offsetRight","offsetTop","offsetBottom","delta","center","centerPx","newCenterPx","panOptions","size","box","offsetX","offsetY","positioning","visible","pixel","mapSize","style","x","y","posX","posY","transform","olOverlay","supportsImageRenderingPixelatedResult_","imageRenderingValueResult_","supportsImageRenderingPixelated","canvas","tmp","imageRenderingValue","getSourceProjection","source","olcsListen","observable","type","listener","uidCounter_","getUid","obj","stableSort","arr","compareFnc","length","i","a","b","node","isGroundPolylinePrimitiveSupported","scene","waitReady","object","p","resolve","_","stopper","createLoader","load","decode","extent","image","resolutionX","getWidth","resolutionY","getHeight","Static","ImageSource","crossOrigin","imageLoadFunction","defaultImageLoadFunction","getProjection","ImageWrapper","src","EventType","resolution","pixelRatio","projection","intersects","olSourceImageStatic","TileWMS","TileImage","params","transparent","createEmpty","coordinate","projectionObj","sourceProjectionObj","tileGrid","sourceProjCoord","sourceResolution","calculateSourceResolution","z","tileResolution","tileCoord","tileExtent","gutter","buffer","baseParams","getRequestParams","DEFAULT_VERSION","layers","mpu","pixelSize","appendParams","urls","url","index","modulo","tileCoordHash","getImageSrc","res","key","version","compareVersions","olSourceTileWMS","Cluster","VectorSource","feature","geometry","assert","fast","distance","minDistance","ratio","changed","mapDistance","features","clustered","ii","coordinates","createOrUpdateFromCoordinate","neighbors","neighbor","uid","centroid","addCoordinate","scaleCoordinate","searchCenter","getCenter","Point","Feature","olSourceCluster","olUseNewCoordinates","TileSource","OLImageryProvider","olMap","opt_fallbackProj","proxy","e","frameState","zoom","xIndex","yIndex","level","attributionsFunction","attributionsFunctionToCredits","tileUrlFunction","z_","y_","tg","format","MVT","styles","Style","Stroke","MVTImageryProvider","cacheSize","LRUCache","getTilegridForProjection","createTileUrlFunctions","cacheKey","promise","r","scaleFactor","f","flatCoordinates","request","styleFunction","vectorContext","toContext","pickOnTerrainOrEllipsoid","ray","pickCenterPoint","extentToRectangle","ext","transformExtent","sourceToImageryProvider","viewProj","olLayer","skip","provider","olSourceImageWMS","sourceProps","olSourceTileImage","isCesiumProjection","olcsCoreOLImageryProvider","rectangle","olSourceVectorTile","VectorTileLayer","fromCode","u","minimumLevel","credit","getExtentCenter","tileLayerToImageryLayer","olLayerTile","olLayerImage","layerOptions","updateCesiumLayerProperties","olLayerWithParents","csLayer","opacity","layerOpacity","layerVisible","ol4326CoordinateToCesiumCartesian","coo","ol4326CoordinateArrayToCsCartesians","toCartesian","cartesians","olGeometryCloneTo4326","proj4326","proj","properties","convertColorToCesium","olColor","ctx","is3857","is4326","attributions","html","calcDistanceForResolution","latitude","fovy","metersPerUnit","visibleMapUnits","relativeCircumference","calcResolutionForDistance","visibleMeters","AutoRenderLoop","ol3d","repaintKey","toDegrees","angleInRadians","toRadians","angleInDegrees","Camera","olObservableUnByKey","input","opt_output","opt_dimension","dim","view","toLonLat","getTransform","fromLonLat","heading","tilt","ll","carto","pos","altitude","height","destination","orientation","ellipsoid","target","bestTarget","globe","bestTargetCartographic","targetNormal","targetToCamera","up","right","normal","tiltAngle","opt_dontSync","old","current","VectorLayerCounterpart","layerProjection","__publicField","billboards","primitives","AbstractSynchronizer","root","fifo","olLayerId","cesiumObjects","LayerGroup","l","newOlLayerWithParents","layerId","layerWithParents","onLayerChange","cesiumObjs","layer","cesiumObject","counterparts","counterpart","group","done","uuid","listenKeyArray","contentKeys","listenAddRemove","collection","event","el","objKey","RasterSynchronizer","olcsAbstractSynchronizer","destroy","result","olLayerItem","BaseVectorLayer","previousStyleFunction","currentStyleFunction","csObj","ip","_a","zIndices","queue","sublayers","layer1","layer2","FeatureConverter","evt","olSourceVector","cancellers","id","canceller","primitive","olGeometry","color","opt_lineWidth","createInstance","instance","instances","heightReference","ctor","dataUri","outline","fillColor","strokeColor","width","fillGeometry","outlineGeometry","olStyle","outlineColor","p1","p2","text","label","bbOptions","bb","point","radius","outlinePrimitive","circlePolygon","olCreateCircularPolygon","positions","geometryInstances","previousDistance","geometryOptions","linePositions","appearance","primitiveOptions","boundingExtent","maxHeight","c","featureExtrudedHeight","rings","hierarchy","polygonHierarchy","olPos","polylineGeometry","altitudeMode","imageStyle","opt_newBillboardCallback","olStyleIcon","isImageLoaded","reallyCreateBillboard","scale","anchor","cancelled","fuid","modelPrimitive","olcsModelFunction","olcsModel","model","accumulate","geometries","functor","subgeos","labels","extentCenter","olGeomSimpleGeometry","first","labelStyle","horizontalOrigin","verticalOrigin","fill","stroke","fallbackStyleFunction","featureStyleFunction","opt_geom","geom3d","olGeomGeometry","geomFuncRes","context","geom","newBillboardAddedCallback","featureBb","prims","bbs","result2","olView","featurePrimitiveMap","olcsCoreVectorLayerCounterpart","layerStyle","prim","VectorSynchronizer","opt_converter","olcsFeatureConverter","csPrimitive","olLayerVector","olLayerVectorTile","olLayerLayer","csPrimitives","olListenKeys","onAddFeature","onRemoveFeature","SynchronizedOverlay","parent","setPropertyFromEvent","observer","sourceProjection","cloneNode","clone","nodes","clonedNode","globeHeight","cartesian","camera","ellipsoidBoundingSphere","pixelCartesian","OverlaySynchronizer","overlay","cesiumOverlay","olcsSynchronizedOverlay","overlayId","removedOverlay","csOverlay","BoundingSphereState","OLCesium","fillArea","containerAttribute","targetElement","overlayEvents","canvasAttribute","sceneOptions","sscc","olcsCamera","firstImageryProvider","olcsRasterSynchronizer","olcsVectorSynchronizer","olcsOverlaySynchronizer","synchronizer","frameTime","interval","julianDate","trackedEntity","state","bs","resolutionScale","enable","interactions","interaction","interactionRemoved","removed","rootGroup","timeout","csCamera","block","olcsAutoRenderLoop","value","to4326Transform","toCesiumPosition","olGeomPoint","coo4326","time"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}