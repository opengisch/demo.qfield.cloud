import{s as Color,m as Cartesian3,H as HeightReference,t as Cartesian2,Y as HorizontalOrigin,Z as VerticalOrigin,_ as DistanceDisplayCondition,$ as defined,a0 as DeveloperError,a1 as AssociativeArray,a2 as destroyObject,a3 as NearFarScalar,a4 as BoundingRectangle,a5 as defaultValue,a6 as Check,a7 as GeometryOffsetAttribute,a8 as VertexFormat,a9 as GeometryAttributes,aa as GeometryAttribute,ab as ComponentDatatype,ac as Geometry,ad as PrimitiveType,ae as BoundingSphere,af as Material,ag as Appearance,ah as PerInstanceColorAppearance,ai as Primitive,aj as ShadowMode,ak as ClassificationType,al as Event,am as oneTimeWarning,r as Cartographic,an as isHeightReferenceRelative,o as CesiumMath,ao as ColorGeometryInstanceAttribute,ap as OffsetGeometryInstanceAttribute,aq as GeometryInstance,ar as BoxOutlineGeometry,as as Resource,at as Cesium3DTileset,au as Matrix4,av as createGuid,aw as Matrix3,ax as EllipsoidTangentPlane,ay as PolylinePipeline,az as Transforms,aA as Quaternion,aB as Cartesian4,E as Ellipsoid,aC as arrayRemoveDuplicates,aD as PolygonPipeline,aE as IndexDatatype,aF as Rectangle,aG as isHeightReferenceClamp,aH as ApproximateTerrainHeights,aI as SceneMode,aJ as SceneTransforms,aK as BlendOption,aL as BufferUsage,aM as EncodedCartesian3,aN as ContextLimits,aO as RenderState,aP as WebGLConstants,aQ as BlendingState,aR as ShaderSource,aS as ShaderProgram,aT as DrawCommand,aU as Pass,aV as VertexArrayFacade,aW as LabelCollection,aX as BillboardCollection,aY as Billboard,aZ as Label,a_ as Uri,J as JulianDate,P as PolygonHierarchy,a$ as LabelStyle,b0 as ColorBlendMode,b1 as ArcType,b2 as RuntimeError,b3 as Credit,b4 as GeometryPipeline,b5 as GeographicProjection,b6 as EllipsoidOutlineGeometry,b7 as PolygonGeometryLibrary,b8 as CoplanarPolygonGeometryLibrary,b9 as WindingOrder,ba as PolygonGeometry,bb as CoplanarPolygonOutlineGeometry,bc as RectangleGeometryLibrary,bd as Matrix2,be as RectangleOutlineGeometry,bf as ModelAnimationLoop,bg as Model,bh as PolylineCollection,bi as createBillboardPointCallback,bj as GeometryType,bk as buildModuleUrl,bl as writeTextToCanvas,bm as combine$2,bn as defer,bo as clone,bp as objectToQuery,bq as queryToObject,br as HeadingPitchRoll,bs as getExtensionFromUri,bt as AttributeCompression,bu as VerticalExaggeration,bv as WebMercatorProjection,bw as OrientedBoundingBox,bx as AxisAlignedBoundingBox,by as TaskProcessor,bz as TerrainProvider,bA as GeographicTilingScheme,bB as ClippingPlaneCollection,bC as ImageryState,bD as IntersectionTests,bE as Ray,bF as Buffer,bG as VertexArray,bH as Texture,bI as PixelFormat,bJ as PixelDatatype,bK as Request,bL as RequestType,bM as Sampler,bN as TextureWrap,bO as TextureMinificationFilter,bP as TextureMagnificationFilter,bQ as RequestState,bR as TileProviderError,bS as binarySearch,bT as Queue,bU as ClippingPolygonCollection,bV as DepthFunction,bW as Intersect,bX as OrthographicFrustum,bY as TileBoundingRegion,bZ as SphereOutlineGeometry,b_ as ImageryLayer,b$ as OrthographicOffCenterFrustum,c0 as TimeConstants,c1 as TimeStandard,c2 as CullFace,c3 as CullingVolume,c4 as ClearCommand,c5 as Framebuffer,c6 as loadKTX2,c7 as CubeMap,c8 as deprecationWarning,q as EllipsoidGeodesic,c9 as FeatureDetection,ca as FramebufferManager,cb as StencilFunction,cc as StencilOperation,cd as StencilConstants,ce as Renderbuffer,cf as RenderbufferFormat,cg as JobType,ch as BlendEquation,ci as BlendFunction,cj as Interval,ck as Cesium3DTilePass,cl as Cesium3DTileFeature,cm as Plane,cn as MetadataType,co as ShaderDestination,cp as ShaderBuilder,cq as MetadataComponentType,cr as resizeImageToNextPowerOfTwo,cs as CustomShaderMode,ct as CustomShaderTranslucencyMode,cu as RequestScheduler,cv as OctahedralProjectedCubeMap,cw as Axis,cx as ComputeCommand,cy as formatError,cz as WebMercatorTilingScheme,cA as Spline,cB as HermiteSpline,cC as IonResource,cD as getJsonFromTypedArray,cE as loadAndExecuteScript,cF as Ion,cG as getImagePixels,cH as barycentricCoordinates,cI as Expression,cJ as MetadataTable,cK as hasExtension,cL as Cesium3DTilesetMetadata,cM as ImplicitTileset,cN as ResourceCache,cO as MetadataSemantic,cP as ImplicitTileCoordinates,cQ as preprocess3DTileContent,cR as ImplicitSubtree,cS as loadImageFromTypedArray,cT as Cesium3DTile,cU as UrlTemplateImageryProvider,cV as SplitDirection,cW as PntsParser,cX as Cesium3DTileBatchTable,cY as DracoLoader,cZ as MersenneTwister,c_ as PointCloudShading,c$ as PointCloudEyeDomeLighting,d0 as createWorldImageryAsync,d1 as IonWorldImageryStyle,d2 as ArcGisMapServerImageryProvider,d3 as ArcGisBaseMapType,d4 as IonImageryProvider,d5 as TileMapServiceImageryProvider,d6 as Cesium3DTileColorBlendMode,d7 as Fullscreen}from"./component-DmEB9E06.js";import{ef as tt,hn as nt,eg as it,dz as rt,ho as ot,eh as at,d8 as st,hp as ct,ei as lt,ej as dt,ek as ut,el as ht,hq as ft,em as pt,en as mt,eo as gt,ep as _t,hr as yt,eq as Ct,er as At,es as St,et as xt,eu as Tt,ev as vt,ew as Et,ex as bt,ey as Pt,ez as wt,eA as Dt,eB as Mt,eC as It,eD as Rt,eE as Ot,eF as Lt,eG as Nt,hs as Ft,ht as Vt,eH as kt,eI as Bt,eJ as Ut,dA as Gt,dB as Ht,eK as zt,d9 as $t,dC as Wt,hu as qt,hv as jt,eL as Xt,eM as Yt,dD as Qt,dE as Kt,dF as Zt,dG as Jt,eN as en,eO as tn,hw as nn,g$ as rn,hx as on,eP as an,hy as sn,eQ as cn,eR as ln,eS as dn,eT as un,eU as hn,eV as fn,eW as pn,eX as mn,eY as gn,eZ as _n,e_ as yn,e$ as Cn,dH as An,f0 as Sn,dI as xn,dJ as Tn,hz as vn,f1 as En,dK as bn,dL as Pn,f2 as wn,hA as Dn,f3 as Mn,f4 as In,f5 as Rn,f6 as On,f7 as Ln,f8 as Nn,f9 as Fn,fa as Vn,fb as kn,hB as Bn,dM as Un,fc as Gn,dN as Hn,dO as zn,hC as $n,hD as Wn,dP as qn,dQ as jn,fd as Xn,hE as Yn,fe as Qn,ff as Kn,fg as Zn,fh as Jn,fi as ei,hF as ti,fj as ni,fk as ii,fl as ri,da as oi,hG as ai,hH as si,hI as ci,hJ as li,hK as di,fm as ui,hL as hi,hM as fi,hN as pi,hO as mi,hP as gi,fn as _i,hQ as yi,hR as Ci,hS as Ai,hT as Si,hU as xi,hV as Ti,hW as vi,hX as Ei,hY as bi,hZ as Pi,h_ as wi,h$ as Di,i0 as Mi,i1 as Ii,i2 as Ri,i3 as Oi,i4 as Li,dR as Ni,fo as Fi,db as Vi,i5 as ki,i6 as Bi,i7 as Ui,i8 as Gi,i9 as Hi,fp as zi,fq as $i,ia as Wi,ib as qi,fr as ji,ic as Xi,fs as Yi,id as Qi,ft as Ki,fu as Zi,fv as Ji,fw as er,fx as tr,dS as nr,dT as ir,dU as rr,dV as or,fy as ar,fz as sr,fA as cr,fB as lr,dW as dr,fC as ur,ie as hr,ig as fr,dc as pr,dd as mr,fD as gr,ih as _r,dX as yr,dY as Cr,fE as Ar,ii as Sr,fF as xr,fG as Tr,fH as vr,fI as Er,fJ as br,fK as Pr,fL as wr,fM as Dr,fN as Mr,ij as Ir,fO as Rr,dZ as Or,d_ as Lr,d$ as Nr,e0 as Fr,fP as Vr,fQ as kr,fR as Br,fS as Ur,fT as Gr,fU as Hr,fV as zr,fW as $r,fX as Wr,ik as qr,fY as jr,fZ as Xr,e1 as Yr,il as Qr,ga as Kr,gs as Zr,gt as Jr,di as eo,dj as to,gb as no,gu as io,gv as ro,gc as oo,gw as ao,gx as so,g9 as co,gd as lo,ge as uo,gf as ho,gg as fo,gh as po,gy as mo,gz as go,gA as _o,gB as yo,gi as Co,i$ as Ao,j0 as So,gC as xo,gD as To,gE as vo,gF as Eo,gG as bo,gH as Po,gI as wo,gJ as Do,gK as Mo,gL as Io,gM as Ro,gN as Oo,gO as Lo,gP as No,gQ as Fo,gR as Vo,gS as Bo,gT as Uo,gj as Go,dk as Ho,dl as zo,dm as $o,g5 as Wo,g6 as qo,g7 as jo,g8 as Xo,g_ as Yo,gU as Qo,dn as Ko,gk as Zo,dp as Jo,gl as ea,dq as ta,gm as na,gn as ia,dr as ra,gV as oa,gW as aa,j1 as sa,j2 as ca,j3 as la,ds as da,dt as ua,go as ha,gX as fa,du as pa,gY as ma,gp as ga,gq as _a,dv as ya,dw as Ca,dx as Aa,dy as Sa,gZ as xa,gr as Ta,j4 as va,j5 as Ea,j6 as ba,j7 as Pa,j8 as wa,j9 as Da,ja as Ma,jb as Ia,jc as Ra,jd as Oa,je as La,jf as Na,jg as Fa,jh as Va,ji as ka,jj as Ba,jk as Ua,jl as Ga,jm as Ha,jn as za,jo as $a,ip as Wa,jp as qa,iq as ja,kp as Xa,jq as Ya,jr as Qa,js as Ka,ir as Za,is as Ja,it as es,iu as ts,iv as ns,iw as is,ix as rs,jt as os,ju as as,jv as ss,jw as cs,jx as ls,jy as ds,jz as us,jA as hs,jB as fs,jC as ps,jD as ms,jE as gs,jF as _s,iy as ys,jG as Cs,jH as As,jI as Ss,jJ as xs,jK as Ts,jL as vs,jM as Es,kq as bs,kr as Ps,jN as ws,jO as Ds,ks as Ms,jP as Is,kt as Rs,jQ as Os,jR as Ls,jS as Ns,iz as Fs,iA as Vs,jT as ks,iB as Bs,iC as Us,iD as Gs,iE as Hs,iF as zs,iG as $s,iH as Ws,iI as qs,iJ as js,iK as Xs,iL as Ys,iM as Qs,jU as Ks,jV as Zs,iN as Js,iO as ec,iP as tc,iQ as nc,iR as ic,jW as rc,jX as oc,iS as ac,ku as sc,jY as cc,kv as lc,jZ as dc,j_ as uc,j$ as hc,k0 as fc,k1 as pc,k2 as mc,k3 as gc,iT as _c,iU as yc,iV as Cc,iW as Ac,k4 as Sc,kw as xc,k5 as Tc,k6 as vc,iX as Ec,k7 as bc,k8 as Pc,k9 as wc,ka as Dc,iY as Mc,kb as Ic,kc as Rc,kd as Oc,ke as Lc,iZ as Nc,kf as Fc,kg as Vc,kh as kc,ki as Bc,kj as Uc,kk as Gc,i_ as Hc,kl as zc,km as $c,kn as Wc,ko as qc,h0 as jc,h1 as Xc,h2 as Yc,h3 as Qc,h4 as Kc,h5 as Zc,e2 as Jc,im as el,de as tl,df as nl,e3 as il,dg as rl,h6 as ol,f_ as al,f$ as sl,g0 as cl,h7 as ll,dh as dl,e4 as ul,h8 as hl,e5 as fl,g1 as pl,h9 as ml,e6 as gl,e7 as _l,e8 as yl,e9 as Cl,ea as Al,eb as Sl,ha as xl,hb as Tl,hc as vl,g2 as El,g3 as bl,hd as Pl,ec as wl,g4 as Dl,io as Ml,he as Il,hf as Rl,hg as Ol,hh as Ll,hi as Nl,hj as Fl,ed as Vl,ee as kl,hk as Bl,hl as Ul,hm as Gl}from"./component-DmEB9E06.js";import{P as Property,G as GroundPrimitive,c as ColorMaterialProperty,d as ConstantProperty,E as Entity,I as Iso8601,C as CallbackProperty,f as createPropertyDescriptor,b as EntityCollection,g as CompositeProperty,h as getTimestamp,i as createRawPropertyDescriptor,j as EventHelper,R as ReferenceFrame,T as TimeIntervalCollection,k as PositionProperty,l as TimeInterval,m as PropertyBag,B as BillboardGraphics,n as BoxGraphics,o as CorridorGraphics,p as CylinderGraphics,q as EllipseGraphics,r as EllipsoidGraphics,L as LabelGraphics,M as ModelGraphics,N as NodeTransformationProperty,s as PathGraphics,t as PointGraphics,u as PolygonGraphics,v as PolylineGraphics,w as PolylineVolumeGraphics,x as RectangleGraphics,y as Cesium3DTilesetGraphics,W as WallGraphics,z as SampledProperty,A as ConstantPositionProperty,D as SampledPositionProperty,F as CompositePositionProperty,H as ImageMaterialProperty,J as ExtrapolationType,K as LinearApproximation,O as ShadowVolumeAppearance,Q as ScaledPositionProperty,U as GroundPolylineGeometry,V as PolylineColorAppearance,X as PolylineMaterialAppearance,Y as GroundPolylinePrimitive,Z as decodeCP437,_ as initReader,$ as getConfiguration,a0 as initStream,a1 as UNDEFINED_VALUE,a2 as BlobReader,a3 as END_OF_CENTRAL_DIR_LENGTH,a4 as getChunkSize,a5 as END_OF_CENTRAL_DIR_SIGNATURE,a6 as readUint8Array,a7 as SPLIT_ZIP_FILE_SIGNATURE,a8 as MAX_32_BITS,a9 as MAX_16_BITS,aa as ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH,ab as ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE,ac as ZIP64_END_OF_CENTRAL_DIR_LENGTH,ad as ZIP64_END_OF_CENTRAL_DIR_SIGNATURE,ae as CENTRAL_FILE_HEADER_SIGNATURE,af as FILE_ATTR_MSDOS_DIR_MASK,ag as DIRECTORY_SIGNATURE,ah as Entry,ai as COMPRESSION_METHOD_AES,aj as COMPRESSION_METHOD_STORE,ak as COMPRESSION_METHOD_DEFLATE,al as LOCAL_FILE_HEADER_SIGNATURE,am as initWriter,an as CODEC_INFLATE,ao as runWorker,ap as ERR_ABORT_CHECK_PASSWORD,aq as BITFLAG_LEVEL,ar as BITFLAG_DATA_DESCRIPTOR,as as BITFLAG_LANG_ENCODING_FLAG,at as EXTRAFIELD_TYPE_ZIP64,au as EXTRAFIELD_TYPE_UNICODE_PATH,av as EXTRAFIELD_TYPE_UNICODE_COMMENT,aw as EXTRAFIELD_TYPE_AES,ax as EXTRAFIELD_TYPE_NTFS,ay as EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP,az as EXTRAFIELD_TYPE_USDZ,aA as EXTRAFIELD_TYPE_NTFS_TAG1,aB as PROPERTY_NAME_UNCOMPPRESSED_SIZE,aC as PROPERTY_NAME_COMPPRESSED_SIZE,aD as PROPERTY_NAME_OFFSET,aE as PROPERTY_NAME_DISK_NUMBER_START,aF as BITFLAG_ENCRYPTED,aG as PROPERTY_NAME_RAW_FILENAME,aH as PROPERTY_NAME_FILENAME,aI as PROPERTY_NAME_RAW_COMMENT,aJ as PROPERTY_NAME_COMMENT,aK as Crc32,aL as PROPERTY_NAME_LAST_MODIFICATION_DATE,aM as PROPERTY_NAME_LAST_ACCESS_DATE,aN as PROPERTY_NAME_CREATION_DATE,aO as PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE,aP as PROPERTY_NAME_RAW_LAST_ACCESS_DATE,aQ as PROPERTY_NAME_RAW_CREATION_DATE,aR as configure,aS as TextWriter,aT as Data64URIWriter,S as ScreenSpaceEventHandler,a as ScreenSpaceEventType,aU as KeyboardEventModifier}from"./ScreenSpaceEventHandler-BV10dpGX.js";import{b2 as zl,b1 as $l,aV as Wl,b3 as ql,b4 as jl,aX as Xl,aY as Yl,aZ as Ql,a_ as Kl,a$ as Zl,b0 as Jl,aW as ed,e as td}from"./ScreenSpaceEventHandler-BV10dpGX.js";import{cW as RBush$1,bd as commonjsGlobal,bc as getDefaultExportFromCjs}from"./lazy-CNpw-HpO.js";function _mergeNamespaces(e,t){for(var n=0;n<t.length;n++){const i=t[n];if(typeof i!="string"&&!Array.isArray(i)){for(const r in i)if(r!=="default"&&!(r in e)){const o=Object.getOwnPropertyDescriptor(i,r);o&&Object.defineProperty(e,r,o.get?o:{enumerable:!0,get:()=>i[r]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}const BoundingSphereState={DONE:0,PENDING:1,FAILED:2},BoundingSphereState$1=Object.freeze(BoundingSphereState),defaultColor$7=Color.WHITE,defaultEyeOffset$1=Cartesian3.ZERO,defaultHeightReference$2=HeightReference.NONE,defaultPixelOffset$1=Cartesian2.ZERO,defaultScale$2=1,defaultRotation=0,defaultAlignedAxis=Cartesian3.ZERO,defaultHorizontalOrigin$1=HorizontalOrigin.CENTER,defaultVerticalOrigin$1=VerticalOrigin.CENTER,defaultSizeInMeters=!1,positionScratch$9=new Cartesian3,colorScratch$7=new Color,eyeOffsetScratch$1=new Cartesian3,pixelOffsetScratch$1=new Cartesian2,scaleByDistanceScratch$2=new NearFarScalar,translucencyByDistanceScratch$2=new NearFarScalar,pixelOffsetScaleByDistanceScratch$1=new NearFarScalar,boundingRectangleScratch=new BoundingRectangle,distanceDisplayConditionScratch$8=new DistanceDisplayCondition;function EntityData$3(e){this.entity=e,this.billboard=void 0,this.textureValue=void 0}function BillboardVisualizer(e,t){if(!defined(e))throw new DeveloperError("entityCluster is required.");if(!defined(t))throw new DeveloperError("entityCollection is required.");t.collectionChanged.addEventListener(BillboardVisualizer.prototype._onCollectionChanged,this),this._cluster=e,this._entityCollection=t,this._items=new AssociativeArray,this._onCollectionChanged(t,t.values,[],[])}BillboardVisualizer.prototype.update=function(e){if(!defined(e))throw new DeveloperError("time is required.");const t=this._items.values,n=this._cluster;for(let i=0,r=t.length;i<r;i++){const o=t[i],a=o.entity,s=a._billboard;let l,c=o.billboard,d=a.isShowing&&a.isAvailable(e)&&Property.getValueOrDefault(s._show,e,!0),h;if(d&&(h=Property.getValueOrUndefined(a._position,e,positionScratch$9),l=Property.getValueOrUndefined(s._image,e),d=defined(h)&&defined(l)),!d){returnPrimitive$2(o,a,n);continue}Property.isConstant(a._position)||(n._clusterDirty=!0),defined(c)||(c=n.getBillboard(a),c.id=a,c.image=void 0,o.billboard=c),c.show=d,(!defined(c.image)||o.textureValue!==l)&&(c.image=l,o.textureValue=l),c.position=h,c.color=Property.getValueOrDefault(s._color,e,defaultColor$7,colorScratch$7),c.eyeOffset=Property.getValueOrDefault(s._eyeOffset,e,defaultEyeOffset$1,eyeOffsetScratch$1),c.heightReference=Property.getValueOrDefault(s._heightReference,e,defaultHeightReference$2),c.pixelOffset=Property.getValueOrDefault(s._pixelOffset,e,defaultPixelOffset$1,pixelOffsetScratch$1),c.scale=Property.getValueOrDefault(s._scale,e,defaultScale$2),c.rotation=Property.getValueOrDefault(s._rotation,e,defaultRotation),c.alignedAxis=Property.getValueOrDefault(s._alignedAxis,e,defaultAlignedAxis),c.horizontalOrigin=Property.getValueOrDefault(s._horizontalOrigin,e,defaultHorizontalOrigin$1),c.verticalOrigin=Property.getValueOrDefault(s._verticalOrigin,e,defaultVerticalOrigin$1),c.width=Property.getValueOrUndefined(s._width,e),c.height=Property.getValueOrUndefined(s._height,e),c.scaleByDistance=Property.getValueOrUndefined(s._scaleByDistance,e,scaleByDistanceScratch$2),c.translucencyByDistance=Property.getValueOrUndefined(s._translucencyByDistance,e,translucencyByDistanceScratch$2),c.pixelOffsetScaleByDistance=Property.getValueOrUndefined(s._pixelOffsetScaleByDistance,e,pixelOffsetScaleByDistanceScratch$1),c.sizeInMeters=Property.getValueOrDefault(s._sizeInMeters,e,defaultSizeInMeters),c.distanceDisplayCondition=Property.getValueOrUndefined(s._distanceDisplayCondition,e,distanceDisplayConditionScratch$8),c.disableDepthTestDistance=Property.getValueOrUndefined(s._disableDepthTestDistance,e);const f=Property.getValueOrUndefined(s._imageSubRegion,e,boundingRectangleScratch);defined(f)&&c.setImageSubRegion(c._imageId,f)}return!0};BillboardVisualizer.prototype.getBoundingSphere=function(e,t){if(!defined(e))throw new DeveloperError("entity is required.");if(!defined(t))throw new DeveloperError("result is required.");const n=this._items.get(e.id);if(!defined(n)||!defined(n.billboard))return BoundingSphereState$1.FAILED;const i=n.billboard;if(i.heightReference===HeightReference.NONE)t.center=Cartesian3.clone(i.position,t.center);else{if(!defined(i._clampedPosition))return BoundingSphereState$1.PENDING;t.center=Cartesian3.clone(i._clampedPosition,t.center)}return t.radius=0,BoundingSphereState$1.DONE};BillboardVisualizer.prototype.isDestroyed=function(){return!1};BillboardVisualizer.prototype.destroy=function(){this._entityCollection.collectionChanged.removeEventListener(BillboardVisualizer.prototype._onCollectionChanged,this);const e=this._entityCollection.values;for(let t=0;t<e.length;t++)this._cluster.removeBillboard(e[t]);return destroyObject(this)};BillboardVisualizer.prototype._onCollectionChanged=function(e,t,n,i){let r,o;const a=this._items,s=this._cluster;for(r=t.length-1;r>-1;r--)o=t[r],defined(o._billboard)&&defined(o._position)&&a.set(o.id,new EntityData$3(o));for(r=i.length-1;r>-1;r--)o=i[r],defined(o._billboard)&&defined(o._position)?a.contains(o.id)||a.set(o.id,new EntityData$3(o)):(returnPrimitive$2(a.get(o.id),o,s),a.remove(o.id));for(r=n.length-1;r>-1;r--)o=n[r],returnPrimitive$2(a.get(o.id),o,s),a.remove(o.id)};function returnPrimitive$2(e,t,n){defined(e)&&(e.billboard=void 0,n.removeBillboard(t))}const diffScratch=new Cartesian3;function BoxGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.minimum,n=e.maximum;if(Check.typeOf.object("min",t),Check.typeOf.object("max",n),defined(e.offsetAttribute)&&e.offsetAttribute===GeometryOffsetAttribute.TOP)throw new DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");const i=defaultValue(e.vertexFormat,VertexFormat.DEFAULT);this._minimum=Cartesian3.clone(t),this._maximum=Cartesian3.clone(n),this._vertexFormat=i,this._offsetAttribute=e.offsetAttribute,this._workerName="createBoxGeometry"}BoxGeometry.fromDimensions=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.dimensions;Check.typeOf.object("dimensions",t),Check.typeOf.number.greaterThanOrEquals("dimensions.x",t.x,0),Check.typeOf.number.greaterThanOrEquals("dimensions.y",t.y,0),Check.typeOf.number.greaterThanOrEquals("dimensions.z",t.z,0);const n=Cartesian3.multiplyByScalar(t,.5,new Cartesian3);return new BoxGeometry({minimum:Cartesian3.negate(n,new Cartesian3),maximum:n,vertexFormat:e.vertexFormat,offsetAttribute:e.offsetAttribute})};BoxGeometry.fromAxisAlignedBoundingBox=function(e){return Check.typeOf.object("boundingBox",e),new BoxGeometry({minimum:e.minimum,maximum:e.maximum})};BoxGeometry.packedLength=2*Cartesian3.packedLength+VertexFormat.packedLength+1;BoxGeometry.pack=function(e,t,n){return Check.typeOf.object("value",e),Check.defined("array",t),n=defaultValue(n,0),Cartesian3.pack(e._minimum,t,n),Cartesian3.pack(e._maximum,t,n+Cartesian3.packedLength),VertexFormat.pack(e._vertexFormat,t,n+2*Cartesian3.packedLength),t[n+2*Cartesian3.packedLength+VertexFormat.packedLength]=defaultValue(e._offsetAttribute,-1),t};const scratchMin$2=new Cartesian3,scratchMax$2=new Cartesian3,scratchVertexFormat$b=new VertexFormat,scratchOptions$i={minimum:scratchMin$2,maximum:scratchMax$2,vertexFormat:scratchVertexFormat$b,offsetAttribute:void 0};BoxGeometry.unpack=function(e,t,n){Check.defined("array",e),t=defaultValue(t,0);const i=Cartesian3.unpack(e,t,scratchMin$2),r=Cartesian3.unpack(e,t+Cartesian3.packedLength,scratchMax$2),o=VertexFormat.unpack(e,t+2*Cartesian3.packedLength,scratchVertexFormat$b),a=e[t+2*Cartesian3.packedLength+VertexFormat.packedLength];return defined(n)?(n._minimum=Cartesian3.clone(i,n._minimum),n._maximum=Cartesian3.clone(r,n._maximum),n._vertexFormat=VertexFormat.clone(o,n._vertexFormat),n._offsetAttribute=a===-1?void 0:a,n):(scratchOptions$i.offsetAttribute=a===-1?void 0:a,new BoxGeometry(scratchOptions$i))};BoxGeometry.createGeometry=function(e){const t=e._minimum,n=e._maximum,i=e._vertexFormat;if(Cartesian3.equals(t,n))return;const r=new GeometryAttributes;let o,a;if(i.position&&(i.st||i.normal||i.tangent||i.bitangent)){if(i.position&&(a=new Float64Array(6*4*3),a[0]=t.x,a[1]=t.y,a[2]=n.z,a[3]=n.x,a[4]=t.y,a[5]=n.z,a[6]=n.x,a[7]=n.y,a[8]=n.z,a[9]=t.x,a[10]=n.y,a[11]=n.z,a[12]=t.x,a[13]=t.y,a[14]=t.z,a[15]=n.x,a[16]=t.y,a[17]=t.z,a[18]=n.x,a[19]=n.y,a[20]=t.z,a[21]=t.x,a[22]=n.y,a[23]=t.z,a[24]=n.x,a[25]=t.y,a[26]=t.z,a[27]=n.x,a[28]=n.y,a[29]=t.z,a[30]=n.x,a[31]=n.y,a[32]=n.z,a[33]=n.x,a[34]=t.y,a[35]=n.z,a[36]=t.x,a[37]=t.y,a[38]=t.z,a[39]=t.x,a[40]=n.y,a[41]=t.z,a[42]=t.x,a[43]=n.y,a[44]=n.z,a[45]=t.x,a[46]=t.y,a[47]=n.z,a[48]=t.x,a[49]=n.y,a[50]=t.z,a[51]=n.x,a[52]=n.y,a[53]=t.z,a[54]=n.x,a[55]=n.y,a[56]=n.z,a[57]=t.x,a[58]=n.y,a[59]=n.z,a[60]=t.x,a[61]=t.y,a[62]=t.z,a[63]=n.x,a[64]=t.y,a[65]=t.z,a[66]=n.x,a[67]=t.y,a[68]=n.z,a[69]=t.x,a[70]=t.y,a[71]=n.z,r.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a})),i.normal){const c=new Float32Array(72);c[0]=0,c[1]=0,c[2]=1,c[3]=0,c[4]=0,c[5]=1,c[6]=0,c[7]=0,c[8]=1,c[9]=0,c[10]=0,c[11]=1,c[12]=0,c[13]=0,c[14]=-1,c[15]=0,c[16]=0,c[17]=-1,c[18]=0,c[19]=0,c[20]=-1,c[21]=0,c[22]=0,c[23]=-1,c[24]=1,c[25]=0,c[26]=0,c[27]=1,c[28]=0,c[29]=0,c[30]=1,c[31]=0,c[32]=0,c[33]=1,c[34]=0,c[35]=0,c[36]=-1,c[37]=0,c[38]=0,c[39]=-1,c[40]=0,c[41]=0,c[42]=-1,c[43]=0,c[44]=0,c[45]=-1,c[46]=0,c[47]=0,c[48]=0,c[49]=1,c[50]=0,c[51]=0,c[52]=1,c[53]=0,c[54]=0,c[55]=1,c[56]=0,c[57]=0,c[58]=1,c[59]=0,c[60]=0,c[61]=-1,c[62]=0,c[63]=0,c[64]=-1,c[65]=0,c[66]=0,c[67]=-1,c[68]=0,c[69]=0,c[70]=-1,c[71]=0,r.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:c})}if(i.st){const c=new Float32Array(48);c[0]=0,c[1]=0,c[2]=1,c[3]=0,c[4]=1,c[5]=1,c[6]=0,c[7]=1,c[8]=1,c[9]=0,c[10]=0,c[11]=0,c[12]=0,c[13]=1,c[14]=1,c[15]=1,c[16]=0,c[17]=0,c[18]=1,c[19]=0,c[20]=1,c[21]=1,c[22]=0,c[23]=1,c[24]=1,c[25]=0,c[26]=0,c[27]=0,c[28]=0,c[29]=1,c[30]=1,c[31]=1,c[32]=1,c[33]=0,c[34]=0,c[35]=0,c[36]=0,c[37]=1,c[38]=1,c[39]=1,c[40]=0,c[41]=0,c[42]=1,c[43]=0,c[44]=1,c[45]=1,c[46]=0,c[47]=1,r.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:c})}if(i.tangent){const c=new Float32Array(72);c[0]=1,c[1]=0,c[2]=0,c[3]=1,c[4]=0,c[5]=0,c[6]=1,c[7]=0,c[8]=0,c[9]=1,c[10]=0,c[11]=0,c[12]=-1,c[13]=0,c[14]=0,c[15]=-1,c[16]=0,c[17]=0,c[18]=-1,c[19]=0,c[20]=0,c[21]=-1,c[22]=0,c[23]=0,c[24]=0,c[25]=1,c[26]=0,c[27]=0,c[28]=1,c[29]=0,c[30]=0,c[31]=1,c[32]=0,c[33]=0,c[34]=1,c[35]=0,c[36]=0,c[37]=-1,c[38]=0,c[39]=0,c[40]=-1,c[41]=0,c[42]=0,c[43]=-1,c[44]=0,c[45]=0,c[46]=-1,c[47]=0,c[48]=-1,c[49]=0,c[50]=0,c[51]=-1,c[52]=0,c[53]=0,c[54]=-1,c[55]=0,c[56]=0,c[57]=-1,c[58]=0,c[59]=0,c[60]=1,c[61]=0,c[62]=0,c[63]=1,c[64]=0,c[65]=0,c[66]=1,c[67]=0,c[68]=0,c[69]=1,c[70]=0,c[71]=0,r.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:c})}if(i.bitangent){const c=new Float32Array(72);c[0]=0,c[1]=1,c[2]=0,c[3]=0,c[4]=1,c[5]=0,c[6]=0,c[7]=1,c[8]=0,c[9]=0,c[10]=1,c[11]=0,c[12]=0,c[13]=1,c[14]=0,c[15]=0,c[16]=1,c[17]=0,c[18]=0,c[19]=1,c[20]=0,c[21]=0,c[22]=1,c[23]=0,c[24]=0,c[25]=0,c[26]=1,c[27]=0,c[28]=0,c[29]=1,c[30]=0,c[31]=0,c[32]=1,c[33]=0,c[34]=0,c[35]=1,c[36]=0,c[37]=0,c[38]=1,c[39]=0,c[40]=0,c[41]=1,c[42]=0,c[43]=0,c[44]=1,c[45]=0,c[46]=0,c[47]=1,c[48]=0,c[49]=0,c[50]=1,c[51]=0,c[52]=0,c[53]=1,c[54]=0,c[55]=0,c[56]=1,c[57]=0,c[58]=0,c[59]=1,c[60]=0,c[61]=0,c[62]=1,c[63]=0,c[64]=0,c[65]=1,c[66]=0,c[67]=0,c[68]=1,c[69]=0,c[70]=0,c[71]=1,r.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:c})}o=new Uint16Array(6*2*3),o[0]=0,o[1]=1,o[2]=2,o[3]=0,o[4]=2,o[5]=3,o[6]=6,o[7]=5,o[8]=4,o[9]=7,o[10]=6,o[11]=4,o[12]=8,o[13]=9,o[14]=10,o[15]=8,o[16]=10,o[17]=11,o[18]=14,o[19]=13,o[20]=12,o[21]=15,o[22]=14,o[23]=12,o[24]=18,o[25]=17,o[26]=16,o[27]=19,o[28]=18,o[29]=16,o[30]=20,o[31]=21,o[32]=22,o[33]=20,o[34]=22,o[35]=23}else a=new Float64Array(8*3),a[0]=t.x,a[1]=t.y,a[2]=t.z,a[3]=n.x,a[4]=t.y,a[5]=t.z,a[6]=n.x,a[7]=n.y,a[8]=t.z,a[9]=t.x,a[10]=n.y,a[11]=t.z,a[12]=t.x,a[13]=t.y,a[14]=n.z,a[15]=n.x,a[16]=t.y,a[17]=n.z,a[18]=n.x,a[19]=n.y,a[20]=n.z,a[21]=t.x,a[22]=n.y,a[23]=n.z,r.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a}),o=new Uint16Array(6*2*3),o[0]=4,o[1]=5,o[2]=6,o[3]=4,o[4]=6,o[5]=7,o[6]=1,o[7]=0,o[8]=3,o[9]=1,o[10]=3,o[11]=2,o[12]=1,o[13]=6,o[14]=5,o[15]=1,o[16]=2,o[17]=6,o[18]=2,o[19]=3,o[20]=7,o[21]=2,o[22]=7,o[23]=6,o[24]=3,o[25]=0,o[26]=4,o[27]=3,o[28]=4,o[29]=7,o[30]=0,o[31]=1,o[32]=5,o[33]=0,o[34]=5,o[35]=4;const s=Cartesian3.subtract(n,t,diffScratch),l=Cartesian3.magnitude(s)*.5;if(defined(e._offsetAttribute)){const c=a.length,d=e._offsetAttribute===GeometryOffsetAttribute.NONE?0:1,h=new Uint8Array(c/3).fill(d);r.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:h})}return new Geometry({attributes:r,indices:o,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:new BoundingSphere(Cartesian3.ZERO,l),offsetAttribute:e._offsetAttribute})};let unitBoxGeometry;BoxGeometry.getUnitBox=function(){return defined(unitBoxGeometry)||(unitBoxGeometry=BoxGeometry.createGeometry(BoxGeometry.fromDimensions({dimensions:new Cartesian3(1,1,1),vertexFormat:VertexFormat.POSITION_ONLY}))),unitBoxGeometry};function DistanceDisplayConditionGeometryInstanceAttribute(e,t){if(e=defaultValue(e,0),t=defaultValue(t,Number.MAX_VALUE),t<=e)throw new DeveloperError("far distance must be greater than near distance.");this.value=new Float32Array([e,t])}Object.defineProperties(DistanceDisplayConditionGeometryInstanceAttribute.prototype,{componentDatatype:{get:function(){return ComponentDatatype.FLOAT}},componentsPerAttribute:{get:function(){return 2}},normalize:{get:function(){return!1}}});DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition=function(e){if(!defined(e))throw new DeveloperError("distanceDisplayCondition is required.");if(e.far<=e.near)throw new DeveloperError("distanceDisplayCondition.far distance must be greater than distanceDisplayCondition.near distance.");return new DistanceDisplayConditionGeometryInstanceAttribute(e.near,e.far)};DistanceDisplayConditionGeometryInstanceAttribute.toValue=function(e,t){if(!defined(e))throw new DeveloperError("distanceDisplayCondition is required.");return defined(t)?(t[0]=e.near,t[1]=e.far,t):new Float32Array([e.near,e.far])};function ShowGeometryInstanceAttribute(e){e=defaultValue(e,!0),this.value=ShowGeometryInstanceAttribute.toValue(e)}Object.defineProperties(ShowGeometryInstanceAttribute.prototype,{componentDatatype:{get:function(){return ComponentDatatype.UNSIGNED_BYTE}},componentsPerAttribute:{get:function(){return 1}},normalize:{get:function(){return!1}}});ShowGeometryInstanceAttribute.toValue=function(e,t){if(!defined(e))throw new DeveloperError("show is required.");return defined(t)?(t[0]=e,t):new Uint8Array([e])};const AllMaterialAppearanceFS=`in vec3 v_positionEC;
in vec3 v_normalEC;
in vec3 v_tangentEC;
in vec3 v_bitangentEC;
in vec2 v_st;

void main()
{
    vec3 positionToEyeEC = -v_positionEC;
    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);

    vec3 normalEC = normalize(v_normalEC);
#ifdef FACE_FORWARD
    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);
#endif

    czm_materialInput materialInput;
    materialInput.normalEC = normalEC;
    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;
    materialInput.positionToEyeEC = positionToEyeEC;
    materialInput.st = v_st;
    czm_material material = czm_getMaterial(materialInput);

#ifdef FLAT
    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#else
    out_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
#endif
}
`,AllMaterialAppearanceVS=`in vec3 position3DHigh;
in vec3 position3DLow;
in vec3 normal;
in vec3 tangent;
in vec3 bitangent;
in vec2 st;
in float batchId;

out vec3 v_positionEC;
out vec3 v_normalEC;
out vec3 v_tangentEC;
out vec3 v_bitangentEC;
out vec2 v_st;

void main()
{
    vec4 p = czm_computePosition();

    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates
    v_normalEC = czm_normal * normal;                         // normal in eye coordinates
    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates
    v_bitangentEC = czm_normal * bitangent;                   // bitangent in eye coordinates
    v_st = st;

    gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`,BasicMaterialAppearanceFS=`in vec3 v_positionEC;
in vec3 v_normalEC;

void main()
{
    vec3 positionToEyeEC = -v_positionEC;

    vec3 normalEC = normalize(v_normalEC);
#ifdef FACE_FORWARD
    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);
#endif

    czm_materialInput materialInput;
    materialInput.normalEC = normalEC;
    materialInput.positionToEyeEC = positionToEyeEC;
    czm_material material = czm_getMaterial(materialInput);

#ifdef FLAT
    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#else
    out_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
#endif
}
`,BasicMaterialAppearanceVS=`in vec3 position3DHigh;
in vec3 position3DLow;
in vec3 normal;
in float batchId;

out vec3 v_positionEC;
out vec3 v_normalEC;

void main()
{
    vec4 p = czm_computePosition();

    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates
    v_normalEC = czm_normal * normal;                         // normal in eye coordinates

    gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`,TexturedMaterialAppearanceFS=`in vec3 v_positionEC;
in vec3 v_normalEC;
in vec2 v_st;

void main()
{
    vec3 positionToEyeEC = -v_positionEC;

    vec3 normalEC = normalize(v_normalEC);
#ifdef FACE_FORWARD
    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);
#endif

    czm_materialInput materialInput;
    materialInput.normalEC = normalEC;
    materialInput.positionToEyeEC = positionToEyeEC;
    materialInput.st = v_st;
    czm_material material = czm_getMaterial(materialInput);

#ifdef FLAT
    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#else
    out_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
#endif
}
`,TexturedMaterialAppearanceVS=`in vec3 position3DHigh;
in vec3 position3DLow;
in vec3 normal;
in vec2 st;
in float batchId;

out vec3 v_positionEC;
out vec3 v_normalEC;
out vec2 v_st;

void main()
{
    vec4 p = czm_computePosition();

    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates
    v_normalEC = czm_normal * normal;                         // normal in eye coordinates
    v_st = st;

    gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`;function MaterialAppearance(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=defaultValue(e.translucent,!0),n=defaultValue(e.closed,!1),i=defaultValue(e.materialSupport,MaterialAppearance.MaterialSupport.TEXTURED);this.material=defined(e.material)?e.material:Material.fromType(Material.ColorType),this.translucent=t,this._vertexShaderSource=defaultValue(e.vertexShaderSource,i.vertexShaderSource),this._fragmentShaderSource=defaultValue(e.fragmentShaderSource,i.fragmentShaderSource),this._renderState=Appearance.getDefaultRenderState(t,n,e.renderState),this._closed=n,this._materialSupport=i,this._vertexFormat=i.vertexFormat,this._flat=defaultValue(e.flat,!1),this._faceForward=defaultValue(e.faceForward,!n)}Object.defineProperties(MaterialAppearance.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}},materialSupport:{get:function(){return this._materialSupport}},vertexFormat:{get:function(){return this._vertexFormat}},flat:{get:function(){return this._flat}},faceForward:{get:function(){return this._faceForward}}});MaterialAppearance.prototype.getFragmentShaderSource=Appearance.prototype.getFragmentShaderSource;MaterialAppearance.prototype.isTranslucent=Appearance.prototype.isTranslucent;MaterialAppearance.prototype.getRenderState=Appearance.prototype.getRenderState;MaterialAppearance.MaterialSupport={BASIC:Object.freeze({vertexFormat:VertexFormat.POSITION_AND_NORMAL,vertexShaderSource:BasicMaterialAppearanceVS,fragmentShaderSource:BasicMaterialAppearanceFS}),TEXTURED:Object.freeze({vertexFormat:VertexFormat.POSITION_NORMAL_AND_ST,vertexShaderSource:TexturedMaterialAppearanceVS,fragmentShaderSource:TexturedMaterialAppearanceFS}),ALL:Object.freeze({vertexFormat:VertexFormat.ALL,vertexShaderSource:AllMaterialAppearanceVS,fragmentShaderSource:AllMaterialAppearanceFS})};function MaterialProperty(){DeveloperError.throwInstantiationError()}Object.defineProperties(MaterialProperty.prototype,{isConstant:{get:DeveloperError.throwInstantiationError},definitionChanged:{get:DeveloperError.throwInstantiationError}});MaterialProperty.prototype.getType=DeveloperError.throwInstantiationError;MaterialProperty.prototype.getValue=DeveloperError.throwInstantiationError;MaterialProperty.prototype.equals=DeveloperError.throwInstantiationError;MaterialProperty.getValue=function(e,t,n){let i;return defined(t)&&(i=t.getType(e),defined(i))?((!defined(n)||n.type!==i)&&(n=Material.fromType(i)),t.getValue(e,n.uniforms),n):((!defined(n)||n.type!==Material.ColorType)&&(n=Material.fromType(Material.ColorType)),Color.clone(Color.WHITE,n.uniforms.color),n)};function DynamicGeometryUpdater$1(e,t,n){Check.defined("geometryUpdater",e),Check.defined("primitives",t),Check.defined("orderedGroundPrimitives",n),this._primitives=t,this._orderedGroundPrimitives=n,this._primitive=void 0,this._outlinePrimitive=void 0,this._geometryUpdater=e,this._options=e._options,this._entity=e._entity,this._material=void 0}DynamicGeometryUpdater$1.prototype._isHidden=function(e,t,n){return!e.isShowing||!e.isAvailable(n)||!Property.getValueOrDefault(t.show,n,!0)};DynamicGeometryUpdater$1.prototype._setOptions=DeveloperError.throwInstantiationError;DynamicGeometryUpdater$1.prototype.update=function(e){Check.defined("time",e);const t=this._geometryUpdater,n=t._onTerrain,i=this._primitives,r=this._orderedGroundPrimitives;n?r.remove(this._primitive):(i.removeAndDestroy(this._primitive),i.removeAndDestroy(this._outlinePrimitive),this._outlinePrimitive=void 0),this._primitive=void 0;const o=this._entity,a=o[this._geometryUpdater._geometryPropertyName];if(this._setOptions(o,a,e),this._isHidden(o,a,e))return;const s=this._geometryUpdater.shadowsProperty.getValue(e),l=this._options;if(!defined(a.fill)||a.fill.getValue(e)){const c=t.fillMaterialProperty,d=c instanceof ColorMaterialProperty;let h;const f=t._getIsClosed(l);if(d)h=new PerInstanceColorAppearance({closed:f,flat:n&&!t._supportsMaterialsforEntitiesOnTerrain});else{const p=MaterialProperty.getValue(e,c,this._material);this._material=p,h=new MaterialAppearance({material:p,translucent:p.isTranslucent(),closed:f})}if(n)l.vertexFormat=PerInstanceColorAppearance.VERTEX_FORMAT,this._primitive=r.add(new GroundPrimitive({geometryInstances:this._geometryUpdater.createFillGeometryInstance(e),appearance:h,asynchronous:!1,shadows:s,classificationType:this._geometryUpdater.classificationTypeProperty.getValue(e)}),Property.getValueOrUndefined(this._geometryUpdater.zIndex,e));else{l.vertexFormat=h.vertexFormat;const p=this._geometryUpdater.createFillGeometryInstance(e);d&&(h.translucent=p.attributes.color.value[3]!==255),this._primitive=i.add(new Primitive({geometryInstances:p,appearance:h,asynchronous:!1,shadows:s}))}}if(!n&&defined(a.outline)&&a.outline.getValue(e)){const c=this._geometryUpdater.createOutlineGeometryInstance(e),d=Property.getValueOrDefault(a.outlineWidth,e,1);this._outlinePrimitive=i.add(new Primitive({geometryInstances:c,appearance:new PerInstanceColorAppearance({flat:!0,translucent:c.attributes.color.value[3]!==255,renderState:{lineWidth:t._scene.clampLineWidth(d)}}),asynchronous:!1,shadows:s}))}};DynamicGeometryUpdater$1.prototype.getBoundingSphere=function(e){if(!defined(e))throw new DeveloperError("result is required.");const t=this._entity,n=this._primitive,i=this._outlinePrimitive;let r;return defined(n)&&n.show&&n.ready&&(r=n.getGeometryInstanceAttributes(t),defined(r)&&defined(r.boundingSphere))?(BoundingSphere.clone(r.boundingSphere,e),BoundingSphereState$1.DONE):defined(i)&&i.show&&i.ready&&(r=i.getGeometryInstanceAttributes(t),defined(r)&&defined(r.boundingSphere))?(BoundingSphere.clone(r.boundingSphere,e),BoundingSphereState$1.DONE):defined(n)&&!n.ready||defined(i)&&!i.ready?BoundingSphereState$1.PENDING:BoundingSphereState$1.FAILED};DynamicGeometryUpdater$1.prototype.isDestroyed=function(){return!1};DynamicGeometryUpdater$1.prototype.destroy=function(){const e=this._primitives,t=this._orderedGroundPrimitives;this._geometryUpdater._onTerrain?t.remove(this._primitive):e.removeAndDestroy(this._primitive),e.removeAndDestroy(this._outlinePrimitive),destroyObject(this)};const defaultMaterial$2=new ColorMaterialProperty(Color.WHITE),defaultShow$1=new ConstantProperty(!0),defaultFill$1=new ConstantProperty(!0),defaultOutline=new ConstantProperty(!1),defaultOutlineColor$3=new ConstantProperty(Color.BLACK),defaultShadows$2=new ConstantProperty(ShadowMode.DISABLED),defaultDistanceDisplayCondition$7=new ConstantProperty(new DistanceDisplayCondition),defaultClassificationType$1=new ConstantProperty(ClassificationType.BOTH);function GeometryUpdater(e){Check.defined("options.entity",e.entity),Check.defined("options.scene",e.scene),Check.defined("options.geometryOptions",e.geometryOptions),Check.defined("options.geometryPropertyName",e.geometryPropertyName),Check.defined("options.observedPropertyNames",e.observedPropertyNames);const t=e.entity,n=e.geometryPropertyName;this._entity=t,this._scene=e.scene,this._fillEnabled=!1,this._isClosed=!1,this._onTerrain=!1,this._dynamic=!1,this._outlineEnabled=!1,this._geometryChanged=new Event,this._showProperty=void 0,this._materialProperty=void 0,this._showOutlineProperty=void 0,this._outlineColorProperty=void 0,this._outlineWidth=1,this._shadowsProperty=void 0,this._distanceDisplayConditionProperty=void 0,this._classificationTypeProperty=void 0,this._options=e.geometryOptions,this._geometryPropertyName=n,this._id=`${n}-${t.id}`,this._observedPropertyNames=e.observedPropertyNames,this._supportsMaterialsforEntitiesOnTerrain=Entity.supportsMaterialsforEntitiesOnTerrain(e.scene)}Object.defineProperties(GeometryUpdater.prototype,{id:{get:function(){return this._id}},entity:{get:function(){return this._entity}},fillEnabled:{get:function(){return this._fillEnabled}},hasConstantFill:{get:function(){return!this._fillEnabled||!defined(this._entity.availability)&&Property.isConstant(this._showProperty)&&Property.isConstant(this._fillProperty)}},fillMaterialProperty:{get:function(){return this._materialProperty}},outlineEnabled:{get:function(){return this._outlineEnabled}},hasConstantOutline:{get:function(){return!this._outlineEnabled||!defined(this._entity.availability)&&Property.isConstant(this._showProperty)&&Property.isConstant(this._showOutlineProperty)}},outlineColorProperty:{get:function(){return this._outlineColorProperty}},outlineWidth:{get:function(){return this._outlineWidth}},shadowsProperty:{get:function(){return this._shadowsProperty}},distanceDisplayConditionProperty:{get:function(){return this._distanceDisplayConditionProperty}},classificationTypeProperty:{get:function(){return this._classificationTypeProperty}},isDynamic:{get:function(){return this._dynamic}},isClosed:{get:function(){return this._isClosed}},onTerrain:{get:function(){return this._onTerrain}},geometryChanged:{get:function(){return this._geometryChanged}}});GeometryUpdater.prototype.isOutlineVisible=function(e){const t=this._entity,n=this._outlineEnabled&&t.isAvailable(e)&&this._showProperty.getValue(e)&&this._showOutlineProperty.getValue(e);return defaultValue(n,!1)};GeometryUpdater.prototype.isFilled=function(e){const t=this._entity,n=this._fillEnabled&&t.isAvailable(e)&&this._showProperty.getValue(e)&&this._fillProperty.getValue(e);return defaultValue(n,!1)};GeometryUpdater.prototype.createFillGeometryInstance=DeveloperError.throwInstantiationError;GeometryUpdater.prototype.createOutlineGeometryInstance=DeveloperError.throwInstantiationError;GeometryUpdater.prototype.isDestroyed=function(){return!1};GeometryUpdater.prototype.destroy=function(){destroyObject(this)};GeometryUpdater.prototype._isHidden=function(e,t){const n=t.show;return defined(n)&&n.isConstant&&!n.getValue(Iso8601.MINIMUM_VALUE)};GeometryUpdater.prototype._isOnTerrain=function(e,t){return!1};GeometryUpdater.prototype._getIsClosed=function(e){return!0};GeometryUpdater.prototype._isDynamic=DeveloperError.throwInstantiationError;GeometryUpdater.prototype._setStaticOptions=DeveloperError.throwInstantiationError;GeometryUpdater.prototype._onEntityPropertyChanged=function(e,t,n,i){if(this._observedPropertyNames.indexOf(t)===-1)return;const r=this._entity[this._geometryPropertyName];if(!defined(r)){(this._fillEnabled||this._outlineEnabled)&&(this._fillEnabled=!1,this._outlineEnabled=!1,this._geometryChanged.raiseEvent(this));return}const o=r.fill,a=defined(o)&&o.isConstant?o.getValue(Iso8601.MINIMUM_VALUE):!0,s=r.outline;let l=defined(s);if(l&&s.isConstant&&(l=s.getValue(Iso8601.MINIMUM_VALUE)),!a&&!l){(this._fillEnabled||this._outlineEnabled)&&(this._fillEnabled=!1,this._outlineEnabled=!1,this._geometryChanged.raiseEvent(this));return}const c=r.show;if(this._isHidden(e,r)){(this._fillEnabled||this._outlineEnabled)&&(this._fillEnabled=!1,this._outlineEnabled=!1,this._geometryChanged.raiseEvent(this));return}this._materialProperty=defaultValue(r.material,defaultMaterial$2),this._fillProperty=defaultValue(o,defaultFill$1),this._showProperty=defaultValue(c,defaultShow$1),this._showOutlineProperty=defaultValue(r.outline,defaultOutline),this._outlineColorProperty=l?defaultValue(r.outlineColor,defaultOutlineColor$3):void 0,this._shadowsProperty=defaultValue(r.shadows,defaultShadows$2),this._distanceDisplayConditionProperty=defaultValue(r.distanceDisplayCondition,defaultDistanceDisplayCondition$7),this._classificationTypeProperty=defaultValue(r.classificationType,defaultClassificationType$1),this._fillEnabled=a;const d=this._isOnTerrain(e,r)&&(this._supportsMaterialsforEntitiesOnTerrain||this._materialProperty instanceof ColorMaterialProperty);if(l&&d&&(oneTimeWarning(oneTimeWarning.geometryOutlines),l=!1),this._onTerrain=d,this._outlineEnabled=l,this._isDynamic(e,r))this._dynamic||(this._dynamic=!0,this._geometryChanged.raiseEvent(this));else{this._setStaticOptions(e,r),this._isClosed=this._getIsClosed(this._options);const h=r.outlineWidth;this._outlineWidth=defined(h)?h.getValue(Iso8601.MINIMUM_VALUE):1,this._dynamic=!1,this._geometryChanged.raiseEvent(this)}};GeometryUpdater.prototype.createDynamicUpdater=function(e,t){if(Check.defined("primitives",e),Check.defined("groundPrimitives",t),!this._dynamic)throw new DeveloperError("This instance does not represent dynamic geometry.");return new this.constructor.DynamicGeometryUpdater(this,e,t)};const scratchPosition$8=new Cartesian3;function TerrainOffsetProperty(e,t,n,i){Check.defined("scene",e),Check.defined("positionProperty",t),this._scene=e,this._heightReference=n,this._extrudedHeightReference=i,this._positionProperty=t,this._position=new Cartesian3,this._cartographicPosition=new Cartographic,this._normal=new Cartesian3,this._definitionChanged=new Event,this._terrainHeight=0,this._removeCallbackFunc=void 0,this._removeEventListener=void 0,this._removeModeListener=void 0;const r=this;if(defined(e.globe)&&(this._removeEventListener=e.terrainProviderChanged.addEventListener(function(){r._updateClamping()}),this._removeModeListener=e.morphComplete.addEventListener(function(){r._updateClamping()})),t.isConstant){const o=t.getValue(Iso8601.MINIMUM_VALUE,scratchPosition$8);if(!defined(o)||Cartesian3.equals(o,Cartesian3.ZERO)||!defined(e.globe))return;this._position=Cartesian3.clone(o,this._position),this._updateClamping(),this._normal=e.ellipsoid.geodeticSurfaceNormal(o,this._normal)}}Object.defineProperties(TerrainOffsetProperty.prototype,{isConstant:{get:function(){return!1}},definitionChanged:{get:function(){return this._definitionChanged}}});TerrainOffsetProperty.prototype._updateClamping=function(){defined(this._removeCallbackFunc)&&this._removeCallbackFunc();const e=this._scene,t=this._position;if(Cartesian3.equals(t,Cartesian3.ZERO)){this._terrainHeight=0;return}const i=e.ellipsoid.cartesianToCartographic(t,this._cartographicPosition),r=e.getHeight(i,this._heightReference);defined(r)?this._terrainHeight=r:this._terrainHeight=0;const o=a=>{this._terrainHeight=a.height,this.definitionChanged.raiseEvent()};this._removeCallbackFunc=e.updateHeight(i,o,this._heightReference)};TerrainOffsetProperty.prototype.getValue=function(e,t){const n=Property.getValueOrDefault(this._heightReference,e,HeightReference.NONE),i=Property.getValueOrDefault(this._extrudedHeightReference,e,HeightReference.NONE);if(n===HeightReference.NONE&&!isHeightReferenceRelative(i))return this._position=Cartesian3.clone(Cartesian3.ZERO,this._position),Cartesian3.clone(Cartesian3.ZERO,t);if(this._positionProperty.isConstant)return Cartesian3.multiplyByScalar(this._normal,this._terrainHeight,t);const r=this._scene,o=this._positionProperty.getValue(e,scratchPosition$8);if(!defined(o)||Cartesian3.equals(o,Cartesian3.ZERO)||!defined(r.globe))return Cartesian3.clone(Cartesian3.ZERO,t);if(Cartesian3.equalsEpsilon(this._position,o,CesiumMath.EPSILON10))return Cartesian3.multiplyByScalar(this._normal,this._terrainHeight,t);this._position=Cartesian3.clone(o,this._position),this._updateClamping();const a=r.ellipsoid.geodeticSurfaceNormal(o,this._normal);return Cartesian3.multiplyByScalar(a,this._terrainHeight,t)};TerrainOffsetProperty.prototype.isDestroyed=function(){return!1};TerrainOffsetProperty.prototype.destroy=function(){return defined(this._removeEventListener)&&this._removeEventListener(),defined(this._removeModeListener)&&this._removeModeListener(),defined(this._removeCallbackFunc)&&this._removeCallbackFunc(),destroyObject(this)};function heightReferenceOnEntityPropertyChanged(e,t,n,i){if(GeometryUpdater.prototype._onEntityPropertyChanged.call(this,e,t,n,i),this._observedPropertyNames.indexOf(t)===-1)return;const r=this._entity[this._geometryPropertyName];if(!defined(r))return;defined(this._terrainOffsetProperty)&&(this._terrainOffsetProperty.destroy(),this._terrainOffsetProperty=void 0);const o=r.heightReference;if(defined(o)){const a=new CallbackProperty(this._computeCenter.bind(this),!this._dynamic);this._terrainOffsetProperty=new TerrainOffsetProperty(this._scene,a,o)}}const defaultOffset$a=Cartesian3.ZERO,offsetScratch$9=new Cartesian3,positionScratch$8=new Cartesian3,scratchColor$g=new Color;function BoxGeometryOptions(e){this.id=e,this.vertexFormat=void 0,this.dimensions=void 0,this.offsetAttribute=void 0}function BoxGeometryUpdater(e,t){GeometryUpdater.call(this,{entity:e,scene:t,geometryOptions:new BoxGeometryOptions(e),geometryPropertyName:"box",observedPropertyNames:["availability","position","orientation","box"]}),this._onEntityPropertyChanged(e,"box",e.box,void 0)}defined(Object.create)&&(BoxGeometryUpdater.prototype=Object.create(GeometryUpdater.prototype),BoxGeometryUpdater.prototype.constructor=BoxGeometryUpdater);Object.defineProperties(BoxGeometryUpdater.prototype,{terrainOffsetProperty:{get:function(){return this._terrainOffsetProperty}}});BoxGeometryUpdater.prototype.createFillGeometryInstance=function(e){if(Check.defined("time",e),!this._fillEnabled)throw new DeveloperError("This instance does not represent a filled geometry.");const t=this._entity,n=t.isAvailable(e),i=new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._fillProperty.getValue(e)),r=this._distanceDisplayConditionProperty.getValue(e),o=DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(r),a={show:i,distanceDisplayCondition:o,color:void 0,offset:void 0};if(this._materialProperty instanceof ColorMaterialProperty){let s;defined(this._materialProperty.color)&&(this._materialProperty.color.isConstant||n)&&(s=this._materialProperty.color.getValue(e,scratchColor$g)),defined(s)||(s=Color.WHITE),a.color=ColorGeometryInstanceAttribute.fromColor(s)}return defined(this._options.offsetAttribute)&&(a.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$a,offsetScratch$9))),new GeometryInstance({id:t,geometry:BoxGeometry.fromDimensions(this._options),modelMatrix:t.computeModelMatrixForHeightReference(e,t.box.heightReference,this._options.dimensions.z*.5,this._scene.ellipsoid),attributes:a})};BoxGeometryUpdater.prototype.createOutlineGeometryInstance=function(e){if(Check.defined("time",e),!this._outlineEnabled)throw new DeveloperError("This instance does not represent an outlined geometry.");const t=this._entity,n=t.isAvailable(e),i=Property.getValueOrDefault(this._outlineColorProperty,e,Color.BLACK,scratchColor$g),r=this._distanceDisplayConditionProperty.getValue(e),o={show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._showOutlineProperty.getValue(e)),color:ColorGeometryInstanceAttribute.fromColor(i),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(r),offset:void 0};return defined(this._options.offsetAttribute)&&(o.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$a,offsetScratch$9))),new GeometryInstance({id:t,geometry:BoxOutlineGeometry.fromDimensions(this._options),modelMatrix:t.computeModelMatrixForHeightReference(e,t.box.heightReference,this._options.dimensions.z*.5,this._scene.ellipsoid),attributes:o})};BoxGeometryUpdater.prototype._computeCenter=function(e,t){return Property.getValueOrUndefined(this._entity.position,e,t)};BoxGeometryUpdater.prototype._isHidden=function(e,t){return!defined(t.dimensions)||!defined(e.position)||GeometryUpdater.prototype._isHidden.call(this,e,t)};BoxGeometryUpdater.prototype._isDynamic=function(e,t){return!e.position.isConstant||!Property.isConstant(e.orientation)||!t.dimensions.isConstant||!Property.isConstant(t.outlineWidth)};BoxGeometryUpdater.prototype._setStaticOptions=function(e,t){const n=Property.getValueOrDefault(t.heightReference,Iso8601.MINIMUM_VALUE,HeightReference.NONE),i=this._options;i.vertexFormat=this._materialProperty instanceof ColorMaterialProperty?PerInstanceColorAppearance.VERTEX_FORMAT:MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat,i.dimensions=t.dimensions.getValue(Iso8601.MINIMUM_VALUE,i.dimensions),i.offsetAttribute=n!==HeightReference.NONE?GeometryOffsetAttribute.ALL:void 0};BoxGeometryUpdater.prototype._onEntityPropertyChanged=heightReferenceOnEntityPropertyChanged;BoxGeometryUpdater.DynamicGeometryUpdater=DynamicBoxGeometryUpdater;function DynamicBoxGeometryUpdater(e,t,n){DynamicGeometryUpdater$1.call(this,e,t,n)}defined(Object.create)&&(DynamicBoxGeometryUpdater.prototype=Object.create(DynamicGeometryUpdater$1.prototype),DynamicBoxGeometryUpdater.prototype.constructor=DynamicBoxGeometryUpdater);DynamicBoxGeometryUpdater.prototype._isHidden=function(e,t,n){const i=Property.getValueOrUndefined(e.position,n,positionScratch$8),r=this._options.dimensions;return!defined(i)||!defined(r)||DynamicGeometryUpdater$1.prototype._isHidden.call(this,e,t,n)};DynamicBoxGeometryUpdater.prototype._setOptions=function(e,t,n){const i=Property.getValueOrDefault(t.heightReference,n,HeightReference.NONE),r=this._options;r.dimensions=Property.getValueOrUndefined(t.dimensions,n,r.dimensions),r.offsetAttribute=i!==HeightReference.NONE?GeometryOffsetAttribute.ALL:void 0};const modelMatrixScratch$1=new Matrix4;function Cesium3DTilesetVisualizer(e,t){if(!defined(e))throw new DeveloperError("scene is required.");if(!defined(t))throw new DeveloperError("entityCollection is required.");t.collectionChanged.addEventListener(Cesium3DTilesetVisualizer.prototype._onCollectionChanged,this),this._scene=e,this._primitives=e.primitives,this._entityCollection=t,this._tilesetHash={},this._entitiesToVisualize=new AssociativeArray,this._onCollectionChanged(t,t.values,[],[])}Cesium3DTilesetVisualizer.prototype.update=function(e){if(!defined(e))throw new DeveloperError("time is required.");const t=this._entitiesToVisualize.values,n=this._tilesetHash,i=this._primitives;for(let r=0,o=t.length;r<o;r++){const a=t[r],s=a._tileset;let l;const c=n[a.id],d=a.isShowing&&a.isAvailable(e)&&Property.getValueOrDefault(s._show,e,!0);let h;d&&(h=a.computeModelMatrix(e,modelMatrixScratch$1),l=Resource.createIfNeeded(Property.getValueOrUndefined(s._uri,e)));const f=defined(c)?c.tilesetPrimitive:void 0;if(!d){defined(f)&&(f.show=!1);continue}(!defined(c)||l.url!==c.url)&&(defined(f)&&i.removeAndDestroy(f),delete n[a.id],createTileset(l,n,a,i)),defined(f)&&(f.show=!0,defined(h)&&(f.modelMatrix=h),f.maximumScreenSpaceError=Property.getValueOrDefault(s.maximumScreenSpaceError,e,f.maximumScreenSpaceError))}return!0};Cesium3DTilesetVisualizer.prototype.isDestroyed=function(){return!1};Cesium3DTilesetVisualizer.prototype.destroy=function(){this._entityCollection.collectionChanged.removeEventListener(Cesium3DTilesetVisualizer.prototype._onCollectionChanged,this);const e=this._entitiesToVisualize.values,t=this._tilesetHash,n=this._primitives;for(let i=e.length-1;i>-1;i--)removeTileset(this,e[i],t,n);return destroyObject(this)};Cesium3DTilesetVisualizer.prototype.getBoundingSphere=function(e,t){if(!defined(e))throw new DeveloperError("entity is required.");if(!defined(t))throw new DeveloperError("result is required.");const n=this._tilesetHash[e.id];if(!defined(n)||n.loadFail)return BoundingSphereState$1.FAILED;const i=n.tilesetPrimitive;return defined(i)?i.show?(BoundingSphere.clone(i.boundingSphere,t),BoundingSphereState$1.DONE):BoundingSphereState$1.FAILED:BoundingSphereState$1.PENDING};Cesium3DTilesetVisualizer.prototype._onCollectionChanged=function(e,t,n,i){let r,o;const a=this._entitiesToVisualize,s=this._tilesetHash,l=this._primitives;for(r=t.length-1;r>-1;r--)o=t[r],defined(o._tileset)&&a.set(o.id,o);for(r=i.length-1;r>-1;r--)o=i[r],defined(o._tileset)?a.set(o.id,o):(removeTileset(this,o,s,l),a.remove(o.id));for(r=n.length-1;r>-1;r--)o=n[r],removeTileset(this,o,s,l),a.remove(o.id)};function removeTileset(e,t,n,i){const r=n[t.id];defined(r)&&(defined(r.tilesetPrimitive)&&i.removeAndDestroy(r.tilesetPrimitive),delete n[t.id])}async function createTileset(e,t,n,i){t[n.id]={url:e.url,loadFail:!1};try{const r=await Cesium3DTileset.fromUrl(e);if(r.id=n,i.add(r),!defined(t[n.id]))return;t[n.id].tilesetPrimitive=r}catch(r){console.error(r),t[n.id].loadFail=!0}}const defaultEvenColor$1=Color.WHITE,defaultOddColor$1=Color.BLACK,defaultRepeat$1=new Cartesian2(2,2);function CheckerboardMaterialProperty(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._definitionChanged=new Event,this._evenColor=void 0,this._evenColorSubscription=void 0,this._oddColor=void 0,this._oddColorSubscription=void 0,this._repeat=void 0,this._repeatSubscription=void 0,this.evenColor=e.evenColor,this.oddColor=e.oddColor,this.repeat=e.repeat}Object.defineProperties(CheckerboardMaterialProperty.prototype,{isConstant:{get:function(){return Property.isConstant(this._evenColor)&&Property.isConstant(this._oddColor)&&Property.isConstant(this._repeat)}},definitionChanged:{get:function(){return this._definitionChanged}},evenColor:createPropertyDescriptor("evenColor"),oddColor:createPropertyDescriptor("oddColor"),repeat:createPropertyDescriptor("repeat")});CheckerboardMaterialProperty.prototype.getType=function(e){return"Checkerboard"};CheckerboardMaterialProperty.prototype.getValue=function(e,t){return defined(t)||(t={}),t.lightColor=Property.getValueOrClonedDefault(this._evenColor,e,defaultEvenColor$1,t.lightColor),t.darkColor=Property.getValueOrClonedDefault(this._oddColor,e,defaultOddColor$1,t.darkColor),t.repeat=Property.getValueOrDefault(this._repeat,e,defaultRepeat$1),t};CheckerboardMaterialProperty.prototype.equals=function(e){return this===e||e instanceof CheckerboardMaterialProperty&&Property.equals(this._evenColor,e._evenColor)&&Property.equals(this._oddColor,e._oddColor)&&Property.equals(this._repeat,e._repeat)};const entityOptionsScratch={id:void 0},entityIdScratch=new Array(2);function clean(e){const t=e.propertyNames,n=t.length;for(let i=0;i<n;i++)e[t[i]]=void 0;e._name=void 0,e._availability=void 0}function subscribeToEntity(e,t,n,i){entityIdScratch[0]=n,entityIdScratch[1]=i.id,t[JSON.stringify(entityIdScratch)]=i.definitionChanged.addEventListener(CompositeEntityCollection.prototype._onDefinitionChanged,e)}function unsubscribeFromEntity(e,t,n,i){entityIdScratch[0]=n,entityIdScratch[1]=i.id;const r=JSON.stringify(entityIdScratch);t[r](),t[r]=void 0}function recomposite(e){if(e._shouldRecomposite=!0,e._suspendCount!==0)return;const t=e._collections,n=t.length,i=e._collectionsCopy,r=i.length;let o,a,s,l,c;const d=e._composite,h=new EntityCollection(e),f=e._eventHash;let p;for(o=0;o<r;o++)for(c=i[o],c.collectionChanged.removeEventListener(CompositeEntityCollection.prototype._onCollectionChanged,e),s=c.values,p=c.id,l=s.length-1;l>-1;l--)a=s[l],unsubscribeFromEntity(e,f,p,a);for(o=n-1;o>=0;o--)for(c=t[o],c.collectionChanged.addEventListener(CompositeEntityCollection.prototype._onCollectionChanged,e),s=c.values,p=c.id,l=s.length-1;l>-1;l--){a=s[l],subscribeToEntity(e,f,p,a);let m=h.getById(a.id);defined(m)||(m=d.getById(a.id),defined(m)?clean(m):(entityOptionsScratch.id=a.id,m=new Entity(entityOptionsScratch)),h.add(m)),m.merge(a)}e._collectionsCopy=t.slice(0),d.suspendEvents(),d.removeAll();const u=h.values;for(o=0;o<u.length;o++)d.add(u[o]);d.resumeEvents()}function CompositeEntityCollection(e,t){this._owner=t,this._composite=new EntityCollection(this),this._suspendCount=0,this._collections=defined(e)?e.slice():[],this._collectionsCopy=[],this._id=createGuid(),this._eventHash={},recomposite(this),this._shouldRecomposite=!1}Object.defineProperties(CompositeEntityCollection.prototype,{collectionChanged:{get:function(){return this._composite._collectionChanged}},id:{get:function(){return this._id}},values:{get:function(){return this._composite.values}},owner:{get:function(){return this._owner}}});CompositeEntityCollection.prototype.addCollection=function(e,t){const n=defined(t);if(!defined(e))throw new DeveloperError("collection is required.");if(n){if(t<0)throw new DeveloperError("index must be greater than or equal to zero.");if(t>this._collections.length)throw new DeveloperError("index must be less than or equal to the number of collections.")}n?this._collections.splice(t,0,e):(t=this._collections.length,this._collections.push(e)),recomposite(this)};CompositeEntityCollection.prototype.removeCollection=function(e){const t=this._collections.indexOf(e);return t!==-1?(this._collections.splice(t,1),recomposite(this),!0):!1};CompositeEntityCollection.prototype.removeAllCollections=function(){this._collections.length=0,recomposite(this)};CompositeEntityCollection.prototype.containsCollection=function(e){return this._collections.indexOf(e)!==-1};CompositeEntityCollection.prototype.contains=function(e){return this._composite.contains(e)};CompositeEntityCollection.prototype.indexOfCollection=function(e){return this._collections.indexOf(e)};CompositeEntityCollection.prototype.getCollection=function(e){if(!defined(e))throw new DeveloperError("index is required.");return this._collections[e]};CompositeEntityCollection.prototype.getCollectionsLength=function(){return this._collections.length};function getCollectionIndex(e,t){if(!defined(t))throw new DeveloperError("collection is required.");const n=e.indexOf(t);if(n===-1)throw new DeveloperError("collection is not in this composite.");return n}function swapCollections(e,t,n){const i=e._collections;if(t=CesiumMath.clamp(t,0,i.length-1),n=CesiumMath.clamp(n,0,i.length-1),t===n)return;const r=i[t];i[t]=i[n],i[n]=r,recomposite(e)}CompositeEntityCollection.prototype.raiseCollection=function(e){const t=getCollectionIndex(this._collections,e);swapCollections(this,t,t+1)};CompositeEntityCollection.prototype.lowerCollection=function(e){const t=getCollectionIndex(this._collections,e);swapCollections(this,t,t-1)};CompositeEntityCollection.prototype.raiseCollectionToTop=function(e){const t=getCollectionIndex(this._collections,e);t!==this._collections.length-1&&(this._collections.splice(t,1),this._collections.push(e),recomposite(this))};CompositeEntityCollection.prototype.lowerCollectionToBottom=function(e){const t=getCollectionIndex(this._collections,e);t!==0&&(this._collections.splice(t,1),this._collections.splice(0,0,e),recomposite(this))};CompositeEntityCollection.prototype.suspendEvents=function(){this._suspendCount++,this._composite.suspendEvents()};CompositeEntityCollection.prototype.resumeEvents=function(){if(this._suspendCount===0)throw new DeveloperError("resumeEvents can not be called before suspendEvents.");this._suspendCount--,this._shouldRecomposite&&this._suspendCount===0&&(recomposite(this),this._shouldRecomposite=!1),this._composite.resumeEvents()};CompositeEntityCollection.prototype.computeAvailability=function(){return this._composite.computeAvailability()};CompositeEntityCollection.prototype.getById=function(e){return this._composite.getById(e)};CompositeEntityCollection.prototype._onCollectionChanged=function(e,t,n){const i=this._collectionsCopy,r=i.length,o=this._composite;o.suspendEvents();let a,s,l,c;const d=n.length,h=this._eventHash,f=e.id;for(a=0;a<d;a++){const u=n[a];unsubscribeFromEntity(this,h,f,u);const m=u.id;for(s=r-1;s>=0;s--)l=i[s].getById(m),defined(l)&&(defined(c)||(c=o.getById(m),clean(c)),c.merge(l));defined(c)||o.removeById(m),c=void 0}const p=t.length;for(a=0;a<p;a++){const u=t[a];subscribeToEntity(this,h,f,u);const m=u.id;for(s=r-1;s>=0;s--)l=i[s].getById(m),defined(l)&&(defined(c)||(c=o.getById(m),defined(c)?clean(c):(entityOptionsScratch.id=m,c=new Entity(entityOptionsScratch),o.add(c))),c.merge(l));c=void 0}o.resumeEvents()};CompositeEntityCollection.prototype._onDefinitionChanged=function(e,t,n,i){const r=this._collections,o=this._composite,a=r.length,s=e.id,l=o.getById(s);let c=l[t];const d=!defined(c);let h=!0;for(let f=a-1;f>=0;f--){const p=r[f].getById(e.id);if(defined(p)){const u=p[t];if(defined(u)){if(h)if(h=!1,defined(u.merge)&&defined(u.clone))c=u.clone(c);else{c=u;break}c.merge(u)}}}d&&l.propertyNames.indexOf(t)===-1&&l.addProperty(t),l[t]=c};function CompositeMaterialProperty(){this._definitionChanged=new Event,this._composite=new CompositeProperty,this._composite.definitionChanged.addEventListener(CompositeMaterialProperty.prototype._raiseDefinitionChanged,this)}Object.defineProperties(CompositeMaterialProperty.prototype,{isConstant:{get:function(){return this._composite.isConstant}},definitionChanged:{get:function(){return this._definitionChanged}},intervals:{get:function(){return this._composite._intervals}}});CompositeMaterialProperty.prototype.getType=function(e){if(!defined(e))throw new DeveloperError("time is required");const t=this._composite._intervals.findDataForIntervalContainingDate(e);if(defined(t))return t.getType(e)};CompositeMaterialProperty.prototype.getValue=function(e,t){if(!defined(e))throw new DeveloperError("time is required");const n=this._composite._intervals.findDataForIntervalContainingDate(e);if(defined(n))return n.getValue(e,t)};CompositeMaterialProperty.prototype.equals=function(e){return this===e||e instanceof CompositeMaterialProperty&&this._composite.equals(e._composite,Property.equals)};CompositeMaterialProperty.prototype._raiseDefinitionChanged=function(){this._definitionChanged.raiseEvent(this)};const CornerType={ROUNDED:0,MITERED:1,BEVELED:2},CornerType$1=Object.freeze(CornerType),scratch2Array=[new Cartesian3,new Cartesian3],scratchCartesian1$6=new Cartesian3,scratchCartesian2$8=new Cartesian3,scratchCartesian3$7=new Cartesian3,scratchCartesian4$4=new Cartesian3,scratchCartesian5$1=new Cartesian3,scratchCartesian6=new Cartesian3,scratchCartesian7=new Cartesian3,scratchCartesian8=new Cartesian3,scratchCartesian9=new Cartesian3,scratch1$2=new Cartesian3,scratch2$2=new Cartesian3,PolylineVolumeGeometryLibrary={};let cartographic=new Cartographic;function scaleToSurface$2(e,t){const n=new Array(e.length);for(let i=0;i<e.length;i++){const r=e[i];cartographic=t.cartesianToCartographic(r,cartographic),n[i]=cartographic.height,e[i]=t.scaleToGeodeticSurface(r,r)}return n}function subdivideHeights(e,t,n,i){const r=e[0],o=e[1],a=Cartesian3.angleBetween(r,o),s=Math.ceil(a/i),l=new Array(s);let c;if(t===n){for(c=0;c<s;c++)l[c]=t;return l.push(n),l}const h=(n-t)/s;for(c=1;c<s;c++){const f=t+c*h;l[c]=f}return l[0]=t,l.push(n),l}const nextScratch=new Cartesian3,prevScratch=new Cartesian3;function computeRotationAngle(e,t,n,i){const r=new EllipsoidTangentPlane(n,i),o=r.projectPointOntoPlane(Cartesian3.add(n,e,nextScratch),nextScratch),a=r.projectPointOntoPlane(Cartesian3.add(n,t,prevScratch),prevScratch),s=Cartesian2.angleBetween(o,a);return a.x*o.y-a.y*o.x>=0?-s:s}const negativeX=new Cartesian3(-1,0,0);let transform$2=new Matrix4;const translation$1=new Matrix4;let rotationZ=new Matrix3;const scaleMatrix=Matrix3.IDENTITY.clone(),westScratch$1=new Cartesian3,finalPosScratch=new Cartesian4,heightCartesian=new Cartesian3;function addPosition(e,t,n,i,r,o,a,s){let l=westScratch$1,c=finalPosScratch;transform$2=Transforms.eastNorthUpToFixedFrame(e,r,transform$2),l=Matrix4.multiplyByPointAsVector(transform$2,negativeX,l),l=Cartesian3.normalize(l,l);const d=computeRotationAngle(l,t,e,r);rotationZ=Matrix3.fromRotationZ(d,rotationZ),heightCartesian.z=o,transform$2=Matrix4.multiplyTransformation(transform$2,Matrix4.fromRotationTranslation(rotationZ,heightCartesian,translation$1),transform$2);const h=scaleMatrix;h[0]=a;for(let f=0;f<s;f++)for(let p=0;p<n.length;p+=3)c=Cartesian3.fromArray(n,p,c),c=Matrix3.multiplyByVector(h,c,c),c=Matrix4.multiplyByPoint(transform$2,c,c),i.push(c.x,c.y,c.z);return i}const centerScratch$4=new Cartesian3;function addPositions(e,t,n,i,r,o,a){for(let s=0;s<e.length;s+=3){const l=Cartesian3.fromArray(e,s,centerScratch$4);i=addPosition(l,t,n,i,r,o[s/3],a,1)}return i}function convertShapeTo3DDuplicate(e,t){const n=e.length,i=new Array(n*6);let r=0;const o=t.x+t.width/2,a=t.y+t.height/2;let s=e[0];i[r++]=s.x-o,i[r++]=0,i[r++]=s.y-a;for(let l=1;l<n;l++){s=e[l];const c=s.x-o,d=s.y-a;i[r++]=c,i[r++]=0,i[r++]=d,i[r++]=c,i[r++]=0,i[r++]=d}return s=e[0],i[r++]=s.x-o,i[r++]=0,i[r++]=s.y-a,i}function convertShapeTo3D(e,t){const n=e.length,i=new Array(n*3);let r=0;const o=t.x+t.width/2,a=t.y+t.height/2;for(let s=0;s<n;s++)i[r++]=e[s].x-o,i[r++]=0,i[r++]=e[s].y-a;return i}const quaterion$1=new Quaternion,startPointScratch=new Cartesian3,rotMatrix$1=new Matrix3;function computeRoundCorner$1(e,t,n,i,r,o,a,s,l,c){const d=Cartesian3.angleBetween(Cartesian3.subtract(t,e,scratch1$2),Cartesian3.subtract(n,e,scratch2$2)),h=i===CornerType$1.BEVELED?0:Math.ceil(d/CesiumMath.toRadians(5));let f;r?f=Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(e,scratch1$2),d/(h+1),quaterion$1),rotMatrix$1):f=Matrix3.fromQuaternion(Quaternion.fromAxisAngle(e,d/(h+1),quaterion$1),rotMatrix$1);let p,u;if(t=Cartesian3.clone(t,startPointScratch),h>0){const m=c?2:1;for(let g=0;g<h;g++)t=Matrix3.multiplyByVector(f,t,t),p=Cartesian3.subtract(t,e,scratch1$2),p=Cartesian3.normalize(p,p),r||(p=Cartesian3.negate(p,p)),u=o.scaleToGeodeticSurface(t,scratch2$2),a=addPosition(u,p,s,a,o,l,1,m)}else p=Cartesian3.subtract(t,e,scratch1$2),p=Cartesian3.normalize(p,p),r||(p=Cartesian3.negate(p,p)),u=o.scaleToGeodeticSurface(t,scratch2$2),a=addPosition(u,p,s,a,o,l,1,1),n=Cartesian3.clone(n,startPointScratch),p=Cartesian3.subtract(n,e,scratch1$2),p=Cartesian3.normalize(p,p),r||(p=Cartesian3.negate(p,p)),u=o.scaleToGeodeticSurface(n,scratch2$2),a=addPosition(u,p,s,a,o,l,1,1);return a}PolylineVolumeGeometryLibrary.removeDuplicatesFromShape=function(e){const t=e.length,n=[];for(let i=t-1,r=0;r<t;i=r++){const o=e[i],a=e[r];Cartesian2.equals(o,a)||n.push(a)}return n};PolylineVolumeGeometryLibrary.angleIsGreaterThanPi=function(e,t,n,i){const r=new EllipsoidTangentPlane(n,i),o=r.projectPointOntoPlane(Cartesian3.add(n,e,nextScratch),nextScratch),a=r.projectPointOntoPlane(Cartesian3.add(n,t,prevScratch),prevScratch);return a.x*o.y-a.y*o.x>=0};const scratchForwardProjection$1=new Cartesian3,scratchBackwardProjection$1=new Cartesian3;PolylineVolumeGeometryLibrary.computePositions=function(e,t,n,i,r){const o=i._ellipsoid,a=scaleToSurface$2(e,o),s=i._granularity,l=i._cornerType,c=r?convertShapeTo3DDuplicate(t,n):convertShapeTo3D(t,n),d=r?convertShapeTo3D(t,n):void 0,h=n.height/2,f=n.width/2;let p=e.length,u=[],m=r?[]:void 0,g=scratchCartesian1$6,_=scratchCartesian2$8,C=scratchCartesian3$7,A=scratchCartesian4$4,S=scratchCartesian5$1,v=scratchCartesian6,b=scratchCartesian7,D=scratchCartesian8,I=scratchCartesian9,L=e[0],N=e[1];A=o.geodeticSurfaceNormal(L,A),g=Cartesian3.subtract(N,L,g),g=Cartesian3.normalize(g,g),D=Cartesian3.cross(A,g,D),D=Cartesian3.normalize(D,D);let y=a[0],x=a[1];r&&(m=addPosition(L,D,d,m,o,y+h,1,1)),I=Cartesian3.clone(L,I),L=N,_=Cartesian3.negate(g,_);let T,E;for(let O=1;O<p-1;O++){const V=r?2:1;if(N=e[O+1],L.equals(N)){oneTimeWarning("Positions are too close and are considered equivalent with rounding error.");continue}g=Cartesian3.subtract(N,L,g),g=Cartesian3.normalize(g,g),C=Cartesian3.add(g,_,C),C=Cartesian3.normalize(C,C),A=o.geodeticSurfaceNormal(L,A);const R=Cartesian3.multiplyByScalar(A,Cartesian3.dot(g,A),scratchForwardProjection$1);Cartesian3.subtract(g,R,R),Cartesian3.normalize(R,R);const w=Cartesian3.multiplyByScalar(A,Cartesian3.dot(_,A),scratchBackwardProjection$1);if(Cartesian3.subtract(_,w,w),Cartesian3.normalize(w,w),!CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(R,w)),1,CesiumMath.EPSILON7)){C=Cartesian3.cross(C,A,C),C=Cartesian3.cross(A,C,C),C=Cartesian3.normalize(C,C);const k=1/Math.max(.25,Cartesian3.magnitude(Cartesian3.cross(C,_,scratch1$2))),H=PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(g,_,L,o);H?(S=Cartesian3.add(L,Cartesian3.multiplyByScalar(C,k*f,C),S),v=Cartesian3.add(S,Cartesian3.multiplyByScalar(D,f,v),v),scratch2Array[0]=Cartesian3.clone(I,scratch2Array[0]),scratch2Array[1]=Cartesian3.clone(v,scratch2Array[1]),T=subdivideHeights(scratch2Array,y+h,x+h,s),E=PolylinePipeline.generateArc({positions:scratch2Array,granularity:s,ellipsoid:o}),u=addPositions(E,D,c,u,o,T,1),D=Cartesian3.cross(A,g,D),D=Cartesian3.normalize(D,D),b=Cartesian3.add(S,Cartesian3.multiplyByScalar(D,f,b),b),l===CornerType$1.ROUNDED||l===CornerType$1.BEVELED?computeRoundCorner$1(S,v,b,l,H,o,u,c,x+h,r):(C=Cartesian3.negate(C,C),u=addPosition(L,C,c,u,o,x+h,k,V)),I=Cartesian3.clone(b,I)):(S=Cartesian3.add(L,Cartesian3.multiplyByScalar(C,k*f,C),S),v=Cartesian3.add(S,Cartesian3.multiplyByScalar(D,-f,v),v),scratch2Array[0]=Cartesian3.clone(I,scratch2Array[0]),scratch2Array[1]=Cartesian3.clone(v,scratch2Array[1]),T=subdivideHeights(scratch2Array,y+h,x+h,s),E=PolylinePipeline.generateArc({positions:scratch2Array,granularity:s,ellipsoid:o}),u=addPositions(E,D,c,u,o,T,1),D=Cartesian3.cross(A,g,D),D=Cartesian3.normalize(D,D),b=Cartesian3.add(S,Cartesian3.multiplyByScalar(D,-f,b),b),l===CornerType$1.ROUNDED||l===CornerType$1.BEVELED?computeRoundCorner$1(S,v,b,l,H,o,u,c,x+h,r):u=addPosition(L,C,c,u,o,x+h,k,V),I=Cartesian3.clone(b,I)),_=Cartesian3.negate(g,_)}else u=addPosition(I,D,c,u,o,y+h,1,1),I=L;y=x,x=a[O+1],L=N}scratch2Array[0]=Cartesian3.clone(I,scratch2Array[0]),scratch2Array[1]=Cartesian3.clone(L,scratch2Array[1]),T=subdivideHeights(scratch2Array,y+h,x+h,s),E=PolylinePipeline.generateArc({positions:scratch2Array,granularity:s,ellipsoid:o}),u=addPositions(E,D,c,u,o,T,1),r&&(m=addPosition(L,D,d,m,o,x+h,1,1)),p=u.length;const P=r?p+m.length:p,M=new Float64Array(P);return M.set(u),r&&M.set(m,p),M};const PolylineVolumeGeometryLibrary$1=PolylineVolumeGeometryLibrary,CorridorGeometryLibrary={},scratch1$1=new Cartesian3,scratch2$1=new Cartesian3,scratch3=new Cartesian3,scratch4=new Cartesian3,scaleArray2=[new Cartesian3,new Cartesian3],cartesian1$2=new Cartesian3,cartesian2$2=new Cartesian3,cartesian3$2=new Cartesian3,cartesian4$1=new Cartesian3,cartesian5$1=new Cartesian3,cartesian6$1=new Cartesian3,cartesian7=new Cartesian3,cartesian8=new Cartesian3,cartesian9=new Cartesian3,cartesian10=new Cartesian3,quaterion=new Quaternion,rotMatrix=new Matrix3;function computeRoundCorner(e,t,n,i,r){const o=Cartesian3.angleBetween(Cartesian3.subtract(t,e,scratch1$1),Cartesian3.subtract(n,e,scratch2$1)),a=i===CornerType$1.BEVELED?1:Math.ceil(o/CesiumMath.toRadians(5))+1,s=a*3,l=new Array(s);l[s-3]=n.x,l[s-2]=n.y,l[s-1]=n.z;let c;r?c=Matrix3.fromQuaternion(Quaternion.fromAxisAngle(Cartesian3.negate(e,scratch1$1),o/a,quaterion),rotMatrix):c=Matrix3.fromQuaternion(Quaternion.fromAxisAngle(e,o/a,quaterion),rotMatrix);let d=0;t=Cartesian3.clone(t,scratch1$1);for(let h=0;h<a;h++)t=Matrix3.multiplyByVector(c,t,t),l[d++]=t.x,l[d++]=t.y,l[d++]=t.z;return l}function addEndCaps(e){let t=cartesian1$2,n=cartesian2$2,i=cartesian3$2,r=e[1];n=Cartesian3.fromArray(e[1],r.length-3,n),i=Cartesian3.fromArray(e[0],0,i),t=Cartesian3.midpoint(n,i,t);const o=computeRoundCorner(t,n,i,CornerType$1.ROUNDED,!1),a=e.length-1,s=e[a-1];r=e[a],n=Cartesian3.fromArray(s,s.length-3,n),i=Cartesian3.fromArray(r,0,i),t=Cartesian3.midpoint(n,i,t);const l=computeRoundCorner(t,n,i,CornerType$1.ROUNDED,!1);return[o,l]}function computeMiteredCorner(e,t,n,i){let r=scratch1$1;return i?r=Cartesian3.add(e,t,r):(t=Cartesian3.negate(t,t),r=Cartesian3.add(e,t,r)),[r.x,r.y,r.z,n.x,n.y,n.z]}function addShiftedPositions(e,t,n,i){const r=new Array(e.length),o=new Array(e.length),a=Cartesian3.multiplyByScalar(t,n,scratch1$1),s=Cartesian3.negate(a,scratch2$1);let l=0,c=e.length-1;for(let d=0;d<e.length;d+=3){const h=Cartesian3.fromArray(e,d,scratch3),f=Cartesian3.add(h,s,scratch4);r[l++]=f.x,r[l++]=f.y,r[l++]=f.z;const p=Cartesian3.add(h,a,scratch4);o[c--]=p.z,o[c--]=p.y,o[c--]=p.x}return i.push(r,o),i}CorridorGeometryLibrary.addAttribute=function(e,t,n,i){const r=t.x,o=t.y,a=t.z;defined(n)&&(e[n]=r,e[n+1]=o,e[n+2]=a),defined(i)&&(e[i]=a,e[i-1]=o,e[i-2]=r)};const scratchForwardProjection=new Cartesian3,scratchBackwardProjection=new Cartesian3;CorridorGeometryLibrary.computePositions=function(e){const t=e.granularity,n=e.positions,i=e.ellipsoid,r=e.width/2,o=e.cornerType,a=e.saveAttributes;let s=cartesian1$2,l=cartesian2$2,c=cartesian3$2,d=cartesian4$1,h=cartesian5$1,f=cartesian6$1,p=cartesian7,u=cartesian8,m=cartesian9,g=cartesian10,_=[];const C=a?[]:void 0,A=a?[]:void 0;let S=n[0],v=n[1];l=Cartesian3.normalize(Cartesian3.subtract(v,S,l),l),s=i.geodeticSurfaceNormal(S,s),d=Cartesian3.normalize(Cartesian3.cross(s,l,d),d),a&&(C.push(d.x,d.y,d.z),A.push(s.x,s.y,s.z)),p=Cartesian3.clone(S,p),S=v,c=Cartesian3.negate(l,c);let b;const D=[];let I;const L=n.length;for(I=1;I<L-1;I++){s=i.geodeticSurfaceNormal(S,s),v=n[I+1],l=Cartesian3.normalize(Cartesian3.subtract(v,S,l),l),h=Cartesian3.normalize(Cartesian3.add(l,c,h),h);const y=Cartesian3.multiplyByScalar(s,Cartesian3.dot(l,s),scratchForwardProjection);Cartesian3.subtract(l,y,y),Cartesian3.normalize(y,y);const x=Cartesian3.multiplyByScalar(s,Cartesian3.dot(c,s),scratchBackwardProjection);if(Cartesian3.subtract(c,x,x),Cartesian3.normalize(x,x),!CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(y,x)),1,CesiumMath.EPSILON7)){h=Cartesian3.cross(h,s,h),h=Cartesian3.cross(s,h,h),h=Cartesian3.normalize(h,h);const E=r/Math.max(.25,Cartesian3.magnitude(Cartesian3.cross(h,c,scratch1$1))),P=PolylineVolumeGeometryLibrary$1.angleIsGreaterThanPi(l,c,S,i);h=Cartesian3.multiplyByScalar(h,E,h),P?(u=Cartesian3.add(S,h,u),g=Cartesian3.add(u,Cartesian3.multiplyByScalar(d,r,g),g),m=Cartesian3.add(u,Cartesian3.multiplyByScalar(d,r*2,m),m),scaleArray2[0]=Cartesian3.clone(p,scaleArray2[0]),scaleArray2[1]=Cartesian3.clone(g,scaleArray2[1]),b=PolylinePipeline.generateArc({positions:scaleArray2,granularity:t,ellipsoid:i}),_=addShiftedPositions(b,d,r,_),a&&(C.push(d.x,d.y,d.z),A.push(s.x,s.y,s.z)),f=Cartesian3.clone(m,f),d=Cartesian3.normalize(Cartesian3.cross(s,l,d),d),m=Cartesian3.add(u,Cartesian3.multiplyByScalar(d,r*2,m),m),p=Cartesian3.add(u,Cartesian3.multiplyByScalar(d,r,p),p),o===CornerType$1.ROUNDED||o===CornerType$1.BEVELED?D.push({leftPositions:computeRoundCorner(u,f,m,o,P)}):D.push({leftPositions:computeMiteredCorner(S,Cartesian3.negate(h,h),m,P)})):(m=Cartesian3.add(S,h,m),g=Cartesian3.add(m,Cartesian3.negate(Cartesian3.multiplyByScalar(d,r,g),g),g),u=Cartesian3.add(m,Cartesian3.negate(Cartesian3.multiplyByScalar(d,r*2,u),u),u),scaleArray2[0]=Cartesian3.clone(p,scaleArray2[0]),scaleArray2[1]=Cartesian3.clone(g,scaleArray2[1]),b=PolylinePipeline.generateArc({positions:scaleArray2,granularity:t,ellipsoid:i}),_=addShiftedPositions(b,d,r,_),a&&(C.push(d.x,d.y,d.z),A.push(s.x,s.y,s.z)),f=Cartesian3.clone(u,f),d=Cartesian3.normalize(Cartesian3.cross(s,l,d),d),u=Cartesian3.add(m,Cartesian3.negate(Cartesian3.multiplyByScalar(d,r*2,u),u),u),p=Cartesian3.add(m,Cartesian3.negate(Cartesian3.multiplyByScalar(d,r,p),p),p),o===CornerType$1.ROUNDED||o===CornerType$1.BEVELED?D.push({rightPositions:computeRoundCorner(m,f,u,o,P)}):D.push({rightPositions:computeMiteredCorner(S,h,u,P)})),c=Cartesian3.negate(l,c)}S=v}s=i.geodeticSurfaceNormal(S,s),scaleArray2[0]=Cartesian3.clone(p,scaleArray2[0]),scaleArray2[1]=Cartesian3.clone(S,scaleArray2[1]),b=PolylinePipeline.generateArc({positions:scaleArray2,granularity:t,ellipsoid:i}),_=addShiftedPositions(b,d,r,_),a&&(C.push(d.x,d.y,d.z),A.push(s.x,s.y,s.z));let N;return o===CornerType$1.ROUNDED&&(N=addEndCaps(_)),{positions:_,corners:D,lefts:C,normals:A,endPositions:N}};const CorridorGeometryLibrary$1=CorridorGeometryLibrary,cartesian1$1=new Cartesian3,cartesian2$1=new Cartesian3,cartesian3$1=new Cartesian3,cartesian4=new Cartesian3,cartesian5=new Cartesian3,cartesian6=new Cartesian3,scratch1=new Cartesian3,scratch2=new Cartesian3;function scaleToSurface$1(e,t){for(let n=0;n<e.length;n++)e[n]=t.scaleToGeodeticSurface(e[n],e[n]);return e}function addNormals(e,t,n,i,r,o){const a=e.normals,s=e.tangents,l=e.bitangents,c=Cartesian3.normalize(Cartesian3.cross(n,t,scratch1),scratch1);o.normal&&CorridorGeometryLibrary$1.addAttribute(a,t,i,r),o.tangent&&CorridorGeometryLibrary$1.addAttribute(s,c,i,r),o.bitangent&&CorridorGeometryLibrary$1.addAttribute(l,n,i,r)}function combine$1(e,t,n){const i=e.positions,r=e.corners,o=e.endPositions,a=e.lefts,s=e.normals,l=new GeometryAttributes;let c,d=0,h=0,f,p=0,u;for(f=0;f<i.length;f+=2)u=i[f].length-3,d+=u,p+=u*2,h+=i[f+1].length-3;for(d+=3,h+=3,f=0;f<r.length;f++){c=r[f];const B=r[f].leftPositions;defined(B)?(u=B.length,d+=u,p+=u):(u=r[f].rightPositions.length,h+=u,p+=u)}const m=defined(o);let g;m&&(g=o[0].length-3,d+=g,h+=g,g/=3,p+=g*6);const _=d+h,C=new Float64Array(_),A=t.normal?new Float32Array(_):void 0,S=t.tangent?new Float32Array(_):void 0,v=t.bitangent?new Float32Array(_):void 0,b={normals:A,tangents:S,bitangents:v};let D=0,I=_-1,L,N,y,x,T=cartesian1$1,E=cartesian2$1,P,M;const O=g/2,V=IndexDatatype.createTypedArray(_/3,p);let R=0;if(m){M=cartesian3$1,P=cartesian4;const B=o[0];for(T=Cartesian3.fromArray(s,0,T),E=Cartesian3.fromArray(a,0,E),f=0;f<O;f++)M=Cartesian3.fromArray(B,(O-1-f)*3,M),P=Cartesian3.fromArray(B,(O+f)*3,P),CorridorGeometryLibrary$1.addAttribute(C,P,D),CorridorGeometryLibrary$1.addAttribute(C,M,void 0,I),addNormals(b,T,E,D,I,t),N=D/3,x=N+1,L=(I-2)/3,y=L-1,V[R++]=L,V[R++]=N,V[R++]=y,V[R++]=y,V[R++]=N,V[R++]=x,D+=3,I-=3}let w=0,U=0,k=i[w++],H=i[w++];C.set(k,D),C.set(H,I-H.length+1),E=Cartesian3.fromArray(a,U,E);let F,G;for(u=H.length-3,f=0;f<u;f+=3)F=n.geodeticSurfaceNormal(Cartesian3.fromArray(k,f,scratch1),scratch1),G=n.geodeticSurfaceNormal(Cartesian3.fromArray(H,u-f,scratch2),scratch2),T=Cartesian3.normalize(Cartesian3.add(F,G,T),T),addNormals(b,T,E,D,I,t),N=D/3,x=N+1,L=(I-2)/3,y=L-1,V[R++]=L,V[R++]=N,V[R++]=y,V[R++]=y,V[R++]=N,V[R++]=x,D+=3,I-=3;for(F=n.geodeticSurfaceNormal(Cartesian3.fromArray(k,u,scratch1),scratch1),G=n.geodeticSurfaceNormal(Cartesian3.fromArray(H,u,scratch2),scratch2),T=Cartesian3.normalize(Cartesian3.add(F,G,T),T),U+=3,f=0;f<r.length;f++){let B;c=r[f];const W=c.leftPositions,Y=c.rightPositions;let z,X,q=cartesian6,Q=cartesian3$1,Z=cartesian4;if(T=Cartesian3.fromArray(s,U,T),defined(W)){for(addNormals(b,T,E,void 0,I,t),I-=3,z=x,X=y,B=0;B<W.length/3;B++)q=Cartesian3.fromArray(W,B*3,q),V[R++]=z,V[R++]=X-B-1,V[R++]=X-B,CorridorGeometryLibrary$1.addAttribute(C,q,void 0,I),Q=Cartesian3.fromArray(C,(X-B-1)*3,Q),Z=Cartesian3.fromArray(C,z*3,Z),E=Cartesian3.normalize(Cartesian3.subtract(Q,Z,E),E),addNormals(b,T,E,void 0,I,t),I-=3;q=Cartesian3.fromArray(C,z*3,q),Q=Cartesian3.subtract(Cartesian3.fromArray(C,X*3,Q),q,Q),Z=Cartesian3.subtract(Cartesian3.fromArray(C,(X-B)*3,Z),q,Z),E=Cartesian3.normalize(Cartesian3.add(Q,Z,E),E),addNormals(b,T,E,D,void 0,t),D+=3}else{for(addNormals(b,T,E,D,void 0,t),D+=3,z=y,X=x,B=0;B<Y.length/3;B++)q=Cartesian3.fromArray(Y,B*3,q),V[R++]=z,V[R++]=X+B,V[R++]=X+B+1,CorridorGeometryLibrary$1.addAttribute(C,q,D),Q=Cartesian3.fromArray(C,z*3,Q),Z=Cartesian3.fromArray(C,(X+B)*3,Z),E=Cartesian3.normalize(Cartesian3.subtract(Q,Z,E),E),addNormals(b,T,E,D,void 0,t),D+=3;q=Cartesian3.fromArray(C,z*3,q),Q=Cartesian3.subtract(Cartesian3.fromArray(C,(X+B)*3,Q),q,Q),Z=Cartesian3.subtract(Cartesian3.fromArray(C,X*3,Z),q,Z),E=Cartesian3.normalize(Cartesian3.negate(Cartesian3.add(Z,Q,E),E),E),addNormals(b,T,E,void 0,I,t),I-=3}for(k=i[w++],H=i[w++],k.splice(0,3),H.splice(H.length-3,3),C.set(k,D),C.set(H,I-H.length+1),u=H.length-3,U+=3,E=Cartesian3.fromArray(a,U,E),B=0;B<H.length;B+=3)F=n.geodeticSurfaceNormal(Cartesian3.fromArray(k,B,scratch1),scratch1),G=n.geodeticSurfaceNormal(Cartesian3.fromArray(H,u-B,scratch2),scratch2),T=Cartesian3.normalize(Cartesian3.add(F,G,T),T),addNormals(b,T,E,D,I,t),x=D/3,N=x-1,y=(I-2)/3,L=y+1,V[R++]=L,V[R++]=N,V[R++]=y,V[R++]=y,V[R++]=N,V[R++]=x,D+=3,I-=3;D-=3,I+=3}if(T=Cartesian3.fromArray(s,s.length-3,T),addNormals(b,T,E,D,I,t),m){D+=3,I-=3,M=cartesian3$1,P=cartesian4;const B=o[1];for(f=0;f<O;f++)M=Cartesian3.fromArray(B,(g-f-1)*3,M),P=Cartesian3.fromArray(B,f*3,P),CorridorGeometryLibrary$1.addAttribute(C,M,void 0,I),CorridorGeometryLibrary$1.addAttribute(C,P,D),addNormals(b,T,E,D,I,t),x=D/3,N=x-1,y=(I-2)/3,L=y+1,V[R++]=L,V[R++]=N,V[R++]=y,V[R++]=y,V[R++]=N,V[R++]=x,D+=3,I-=3}if(l.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:C}),t.st){const B=new Float32Array(_/3*2);let W,Y,z=0;if(m){d/=3,h/=3;const X=Math.PI/(g+1);Y=1/(d-g+1),W=1/(h-g+1);let q;const Q=g/2;for(f=Q+1;f<g+1;f++)q=CesiumMath.PI_OVER_TWO+X*f,B[z++]=W*(1+Math.cos(q)),B[z++]=.5*(1+Math.sin(q));for(f=1;f<h-g+1;f++)B[z++]=f*W,B[z++]=0;for(f=g;f>Q;f--)q=CesiumMath.PI_OVER_TWO-f*X,B[z++]=1-W*(1+Math.cos(q)),B[z++]=.5*(1+Math.sin(q));for(f=Q;f>0;f--)q=CesiumMath.PI_OVER_TWO-X*f,B[z++]=1-Y*(1+Math.cos(q)),B[z++]=.5*(1+Math.sin(q));for(f=d-g;f>0;f--)B[z++]=f*Y,B[z++]=1;for(f=1;f<Q+1;f++)q=CesiumMath.PI_OVER_TWO+X*f,B[z++]=Y*(1+Math.cos(q)),B[z++]=.5*(1+Math.sin(q))}else{for(d/=3,h/=3,Y=1/(d-1),W=1/(h-1),f=0;f<h;f++)B[z++]=f*W,B[z++]=0;for(f=d;f>0;f--)B[z++]=(f-1)*Y,B[z++]=1}l.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:B})}return t.normal&&(l.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:b.normals})),t.tangent&&(l.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:b.tangents})),t.bitangent&&(l.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:b.bitangents})),{attributes:l,indices:V}}function extrudedAttributes(e,t){if(!t.normal&&!t.tangent&&!t.bitangent&&!t.st)return e;const n=e.position.values;let i,r;(t.normal||t.bitangent)&&(i=e.normal.values,r=e.bitangent.values);const o=e.position.values.length/18,a=o*3,s=o*2,l=a*2;let c;if(t.normal||t.bitangent||t.tangent){const d=t.normal?new Float32Array(a*6):void 0,h=t.tangent?new Float32Array(a*6):void 0,f=t.bitangent?new Float32Array(a*6):void 0;let p=cartesian1$1,u=cartesian2$1,m=cartesian3$1,g=cartesian4,_=cartesian5,C=cartesian6,A=l;for(c=0;c<a;c+=3){const S=A+l;p=Cartesian3.fromArray(n,c,p),u=Cartesian3.fromArray(n,c+a,u),m=Cartesian3.fromArray(n,(c+3)%a,m),u=Cartesian3.subtract(u,p,u),m=Cartesian3.subtract(m,p,m),g=Cartesian3.normalize(Cartesian3.cross(u,m,g),g),t.normal&&(CorridorGeometryLibrary$1.addAttribute(d,g,S),CorridorGeometryLibrary$1.addAttribute(d,g,S+3),CorridorGeometryLibrary$1.addAttribute(d,g,A),CorridorGeometryLibrary$1.addAttribute(d,g,A+3)),(t.tangent||t.bitangent)&&(C=Cartesian3.fromArray(i,c,C),t.bitangent&&(CorridorGeometryLibrary$1.addAttribute(f,C,S),CorridorGeometryLibrary$1.addAttribute(f,C,S+3),CorridorGeometryLibrary$1.addAttribute(f,C,A),CorridorGeometryLibrary$1.addAttribute(f,C,A+3)),t.tangent&&(_=Cartesian3.normalize(Cartesian3.cross(C,g,_),_),CorridorGeometryLibrary$1.addAttribute(h,_,S),CorridorGeometryLibrary$1.addAttribute(h,_,S+3),CorridorGeometryLibrary$1.addAttribute(h,_,A),CorridorGeometryLibrary$1.addAttribute(h,_,A+3))),A+=6}if(t.normal){for(d.set(i),c=0;c<a;c+=3)d[c+a]=-i[c],d[c+a+1]=-i[c+1],d[c+a+2]=-i[c+2];e.normal.values=d}else e.normal=void 0;if(t.bitangent?(f.set(r),f.set(r,a),e.bitangent.values=f):e.bitangent=void 0,t.tangent){const S=e.tangent.values;h.set(S),h.set(S,a),e.tangent.values=h}}if(t.st){const d=e.st.values,h=new Float32Array(s*6);h.set(d),h.set(d,s);let f=s*2;for(let p=0;p<2;p++){for(h[f++]=d[0],h[f++]=d[1],c=2;c<s;c+=2){const u=d[c],m=d[c+1];h[f++]=u,h[f++]=m,h[f++]=u,h[f++]=m}h[f++]=d[0],h[f++]=d[1]}e.st.values=h}return e}function addWallPositions$1(e,t,n){n[t++]=e[0],n[t++]=e[1],n[t++]=e[2];for(let i=3;i<e.length;i+=3){const r=e[i],o=e[i+1],a=e[i+2];n[t++]=r,n[t++]=o,n[t++]=a,n[t++]=r,n[t++]=o,n[t++]=a}return n[t++]=e[0],n[t++]=e[1],n[t++]=e[2],n}function computePositionsExtruded$1(e,t){const n=new VertexFormat({position:t.position,normal:t.normal||t.bitangent||e.shadowVolume,tangent:t.tangent,bitangent:t.normal||t.bitangent,st:t.st}),i=e.ellipsoid,r=CorridorGeometryLibrary$1.computePositions(e),o=combine$1(r,n,i),a=e.height,s=e.extrudedHeight;let l=o.attributes;const c=o.indices;let d=l.position.values,h=d.length;const f=new Float64Array(h*6);let p=new Float64Array(h);p.set(d);let u=new Float64Array(h*4);d=PolygonPipeline.scaleToGeodeticHeight(d,a,i),u=addWallPositions$1(d,0,u),p=PolygonPipeline.scaleToGeodeticHeight(p,s,i),u=addWallPositions$1(p,h*2,u),f.set(d),f.set(p,h),f.set(u,h*2),l.position.values=f,l=extrudedAttributes(l,t);let m;const g=h/3;if(e.shadowVolume){const L=l.normal.values;h=L.length;let N=new Float32Array(h*6);for(m=0;m<h;m++)L[m]=-L[m];N.set(L,h),N=addWallPositions$1(L,h*4,N),l.extrudeDirection=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:N}),t.normal||(l.normal=void 0)}if(defined(e.offsetAttribute)){let L=new Uint8Array(g*6);if(e.offsetAttribute===GeometryOffsetAttribute.TOP)L=L.fill(1,0,g).fill(1,g*2,g*4);else{const N=e.offsetAttribute===GeometryOffsetAttribute.NONE?0:1;L=L.fill(N)}l.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:L})}const _=c.length,C=g+g,A=IndexDatatype.createTypedArray(f.length/3,_*2+C*3);A.set(c);let S=_;for(m=0;m<_;m+=3){const L=c[m],N=c[m+1],y=c[m+2];A[S++]=y+g,A[S++]=N+g,A[S++]=L+g}let v,b,D,I;for(m=0;m<C;m+=2)v=m+C,b=v+C,D=v+1,I=b+1,A[S++]=v,A[S++]=b,A[S++]=D,A[S++]=D,A[S++]=b,A[S++]=I;return{attributes:l,indices:A}}const scratchCartesian1$5=new Cartesian3,scratchCartesian2$7=new Cartesian3,scratchCartographic$a=new Cartographic;function computeOffsetPoints(e,t,n,i,r,o){const a=Cartesian3.subtract(t,e,scratchCartesian1$5);Cartesian3.normalize(a,a);const s=n.geodeticSurfaceNormal(e,scratchCartesian2$7),l=Cartesian3.cross(a,s,scratchCartesian1$5);Cartesian3.multiplyByScalar(l,i,l);let c=r.latitude,d=r.longitude,h=o.latitude,f=o.longitude;Cartesian3.add(e,l,scratchCartesian2$7),n.cartesianToCartographic(scratchCartesian2$7,scratchCartographic$a);let p=scratchCartographic$a.latitude,u=scratchCartographic$a.longitude;c=Math.min(c,p),d=Math.min(d,u),h=Math.max(h,p),f=Math.max(f,u),Cartesian3.subtract(e,l,scratchCartesian2$7),n.cartesianToCartographic(scratchCartesian2$7,scratchCartographic$a),p=scratchCartographic$a.latitude,u=scratchCartographic$a.longitude,c=Math.min(c,p),d=Math.min(d,u),h=Math.max(h,p),f=Math.max(f,u),r.latitude=c,r.longitude=d,o.latitude=h,o.longitude=f}const scratchCartesianOffset=new Cartesian3,scratchCartesianEnds=new Cartesian3,scratchCartographicMin=new Cartographic,scratchCartographicMax=new Cartographic;function computeRectangle$2(e,t,n,i,r){e=scaleToSurface$1(e,t);const o=arrayRemoveDuplicates(e,Cartesian3.equalsEpsilon),a=o.length;if(a<2||n<=0)return new Rectangle;const s=n*.5;scratchCartographicMin.latitude=Number.POSITIVE_INFINITY,scratchCartographicMin.longitude=Number.POSITIVE_INFINITY,scratchCartographicMax.latitude=Number.NEGATIVE_INFINITY,scratchCartographicMax.longitude=Number.NEGATIVE_INFINITY;let l,c;if(i===CornerType$1.ROUNDED){const f=o[0];Cartesian3.subtract(f,o[1],scratchCartesianOffset),Cartesian3.normalize(scratchCartesianOffset,scratchCartesianOffset),Cartesian3.multiplyByScalar(scratchCartesianOffset,s,scratchCartesianOffset),Cartesian3.add(f,scratchCartesianOffset,scratchCartesianEnds),t.cartesianToCartographic(scratchCartesianEnds,scratchCartographic$a),l=scratchCartographic$a.latitude,c=scratchCartographic$a.longitude,scratchCartographicMin.latitude=Math.min(scratchCartographicMin.latitude,l),scratchCartographicMin.longitude=Math.min(scratchCartographicMin.longitude,c),scratchCartographicMax.latitude=Math.max(scratchCartographicMax.latitude,l),scratchCartographicMax.longitude=Math.max(scratchCartographicMax.longitude,c)}for(let f=0;f<a-1;++f)computeOffsetPoints(o[f],o[f+1],t,s,scratchCartographicMin,scratchCartographicMax);const d=o[a-1];Cartesian3.subtract(d,o[a-2],scratchCartesianOffset),Cartesian3.normalize(scratchCartesianOffset,scratchCartesianOffset),Cartesian3.multiplyByScalar(scratchCartesianOffset,s,scratchCartesianOffset),Cartesian3.add(d,scratchCartesianOffset,scratchCartesianEnds),computeOffsetPoints(d,scratchCartesianEnds,t,s,scratchCartographicMin,scratchCartographicMax),i===CornerType$1.ROUNDED&&(t.cartesianToCartographic(scratchCartesianEnds,scratchCartographic$a),l=scratchCartographic$a.latitude,c=scratchCartographic$a.longitude,scratchCartographicMin.latitude=Math.min(scratchCartographicMin.latitude,l),scratchCartographicMin.longitude=Math.min(scratchCartographicMin.longitude,c),scratchCartographicMax.latitude=Math.max(scratchCartographicMax.latitude,l),scratchCartographicMax.longitude=Math.max(scratchCartographicMax.longitude,c));const h=defined(r)?r:new Rectangle;return h.north=scratchCartographicMax.latitude,h.south=scratchCartographicMin.latitude,h.east=scratchCartographicMax.longitude,h.west=scratchCartographicMin.longitude,h}function CorridorGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.positions,n=e.width;Check.defined("options.positions",t),Check.defined("options.width",n);const i=defaultValue(e.height,0),r=defaultValue(e.extrudedHeight,i);this._positions=t,this._ellipsoid=Ellipsoid.clone(defaultValue(e.ellipsoid,Ellipsoid.default)),this._vertexFormat=VertexFormat.clone(defaultValue(e.vertexFormat,VertexFormat.DEFAULT)),this._width=n,this._height=Math.max(i,r),this._extrudedHeight=Math.min(i,r),this._cornerType=defaultValue(e.cornerType,CornerType$1.ROUNDED),this._granularity=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=defaultValue(e.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=e.offsetAttribute,this._rectangle=void 0,this.packedLength=1+t.length*Cartesian3.packedLength+Ellipsoid.packedLength+VertexFormat.packedLength+7}CorridorGeometry.pack=function(e,t,n){Check.defined("value",e),Check.defined("array",t),n=defaultValue(n,0);const i=e._positions,r=i.length;t[n++]=r;for(let o=0;o<r;++o,n+=Cartesian3.packedLength)Cartesian3.pack(i[o],t,n);return Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,VertexFormat.pack(e._vertexFormat,t,n),n+=VertexFormat.packedLength,t[n++]=e._width,t[n++]=e._height,t[n++]=e._extrudedHeight,t[n++]=e._cornerType,t[n++]=e._granularity,t[n++]=e._shadowVolume?1:0,t[n]=defaultValue(e._offsetAttribute,-1),t};const scratchEllipsoid$c=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchVertexFormat$a=new VertexFormat,scratchOptions$h={positions:void 0,ellipsoid:scratchEllipsoid$c,vertexFormat:scratchVertexFormat$a,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};CorridorGeometry.unpack=function(e,t,n){Check.defined("array",e),t=defaultValue(t,0);const i=e[t++],r=new Array(i);for(let u=0;u<i;++u,t+=Cartesian3.packedLength)r[u]=Cartesian3.unpack(e,t);const o=Ellipsoid.unpack(e,t,scratchEllipsoid$c);t+=Ellipsoid.packedLength;const a=VertexFormat.unpack(e,t,scratchVertexFormat$a);t+=VertexFormat.packedLength;const s=e[t++],l=e[t++],c=e[t++],d=e[t++],h=e[t++],f=e[t++]===1,p=e[t];return defined(n)?(n._positions=r,n._ellipsoid=Ellipsoid.clone(o,n._ellipsoid),n._vertexFormat=VertexFormat.clone(a,n._vertexFormat),n._width=s,n._height=l,n._extrudedHeight=c,n._cornerType=d,n._granularity=h,n._shadowVolume=f,n._offsetAttribute=p===-1?void 0:p,n):(scratchOptions$h.positions=r,scratchOptions$h.width=s,scratchOptions$h.height=l,scratchOptions$h.extrudedHeight=c,scratchOptions$h.cornerType=d,scratchOptions$h.granularity=h,scratchOptions$h.shadowVolume=f,scratchOptions$h.offsetAttribute=p===-1?void 0:p,new CorridorGeometry(scratchOptions$h))};CorridorGeometry.computeRectangle=function(e,t){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const n=e.positions,i=e.width;Check.defined("options.positions",n),Check.defined("options.width",i);const r=defaultValue(e.ellipsoid,Ellipsoid.default),o=defaultValue(e.cornerType,CornerType$1.ROUNDED);return computeRectangle$2(n,r,i,o,t)};CorridorGeometry.createGeometry=function(e){let t=e._positions;const n=e._width,i=e._ellipsoid;t=scaleToSurface$1(t,i);const r=arrayRemoveDuplicates(t,Cartesian3.equalsEpsilon);if(r.length<2||n<=0)return;const o=e._height,a=e._extrudedHeight,s=!CesiumMath.equalsEpsilon(o,a,0,CesiumMath.EPSILON2),l=e._vertexFormat,c={ellipsoid:i,positions:r,width:n,cornerType:e._cornerType,granularity:e._granularity,saveAttributes:!0};let d;if(s)c.height=o,c.extrudedHeight=a,c.shadowVolume=e._shadowVolume,c.offsetAttribute=e._offsetAttribute,d=computePositionsExtruded$1(c,l);else{const p=CorridorGeometryLibrary$1.computePositions(c);if(d=combine$1(p,l,i),d.attributes.position.values=PolygonPipeline.scaleToGeodeticHeight(d.attributes.position.values,o,i),defined(e._offsetAttribute)){const u=e._offsetAttribute===GeometryOffsetAttribute.NONE?0:1,m=d.attributes.position.values.length,g=new Uint8Array(m/3).fill(u);d.attributes.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:g})}}const h=d.attributes,f=BoundingSphere.fromVertices(h.position.values,void 0,3);return l.position||(d.attributes.position.values=void 0),new Geometry({attributes:h,indices:d.indices,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:f,offsetAttribute:e._offsetAttribute})};CorridorGeometry.createShadowVolume=function(e,t,n){const i=e._granularity,r=e._ellipsoid,o=t(i,r),a=n(i,r);return new CorridorGeometry({positions:e._positions,width:e._width,cornerType:e._cornerType,ellipsoid:r,granularity:i,extrudedHeight:o,height:a,vertexFormat:VertexFormat.POSITION_ONLY,shadowVolume:!0})};Object.defineProperties(CorridorGeometry.prototype,{rectangle:{get:function(){return defined(this._rectangle)||(this._rectangle=computeRectangle$2(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}});const cartesian1=new Cartesian3,cartesian2=new Cartesian3,cartesian3=new Cartesian3;function scaleToSurface(e,t){for(let n=0;n<e.length;n++)e[n]=t.scaleToGeodeticSurface(e[n],e[n]);return e}function combine(e,t){const n=[],i=e.positions,r=e.corners,o=e.endPositions,a=new GeometryAttributes;let s,l=0,c=0,d,h=0,f;for(d=0;d<i.length;d+=2)f=i[d].length-3,l+=f,h+=f/3*4,c+=i[d+1].length-3;for(l+=3,c+=3,d=0;d<r.length;d++){s=r[d];const P=r[d].leftPositions;defined(P)?(f=P.length,l+=f,h+=f/3*2):(f=r[d].rightPositions.length,c+=f,h+=f/3*2)}const p=defined(o);let u;p&&(u=o[0].length-3,l+=u,c+=u,u/=3,h+=u*4);const m=l+c,g=new Float64Array(m);let _=0,C=m-1,A,S,v,b,D,I;const L=u/2,N=IndexDatatype.createTypedArray(m/3,h+4);let y=0;if(N[y++]=_/3,N[y++]=(C-2)/3,p){n.push(_/3),I=cartesian1,D=cartesian2;const P=o[0];for(d=0;d<L;d++)I=Cartesian3.fromArray(P,(L-1-d)*3,I),D=Cartesian3.fromArray(P,(L+d)*3,D),CorridorGeometryLibrary$1.addAttribute(g,D,_),CorridorGeometryLibrary$1.addAttribute(g,I,void 0,C),S=_/3,b=S+1,A=(C-2)/3,v=A-1,N[y++]=A,N[y++]=v,N[y++]=S,N[y++]=b,_+=3,C-=3}let x=0,T=i[x++],E=i[x++];for(g.set(T,_),g.set(E,C-E.length+1),f=E.length-3,n.push(_/3,(C-2)/3),d=0;d<f;d+=3)S=_/3,b=S+1,A=(C-2)/3,v=A-1,N[y++]=A,N[y++]=v,N[y++]=S,N[y++]=b,_+=3,C-=3;for(d=0;d<r.length;d++){let P;s=r[d];const M=s.leftPositions,O=s.rightPositions;let V,R=cartesian3;if(defined(M)){for(C-=3,V=v,n.push(b),P=0;P<M.length/3;P++)R=Cartesian3.fromArray(M,P*3,R),N[y++]=V-P-1,N[y++]=V-P,CorridorGeometryLibrary$1.addAttribute(g,R,void 0,C),C-=3;n.push(V-Math.floor(M.length/6)),t===CornerType$1.BEVELED&&n.push((C-2)/3+1),_+=3}else{for(_+=3,V=b,n.push(v),P=0;P<O.length/3;P++)R=Cartesian3.fromArray(O,P*3,R),N[y++]=V+P,N[y++]=V+P+1,CorridorGeometryLibrary$1.addAttribute(g,R,_),_+=3;n.push(V+Math.floor(O.length/6)),t===CornerType$1.BEVELED&&n.push(_/3-1),C-=3}for(T=i[x++],E=i[x++],T.splice(0,3),E.splice(E.length-3,3),g.set(T,_),g.set(E,C-E.length+1),f=E.length-3,P=0;P<E.length;P+=3)b=_/3,S=b-1,v=(C-2)/3,A=v+1,N[y++]=A,N[y++]=v,N[y++]=S,N[y++]=b,_+=3,C-=3;_-=3,C+=3,n.push(_/3,(C-2)/3)}if(p){_+=3,C-=3,I=cartesian1,D=cartesian2;const P=o[1];for(d=0;d<L;d++)I=Cartesian3.fromArray(P,(u-d-1)*3,I),D=Cartesian3.fromArray(P,d*3,D),CorridorGeometryLibrary$1.addAttribute(g,I,void 0,C),CorridorGeometryLibrary$1.addAttribute(g,D,_),b=_/3,S=b-1,v=(C-2)/3,A=v+1,N[y++]=A,N[y++]=v,N[y++]=S,N[y++]=b,_+=3,C-=3;n.push(_/3)}else n.push(_/3,(C-2)/3);return N[y++]=_/3,N[y++]=(C-2)/3,a.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:g}),{attributes:a,indices:N,wallIndices:n}}function computePositionsExtruded(e){const t=e.ellipsoid,n=CorridorGeometryLibrary$1.computePositions(e),i=combine(n,e.cornerType),r=i.wallIndices,o=e.height,a=e.extrudedHeight,s=i.attributes,l=i.indices;let c=s.position.values,d=c.length,h=new Float64Array(d);h.set(c);const f=new Float64Array(d*2);if(c=PolygonPipeline.scaleToGeodeticHeight(c,o,t),h=PolygonPipeline.scaleToGeodeticHeight(h,a,t),f.set(c),f.set(h,d),s.position.values=f,d/=3,defined(e.offsetAttribute)){let A=new Uint8Array(d*2);if(e.offsetAttribute===GeometryOffsetAttribute.TOP)A=A.fill(1,0,d);else{const S=e.offsetAttribute===GeometryOffsetAttribute.NONE?0:1;A=A.fill(S)}s.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:A})}let p;const u=l.length,m=IndexDatatype.createTypedArray(f.length/3,(u+r.length)*2);m.set(l);let g=u;for(p=0;p<u;p+=2){const A=l[p],S=l[p+1];m[g++]=A+d,m[g++]=S+d}let _,C;for(p=0;p<r.length;p++)_=r[p],C=_+d,m[g++]=_,m[g++]=C;return{attributes:s,indices:m}}function CorridorOutlineGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.positions,n=e.width;Check.typeOf.object("options.positions",t),Check.typeOf.number("options.width",n);const i=defaultValue(e.height,0),r=defaultValue(e.extrudedHeight,i);this._positions=t,this._ellipsoid=Ellipsoid.clone(defaultValue(e.ellipsoid,Ellipsoid.default)),this._width=n,this._height=Math.max(i,r),this._extrudedHeight=Math.min(i,r),this._cornerType=defaultValue(e.cornerType,CornerType$1.ROUNDED),this._granularity=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),this._offsetAttribute=e.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+t.length*Cartesian3.packedLength+Ellipsoid.packedLength+6}CorridorOutlineGeometry.pack=function(e,t,n){Check.typeOf.object("value",e),Check.typeOf.object("array",t),n=defaultValue(n,0);const i=e._positions,r=i.length;t[n++]=r;for(let o=0;o<r;++o,n+=Cartesian3.packedLength)Cartesian3.pack(i[o],t,n);return Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,t[n++]=e._width,t[n++]=e._height,t[n++]=e._extrudedHeight,t[n++]=e._cornerType,t[n++]=e._granularity,t[n]=defaultValue(e._offsetAttribute,-1),t};const scratchEllipsoid$b=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchOptions$g={positions:void 0,ellipsoid:scratchEllipsoid$b,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};CorridorOutlineGeometry.unpack=function(e,t,n){Check.typeOf.object("array",e),t=defaultValue(t,0);const i=e[t++],r=new Array(i);for(let f=0;f<i;++f,t+=Cartesian3.packedLength)r[f]=Cartesian3.unpack(e,t);const o=Ellipsoid.unpack(e,t,scratchEllipsoid$b);t+=Ellipsoid.packedLength;const a=e[t++],s=e[t++],l=e[t++],c=e[t++],d=e[t++],h=e[t];return defined(n)?(n._positions=r,n._ellipsoid=Ellipsoid.clone(o,n._ellipsoid),n._width=a,n._height=s,n._extrudedHeight=l,n._cornerType=c,n._granularity=d,n._offsetAttribute=h===-1?void 0:h,n):(scratchOptions$g.positions=r,scratchOptions$g.width=a,scratchOptions$g.height=s,scratchOptions$g.extrudedHeight=l,scratchOptions$g.cornerType=c,scratchOptions$g.granularity=d,scratchOptions$g.offsetAttribute=h===-1?void 0:h,new CorridorOutlineGeometry(scratchOptions$g))};CorridorOutlineGeometry.createGeometry=function(e){let t=e._positions;const n=e._width,i=e._ellipsoid;t=scaleToSurface(t,i);const r=arrayRemoveDuplicates(t,Cartesian3.equalsEpsilon);if(r.length<2||n<=0)return;const o=e._height,a=e._extrudedHeight,s=!CesiumMath.equalsEpsilon(o,a,0,CesiumMath.EPSILON2),l={ellipsoid:i,positions:r,width:n,cornerType:e._cornerType,granularity:e._granularity,saveAttributes:!1};let c;if(s)l.height=o,l.extrudedHeight=a,l.offsetAttribute=e._offsetAttribute,c=computePositionsExtruded(l);else{const f=CorridorGeometryLibrary$1.computePositions(l);if(c=combine(f,l.cornerType),c.attributes.position.values=PolygonPipeline.scaleToGeodeticHeight(c.attributes.position.values,o,i),defined(e._offsetAttribute)){const p=c.attributes.position.values.length,u=e._offsetAttribute===GeometryOffsetAttribute.NONE?0:1,m=new Uint8Array(p/3).fill(u);c.attributes.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:m})}}const d=c.attributes,h=BoundingSphere.fromVertices(d.position.values,void 0,3);return new Geometry({attributes:d,indices:c.indices,primitiveType:PrimitiveType.LINES,boundingSphere:h,offsetAttribute:e._offsetAttribute})};const defaultZIndex$1=new ConstantProperty(0);function GroundGeometryUpdater(e){GeometryUpdater.call(this,e),this._zIndex=0,this._terrainOffsetProperty=void 0}defined(Object.create)&&(GroundGeometryUpdater.prototype=Object.create(GeometryUpdater.prototype),GroundGeometryUpdater.prototype.constructor=GroundGeometryUpdater);Object.defineProperties(GroundGeometryUpdater.prototype,{zIndex:{get:function(){return this._zIndex}},terrainOffsetProperty:{get:function(){return this._terrainOffsetProperty}}});GroundGeometryUpdater.prototype._isOnTerrain=function(e,t){return this._fillEnabled&&!defined(t.height)&&!defined(t.extrudedHeight)&&GroundPrimitive.isSupported(this._scene)};GroundGeometryUpdater.prototype._getIsClosed=function(e){const t=e.height,n=e.extrudedHeight;return t===0||defined(n)&&n!==t};GroundGeometryUpdater.prototype._computeCenter=DeveloperError.throwInstantiationError;GroundGeometryUpdater.prototype._onEntityPropertyChanged=function(e,t,n,i){if(GeometryUpdater.prototype._onEntityPropertyChanged.call(this,e,t,n,i),this._observedPropertyNames.indexOf(t)===-1)return;const r=this._entity[this._geometryPropertyName];if(!defined(r))return;defined(r.zIndex)&&(defined(r.height)||defined(r.extrudedHeight))&&oneTimeWarning(oneTimeWarning.geometryZIndex),this._zIndex=defaultValue(r.zIndex,defaultZIndex$1),defined(this._terrainOffsetProperty)&&(this._terrainOffsetProperty.destroy(),this._terrainOffsetProperty=void 0);const o=r.heightReference,a=r.extrudedHeightReference;if(defined(o)||defined(a)){const s=new CallbackProperty(this._computeCenter.bind(this),!this._dynamic);this._terrainOffsetProperty=new TerrainOffsetProperty(this._scene,s,o,a)}};GroundGeometryUpdater.prototype.destroy=function(){defined(this._terrainOffsetProperty)&&(this._terrainOffsetProperty.destroy(),this._terrainOffsetProperty=void 0),GeometryUpdater.prototype.destroy.call(this)};GroundGeometryUpdater.getGeometryHeight=function(e,t){if(Check.defined("heightReference",t),!defined(e)){t!==HeightReference.NONE&&oneTimeWarning(oneTimeWarning.geometryHeightReference);return}return isHeightReferenceClamp(t)?0:e};GroundGeometryUpdater.getGeometryExtrudedHeight=function(e,t){if(Check.defined("extrudedHeightReference",t),!defined(e)){t!==HeightReference.NONE&&oneTimeWarning(oneTimeWarning.geometryExtrudedHeightReference);return}return isHeightReferenceClamp(t)?GroundGeometryUpdater.CLAMP_TO_GROUND:e};GroundGeometryUpdater.CLAMP_TO_GROUND="clamp";GroundGeometryUpdater.computeGeometryOffsetAttribute=function(e,t,n,i){(!defined(e)||!defined(t))&&(t=HeightReference.NONE),(!defined(n)||!defined(i))&&(i=HeightReference.NONE);let r=0;if(t!==HeightReference.NONE&&r++,i===HeightReference.RELATIVE_TO_GROUND&&r++,r===2)return GeometryOffsetAttribute.ALL;if(r===1)return GeometryOffsetAttribute.TOP};const scratchColor$f=new Color,defaultOffset$9=Cartesian3.ZERO,offsetScratch$8=new Cartesian3,scratchRectangle$6=new Rectangle;function CorridorGeometryOptions(e){this.id=e,this.vertexFormat=void 0,this.positions=void 0,this.width=void 0,this.cornerType=void 0,this.height=void 0,this.extrudedHeight=void 0,this.granularity=void 0,this.offsetAttribute=void 0}function CorridorGeometryUpdater(e,t){GroundGeometryUpdater.call(this,{entity:e,scene:t,geometryOptions:new CorridorGeometryOptions(e),geometryPropertyName:"corridor",observedPropertyNames:["availability","corridor"]}),this._onEntityPropertyChanged(e,"corridor",e.corridor,void 0)}defined(Object.create)&&(CorridorGeometryUpdater.prototype=Object.create(GroundGeometryUpdater.prototype),CorridorGeometryUpdater.prototype.constructor=CorridorGeometryUpdater);CorridorGeometryUpdater.prototype.createFillGeometryInstance=function(e){if(Check.defined("time",e),!this._fillEnabled)throw new DeveloperError("This instance does not represent a filled geometry.");const t=this._entity,n=t.isAvailable(e),i={show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._fillProperty.getValue(e)),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(e)),offset:void 0,color:void 0};if(this._materialProperty instanceof ColorMaterialProperty){let r;defined(this._materialProperty.color)&&(this._materialProperty.color.isConstant||n)&&(r=this._materialProperty.color.getValue(e,scratchColor$f)),defined(r)||(r=Color.WHITE),i.color=ColorGeometryInstanceAttribute.fromColor(r)}return defined(this._options.offsetAttribute)&&(i.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$9,offsetScratch$8))),new GeometryInstance({id:t,geometry:new CorridorGeometry(this._options),attributes:i})};CorridorGeometryUpdater.prototype.createOutlineGeometryInstance=function(e){if(Check.defined("time",e),!this._outlineEnabled)throw new DeveloperError("This instance does not represent an outlined geometry.");const t=this._entity,n=t.isAvailable(e),i=Property.getValueOrDefault(this._outlineColorProperty,e,Color.BLACK,scratchColor$f),r={show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._showOutlineProperty.getValue(e)),color:ColorGeometryInstanceAttribute.fromColor(i),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(e)),offset:void 0};return defined(this._options.offsetAttribute)&&(r.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$9,offsetScratch$8))),new GeometryInstance({id:t,geometry:new CorridorOutlineGeometry(this._options),attributes:r})};CorridorGeometryUpdater.prototype._computeCenter=function(e,t){const n=Property.getValueOrUndefined(this._entity.corridor.positions,e);if(!(!defined(n)||n.length===0))return Cartesian3.clone(n[Math.floor(n.length/2)],t)};CorridorGeometryUpdater.prototype._isHidden=function(e,t){return!defined(t.positions)||!defined(t.width)||GeometryUpdater.prototype._isHidden.call(this,e,t)};CorridorGeometryUpdater.prototype._isDynamic=function(e,t){return!t.positions.isConstant||!Property.isConstant(t.height)||!Property.isConstant(t.extrudedHeight)||!Property.isConstant(t.granularity)||!Property.isConstant(t.width)||!Property.isConstant(t.outlineWidth)||!Property.isConstant(t.cornerType)||!Property.isConstant(t.zIndex)||this._onTerrain&&!Property.isConstant(this._materialProperty)&&!(this._materialProperty instanceof ColorMaterialProperty)};CorridorGeometryUpdater.prototype._setStaticOptions=function(e,t){let n=Property.getValueOrUndefined(t.height,Iso8601.MINIMUM_VALUE);const i=Property.getValueOrDefault(t.heightReference,Iso8601.MINIMUM_VALUE,HeightReference.NONE);let r=Property.getValueOrUndefined(t.extrudedHeight,Iso8601.MINIMUM_VALUE);const o=Property.getValueOrDefault(t.extrudedHeightReference,Iso8601.MINIMUM_VALUE,HeightReference.NONE);defined(r)&&!defined(n)&&(n=0);const a=this._options;a.vertexFormat=this._materialProperty instanceof ColorMaterialProperty?PerInstanceColorAppearance.VERTEX_FORMAT:MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat,a.positions=t.positions.getValue(Iso8601.MINIMUM_VALUE,a.positions),a.width=t.width.getValue(Iso8601.MINIMUM_VALUE),a.granularity=Property.getValueOrUndefined(t.granularity,Iso8601.MINIMUM_VALUE),a.cornerType=Property.getValueOrUndefined(t.cornerType,Iso8601.MINIMUM_VALUE),a.offsetAttribute=GroundGeometryUpdater.computeGeometryOffsetAttribute(n,i,r,o),a.height=GroundGeometryUpdater.getGeometryHeight(n,i),r=GroundGeometryUpdater.getGeometryExtrudedHeight(r,o),r===GroundGeometryUpdater.CLAMP_TO_GROUND&&(r=ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(a,scratchRectangle$6)).minimumTerrainHeight),a.extrudedHeight=r};CorridorGeometryUpdater.DynamicGeometryUpdater=DynamicCorridorGeometryUpdater;function DynamicCorridorGeometryUpdater(e,t,n){DynamicGeometryUpdater$1.call(this,e,t,n)}defined(Object.create)&&(DynamicCorridorGeometryUpdater.prototype=Object.create(DynamicGeometryUpdater$1.prototype),DynamicCorridorGeometryUpdater.prototype.constructor=DynamicCorridorGeometryUpdater);DynamicCorridorGeometryUpdater.prototype._isHidden=function(e,t,n){const i=this._options;return!defined(i.positions)||!defined(i.width)||DynamicGeometryUpdater$1.prototype._isHidden.call(this,e,t,n)};DynamicCorridorGeometryUpdater.prototype._setOptions=function(e,t,n){const i=this._options;let r=Property.getValueOrUndefined(t.height,n);const o=Property.getValueOrDefault(t.heightReference,n,HeightReference.NONE);let a=Property.getValueOrUndefined(t.extrudedHeight,n);const s=Property.getValueOrDefault(t.extrudedHeightReference,n,HeightReference.NONE);defined(a)&&!defined(r)&&(r=0),i.positions=Property.getValueOrUndefined(t.positions,n),i.width=Property.getValueOrUndefined(t.width,n),i.granularity=Property.getValueOrUndefined(t.granularity,n),i.cornerType=Property.getValueOrUndefined(t.cornerType,n),i.offsetAttribute=GroundGeometryUpdater.computeGeometryOffsetAttribute(r,o,a,s),i.height=GroundGeometryUpdater.getGeometryHeight(r,o),a=GroundGeometryUpdater.getGeometryExtrudedHeight(a,s),a===GroundGeometryUpdater.CLAMP_TO_GROUND&&(a=ApproximateTerrainHeights.getMinimumMaximumHeights(CorridorGeometry.computeRectangle(i,scratchRectangle$6)).minimumTerrainHeight),i.extrudedHeight=a};function DataSource(){DeveloperError.throwInstantiationError()}Object.defineProperties(DataSource.prototype,{name:{get:DeveloperError.throwInstantiationError},clock:{get:DeveloperError.throwInstantiationError},entities:{get:DeveloperError.throwInstantiationError},isLoading:{get:DeveloperError.throwInstantiationError},changedEvent:{get:DeveloperError.throwInstantiationError},errorEvent:{get:DeveloperError.throwInstantiationError},loadingEvent:{get:DeveloperError.throwInstantiationError},show:{get:DeveloperError.throwInstantiationError},clustering:{get:DeveloperError.throwInstantiationError}});DataSource.prototype.update=function(e){DeveloperError.throwInstantiationError()};DataSource.setLoading=function(e,t){e._isLoading!==t&&(t?e._entityCollection.suspendEvents():e._entityCollection.resumeEvents(),e._isLoading=t,e._loading.raiseEvent(e,t))};function EllipsoidalOccluder(e,t){Check.typeOf.object("ellipsoid",e),this._ellipsoid=e,this._cameraPosition=new Cartesian3,this._cameraPositionInScaledSpace=new Cartesian3,this._distanceToLimbInScaledSpaceSquared=0,defined(t)&&(this.cameraPosition=t)}Object.defineProperties(EllipsoidalOccluder.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},cameraPosition:{get:function(){return this._cameraPosition},set:function(e){const n=this._ellipsoid.transformPositionToScaledSpace(e,this._cameraPositionInScaledSpace),i=Cartesian3.magnitudeSquared(n)-1;Cartesian3.clone(e,this._cameraPosition),this._cameraPositionInScaledSpace=n,this._distanceToLimbInScaledSpaceSquared=i}}});const scratchCartesian$5=new Cartesian3;EllipsoidalOccluder.prototype.isPointVisible=function(e){const n=this._ellipsoid.transformPositionToScaledSpace(e,scratchCartesian$5);return isScaledSpacePointVisible(n,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)};EllipsoidalOccluder.prototype.isScaledSpacePointVisible=function(e){return isScaledSpacePointVisible(e,this._cameraPositionInScaledSpace,this._distanceToLimbInScaledSpaceSquared)};const scratchCameraPositionInScaledSpaceShrunk=new Cartesian3;EllipsoidalOccluder.prototype.isScaledSpacePointVisiblePossiblyUnderEllipsoid=function(e,t){const n=this._ellipsoid;let i,r;return defined(t)&&t<0&&n.minimumRadius>-t?(r=scratchCameraPositionInScaledSpaceShrunk,r.x=this._cameraPosition.x/(n.radii.x+t),r.y=this._cameraPosition.y/(n.radii.y+t),r.z=this._cameraPosition.z/(n.radii.z+t),i=r.x*r.x+r.y*r.y+r.z*r.z-1):(r=this._cameraPositionInScaledSpace,i=this._distanceToLimbInScaledSpaceSquared),isScaledSpacePointVisible(e,r,i)};EllipsoidalOccluder.prototype.computeHorizonCullingPoint=function(e,t,n){return computeHorizonCullingPointFromPositions(this._ellipsoid,e,t,n)};const scratchEllipsoidShrunk=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);EllipsoidalOccluder.prototype.computeHorizonCullingPointPossiblyUnderEllipsoid=function(e,t,n,i){const r=getPossiblyShrunkEllipsoid(this._ellipsoid,n,scratchEllipsoidShrunk);return computeHorizonCullingPointFromPositions(r,e,t,i)};EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVertices=function(e,t,n,i,r){return computeHorizonCullingPointFromVertices(this._ellipsoid,e,t,n,i,r)};EllipsoidalOccluder.prototype.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid=function(e,t,n,i,r,o){const a=getPossiblyShrunkEllipsoid(this._ellipsoid,r,scratchEllipsoidShrunk);return computeHorizonCullingPointFromVertices(a,e,t,n,i,o)};const subsampleScratch=[];EllipsoidalOccluder.prototype.computeHorizonCullingPointFromRectangle=function(e,t,n){Check.typeOf.object("rectangle",e);const i=Rectangle.subsample(e,t,0,subsampleScratch),r=BoundingSphere.fromPoints(i);if(!(Cartesian3.magnitude(r.center)<.1*t.minimumRadius))return this.computeHorizonCullingPoint(r.center,i,n)};const scratchEllipsoidShrunkRadii=new Cartesian3;function getPossiblyShrunkEllipsoid(e,t,n){if(defined(t)&&t<0&&e.minimumRadius>-t){const i=Cartesian3.fromElements(e.radii.x+t,e.radii.y+t,e.radii.z+t,scratchEllipsoidShrunkRadii);e=Ellipsoid.fromCartesian3(i,n)}return e}function computeHorizonCullingPointFromPositions(e,t,n,i){Check.typeOf.object("directionToPoint",t),Check.defined("positions",n),defined(i)||(i=new Cartesian3);const r=computeScaledSpaceDirectionToPoint(e,t);let o=0;for(let a=0,s=n.length;a<s;++a){const l=n[a],c=computeMagnitude(e,l,r);if(c<0)return;o=Math.max(o,c)}return magnitudeToPoint(r,o,i)}const positionScratch$7=new Cartesian3;function computeHorizonCullingPointFromVertices(e,t,n,i,r,o){Check.typeOf.object("directionToPoint",t),Check.defined("vertices",n),Check.typeOf.number("stride",i),defined(o)||(o=new Cartesian3),i=defaultValue(i,3),r=defaultValue(r,Cartesian3.ZERO);const a=computeScaledSpaceDirectionToPoint(e,t);let s=0;for(let l=0,c=n.length;l<c;l+=i){positionScratch$7.x=n[l]+r.x,positionScratch$7.y=n[l+1]+r.y,positionScratch$7.z=n[l+2]+r.z;const d=computeMagnitude(e,positionScratch$7,a);if(d<0)return;s=Math.max(s,d)}return magnitudeToPoint(a,s,o)}function isScaledSpacePointVisible(e,t,n){const i=t,r=n,o=Cartesian3.subtract(e,i,scratchCartesian$5),a=-Cartesian3.dot(o,i);return!(r<0?a>0:a>r&&a*a/Cartesian3.magnitudeSquared(o)>r)}const scaledSpaceScratch=new Cartesian3,directionScratch=new Cartesian3;function computeMagnitude(e,t,n){const i=e.transformPositionToScaledSpace(t,scaledSpaceScratch);let r=Cartesian3.magnitudeSquared(i),o=Math.sqrt(r);const a=Cartesian3.divideByScalar(i,o,directionScratch);r=Math.max(1,r),o=Math.max(1,o);const s=Cartesian3.dot(a,n),l=Cartesian3.magnitude(Cartesian3.cross(a,n,a)),c=1/o,d=Math.sqrt(r-1)*c;return 1/(s*c-l*d)}function magnitudeToPoint(e,t,n){if(!(t<=0||t===1/0||t!==t))return Cartesian3.multiplyByScalar(e,t,n)}const directionToPointScratch=new Cartesian3;function computeScaledSpaceDirectionToPoint(e,t){return Cartesian3.equals(t,Cartesian3.ZERO)?t:(e.transformPositionToScaledSpace(t,directionToPointScratch),Cartesian3.normalize(directionToPointScratch,directionToPointScratch))}function PointPrimitive(e,t){if(e=defaultValue(e,defaultValue.EMPTY_OBJECT),defined(e.disableDepthTestDistance)&&e.disableDepthTestDistance<0)throw new DeveloperError("disableDepthTestDistance must be greater than or equal to 0.0.");let n=e.translucencyByDistance,i=e.scaleByDistance,r=e.distanceDisplayCondition;if(defined(n)){if(n.far<=n.near)throw new DeveloperError("translucencyByDistance.far must be greater than translucencyByDistance.near.");n=NearFarScalar.clone(n)}if(defined(i)){if(i.far<=i.near)throw new DeveloperError("scaleByDistance.far must be greater than scaleByDistance.near.");i=NearFarScalar.clone(i)}if(defined(r)){if(r.far<=r.near)throw new DeveloperError("distanceDisplayCondition.far must be greater than distanceDisplayCondition.near.");r=DistanceDisplayCondition.clone(r)}this._show=defaultValue(e.show,!0),this._position=Cartesian3.clone(defaultValue(e.position,Cartesian3.ZERO)),this._actualPosition=Cartesian3.clone(this._position),this._color=Color.clone(defaultValue(e.color,Color.WHITE)),this._outlineColor=Color.clone(defaultValue(e.outlineColor,Color.TRANSPARENT)),this._outlineWidth=defaultValue(e.outlineWidth,0),this._pixelSize=defaultValue(e.pixelSize,10),this._scaleByDistance=i,this._translucencyByDistance=n,this._distanceDisplayCondition=r,this._disableDepthTestDistance=defaultValue(e.disableDepthTestDistance,0),this._id=e.id,this._collection=defaultValue(e.collection,t),this._clusterShow=!0,this._pickId=void 0,this._pointPrimitiveCollection=t,this._dirty=!1,this._index=-1}const SHOW_INDEX$3=PointPrimitive.SHOW_INDEX=0,POSITION_INDEX$3=PointPrimitive.POSITION_INDEX=1,COLOR_INDEX$3=PointPrimitive.COLOR_INDEX=2,OUTLINE_COLOR_INDEX$1=PointPrimitive.OUTLINE_COLOR_INDEX=3,OUTLINE_WIDTH_INDEX$1=PointPrimitive.OUTLINE_WIDTH_INDEX=4,PIXEL_SIZE_INDEX$1=PointPrimitive.PIXEL_SIZE_INDEX=5,SCALE_BY_DISTANCE_INDEX$1=PointPrimitive.SCALE_BY_DISTANCE_INDEX=6,TRANSLUCENCY_BY_DISTANCE_INDEX$1=PointPrimitive.TRANSLUCENCY_BY_DISTANCE_INDEX=7,DISTANCE_DISPLAY_CONDITION_INDEX$1=PointPrimitive.DISTANCE_DISPLAY_CONDITION_INDEX=8,DISABLE_DEPTH_DISTANCE_INDEX$1=PointPrimitive.DISABLE_DEPTH_DISTANCE_INDEX=9;PointPrimitive.NUMBER_OF_PROPERTIES=10;function makeDirty$1(e,t){const n=e._pointPrimitiveCollection;defined(n)&&(n._updatePointPrimitive(e,t),e._dirty=!0)}Object.defineProperties(PointPrimitive.prototype,{show:{get:function(){return this._show},set:function(e){if(!defined(e))throw new DeveloperError("value is required.");this._show!==e&&(this._show=e,makeDirty$1(this,SHOW_INDEX$3))}},position:{get:function(){return this._position},set:function(e){if(!defined(e))throw new DeveloperError("value is required.");const t=this._position;Cartesian3.equals(t,e)||(Cartesian3.clone(e,t),Cartesian3.clone(e,this._actualPosition),makeDirty$1(this,POSITION_INDEX$3))}},scaleByDistance:{get:function(){return this._scaleByDistance},set:function(e){if(defined(e)&&e.far<=e.near)throw new DeveloperError("far distance must be greater than near distance.");const t=this._scaleByDistance;NearFarScalar.equals(t,e)||(this._scaleByDistance=NearFarScalar.clone(e,t),makeDirty$1(this,SCALE_BY_DISTANCE_INDEX$1))}},translucencyByDistance:{get:function(){return this._translucencyByDistance},set:function(e){if(defined(e)&&e.far<=e.near)throw new DeveloperError("far distance must be greater than near distance.");const t=this._translucencyByDistance;NearFarScalar.equals(t,e)||(this._translucencyByDistance=NearFarScalar.clone(e,t),makeDirty$1(this,TRANSLUCENCY_BY_DISTANCE_INDEX$1))}},pixelSize:{get:function(){return this._pixelSize},set:function(e){if(!defined(e))throw new DeveloperError("value is required.");this._pixelSize!==e&&(this._pixelSize=e,makeDirty$1(this,PIXEL_SIZE_INDEX$1))}},color:{get:function(){return this._color},set:function(e){if(!defined(e))throw new DeveloperError("value is required.");const t=this._color;Color.equals(t,e)||(Color.clone(e,t),makeDirty$1(this,COLOR_INDEX$3))}},outlineColor:{get:function(){return this._outlineColor},set:function(e){if(!defined(e))throw new DeveloperError("value is required.");const t=this._outlineColor;Color.equals(t,e)||(Color.clone(e,t),makeDirty$1(this,OUTLINE_COLOR_INDEX$1))}},outlineWidth:{get:function(){return this._outlineWidth},set:function(e){if(!defined(e))throw new DeveloperError("value is required.");this._outlineWidth!==e&&(this._outlineWidth=e,makeDirty$1(this,OUTLINE_WIDTH_INDEX$1))}},distanceDisplayCondition:{get:function(){return this._distanceDisplayCondition},set:function(e){if(defined(e)&&e.far<=e.near)throw new DeveloperError("far must be greater than near");DistanceDisplayCondition.equals(this._distanceDisplayCondition,e)||(this._distanceDisplayCondition=DistanceDisplayCondition.clone(e,this._distanceDisplayCondition),makeDirty$1(this,DISTANCE_DISPLAY_CONDITION_INDEX$1))}},disableDepthTestDistance:{get:function(){return this._disableDepthTestDistance},set:function(e){if(this._disableDepthTestDistance!==e){if(!defined(e)||e<0)throw new DeveloperError("disableDepthTestDistance must be greater than or equal to 0.0.");this._disableDepthTestDistance=e,makeDirty$1(this,DISABLE_DEPTH_DISTANCE_INDEX$1)}}},id:{get:function(){return this._id},set:function(e){this._id=e,defined(this._pickId)&&(this._pickId.object.id=e)}},pickId:{get:function(){return this._pickId}},clusterShow:{get:function(){return this._clusterShow},set:function(e){this._clusterShow!==e&&(this._clusterShow=e,makeDirty$1(this,SHOW_INDEX$3))}}});PointPrimitive.prototype.getPickId=function(e){return defined(this._pickId)||(this._pickId=e.createPickId({primitive:this,collection:this._collection,id:this._id})),this._pickId};PointPrimitive.prototype._getActualPosition=function(){return this._actualPosition};PointPrimitive.prototype._setActualPosition=function(e){Cartesian3.clone(e,this._actualPosition),makeDirty$1(this,POSITION_INDEX$3)};const tempCartesian3=new Cartesian4;PointPrimitive._computeActualPosition=function(e,t,n){return t.mode===SceneMode.SCENE3D?e:(Matrix4.multiplyByPoint(n,e,tempCartesian3),SceneTransforms.computeActualEllipsoidPosition(t,tempCartesian3))};const scratchCartesian4$3=new Cartesian4;PointPrimitive._computeScreenSpacePosition=function(e,t,n,i){const r=Matrix4.multiplyByVector(e,Cartesian4.fromElements(t.x,t.y,t.z,1,scratchCartesian4$3),scratchCartesian4$3);return SceneTransforms.worldToWindowCoordinates(n,r,i)};PointPrimitive.prototype.computeScreenSpacePosition=function(e,t){const n=this._pointPrimitiveCollection;if(defined(t)||(t=new Cartesian2),!defined(n))throw new DeveloperError("PointPrimitive must be in a collection.");if(!defined(e))throw new DeveloperError("scene is required.");const i=n.modelMatrix,r=PointPrimitive._computeScreenSpacePosition(i,this._actualPosition,e,t);if(defined(r))return r.y=e.canvas.clientHeight-r.y,r};PointPrimitive.getScreenSpaceBoundingBox=function(e,t,n){const i=e.pixelSize,r=i*.5,o=t.x-r,a=t.y-r,s=i,l=i;return defined(n)||(n=new BoundingRectangle),n.x=o,n.y=a,n.width=s,n.height=l,n};PointPrimitive.prototype.equals=function(e){return this===e||defined(e)&&this._id===e._id&&Cartesian3.equals(this._position,e._position)&&Color.equals(this._color,e._color)&&this._pixelSize===e._pixelSize&&this._outlineWidth===e._outlineWidth&&this._show===e._show&&Color.equals(this._outlineColor,e._outlineColor)&&NearFarScalar.equals(this._scaleByDistance,e._scaleByDistance)&&NearFarScalar.equals(this._translucencyByDistance,e._translucencyByDistance)&&DistanceDisplayCondition.equals(this._distanceDisplayCondition,e._distanceDisplayCondition)&&this._disableDepthTestDistance===e._disableDepthTestDistance};PointPrimitive.prototype._destroy=function(){this._pickId=this._pickId&&this._pickId.destroy(),this._pointPrimitiveCollection=void 0};const PointPrimitiveCollectionFS=`in vec4 v_color;
in vec4 v_outlineColor;
in float v_innerPercent;
in float v_pixelDistance;
in vec4 v_pickColor;

void main()
{
    // The distance in UV space from this fragment to the center of the point, at most 0.5.
    float distanceToCenter = length(gl_PointCoord - vec2(0.5));
    // The max distance stops one pixel shy of the edge to leave space for anti-aliasing.
    float maxDistance = max(0.0, 0.5 - v_pixelDistance);
    float wholeAlpha = 1.0 - smoothstep(maxDistance, 0.5, distanceToCenter);
    float innerAlpha = 1.0 - smoothstep(maxDistance * v_innerPercent, 0.5 * v_innerPercent, distanceToCenter);

    vec4 color = mix(v_outlineColor, v_color, innerAlpha);
    color.a *= wholeAlpha;

// Fully transparent parts of the billboard are not pickable.
#if !defined(OPAQUE) && !defined(TRANSLUCENT)
    if (color.a < 0.005)   // matches 0/255 and 1/255
    {
        discard;
    }
#else
// The billboard is rendered twice. The opaque pass discards translucent fragments
// and the translucent pass discards opaque fragments.
#ifdef OPAQUE
    if (color.a < 0.995)   // matches < 254/255
    {
        discard;
    }
#else
    if (color.a >= 0.995)  // matches 254/255 and 255/255
    {
        discard;
    }
#endif
#endif

    out_FragColor = czm_gammaCorrect(color);
    czm_writeLogDepth();
}
`,PointPrimitiveCollectionVS=`uniform float u_maxTotalPointSize;

in vec4 positionHighAndSize;
in vec4 positionLowAndOutline;
in vec4 compressedAttribute0;                       // color, outlineColor, pick color
in vec4 compressedAttribute1;                       // show, translucency by distance, some free space
in vec4 scaleByDistance;                            // near, nearScale, far, farScale
in vec3 distanceDisplayConditionAndDisableDepth;    // near, far, disableDepthTestDistance

out vec4 v_color;
out vec4 v_outlineColor;
out float v_innerPercent;
out float v_pixelDistance;
out vec4 v_pickColor;

const float SHIFT_LEFT8 = 256.0;
const float SHIFT_RIGHT8 = 1.0 / 256.0;

void main()
{
    // Modifying this shader may also require modifications to PointPrimitive._computeScreenSpacePosition

    // unpack attributes
    vec3 positionHigh = positionHighAndSize.xyz;
    vec3 positionLow = positionLowAndOutline.xyz;
    float outlineWidthBothSides = 2.0 * positionLowAndOutline.w;
    float totalSize = positionHighAndSize.w + outlineWidthBothSides;
    float outlinePercent = outlineWidthBothSides / totalSize;
    // Scale in response to browser-zoom.
    totalSize *= czm_pixelRatio;

    float temp = compressedAttribute1.x * SHIFT_RIGHT8;
    float show = floor(temp);

#ifdef EYE_DISTANCE_TRANSLUCENCY
    vec4 translucencyByDistance;
    translucencyByDistance.x = compressedAttribute1.z;
    translucencyByDistance.z = compressedAttribute1.w;

    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;

    temp = compressedAttribute1.y * SHIFT_RIGHT8;
    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;
#endif

    ///////////////////////////////////////////////////////////////////////////

    vec4 color;
    vec4 outlineColor;
    vec4 pickColor;

    // compressedAttribute0.z => pickColor.rgb

    temp = compressedAttribute0.z * SHIFT_RIGHT8;
    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
    pickColor.r = floor(temp);

    // compressedAttribute0.x => color.rgb

    temp = compressedAttribute0.x * SHIFT_RIGHT8;
    color.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    color.g = (temp - floor(temp)) * SHIFT_LEFT8;
    color.r = floor(temp);

    // compressedAttribute0.y => outlineColor.rgb

    temp = compressedAttribute0.y * SHIFT_RIGHT8;
    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;
    temp = floor(temp) * SHIFT_RIGHT8;
    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;
    outlineColor.r = floor(temp);

    // compressedAttribute0.w => color.a, outlineColor.a, pickColor.a

    temp = compressedAttribute0.w * SHIFT_RIGHT8;
    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
    pickColor = pickColor / 255.0;

    temp = floor(temp) * SHIFT_RIGHT8;
    outlineColor.a = (temp - floor(temp)) * SHIFT_LEFT8;
    outlineColor /= 255.0;
    color.a = floor(temp);
    color /= 255.0;

    ///////////////////////////////////////////////////////////////////////////

    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
    vec4 positionEC = czm_modelViewRelativeToEye * p;

    ///////////////////////////////////////////////////////////////////////////

#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)
    float lengthSq;
    if (czm_sceneMode == czm_sceneMode2D)
    {
        // 2D camera distance is a special case
        // treat all billboards as flattened to the z=0.0 plane
        lengthSq = czm_eyeHeight2D.y;
    }
    else
    {
        lengthSq = dot(positionEC.xyz, positionEC.xyz);
    }
#endif

#ifdef EYE_DISTANCE_SCALING
    totalSize *= czm_nearFarScalar(scaleByDistance, lengthSq);
#endif
    if (totalSize > 0.0) {
        // Add padding for anti-aliasing on both sides.
        totalSize += 3.0;
    }

    // Clamp to max point size.
    totalSize = min(totalSize, u_maxTotalPointSize);
    // If size is too small, push vertex behind near plane for clipping.
    // Note that context.minimumAliasedPointSize "will be at most 1.0".
    if (totalSize < 1.0)
    {
        positionEC.xyz = vec3(0.0);
        totalSize = 1.0;
    }

    float translucency = 1.0;
#ifdef EYE_DISTANCE_TRANSLUCENCY
    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);
    // push vertex behind near plane for clipping
    if (translucency < 0.004)
    {
        positionEC.xyz = vec3(0.0);
    }
#endif

#ifdef DISTANCE_DISPLAY_CONDITION
    float nearSq = distanceDisplayConditionAndDisableDepth.x;
    float farSq = distanceDisplayConditionAndDisableDepth.y;
    if (lengthSq < nearSq || lengthSq > farSq) {
        // push vertex behind camera to force it to be clipped
        positionEC.xyz = vec3(0.0, 0.0, 1.0);
    }
#endif

    gl_Position = czm_projection * positionEC;
    czm_vertexLogDepth();

#ifdef DISABLE_DEPTH_DISTANCE
    float disableDepthTestDistance = distanceDisplayConditionAndDisableDepth.z;
    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)
    {
        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;
    }

    if (disableDepthTestDistance != 0.0)
    {
        // Don't try to "multiply both sides" by w.  Greater/less-than comparisons won't work for negative values of w.
        float zclip = gl_Position.z / gl_Position.w;
        bool clipped = (zclip < -1.0 || zclip > 1.0);
        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))
        {
            // Position z on the near plane.
            gl_Position.z = -gl_Position.w;
#ifdef LOG_DEPTH
            czm_vertexLogDepth(vec4(czm_currentFrustum.x));
#endif
        }
    }
#endif

    v_color = color;
    v_color.a *= translucency * show;
    v_outlineColor = outlineColor;
    v_outlineColor.a *= translucency * show;

    v_innerPercent = 1.0 - outlinePercent;
    v_pixelDistance = 2.0 / totalSize;
    gl_PointSize = totalSize * show;
    gl_Position *= show;

    v_pickColor = pickColor;
}
`,SHOW_INDEX$2=PointPrimitive.SHOW_INDEX,POSITION_INDEX$2=PointPrimitive.POSITION_INDEX,COLOR_INDEX$2=PointPrimitive.COLOR_INDEX,OUTLINE_COLOR_INDEX=PointPrimitive.OUTLINE_COLOR_INDEX,OUTLINE_WIDTH_INDEX=PointPrimitive.OUTLINE_WIDTH_INDEX,PIXEL_SIZE_INDEX=PointPrimitive.PIXEL_SIZE_INDEX,SCALE_BY_DISTANCE_INDEX=PointPrimitive.SCALE_BY_DISTANCE_INDEX,TRANSLUCENCY_BY_DISTANCE_INDEX=PointPrimitive.TRANSLUCENCY_BY_DISTANCE_INDEX,DISTANCE_DISPLAY_CONDITION_INDEX=PointPrimitive.DISTANCE_DISPLAY_CONDITION_INDEX,DISABLE_DEPTH_DISTANCE_INDEX=PointPrimitive.DISABLE_DEPTH_DISTANCE_INDEX,NUMBER_OF_PROPERTIES$1=PointPrimitive.NUMBER_OF_PROPERTIES,attributeLocations$2={positionHighAndSize:0,positionLowAndOutline:1,compressedAttribute0:2,compressedAttribute1:3,scaleByDistance:4,distanceDisplayConditionAndDisableDepth:5};function PointPrimitiveCollection(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._sp=void 0,this._spTranslucent=void 0,this._rsOpaque=void 0,this._rsTranslucent=void 0,this._vaf=void 0,this._pointPrimitives=[],this._pointPrimitivesToUpdate=[],this._pointPrimitivesToUpdateIndex=0,this._pointPrimitivesRemoved=!1,this._createVertexArray=!1,this._shaderScaleByDistance=!1,this._compiledShaderScaleByDistance=!1,this._shaderTranslucencyByDistance=!1,this._compiledShaderTranslucencyByDistance=!1,this._shaderDistanceDisplayCondition=!1,this._compiledShaderDistanceDisplayCondition=!1,this._shaderDisableDepthDistance=!1,this._compiledShaderDisableDepthDistance=!1,this._propertiesChanged=new Uint32Array(NUMBER_OF_PROPERTIES$1),this._maxPixelSize=1,this._baseVolume=new BoundingSphere,this._baseVolumeWC=new BoundingSphere,this._baseVolume2D=new BoundingSphere,this._boundingVolume=new BoundingSphere,this._boundingVolumeDirty=!1,this._colorCommands=[],this.show=defaultValue(e.show,!0),this.modelMatrix=Matrix4.clone(defaultValue(e.modelMatrix,Matrix4.IDENTITY)),this._modelMatrix=Matrix4.clone(Matrix4.IDENTITY),this.debugShowBoundingVolume=defaultValue(e.debugShowBoundingVolume,!1),this.blendOption=defaultValue(e.blendOption,BlendOption.OPAQUE_AND_TRANSLUCENT),this._blendOption=void 0,this._mode=SceneMode.SCENE3D,this._maxTotalPointSize=1,this._buffersUsage=[BufferUsage.STATIC_DRAW,BufferUsage.STATIC_DRAW,BufferUsage.STATIC_DRAW,BufferUsage.STATIC_DRAW,BufferUsage.STATIC_DRAW,BufferUsage.STATIC_DRAW,BufferUsage.STATIC_DRAW,BufferUsage.STATIC_DRAW,BufferUsage.STATIC_DRAW];const t=this;this._uniforms={u_maxTotalPointSize:function(){return t._maxTotalPointSize}}}Object.defineProperties(PointPrimitiveCollection.prototype,{length:{get:function(){return removePointPrimitives(this),this._pointPrimitives.length}}});function destroyPointPrimitives(e){const t=e.length;for(let n=0;n<t;++n)e[n]&&e[n]._destroy()}PointPrimitiveCollection.prototype.add=function(e){const t=new PointPrimitive(e,this);return t._index=this._pointPrimitives.length,this._pointPrimitives.push(t),this._createVertexArray=!0,t};PointPrimitiveCollection.prototype.remove=function(e){return this.contains(e)?(this._pointPrimitives[e._index]=null,this._pointPrimitivesRemoved=!0,this._createVertexArray=!0,e._destroy(),!0):!1};PointPrimitiveCollection.prototype.removeAll=function(){destroyPointPrimitives(this._pointPrimitives),this._pointPrimitives=[],this._pointPrimitivesToUpdate=[],this._pointPrimitivesToUpdateIndex=0,this._pointPrimitivesRemoved=!1,this._createVertexArray=!0};function removePointPrimitives(e){if(e._pointPrimitivesRemoved){e._pointPrimitivesRemoved=!1;const t=[],n=e._pointPrimitives,i=n.length;for(let r=0,o=0;r<i;++r){const a=n[r];a&&(a._index=o++,t.push(a))}e._pointPrimitives=t}}PointPrimitiveCollection.prototype._updatePointPrimitive=function(e,t){e._dirty||(this._pointPrimitivesToUpdate[this._pointPrimitivesToUpdateIndex++]=e),++this._propertiesChanged[t]};PointPrimitiveCollection.prototype.contains=function(e){return defined(e)&&e._pointPrimitiveCollection===this};PointPrimitiveCollection.prototype.get=function(e){if(!defined(e))throw new DeveloperError("index is required.");return removePointPrimitives(this),this._pointPrimitives[e]};PointPrimitiveCollection.prototype.computeNewBuffersUsage=function(){const e=this._buffersUsage;let t=!1;const n=this._propertiesChanged;for(let i=0;i<NUMBER_OF_PROPERTIES$1;++i){const r=n[i]===0?BufferUsage.STATIC_DRAW:BufferUsage.STREAM_DRAW;t=t||e[i]!==r,e[i]=r}return t};function createVAF$1(e,t,n){return new VertexArrayFacade(e,[{index:attributeLocations$2.positionHighAndSize,componentsPerAttribute:4,componentDatatype:ComponentDatatype.FLOAT,usage:n[POSITION_INDEX$2]},{index:attributeLocations$2.positionLowAndShow,componentsPerAttribute:4,componentDatatype:ComponentDatatype.FLOAT,usage:n[POSITION_INDEX$2]},{index:attributeLocations$2.compressedAttribute0,componentsPerAttribute:4,componentDatatype:ComponentDatatype.FLOAT,usage:n[COLOR_INDEX$2]},{index:attributeLocations$2.compressedAttribute1,componentsPerAttribute:4,componentDatatype:ComponentDatatype.FLOAT,usage:n[TRANSLUCENCY_BY_DISTANCE_INDEX]},{index:attributeLocations$2.scaleByDistance,componentsPerAttribute:4,componentDatatype:ComponentDatatype.FLOAT,usage:n[SCALE_BY_DISTANCE_INDEX]},{index:attributeLocations$2.distanceDisplayConditionAndDisableDepth,componentsPerAttribute:3,componentDatatype:ComponentDatatype.FLOAT,usage:n[DISTANCE_DISPLAY_CONDITION_INDEX]}],t)}const writePositionScratch$1=new EncodedCartesian3;function writePositionSizeAndOutline(e,t,n,i){const r=i._index,o=i._getActualPosition();e._mode===SceneMode.SCENE3D&&(BoundingSphere.expand(e._baseVolume,o,e._baseVolume),e._boundingVolumeDirty=!0),EncodedCartesian3.fromCartesian(o,writePositionScratch$1);const a=i.pixelSize,s=i.outlineWidth;e._maxPixelSize=Math.max(e._maxPixelSize,a+s);const l=n[attributeLocations$2.positionHighAndSize],c=writePositionScratch$1.high;l(r,c.x,c.y,c.z,a);const d=n[attributeLocations$2.positionLowAndOutline],h=writePositionScratch$1.low;d(r,h.x,h.y,h.z,s)}const LEFT_SHIFT16=65536,LEFT_SHIFT8=256;function writeCompressedAttrib0(e,t,n,i){const r=i._index,o=i.color,a=i.getPickId(t).color,s=i.outlineColor;let l=Color.floatToByte(o.red),c=Color.floatToByte(o.green),d=Color.floatToByte(o.blue);const h=l*LEFT_SHIFT16+c*LEFT_SHIFT8+d;l=Color.floatToByte(s.red),c=Color.floatToByte(s.green),d=Color.floatToByte(s.blue);const f=l*LEFT_SHIFT16+c*LEFT_SHIFT8+d;l=Color.floatToByte(a.red),c=Color.floatToByte(a.green),d=Color.floatToByte(a.blue);const p=l*LEFT_SHIFT16+c*LEFT_SHIFT8+d,u=Color.floatToByte(o.alpha)*LEFT_SHIFT16+Color.floatToByte(s.alpha)*LEFT_SHIFT8+Color.floatToByte(a.alpha),m=n[attributeLocations$2.compressedAttribute0];m(r,h,f,p,u)}function writeCompressedAttrib1(e,t,n,i){const r=i._index;let o=0,a=1,s=1,l=1;const c=i.translucencyByDistance;defined(c)&&(o=c.near,a=c.nearValue,s=c.far,l=c.farValue,(a!==1||l!==1)&&(e._shaderTranslucencyByDistance=!0));let d=i.show&&i.clusterShow;i.color.alpha===0&&i.outlineColor.alpha===0&&(d=!1),a=CesiumMath.clamp(a,0,1),a=a===1?255:a*255|0;const h=(d?1:0)*LEFT_SHIFT8+a;l=CesiumMath.clamp(l,0,1),l=l===1?255:l*255|0;const f=l,p=n[attributeLocations$2.compressedAttribute1];p(r,h,f,o,s)}function writeScaleByDistance(e,t,n,i){const r=i._index,o=n[attributeLocations$2.scaleByDistance];let a=0,s=1,l=1,c=1;const d=i.scaleByDistance;defined(d)&&(a=d.near,s=d.nearValue,l=d.far,c=d.farValue,(s!==1||c!==1)&&(e._shaderScaleByDistance=!0)),o(r,a,s,l,c)}function writeDistanceDisplayConditionAndDepthDisable(e,t,n,i){const r=i._index,o=n[attributeLocations$2.distanceDisplayConditionAndDisableDepth];let a=0,s=Number.MAX_VALUE;const l=i.distanceDisplayCondition;defined(l)&&(a=l.near,s=l.far,a*=a,s*=s,e._shaderDistanceDisplayCondition=!0);let c=i.disableDepthTestDistance;c*=c,c>0&&(e._shaderDisableDepthDistance=!0,c===Number.POSITIVE_INFINITY&&(c=-1)),o(r,a,s,c)}function writePointPrimitive(e,t,n,i){writePositionSizeAndOutline(e,t,n,i),writeCompressedAttrib0(e,t,n,i),writeCompressedAttrib1(e,t,n,i),writeScaleByDistance(e,t,n,i),writeDistanceDisplayConditionAndDepthDisable(e,t,n,i)}function recomputeActualPositions(e,t,n,i,r,o){let a;i.mode===SceneMode.SCENE3D?(a=e._baseVolume,e._boundingVolumeDirty=!0):a=e._baseVolume2D;const s=[];for(let l=0;l<n;++l){const c=t[l],d=c.position,h=PointPrimitive._computeActualPosition(d,i,r);defined(h)&&(c._setActualPosition(h),o?s.push(h):BoundingSphere.expand(a,h,a))}o&&BoundingSphere.fromPoints(s,a)}function updateMode(e,t){const n=t.mode,i=e._pointPrimitives,r=e._pointPrimitivesToUpdate,o=e._modelMatrix;e._createVertexArray||e._mode!==n||n!==SceneMode.SCENE3D&&!Matrix4.equals(o,e.modelMatrix)?(e._mode=n,Matrix4.clone(e.modelMatrix,o),e._createVertexArray=!0,(n===SceneMode.SCENE3D||n===SceneMode.SCENE2D||n===SceneMode.COLUMBUS_VIEW)&&recomputeActualPositions(e,i,i.length,t,o,!0)):n===SceneMode.MORPHING?recomputeActualPositions(e,i,i.length,t,o,!0):(n===SceneMode.SCENE2D||n===SceneMode.COLUMBUS_VIEW)&&recomputeActualPositions(e,r,e._pointPrimitivesToUpdateIndex,t,o,!1)}function updateBoundingVolume(e,t,n){const r=t.camera.getPixelSize(n,t.context.drawingBufferWidth,t.context.drawingBufferHeight)*e._maxPixelSize;n.radius+=r}const scratchWriterArray$1=[];PointPrimitiveCollection.prototype.update=function(e){if(removePointPrimitives(this),!this.show)return;this._maxTotalPointSize=ContextLimits.maximumAliasedPointSize,updateMode(this,e);const n=this._pointPrimitives.length,i=this._pointPrimitivesToUpdate,r=this._pointPrimitivesToUpdateIndex,o=this._propertiesChanged,a=this._createVertexArray;let s;const l=e.context,c=e.passes,d=c.pick;if(a||!d&&this.computeNewBuffersUsage()){this._createVertexArray=!1;for(let v=0;v<NUMBER_OF_PROPERTIES$1;++v)o[v]=0;if(this._vaf=this._vaf&&this._vaf.destroy(),n>0){this._vaf=createVAF$1(l,n,this._buffersUsage),s=this._vaf.writers;for(let v=0;v<n;++v){const b=this._pointPrimitives[v];b._dirty=!1,writePointPrimitive(this,l,s,b)}this._vaf.commit()}this._pointPrimitivesToUpdateIndex=0}else if(r>0){const v=scratchWriterArray$1;v.length=0,(o[POSITION_INDEX$2]||o[OUTLINE_WIDTH_INDEX]||o[PIXEL_SIZE_INDEX])&&v.push(writePositionSizeAndOutline),(o[COLOR_INDEX$2]||o[OUTLINE_COLOR_INDEX])&&v.push(writeCompressedAttrib0),(o[SHOW_INDEX$2]||o[TRANSLUCENCY_BY_DISTANCE_INDEX])&&v.push(writeCompressedAttrib1),o[SCALE_BY_DISTANCE_INDEX]&&v.push(writeScaleByDistance),(o[DISTANCE_DISPLAY_CONDITION_INDEX]||o[DISABLE_DEPTH_DISTANCE_INDEX])&&v.push(writeDistanceDisplayConditionAndDepthDisable);const b=v.length;if(s=this._vaf.writers,r/n>.1){for(let D=0;D<r;++D){const I=i[D];I._dirty=!1;for(let L=0;L<b;++L)v[L](this,l,s,I)}this._vaf.commit()}else{for(let D=0;D<r;++D){const I=i[D];I._dirty=!1;for(let L=0;L<b;++L)v[L](this,l,s,I);this._vaf.subCommit(I._index,1)}this._vaf.endSubCommits()}this._pointPrimitivesToUpdateIndex=0}if(r>n*1.5&&(i.length=n),!defined(this._vaf)||!defined(this._vaf.va))return;this._boundingVolumeDirty&&(this._boundingVolumeDirty=!1,BoundingSphere.transform(this._baseVolume,this.modelMatrix,this._baseVolumeWC));let h,f=Matrix4.IDENTITY;e.mode===SceneMode.SCENE3D?(f=this.modelMatrix,h=BoundingSphere.clone(this._baseVolumeWC,this._boundingVolume)):h=BoundingSphere.clone(this._baseVolume2D,this._boundingVolume),updateBoundingVolume(this,e,h);const p=this._blendOption!==this.blendOption;this._blendOption=this.blendOption,p&&(this._blendOption===BlendOption.OPAQUE||this._blendOption===BlendOption.OPAQUE_AND_TRANSLUCENT?this._rsOpaque=RenderState.fromCache({depthTest:{enabled:!0,func:WebGLConstants.LEQUAL},depthMask:!0}):this._rsOpaque=void 0,this._blendOption===BlendOption.TRANSLUCENT||this._blendOption===BlendOption.OPAQUE_AND_TRANSLUCENT?this._rsTranslucent=RenderState.fromCache({depthTest:{enabled:!0,func:WebGLConstants.LEQUAL},depthMask:!1,blending:BlendingState.ALPHA_BLEND}):this._rsTranslucent=void 0),this._shaderDisableDepthDistance=this._shaderDisableDepthDistance||e.minimumDisableDepthTestDistance!==0;let u,m;(p||this._shaderScaleByDistance&&!this._compiledShaderScaleByDistance||this._shaderTranslucencyByDistance&&!this._compiledShaderTranslucencyByDistance||this._shaderDistanceDisplayCondition&&!this._compiledShaderDistanceDisplayCondition||this._shaderDisableDepthDistance!==this._compiledShaderDisableDepthDistance)&&(u=new ShaderSource({sources:[PointPrimitiveCollectionVS]}),this._shaderScaleByDistance&&u.defines.push("EYE_DISTANCE_SCALING"),this._shaderTranslucencyByDistance&&u.defines.push("EYE_DISTANCE_TRANSLUCENCY"),this._shaderDistanceDisplayCondition&&u.defines.push("DISTANCE_DISPLAY_CONDITION"),this._shaderDisableDepthDistance&&u.defines.push("DISABLE_DEPTH_DISTANCE"),this._blendOption===BlendOption.OPAQUE_AND_TRANSLUCENT&&(m=new ShaderSource({defines:["OPAQUE"],sources:[PointPrimitiveCollectionFS]}),this._sp=ShaderProgram.replaceCache({context:l,shaderProgram:this._sp,vertexShaderSource:u,fragmentShaderSource:m,attributeLocations:attributeLocations$2}),m=new ShaderSource({defines:["TRANSLUCENT"],sources:[PointPrimitiveCollectionFS]}),this._spTranslucent=ShaderProgram.replaceCache({context:l,shaderProgram:this._spTranslucent,vertexShaderSource:u,fragmentShaderSource:m,attributeLocations:attributeLocations$2})),this._blendOption===BlendOption.OPAQUE&&(m=new ShaderSource({sources:[PointPrimitiveCollectionFS]}),this._sp=ShaderProgram.replaceCache({context:l,shaderProgram:this._sp,vertexShaderSource:u,fragmentShaderSource:m,attributeLocations:attributeLocations$2})),this._blendOption===BlendOption.TRANSLUCENT&&(m=new ShaderSource({sources:[PointPrimitiveCollectionFS]}),this._spTranslucent=ShaderProgram.replaceCache({context:l,shaderProgram:this._spTranslucent,vertexShaderSource:u,fragmentShaderSource:m,attributeLocations:attributeLocations$2})),this._compiledShaderScaleByDistance=this._shaderScaleByDistance,this._compiledShaderTranslucencyByDistance=this._shaderTranslucencyByDistance,this._compiledShaderDistanceDisplayCondition=this._shaderDistanceDisplayCondition,this._compiledShaderDisableDepthDistance=this._shaderDisableDepthDistance);let g,_,C,A;const S=e.commandList;if(c.render||d){const v=this._colorCommands,b=this._blendOption===BlendOption.OPAQUE,D=this._blendOption===BlendOption.OPAQUE_AND_TRANSLUCENT;g=this._vaf.va,_=g.length,v.length=_;const I=D?_*2:_;for(A=0;A<I;++A){const L=b||D&&A%2===0;C=v[A],defined(C)||(C=v[A]=new DrawCommand),C.primitiveType=PrimitiveType.POINTS,C.pass=L||!D?Pass.OPAQUE:Pass.TRANSLUCENT,C.owner=this;const N=D?Math.floor(A/2):A;C.boundingVolume=h,C.modelMatrix=f,C.shaderProgram=L?this._sp:this._spTranslucent,C.uniformMap=this._uniforms,C.vertexArray=g[N].va,C.renderState=L?this._rsOpaque:this._rsTranslucent,C.debugShowBoundingVolume=this.debugShowBoundingVolume,C.pickId="v_pickColor",S.push(C)}}};PointPrimitiveCollection.prototype.isDestroyed=function(){return!1};PointPrimitiveCollection.prototype.destroy=function(){return this._sp=this._sp&&this._sp.destroy(),this._spTranslucent=this._spTranslucent&&this._spTranslucent.destroy(),this._spPick=this._spPick&&this._spPick.destroy(),this._vaf=this._vaf&&this._vaf.destroy(),destroyPointPrimitives(this._pointPrimitives),destroyObject(this)};const ARRAY_TYPES=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],VERSION$1=1,HEADER_SIZE=8;class KDBush{static from(t){if(!(t instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[n,i]=new Uint8Array(t,0,2);if(n!==219)throw new Error("Data does not appear to be in a KDBush format.");const r=i>>4;if(r!==VERSION$1)throw new Error(`Got v${r} data when expected v${VERSION$1}.`);const o=ARRAY_TYPES[i&15];if(!o)throw new Error("Unrecognized array type.");const[a]=new Uint16Array(t,2,1),[s]=new Uint32Array(t,4,1);return new KDBush(s,a,o,t)}constructor(t,n=64,i=Float64Array,r){if(isNaN(t)||t<0)throw new Error(`Unpexpected numItems value: ${t}.`);this.numItems=+t,this.nodeSize=Math.min(Math.max(+n,2),65535),this.ArrayType=i,this.IndexArrayType=t<65536?Uint16Array:Uint32Array;const o=ARRAY_TYPES.indexOf(this.ArrayType),a=t*2*this.ArrayType.BYTES_PER_ELEMENT,s=t*this.IndexArrayType.BYTES_PER_ELEMENT,l=(8-s%8)%8;if(o<0)throw new Error(`Unexpected typed array class: ${i}.`);r&&r instanceof ArrayBuffer?(this.data=r,this.ids=new this.IndexArrayType(this.data,HEADER_SIZE,t),this.coords=new this.ArrayType(this.data,HEADER_SIZE+s+l,t*2),this._pos=t*2,this._finished=!0):(this.data=new ArrayBuffer(HEADER_SIZE+a+s+l),this.ids=new this.IndexArrayType(this.data,HEADER_SIZE,t),this.coords=new this.ArrayType(this.data,HEADER_SIZE+s+l,t*2),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,(VERSION$1<<4)+o]),new Uint16Array(this.data,2,1)[0]=n,new Uint32Array(this.data,4,1)[0]=t)}add(t,n){const i=this._pos>>1;return this.ids[i]=i,this.coords[this._pos++]=t,this.coords[this._pos++]=n,i}finish(){const t=this._pos>>1;if(t!==this.numItems)throw new Error(`Added ${t} items when expected ${this.numItems}.`);return sort$1(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(t,n,i,r){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:o,coords:a,nodeSize:s}=this,l=[0,o.length-1,0],c=[];for(;l.length;){const d=l.pop()||0,h=l.pop()||0,f=l.pop()||0;if(h-f<=s){for(let g=f;g<=h;g++){const _=a[2*g],C=a[2*g+1];_>=t&&_<=i&&C>=n&&C<=r&&c.push(o[g])}continue}const p=f+h>>1,u=a[2*p],m=a[2*p+1];u>=t&&u<=i&&m>=n&&m<=r&&c.push(o[p]),(d===0?t<=u:n<=m)&&(l.push(f),l.push(p-1),l.push(1-d)),(d===0?i>=u:r>=m)&&(l.push(p+1),l.push(h),l.push(1-d))}return c}within(t,n,i){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:r,coords:o,nodeSize:a}=this,s=[0,r.length-1,0],l=[],c=i*i;for(;s.length;){const d=s.pop()||0,h=s.pop()||0,f=s.pop()||0;if(h-f<=a){for(let g=f;g<=h;g++)sqDist(o[2*g],o[2*g+1],t,n)<=c&&l.push(r[g]);continue}const p=f+h>>1,u=o[2*p],m=o[2*p+1];sqDist(u,m,t,n)<=c&&l.push(r[p]),(d===0?t-i<=u:n-i<=m)&&(s.push(f),s.push(p-1),s.push(1-d)),(d===0?t+i>=u:n+i>=m)&&(s.push(p+1),s.push(h),s.push(1-d))}return l}}function sort$1(e,t,n,i,r,o){if(r-i<=n)return;const a=i+r>>1;select(e,t,a,i,r,o),sort$1(e,t,n,i,a-1,1-o),sort$1(e,t,n,a+1,r,1-o)}function select(e,t,n,i,r,o){for(;r>i;){if(r-i>600){const c=r-i+1,d=n-i+1,h=Math.log(c),f=.5*Math.exp(2*h/3),p=.5*Math.sqrt(h*f*(c-f)/c)*(d-c/2<0?-1:1),u=Math.max(i,Math.floor(n-d*f/c+p)),m=Math.min(r,Math.floor(n+(c-d)*f/c+p));select(e,t,n,u,m,o)}const a=t[2*n+o];let s=i,l=r;for(swapItem(e,t,i,n),t[2*r+o]>a&&swapItem(e,t,i,r);s<l;){for(swapItem(e,t,s,l),s++,l--;t[2*s+o]<a;)s++;for(;t[2*l+o]>a;)l--}t[2*i+o]===a?swapItem(e,t,i,l):(l++,swapItem(e,t,l,r)),l<=n&&(i=l+1),n<=l&&(r=l-1)}}function swapItem(e,t,n,i){swap$1(e,n,i),swap$1(t,2*n,2*i),swap$1(t,2*n+1,2*i+1)}function swap$1(e,t,n){const i=e[t];e[t]=e[n],e[n]=i}function sqDist(e,t,n,i){const r=e-n,o=t-i;return r*r+o*o}function EntityCluster(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._enabled=defaultValue(e.enabled,!1),this._pixelRange=defaultValue(e.pixelRange,80),this._minimumClusterSize=defaultValue(e.minimumClusterSize,2),this._clusterBillboards=defaultValue(e.clusterBillboards,!0),this._clusterLabels=defaultValue(e.clusterLabels,!0),this._clusterPoints=defaultValue(e.clusterPoints,!0),this._labelCollection=void 0,this._billboardCollection=void 0,this._pointCollection=void 0,this._clusterBillboardCollection=void 0,this._clusterLabelCollection=void 0,this._clusterPointCollection=void 0,this._collectionIndicesByEntity={},this._unusedLabelIndices=[],this._unusedBillboardIndices=[],this._unusedPointIndices=[],this._previousClusters=[],this._previousHeight=void 0,this._enabledDirty=!1,this._clusterDirty=!1,this._cluster=void 0,this._removeEventListener=void 0,this._clusterEvent=new Event,this.show=defaultValue(e.show,!0)}function expandBoundingBox(e,t){e.x-=t,e.y-=t,e.width+=t*2,e.height+=t*2}const labelBoundingBoxScratch=new BoundingRectangle;function getBoundingBox(e,t,n,i,r){if(defined(e._labelCollection)&&i._clusterLabels?r=Label.getScreenSpaceBoundingBox(e,t,r):defined(e._billboardCollection)&&i._clusterBillboards?r=Billboard.getScreenSpaceBoundingBox(e,t,r):defined(e._pointPrimitiveCollection)&&i._clusterPoints&&(r=PointPrimitive.getScreenSpaceBoundingBox(e,t,r)),expandBoundingBox(r,n),i._clusterLabels&&!defined(e._labelCollection)&&defined(e.id)&&hasLabelIndex(i,e.id.id)&&defined(e.id._label)){const o=i._collectionIndicesByEntity[e.id.id].labelIndex,a=i._labelCollection.get(o),s=Label.getScreenSpaceBoundingBox(a,t,labelBoundingBoxScratch);expandBoundingBox(s,n),r=BoundingRectangle.union(r,s,r)}return r}function addNonClusteredItem(e,t){if(e.clusterShow=!0,!defined(e._labelCollection)&&defined(e.id)&&hasLabelIndex(t,e.id.id)&&defined(e.id._label)){const n=t._collectionIndicesByEntity[e.id.id].labelIndex,i=t._labelCollection.get(n);i.clusterShow=!0}}function addCluster(e,t,n,i){const r={billboard:i._clusterBillboardCollection.add(),label:i._clusterLabelCollection.add(),point:i._clusterPointCollection.add()};r.billboard.show=!1,r.point.show=!1,r.label.show=!0,r.label.text=t.toLocaleString(),r.label.id=n,r.billboard.position=r.label.position=r.point.position=e,i._clusterEvent.raiseEvent(n,r)}function hasLabelIndex(e,t){return defined(e)&&defined(e._collectionIndicesByEntity[t])&&defined(e._collectionIndicesByEntity[t].labelIndex)}function getScreenSpacePositions(e,t,n,i,r){if(!defined(e))return;const o=e.length;for(let a=0;a<o;++a){const s=e.get(a);if(s.clusterShow=!1,!s.show||r._scene.mode===SceneMode.SCENE3D&&!i.isPointVisible(s.position))continue;const l=r._clusterLabels&&defined(s._labelCollection),c=r._clusterBillboards&&defined(s.id._billboard),d=r._clusterPoints&&defined(s.id._point);if(l&&(d||c))continue;const h=s.computeScreenSpacePosition(n);defined(h)&&t.push({index:a,collection:e,clustered:!1,coord:h})}}const pointBoundinRectangleScratch=new BoundingRectangle,totalBoundingRectangleScratch=new BoundingRectangle,neighborBoundingRectangleScratch=new BoundingRectangle;function createDeclutterCallback(e){return function(t){if(defined(t)&&t<.05||!e.enabled)return;const n=e._scene,i=e._labelCollection,r=e._billboardCollection,o=e._pointCollection;if(!defined(i)&&!defined(r)&&!defined(o)||!e._clusterBillboards&&!e._clusterLabels&&!e._clusterPoints)return;let a=e._clusterLabelCollection,s=e._clusterBillboardCollection,l=e._clusterPointCollection;defined(a)?a.removeAll():a=e._clusterLabelCollection=new LabelCollection({scene:n}),defined(s)?s.removeAll():s=e._clusterBillboardCollection=new BillboardCollection({scene:n}),defined(l)?l.removeAll():l=e._clusterPointCollection=new PointPrimitiveCollection;const c=e._pixelRange,d=e._minimumClusterSize,h=e._previousClusters,f=[],p=e._previousHeight,u=n.camera.positionCartographic.height,m=n.ellipsoid,g=n.camera.positionWC,_=new EllipsoidalOccluder(m,g),C=[];e._clusterLabels&&getScreenSpacePositions(i,C,n,_,e),e._clusterBillboards&&getScreenSpacePositions(r,C,n,_,e),e._clusterPoints&&getScreenSpacePositions(o,C,n,_,e);let A,S,v,b,D,I,L,N,y,x,T,E;if(C.length>0){const P=new KDBush(C.length,64,Uint32Array);for(let M=0;M<C.length;++M)P.add(C[M].coord.x,C[M].coord.y);if(P.finish(),u<p)for(v=h.length,A=0;A<v;++A){const M=h[A];if(!_.isPointVisible(M.position))continue;const O=Billboard._computeScreenSpacePosition(Matrix4.IDENTITY,M.position,Cartesian3.ZERO,Cartesian2.ZERO,n);if(!defined(O))continue;const V=1-u/p;let R=M.width=M.width*V,w=M.height=M.height*V;R=Math.max(R,M.minimumWidth),w=Math.max(w,M.minimumHeight);const U=O.x-R*.5,k=O.y-w*.5,H=O.x+R,F=O.y+w;for(D=P.range(U,k,H,F),I=D.length,x=0,y=[],S=0;S<I;++S)L=D[S],N=C[L],N.clustered||(++x,T=N.collection,E=N.index,y.push(T.get(E).id));if(x>=d)for(addCluster(M.position,x,y,e),f.push(M),S=0;S<I;++S)C[D[S]].clustered=!0}for(v=C.length,A=0;A<v;++A){const M=C[A];if(M.clustered)continue;M.clustered=!0,T=M.collection,E=M.index;const O=T.get(E);b=getBoundingBox(O,M.coord,c,e,pointBoundinRectangleScratch);const V=BoundingRectangle.clone(b,totalBoundingRectangleScratch);D=P.range(b.x,b.y,b.x+b.width,b.y+b.height),I=D.length;const R=Cartesian3.clone(O.position);for(x=1,y=[O.id],S=0;S<I;++S)if(L=D[S],N=C[L],!N.clustered){const w=N.collection.get(N.index),U=getBoundingBox(w,N.coord,c,e,neighborBoundingRectangleScratch);Cartesian3.add(w.position,R,R),BoundingRectangle.union(V,U,V),++x,y.push(w.id)}if(x>=d){const w=Cartesian3.multiplyByScalar(R,1/x,R);for(addCluster(w,x,y,e),f.push({position:w,width:V.width,height:V.height,minimumWidth:b.width,minimumHeight:b.height}),S=0;S<I;++S)C[D[S]].clustered=!0}else addNonClusteredItem(O,e)}}a.length===0&&(a.destroy(),e._clusterLabelCollection=void 0),s.length===0&&(s.destroy(),e._clusterBillboardCollection=void 0),l.length===0&&(l.destroy(),e._clusterPointCollection=void 0),e._previousClusters=f,e._previousHeight=u}}EntityCluster.prototype._initialize=function(e){this._scene=e;const t=createDeclutterCallback(this);this._cluster=t,this._removeEventListener=e.camera.changed.addEventListener(t)};Object.defineProperties(EntityCluster.prototype,{enabled:{get:function(){return this._enabled},set:function(e){this._enabledDirty=e!==this._enabled,this._enabled=e}},pixelRange:{get:function(){return this._pixelRange},set:function(e){this._clusterDirty=this._clusterDirty||e!==this._pixelRange,this._pixelRange=e}},minimumClusterSize:{get:function(){return this._minimumClusterSize},set:function(e){this._clusterDirty=this._clusterDirty||e!==this._minimumClusterSize,this._minimumClusterSize=e}},clusterEvent:{get:function(){return this._clusterEvent}},clusterBillboards:{get:function(){return this._clusterBillboards},set:function(e){this._clusterDirty=this._clusterDirty||e!==this._clusterBillboards,this._clusterBillboards=e}},clusterLabels:{get:function(){return this._clusterLabels},set:function(e){this._clusterDirty=this._clusterDirty||e!==this._clusterLabels,this._clusterLabels=e}},clusterPoints:{get:function(){return this._clusterPoints},set:function(e){this._clusterDirty=this._clusterDirty||e!==this._clusterPoints,this._clusterPoints=e}}});function createGetEntity(e,t,n,i){return function(r){let o=this[e];defined(this._collectionIndicesByEntity)||(this._collectionIndicesByEntity={});let a=this._collectionIndicesByEntity[r.id];if(defined(a)||(a=this._collectionIndicesByEntity[r.id]={billboardIndex:void 0,labelIndex:void 0,pointIndex:void 0}),defined(o)&&defined(a[i]))return o.get(a[i]);defined(o)||(o=this[e]=new t({scene:this._scene}));let s,l;const c=this[n];c.length>0?(s=c.shift(),l=o.get(s)):(l=o.add(),s=o.length-1),a[i]=s;const d=this;return Promise.resolve().then(function(){d._clusterDirty=!0}),l}}function removeEntityIndicesIfUnused(e,t){const n=e._collectionIndicesByEntity[t];!defined(n.billboardIndex)&&!defined(n.labelIndex)&&!defined(n.pointIndex)&&delete e._collectionIndicesByEntity[t]}EntityCluster.prototype.getLabel=createGetEntity("_labelCollection",LabelCollection,"_unusedLabelIndices","labelIndex");EntityCluster.prototype.removeLabel=function(e){const t=this._collectionIndicesByEntity&&this._collectionIndicesByEntity[e.id];if(!defined(this._labelCollection)||!defined(t)||!defined(t.labelIndex))return;const n=t.labelIndex;t.labelIndex=void 0,removeEntityIndicesIfUnused(this,e.id);const i=this._labelCollection.get(n);i.show=!1,i.text="",i.id=void 0,this._unusedLabelIndices.push(n),this._clusterDirty=!0};EntityCluster.prototype.getBillboard=createGetEntity("_billboardCollection",BillboardCollection,"_unusedBillboardIndices","billboardIndex");EntityCluster.prototype.removeBillboard=function(e){const t=this._collectionIndicesByEntity&&this._collectionIndicesByEntity[e.id];if(!defined(this._billboardCollection)||!defined(t)||!defined(t.billboardIndex))return;const n=t.billboardIndex;t.billboardIndex=void 0,removeEntityIndicesIfUnused(this,e.id);const i=this._billboardCollection.get(n);i.id=void 0,i.show=!1,i.image=void 0,this._unusedBillboardIndices.push(n),this._clusterDirty=!0};EntityCluster.prototype.getPoint=createGetEntity("_pointCollection",PointPrimitiveCollection,"_unusedPointIndices","pointIndex");EntityCluster.prototype.removePoint=function(e){const t=this._collectionIndicesByEntity&&this._collectionIndicesByEntity[e.id];if(!defined(this._pointCollection)||!defined(t)||!defined(t.pointIndex))return;const n=t.pointIndex;t.pointIndex=void 0,removeEntityIndicesIfUnused(this,e.id);const i=this._pointCollection.get(n);i.show=!1,i.id=void 0,this._unusedPointIndices.push(n),this._clusterDirty=!0};function disableCollectionClustering(e){if(!defined(e))return;const t=e.length;for(let n=0;n<t;++n)e.get(n).clusterShow=!0}function updateEnable(e){e.enabled||(defined(e._clusterLabelCollection)&&e._clusterLabelCollection.destroy(),defined(e._clusterBillboardCollection)&&e._clusterBillboardCollection.destroy(),defined(e._clusterPointCollection)&&e._clusterPointCollection.destroy(),e._clusterLabelCollection=void 0,e._clusterBillboardCollection=void 0,e._clusterPointCollection=void 0,disableCollectionClustering(e._labelCollection),disableCollectionClustering(e._billboardCollection),disableCollectionClustering(e._pointCollection))}EntityCluster.prototype.update=function(e){if(!this.show)return;let t;defined(this._labelCollection)&&this._labelCollection.length>0&&this._labelCollection.get(0)._glyphs.length===0&&(t=e.commandList,e.commandList=[],this._labelCollection.update(e),e.commandList=t),defined(this._billboardCollection)&&this._billboardCollection.length>0&&!defined(this._billboardCollection.get(0).width)&&(t=e.commandList,e.commandList=[],this._billboardCollection.update(e),e.commandList=t),this._enabledDirty&&(this._enabledDirty=!1,updateEnable(this),this._clusterDirty=!0),this._clusterDirty&&(this._clusterDirty=!1,this._cluster()),defined(this._clusterLabelCollection)&&this._clusterLabelCollection.update(e),defined(this._clusterBillboardCollection)&&this._clusterBillboardCollection.update(e),defined(this._clusterPointCollection)&&this._clusterPointCollection.update(e),defined(this._labelCollection)&&this._labelCollection.update(e),defined(this._billboardCollection)&&this._billboardCollection.update(e),defined(this._pointCollection)&&this._pointCollection.update(e)};EntityCluster.prototype.destroy=function(){this._labelCollection=this._labelCollection&&this._labelCollection.destroy(),this._billboardCollection=this._billboardCollection&&this._billboardCollection.destroy(),this._pointCollection=this._pointCollection&&this._pointCollection.destroy(),this._clusterLabelCollection=this._clusterLabelCollection&&this._clusterLabelCollection.destroy(),this._clusterBillboardCollection=this._clusterBillboardCollection&&this._clusterBillboardCollection.destroy(),this._clusterPointCollection=this._clusterPointCollection&&this._clusterPointCollection.destroy(),defined(this._removeEventListener)&&(this._removeEventListener(),this._removeEventListener=void 0),this._labelCollection=void 0,this._billboardCollection=void 0,this._pointCollection=void 0,this._clusterBillboardCollection=void 0,this._clusterLabelCollection=void 0,this._clusterPointCollection=void 0,this._collectionIndicesByEntity=void 0,this._unusedLabelIndices=[],this._unusedBillboardIndices=[],this._unusedPointIndices=[],this._previousClusters=[],this._previousHeight=void 0,this._enabledDirty=!1,this._pixelRangeDirty=!1,this._minimumClusterSizeDirty=!1};function CustomDataSource(e){this._name=e,this._clock=void 0,this._changed=new Event,this._error=new Event,this._isLoading=!1,this._loading=new Event,this._entityCollection=new EntityCollection(this),this._entityCluster=new EntityCluster}Object.defineProperties(CustomDataSource.prototype,{name:{get:function(){return this._name},set:function(e){this._name!==e&&(this._name=e,this._changed.raiseEvent(this))}},clock:{get:function(){return this._clock},set:function(e){this._clock!==e&&(this._clock=e,this._changed.raiseEvent(this))}},entities:{get:function(){return this._entityCollection}},isLoading:{get:function(){return this._isLoading},set:function(e){DataSource.setLoading(this,e)}},changedEvent:{get:function(){return this._changed}},errorEvent:{get:function(){return this._error}},loadingEvent:{get:function(){return this._loading}},show:{get:function(){return this._entityCollection.show},set:function(e){this._entityCollection.show=e}},clustering:{get:function(){return this._entityCluster},set:function(e){if(!defined(e))throw new DeveloperError("value must be defined.");this._entityCluster=e}}});CustomDataSource.prototype.update=function(e){return!0};const CylinderGeometryLibrary={};CylinderGeometryLibrary.computePositions=function(e,t,n,i,r){const o=e*.5,a=-o,s=i+i,l=r?2*s:s,c=new Float64Array(l*3);let d,h=0,f=0;const p=r?s*3:0,u=r?(s+i)*3:i*3;for(d=0;d<i;d++){const m=d/i*CesiumMath.TWO_PI,g=Math.cos(m),_=Math.sin(m),C=g*n,A=_*n,S=g*t,v=_*t;c[f+p]=C,c[f+p+1]=A,c[f+p+2]=a,c[f+u]=S,c[f+u+1]=v,c[f+u+2]=o,f+=3,r&&(c[h++]=C,c[h++]=A,c[h++]=a,c[h++]=S,c[h++]=v,c[h++]=o)}return c};const CylinderGeometryLibrary$1=CylinderGeometryLibrary,radiusScratch$1=new Cartesian2,normalScratch$3=new Cartesian3,bitangentScratch$1=new Cartesian3,tangentScratch$1=new Cartesian3,positionScratch$6=new Cartesian3;function CylinderGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.length,n=e.topRadius,i=e.bottomRadius,r=defaultValue(e.vertexFormat,VertexFormat.DEFAULT),o=defaultValue(e.slices,128);if(!defined(t))throw new DeveloperError("options.length must be defined.");if(!defined(n))throw new DeveloperError("options.topRadius must be defined.");if(!defined(i))throw new DeveloperError("options.bottomRadius must be defined.");if(o<3)throw new DeveloperError("options.slices must be greater than or equal to 3.");if(defined(e.offsetAttribute)&&e.offsetAttribute===GeometryOffsetAttribute.TOP)throw new DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=t,this._topRadius=n,this._bottomRadius=i,this._vertexFormat=VertexFormat.clone(r),this._slices=o,this._offsetAttribute=e.offsetAttribute,this._workerName="createCylinderGeometry"}CylinderGeometry.packedLength=VertexFormat.packedLength+5;CylinderGeometry.pack=function(e,t,n){if(!defined(e))throw new DeveloperError("value is required");if(!defined(t))throw new DeveloperError("array is required");return n=defaultValue(n,0),VertexFormat.pack(e._vertexFormat,t,n),n+=VertexFormat.packedLength,t[n++]=e._length,t[n++]=e._topRadius,t[n++]=e._bottomRadius,t[n++]=e._slices,t[n]=defaultValue(e._offsetAttribute,-1),t};const scratchVertexFormat$9=new VertexFormat,scratchOptions$f={vertexFormat:scratchVertexFormat$9,length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,offsetAttribute:void 0};CylinderGeometry.unpack=function(e,t,n){if(!defined(e))throw new DeveloperError("array is required");t=defaultValue(t,0);const i=VertexFormat.unpack(e,t,scratchVertexFormat$9);t+=VertexFormat.packedLength;const r=e[t++],o=e[t++],a=e[t++],s=e[t++],l=e[t];return defined(n)?(n._vertexFormat=VertexFormat.clone(i,n._vertexFormat),n._length=r,n._topRadius=o,n._bottomRadius=a,n._slices=s,n._offsetAttribute=l===-1?void 0:l,n):(scratchOptions$f.length=r,scratchOptions$f.topRadius=o,scratchOptions$f.bottomRadius=a,scratchOptions$f.slices=s,scratchOptions$f.offsetAttribute=l===-1?void 0:l,new CylinderGeometry(scratchOptions$f))};CylinderGeometry.createGeometry=function(e){let t=e._length;const n=e._topRadius,i=e._bottomRadius,r=e._vertexFormat,o=e._slices;if(t<=0||n<0||i<0||n===0&&i===0)return;const a=o+o,s=o+a,l=a+a,c=CylinderGeometryLibrary$1.computePositions(t,n,i,o,!0),d=r.st?new Float32Array(l*2):void 0,h=r.normal?new Float32Array(l*3):void 0,f=r.tangent?new Float32Array(l*3):void 0,p=r.bitangent?new Float32Array(l*3):void 0;let u;const m=r.normal||r.tangent||r.bitangent;if(m){const D=r.tangent||r.bitangent;let I=0,L=0,N=0;const y=Math.atan2(i-n,t),x=normalScratch$3;x.z=Math.sin(y);const T=Math.cos(y);let E=tangentScratch$1,P=bitangentScratch$1;for(u=0;u<o;u++){const M=u/o*CesiumMath.TWO_PI,O=T*Math.cos(M),V=T*Math.sin(M);m&&(x.x=O,x.y=V,D&&(E=Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z,x,E),E)),r.normal&&(h[I++]=x.x,h[I++]=x.y,h[I++]=x.z,h[I++]=x.x,h[I++]=x.y,h[I++]=x.z),r.tangent&&(f[L++]=E.x,f[L++]=E.y,f[L++]=E.z,f[L++]=E.x,f[L++]=E.y,f[L++]=E.z),r.bitangent&&(P=Cartesian3.normalize(Cartesian3.cross(x,E,P),P),p[N++]=P.x,p[N++]=P.y,p[N++]=P.z,p[N++]=P.x,p[N++]=P.y,p[N++]=P.z))}for(u=0;u<o;u++)r.normal&&(h[I++]=0,h[I++]=0,h[I++]=-1),r.tangent&&(f[L++]=1,f[L++]=0,f[L++]=0),r.bitangent&&(p[N++]=0,p[N++]=-1,p[N++]=0);for(u=0;u<o;u++)r.normal&&(h[I++]=0,h[I++]=0,h[I++]=1),r.tangent&&(f[L++]=1,f[L++]=0,f[L++]=0),r.bitangent&&(p[N++]=0,p[N++]=1,p[N++]=0)}const g=12*o-12,_=IndexDatatype.createTypedArray(l,g);let C=0,A=0;for(u=0;u<o-1;u++)_[C++]=A,_[C++]=A+2,_[C++]=A+3,_[C++]=A,_[C++]=A+3,_[C++]=A+1,A+=2;for(_[C++]=a-2,_[C++]=0,_[C++]=1,_[C++]=a-2,_[C++]=1,_[C++]=a-1,u=1;u<o-1;u++)_[C++]=a+u+1,_[C++]=a+u,_[C++]=a;for(u=1;u<o-1;u++)_[C++]=s,_[C++]=s+u,_[C++]=s+u+1;let S=0;if(r.st){const D=Math.max(n,i);for(u=0;u<l;u++){const I=Cartesian3.fromArray(c,u*3,positionScratch$6);d[S++]=(I.x+D)/(2*D),d[S++]=(I.y+D)/(2*D)}}const v=new GeometryAttributes;r.position&&(v.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})),r.normal&&(v.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:h})),r.tangent&&(v.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:f})),r.bitangent&&(v.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),r.st&&(v.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:d})),radiusScratch$1.x=t*.5,radiusScratch$1.y=Math.max(i,n);const b=new BoundingSphere(Cartesian3.ZERO,Cartesian2.magnitude(radiusScratch$1));if(defined(e._offsetAttribute)){t=c.length;const D=e._offsetAttribute===GeometryOffsetAttribute.NONE?0:1,I=new Uint8Array(t/3).fill(D);v.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:I})}return new Geometry({attributes:v,indices:_,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:b,offsetAttribute:e._offsetAttribute})};let unitCylinderGeometry;CylinderGeometry.getUnitCylinder=function(){return defined(unitCylinderGeometry)||(unitCylinderGeometry=CylinderGeometry.createGeometry(new CylinderGeometry({topRadius:1,bottomRadius:1,length:1,vertexFormat:VertexFormat.POSITION_ONLY}))),unitCylinderGeometry};const radiusScratch=new Cartesian2;function CylinderOutlineGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.length,n=e.topRadius,i=e.bottomRadius,r=defaultValue(e.slices,128),o=Math.max(defaultValue(e.numberOfVerticalLines,16),0);if(Check.typeOf.number("options.positions",t),Check.typeOf.number("options.topRadius",n),Check.typeOf.number("options.bottomRadius",i),Check.typeOf.number.greaterThanOrEquals("options.slices",r,3),defined(e.offsetAttribute)&&e.offsetAttribute===GeometryOffsetAttribute.TOP)throw new DeveloperError("GeometryOffsetAttribute.TOP is not a supported options.offsetAttribute for this geometry.");this._length=t,this._topRadius=n,this._bottomRadius=i,this._slices=r,this._numberOfVerticalLines=o,this._offsetAttribute=e.offsetAttribute,this._workerName="createCylinderOutlineGeometry"}CylinderOutlineGeometry.packedLength=6;CylinderOutlineGeometry.pack=function(e,t,n){return Check.typeOf.object("value",e),Check.defined("array",t),n=defaultValue(n,0),t[n++]=e._length,t[n++]=e._topRadius,t[n++]=e._bottomRadius,t[n++]=e._slices,t[n++]=e._numberOfVerticalLines,t[n]=defaultValue(e._offsetAttribute,-1),t};const scratchOptions$e={length:void 0,topRadius:void 0,bottomRadius:void 0,slices:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};CylinderOutlineGeometry.unpack=function(e,t,n){Check.defined("array",e),t=defaultValue(t,0);const i=e[t++],r=e[t++],o=e[t++],a=e[t++],s=e[t++],l=e[t];return defined(n)?(n._length=i,n._topRadius=r,n._bottomRadius=o,n._slices=a,n._numberOfVerticalLines=s,n._offsetAttribute=l===-1?void 0:l,n):(scratchOptions$e.length=i,scratchOptions$e.topRadius=r,scratchOptions$e.bottomRadius=o,scratchOptions$e.slices=a,scratchOptions$e.numberOfVerticalLines=s,scratchOptions$e.offsetAttribute=l===-1?void 0:l,new CylinderOutlineGeometry(scratchOptions$e))};CylinderOutlineGeometry.createGeometry=function(e){let t=e._length;const n=e._topRadius,i=e._bottomRadius,r=e._slices,o=e._numberOfVerticalLines;if(t<=0||n<0||i<0||n===0&&i===0)return;const a=r*2,s=CylinderGeometryLibrary$1.computePositions(t,n,i,r,!1);let l=r*2,c;if(o>0){const m=Math.min(o,r);c=Math.round(r/m),l+=m}const d=IndexDatatype.createTypedArray(a,l*2);let h=0,f;for(f=0;f<r-1;f++)d[h++]=f,d[h++]=f+1,d[h++]=f+r,d[h++]=f+1+r;if(d[h++]=r-1,d[h++]=0,d[h++]=r+r-1,d[h++]=r,o>0)for(f=0;f<r;f+=c)d[h++]=f,d[h++]=f+r;const p=new GeometryAttributes;p.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:s}),radiusScratch.x=t*.5,radiusScratch.y=Math.max(i,n);const u=new BoundingSphere(Cartesian3.ZERO,Cartesian2.magnitude(radiusScratch));if(defined(e._offsetAttribute)){t=s.length;const m=e._offsetAttribute===GeometryOffsetAttribute.NONE?0:1,g=new Uint8Array(t/3).fill(m);p.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:g})}return new Geometry({attributes:p,indices:d,primitiveType:PrimitiveType.LINES,boundingSphere:u,offsetAttribute:e._offsetAttribute})};const defaultOffset$8=Cartesian3.ZERO,offsetScratch$7=new Cartesian3,positionScratch$5=new Cartesian3,scratchColor$e=new Color;function CylinderGeometryOptions(e){this.id=e,this.vertexFormat=void 0,this.length=void 0,this.topRadius=void 0,this.bottomRadius=void 0,this.slices=void 0,this.numberOfVerticalLines=void 0,this.offsetAttribute=void 0}function CylinderGeometryUpdater(e,t){GeometryUpdater.call(this,{entity:e,scene:t,geometryOptions:new CylinderGeometryOptions(e),geometryPropertyName:"cylinder",observedPropertyNames:["availability","position","orientation","cylinder"]}),this._onEntityPropertyChanged(e,"cylinder",e.cylinder,void 0)}defined(Object.create)&&(CylinderGeometryUpdater.prototype=Object.create(GeometryUpdater.prototype),CylinderGeometryUpdater.prototype.constructor=CylinderGeometryUpdater);Object.defineProperties(CylinderGeometryUpdater.prototype,{terrainOffsetProperty:{get:function(){return this._terrainOffsetProperty}}});CylinderGeometryUpdater.prototype.createFillGeometryInstance=function(e){if(Check.defined("time",e),!this._fillEnabled)throw new DeveloperError("This instance does not represent a filled geometry.");const t=this._entity,n=t.isAvailable(e),i=new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._fillProperty.getValue(e)),r=this._distanceDisplayConditionProperty.getValue(e),o=DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(r),a={show:i,distanceDisplayCondition:o,color:void 0,offset:void 0};if(this._materialProperty instanceof ColorMaterialProperty){let s;defined(this._materialProperty.color)&&(this._materialProperty.color.isConstant||n)&&(s=this._materialProperty.color.getValue(e,scratchColor$e)),defined(s)||(s=Color.WHITE),a.color=ColorGeometryInstanceAttribute.fromColor(s)}return defined(this._options.offsetAttribute)&&(a.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$8,offsetScratch$7))),new GeometryInstance({id:t,geometry:new CylinderGeometry(this._options),modelMatrix:t.computeModelMatrixForHeightReference(e,t.cylinder.heightReference,this._options.length*.5,this._scene.ellipsoid),attributes:a})};CylinderGeometryUpdater.prototype.createOutlineGeometryInstance=function(e){if(Check.defined("time",e),!this._outlineEnabled)throw new DeveloperError("This instance does not represent an outlined geometry.");const t=this._entity,n=t.isAvailable(e),i=Property.getValueOrDefault(this._outlineColorProperty,e,Color.BLACK,scratchColor$e),r=this._distanceDisplayConditionProperty.getValue(e),o={show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._showOutlineProperty.getValue(e)),color:ColorGeometryInstanceAttribute.fromColor(i),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(r),offset:void 0};return defined(this._options.offsetAttribute)&&(o.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$8,offsetScratch$7))),new GeometryInstance({id:t,geometry:new CylinderOutlineGeometry(this._options),modelMatrix:t.computeModelMatrixForHeightReference(e,t.cylinder.heightReference,this._options.length*.5,this._scene.ellipsoid),attributes:o})};CylinderGeometryUpdater.prototype._computeCenter=function(e,t){return Property.getValueOrUndefined(this._entity.position,e,t)};CylinderGeometryUpdater.prototype._isHidden=function(e,t){return!defined(e.position)||!defined(t.length)||!defined(t.topRadius)||!defined(t.bottomRadius)||GeometryUpdater.prototype._isHidden.call(this,e,t)};CylinderGeometryUpdater.prototype._isDynamic=function(e,t){return!e.position.isConstant||!Property.isConstant(e.orientation)||!t.length.isConstant||!t.topRadius.isConstant||!t.bottomRadius.isConstant||!Property.isConstant(t.slices)||!Property.isConstant(t.outlineWidth)||!Property.isConstant(t.numberOfVerticalLines)};CylinderGeometryUpdater.prototype._setStaticOptions=function(e,t){const n=Property.getValueOrDefault(t.heightReference,Iso8601.MINIMUM_VALUE,HeightReference.NONE),i=this._options;i.vertexFormat=this._materialProperty instanceof ColorMaterialProperty?PerInstanceColorAppearance.VERTEX_FORMAT:MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat,i.length=t.length.getValue(Iso8601.MINIMUM_VALUE),i.topRadius=t.topRadius.getValue(Iso8601.MINIMUM_VALUE),i.bottomRadius=t.bottomRadius.getValue(Iso8601.MINIMUM_VALUE),i.slices=Property.getValueOrUndefined(t.slices,Iso8601.MINIMUM_VALUE),i.numberOfVerticalLines=Property.getValueOrUndefined(t.numberOfVerticalLines,Iso8601.MINIMUM_VALUE),i.offsetAttribute=n!==HeightReference.NONE?GeometryOffsetAttribute.ALL:void 0};CylinderGeometryUpdater.prototype._onEntityPropertyChanged=heightReferenceOnEntityPropertyChanged;CylinderGeometryUpdater.DynamicGeometryUpdater=DynamicCylinderGeometryUpdater;function DynamicCylinderGeometryUpdater(e,t,n){DynamicGeometryUpdater$1.call(this,e,t,n)}defined(Object.create)&&(DynamicCylinderGeometryUpdater.prototype=Object.create(DynamicGeometryUpdater$1.prototype),DynamicCylinderGeometryUpdater.prototype.constructor=DynamicCylinderGeometryUpdater);DynamicCylinderGeometryUpdater.prototype._isHidden=function(e,t,n){const i=this._options,r=Property.getValueOrUndefined(e.position,n,positionScratch$5);return!defined(r)||!defined(i.length)||!defined(i.topRadius)||!defined(i.bottomRadius)||DynamicGeometryUpdater$1.prototype._isHidden.call(this,e,t,n)};DynamicCylinderGeometryUpdater.prototype._setOptions=function(e,t,n){const i=Property.getValueOrDefault(t.heightReference,n,HeightReference.NONE),r=this._options;r.length=Property.getValueOrUndefined(t.length,n),r.topRadius=Property.getValueOrUndefined(t.topRadius,n),r.bottomRadius=Property.getValueOrUndefined(t.bottomRadius,n),r.slices=Property.getValueOrUndefined(t.slices,n),r.numberOfVerticalLines=Property.getValueOrUndefined(t.numberOfVerticalLines,n),r.offsetAttribute=i!==HeightReference.NONE?GeometryOffsetAttribute.ALL:void 0};const ClockRange={UNBOUNDED:0,CLAMPED:1,LOOP_STOP:2},ClockRange$1=Object.freeze(ClockRange),ClockStep={TICK_DEPENDENT:0,SYSTEM_CLOCK_MULTIPLIER:1,SYSTEM_CLOCK:2},ClockStep$1=Object.freeze(ClockStep);function getFilenameFromUri(e){if(!defined(e))throw new DeveloperError("uri is required.");const t=new Uri(e);t.normalize();let n=t.path();const i=n.lastIndexOf("/");return i!==-1&&(n=n.substr(i+1)),n}const factorial=CesiumMath.factorial;function calculateCoefficientTerm(e,t,n,i,r,o){let a=0,s,l,c;if(i>0){for(l=0;l<r;l++){for(s=!1,c=0;c<o.length&&!s;c++)l===o[c]&&(s=!0);s||(o.push(l),a+=calculateCoefficientTerm(e,t,n,i-1,r,o),o.splice(o.length-1,1))}return a}for(a=1,l=0;l<r;l++){for(s=!1,c=0;c<o.length&&!s;c++)l===o[c]&&(s=!0);s||(a*=e-n[t[l]])}return a}const HermitePolynomialApproximation={type:"Hermite"};HermitePolynomialApproximation.getRequiredDataPoints=function(e,t){if(t=defaultValue(t,0),!defined(e))throw new DeveloperError("degree is required.");if(e<0)throw new DeveloperError("degree must be 0 or greater.");if(t<0)throw new DeveloperError("inputOrder must be 0 or greater.");return Math.max(Math.floor((e+1)/(t+1)),2)};HermitePolynomialApproximation.interpolateOrderZero=function(e,t,n,i,r){defined(r)||(r=new Array(i));let o,a,s,l,c,d;const h=t.length,f=new Array(i);for(o=0;o<i;o++){r[o]=0;const g=new Array(h);for(f[o]=g,a=0;a<h;a++)g[a]=[]}const p=h,u=new Array(p);for(o=0;o<p;o++)u[o]=o;let m=h-1;for(l=0;l<i;l++){for(a=0;a<p;a++)d=u[a]*i+l,f[l][0].push(n[d]);for(o=1;o<p;o++){let g=!1;for(a=0;a<p-o;a++){const _=t[u[a]],C=t[u[a+o]];let A;C-_<=0?(d=u[a]*i+i*o+l,A=n[d],f[l][o].push(A/factorial(o))):(A=f[l][o-1][a+1]-f[l][o-1][a],f[l][o].push(A/(C-_))),g=g||A!==0}g||(m=o-1)}}for(s=0,c=0;s<=c;s++)for(o=s;o<=m;o++){const g=calculateCoefficientTerm(e,u,t,s,o,[]);for(l=0;l<i;l++){const _=f[l][o][0];r[l+s*i]+=_*g}}return r};const arrayScratch$1=[];HermitePolynomialApproximation.interpolate=function(e,t,n,i,r,o,a){const s=i*(o+1);defined(a)||(a=new Array(s));for(let _=0;_<s;_++)a[_]=0;const l=t.length,c=new Array(l*(r+1));let d;for(d=0;d<l;d++)for(let _=0;_<r+1;_++)c[d*(r+1)+_]=d;const h=c.length,f=arrayScratch$1,p=fillCoefficientList(f,c,t,n,i,r),u=[],m=h*(h+1)/2,g=Math.min(p,o);for(let _=0;_<=g;_++)for(d=_;d<=p;d++){u.length=0;const C=calculateCoefficientTerm(e,c,t,_,d,u),A=Math.floor(d*(1-d)/2)+h*d;for(let S=0;S<i;S++){const v=Math.floor(S*m),b=f[v+A];a[S+_*i]+=b*C}}return a};function fillCoefficientList(e,t,n,i,r,o){let a,s,l=-1;const c=t.length,d=c*(c+1)/2;for(let h=0;h<r;h++){const f=Math.floor(h*d);for(a=0;a<c;a++)s=t[a]*r*(o+1)+h,e[f+a]=i[s];for(let p=1;p<c;p++){let u=0;const m=Math.floor(p*(1-p)/2)+c*p;let g=!1;for(a=0;a<c-p;a++){const _=n[t[a]],C=n[t[a+p]];let A,S;if(C-_<=0)s=t[a]*r*(o+1)+r*p+h,A=i[s],S=A/CesiumMath.factorial(p),e[f+m+u]=S,u++;else{const v=Math.floor((p-1)*(2-p)/2)+c*(p-1);A=e[f+v+a+1]-e[f+v+a],S=A/(C-_),e[f+m+u]=S,u++}g=g||A!==0}g&&(l=Math.max(l,p))}}return l}const HermitePolynomialApproximation$1=HermitePolynomialApproximation,LagrangePolynomialApproximation={type:"Lagrange"};LagrangePolynomialApproximation.getRequiredDataPoints=function(e){return Math.max(e+1,2)};LagrangePolynomialApproximation.interpolateOrderZero=function(e,t,n,i,r){defined(r)||(r=new Array(i));let o,a;const s=t.length;for(o=0;o<i;o++)r[o]=0;for(o=0;o<s;o++){let l=1;for(a=0;a<s;a++)if(a!==o){const c=t[o]-t[a];l*=(e-t[a])/c}for(a=0;a<i;a++)r[a]+=l*n[o*i+a]}return r};const LagrangePolynomialApproximation$1=LagrangePolynomialApproximation;function Spherical(e,t,n){this.clock=defaultValue(e,0),this.cone=defaultValue(t,0),this.magnitude=defaultValue(n,1)}Spherical.fromCartesian3=function(e,t){Check.typeOf.object("cartesian3",e);const n=e.x,i=e.y,r=e.z,o=n*n+i*i;return defined(t)||(t=new Spherical),t.clock=Math.atan2(i,n),t.cone=Math.atan2(Math.sqrt(o),r),t.magnitude=Math.sqrt(o+r*r),t};Spherical.clone=function(e,t){if(defined(e))return defined(t)?(t.clock=e.clock,t.cone=e.cone,t.magnitude=e.magnitude,t):new Spherical(e.clock,e.cone,e.magnitude)};Spherical.normalize=function(e,t){return Check.typeOf.object("spherical",e),defined(t)?(t.clock=e.clock,t.cone=e.cone,t.magnitude=1,t):new Spherical(e.clock,e.cone,1)};Spherical.equals=function(e,t){return e===t||defined(e)&&defined(t)&&e.clock===t.clock&&e.cone===t.cone&&e.magnitude===t.magnitude};Spherical.equalsEpsilon=function(e,t,n){return n=defaultValue(n,0),e===t||defined(e)&&defined(t)&&Math.abs(e.clock-t.clock)<=n&&Math.abs(e.cone-t.cone)<=n&&Math.abs(e.magnitude-t.magnitude)<=n};Spherical.prototype.equals=function(e){return Spherical.equals(this,e)};Spherical.prototype.clone=function(e){return Spherical.clone(this,e)};Spherical.prototype.equalsEpsilon=function(e,t){return Spherical.equalsEpsilon(this,e,t)};Spherical.prototype.toString=function(){return`(${this.clock}, ${this.cone}, ${this.magnitude})`};function Clock(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);let t=e.currentTime,n=e.startTime,i=e.stopTime;if(defined(t)?t=JulianDate.clone(t):defined(n)?t=JulianDate.clone(n):defined(i)?t=JulianDate.addDays(i,-1,new JulianDate):t=JulianDate.now(),defined(n)?n=JulianDate.clone(n):n=JulianDate.clone(t),defined(i)?i=JulianDate.clone(i):i=JulianDate.addDays(n,1,new JulianDate),JulianDate.greaterThan(n,i))throw new DeveloperError("startTime must come before stopTime.");this.startTime=n,this.stopTime=i,this.clockRange=defaultValue(e.clockRange,ClockRange$1.UNBOUNDED),this.canAnimate=defaultValue(e.canAnimate,!0),this.onTick=new Event,this.onStop=new Event,this._currentTime=void 0,this._multiplier=void 0,this._clockStep=void 0,this._shouldAnimate=void 0,this._lastSystemTime=getTimestamp(),this.currentTime=t,this.multiplier=defaultValue(e.multiplier,1),this.shouldAnimate=defaultValue(e.shouldAnimate,!1),this.clockStep=defaultValue(e.clockStep,ClockStep$1.SYSTEM_CLOCK_MULTIPLIER)}Object.defineProperties(Clock.prototype,{currentTime:{get:function(){return this._currentTime},set:function(e){JulianDate.equals(this._currentTime,e)||(this._clockStep===ClockStep$1.SYSTEM_CLOCK&&(this._clockStep=ClockStep$1.SYSTEM_CLOCK_MULTIPLIER),this._currentTime=e)}},multiplier:{get:function(){return this._multiplier},set:function(e){this._multiplier!==e&&(this._clockStep===ClockStep$1.SYSTEM_CLOCK&&(this._clockStep=ClockStep$1.SYSTEM_CLOCK_MULTIPLIER),this._multiplier=e)}},clockStep:{get:function(){return this._clockStep},set:function(e){e===ClockStep$1.SYSTEM_CLOCK&&(this._multiplier=1,this._shouldAnimate=!0,this._currentTime=JulianDate.now()),this._clockStep=e}},shouldAnimate:{get:function(){return this._shouldAnimate},set:function(e){this._shouldAnimate!==e&&(this._clockStep===ClockStep$1.SYSTEM_CLOCK&&(this._clockStep=ClockStep$1.SYSTEM_CLOCK_MULTIPLIER),this._shouldAnimate=e)}}});Clock.prototype.tick=function(){const e=getTimestamp();let t=JulianDate.clone(this._currentTime);if(this.canAnimate&&this._shouldAnimate){const n=this._clockStep;if(n===ClockStep$1.SYSTEM_CLOCK)t=JulianDate.now(t);else{const i=this._multiplier;if(n===ClockStep$1.TICK_DEPENDENT)t=JulianDate.addSeconds(t,i,t);else{const s=e-this._lastSystemTime;t=JulianDate.addSeconds(t,i*(s/1e3),t)}const r=this.clockRange,o=this.startTime,a=this.stopTime;if(r===ClockRange$1.CLAMPED)JulianDate.lessThan(t,o)?t=JulianDate.clone(o,t):JulianDate.greaterThan(t,a)&&(t=JulianDate.clone(a,t),this.onStop.raiseEvent(this));else if(r===ClockRange$1.LOOP_STOP)for(JulianDate.lessThan(t,o)&&(t=JulianDate.clone(o,t));JulianDate.greaterThan(t,a);)t=JulianDate.addSeconds(o,JulianDate.secondsDifference(t,a),t),this.onStop.raiseEvent(this)}}return this._currentTime=t,this._lastSystemTime=e,this.onTick.raiseEvent(this),t};function DataSourceClock(){this._definitionChanged=new Event,this._startTime=void 0,this._stopTime=void 0,this._currentTime=void 0,this._clockRange=void 0,this._clockStep=void 0,this._multiplier=void 0}Object.defineProperties(DataSourceClock.prototype,{definitionChanged:{get:function(){return this._definitionChanged}},startTime:createRawPropertyDescriptor("startTime"),stopTime:createRawPropertyDescriptor("stopTime"),currentTime:createRawPropertyDescriptor("currentTime"),clockRange:createRawPropertyDescriptor("clockRange"),clockStep:createRawPropertyDescriptor("clockStep"),multiplier:createRawPropertyDescriptor("multiplier")});DataSourceClock.prototype.clone=function(e){return defined(e)||(e=new DataSourceClock),e.startTime=this.startTime,e.stopTime=this.stopTime,e.currentTime=this.currentTime,e.clockRange=this.clockRange,e.clockStep=this.clockStep,e.multiplier=this.multiplier,e};DataSourceClock.prototype.equals=function(e){return this===e||defined(e)&&JulianDate.equals(this.startTime,e.startTime)&&JulianDate.equals(this.stopTime,e.stopTime)&&JulianDate.equals(this.currentTime,e.currentTime)&&this.clockRange===e.clockRange&&this.clockStep===e.clockStep&&this.multiplier===e.multiplier};DataSourceClock.prototype.merge=function(e){if(!defined(e))throw new DeveloperError("source is required.");this.startTime=defaultValue(this.startTime,e.startTime),this.stopTime=defaultValue(this.stopTime,e.stopTime),this.currentTime=defaultValue(this.currentTime,e.currentTime),this.clockRange=defaultValue(this.clockRange,e.clockRange),this.clockStep=defaultValue(this.clockStep,e.clockStep),this.multiplier=defaultValue(this.multiplier,e.multiplier)};DataSourceClock.prototype.getValue=function(e){return defined(e)||(e=new Clock),e.startTime=defaultValue(this.startTime,e.startTime),e.stopTime=defaultValue(this.stopTime,e.stopTime),e.currentTime=defaultValue(this.currentTime,e.currentTime),e.clockRange=defaultValue(this.clockRange,e.clockRange),e.multiplier=defaultValue(this.multiplier,e.multiplier),e.clockStep=defaultValue(this.clockStep,e.clockStep),e};const defaultColor$6=Color.WHITE,defaultCellAlpha=.1,defaultLineCount=new Cartesian2(8,8),defaultLineOffset=new Cartesian2(0,0),defaultLineThickness=new Cartesian2(1,1);function GridMaterialProperty(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._definitionChanged=new Event,this._color=void 0,this._colorSubscription=void 0,this._cellAlpha=void 0,this._cellAlphaSubscription=void 0,this._lineCount=void 0,this._lineCountSubscription=void 0,this._lineThickness=void 0,this._lineThicknessSubscription=void 0,this._lineOffset=void 0,this._lineOffsetSubscription=void 0,this.color=e.color,this.cellAlpha=e.cellAlpha,this.lineCount=e.lineCount,this.lineThickness=e.lineThickness,this.lineOffset=e.lineOffset}Object.defineProperties(GridMaterialProperty.prototype,{isConstant:{get:function(){return Property.isConstant(this._color)&&Property.isConstant(this._cellAlpha)&&Property.isConstant(this._lineCount)&&Property.isConstant(this._lineThickness)&&Property.isConstant(this._lineOffset)}},definitionChanged:{get:function(){return this._definitionChanged}},color:createPropertyDescriptor("color"),cellAlpha:createPropertyDescriptor("cellAlpha"),lineCount:createPropertyDescriptor("lineCount"),lineThickness:createPropertyDescriptor("lineThickness"),lineOffset:createPropertyDescriptor("lineOffset")});GridMaterialProperty.prototype.getType=function(e){return"Grid"};GridMaterialProperty.prototype.getValue=function(e,t){return defined(t)||(t={}),t.color=Property.getValueOrClonedDefault(this._color,e,defaultColor$6,t.color),t.cellAlpha=Property.getValueOrDefault(this._cellAlpha,e,defaultCellAlpha),t.lineCount=Property.getValueOrClonedDefault(this._lineCount,e,defaultLineCount,t.lineCount),t.lineThickness=Property.getValueOrClonedDefault(this._lineThickness,e,defaultLineThickness,t.lineThickness),t.lineOffset=Property.getValueOrClonedDefault(this._lineOffset,e,defaultLineOffset,t.lineOffset),t};GridMaterialProperty.prototype.equals=function(e){return this===e||e instanceof GridMaterialProperty&&Property.equals(this._color,e._color)&&Property.equals(this._cellAlpha,e._cellAlpha)&&Property.equals(this._lineCount,e._lineCount)&&Property.equals(this._lineThickness,e._lineThickness)&&Property.equals(this._lineOffset,e._lineOffset)};function PolylineArrowMaterialProperty(e){this._definitionChanged=new Event,this._color=void 0,this._colorSubscription=void 0,this.color=e}Object.defineProperties(PolylineArrowMaterialProperty.prototype,{isConstant:{get:function(){return Property.isConstant(this._color)}},definitionChanged:{get:function(){return this._definitionChanged}},color:createPropertyDescriptor("color")});PolylineArrowMaterialProperty.prototype.getType=function(e){return"PolylineArrow"};PolylineArrowMaterialProperty.prototype.getValue=function(e,t){return defined(t)||(t={}),t.color=Property.getValueOrClonedDefault(this._color,e,Color.WHITE,t.color),t};PolylineArrowMaterialProperty.prototype.equals=function(e){return this===e||e instanceof PolylineArrowMaterialProperty&&Property.equals(this._color,e._color)};const defaultColor$5=Color.WHITE,defaultGapColor=Color.TRANSPARENT,defaultDashLength=16,defaultDashPattern=255;function PolylineDashMaterialProperty(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._definitionChanged=new Event,this._color=void 0,this._colorSubscription=void 0,this._gapColor=void 0,this._gapColorSubscription=void 0,this._dashLength=void 0,this._dashLengthSubscription=void 0,this._dashPattern=void 0,this._dashPatternSubscription=void 0,this.color=e.color,this.gapColor=e.gapColor,this.dashLength=e.dashLength,this.dashPattern=e.dashPattern}Object.defineProperties(PolylineDashMaterialProperty.prototype,{isConstant:{get:function(){return Property.isConstant(this._color)&&Property.isConstant(this._gapColor)&&Property.isConstant(this._dashLength)&&Property.isConstant(this._dashPattern)}},definitionChanged:{get:function(){return this._definitionChanged}},color:createPropertyDescriptor("color"),gapColor:createPropertyDescriptor("gapColor"),dashLength:createPropertyDescriptor("dashLength"),dashPattern:createPropertyDescriptor("dashPattern")});PolylineDashMaterialProperty.prototype.getType=function(e){return"PolylineDash"};PolylineDashMaterialProperty.prototype.getValue=function(e,t){return defined(t)||(t={}),t.color=Property.getValueOrClonedDefault(this._color,e,defaultColor$5,t.color),t.gapColor=Property.getValueOrClonedDefault(this._gapColor,e,defaultGapColor,t.gapColor),t.dashLength=Property.getValueOrDefault(this._dashLength,e,defaultDashLength,t.dashLength),t.dashPattern=Property.getValueOrDefault(this._dashPattern,e,defaultDashPattern,t.dashPattern),t};PolylineDashMaterialProperty.prototype.equals=function(e){return this===e||e instanceof PolylineDashMaterialProperty&&Property.equals(this._color,e._color)&&Property.equals(this._gapColor,e._gapColor)&&Property.equals(this._dashLength,e._dashLength)&&Property.equals(this._dashPattern,e._dashPattern)};const defaultColor$4=Color.WHITE,defaultGlowPower=.25,defaultTaperPower=1;function PolylineGlowMaterialProperty(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._definitionChanged=new Event,this._color=void 0,this._colorSubscription=void 0,this._glowPower=void 0,this._glowPowerSubscription=void 0,this._taperPower=void 0,this._taperPowerSubscription=void 0,this.color=e.color,this.glowPower=e.glowPower,this.taperPower=e.taperPower}Object.defineProperties(PolylineGlowMaterialProperty.prototype,{isConstant:{get:function(){return Property.isConstant(this._color)&&Property.isConstant(this._glow)}},definitionChanged:{get:function(){return this._definitionChanged}},color:createPropertyDescriptor("color"),glowPower:createPropertyDescriptor("glowPower"),taperPower:createPropertyDescriptor("taperPower")});PolylineGlowMaterialProperty.prototype.getType=function(e){return"PolylineGlow"};PolylineGlowMaterialProperty.prototype.getValue=function(e,t){return defined(t)||(t={}),t.color=Property.getValueOrClonedDefault(this._color,e,defaultColor$4,t.color),t.glowPower=Property.getValueOrDefault(this._glowPower,e,defaultGlowPower,t.glowPower),t.taperPower=Property.getValueOrDefault(this._taperPower,e,defaultTaperPower,t.taperPower),t};PolylineGlowMaterialProperty.prototype.equals=function(e){return this===e||e instanceof PolylineGlowMaterialProperty&&Property.equals(this._color,e._color)&&Property.equals(this._glowPower,e._glowPower)&&Property.equals(this._taperPower,e._taperPower)};const defaultColor$3=Color.WHITE,defaultOutlineColor$2=Color.BLACK,defaultOutlineWidth$2=1;function PolylineOutlineMaterialProperty(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._definitionChanged=new Event,this._color=void 0,this._colorSubscription=void 0,this._outlineColor=void 0,this._outlineColorSubscription=void 0,this._outlineWidth=void 0,this._outlineWidthSubscription=void 0,this.color=e.color,this.outlineColor=e.outlineColor,this.outlineWidth=e.outlineWidth}Object.defineProperties(PolylineOutlineMaterialProperty.prototype,{isConstant:{get:function(){return Property.isConstant(this._color)&&Property.isConstant(this._outlineColor)&&Property.isConstant(this._outlineWidth)}},definitionChanged:{get:function(){return this._definitionChanged}},color:createPropertyDescriptor("color"),outlineColor:createPropertyDescriptor("outlineColor"),outlineWidth:createPropertyDescriptor("outlineWidth")});PolylineOutlineMaterialProperty.prototype.getType=function(e){return"PolylineOutline"};PolylineOutlineMaterialProperty.prototype.getValue=function(e,t){return defined(t)||(t={}),t.color=Property.getValueOrClonedDefault(this._color,e,defaultColor$3,t.color),t.outlineColor=Property.getValueOrClonedDefault(this._outlineColor,e,defaultOutlineColor$2,t.outlineColor),t.outlineWidth=Property.getValueOrDefault(this._outlineWidth,e,defaultOutlineWidth$2),t};PolylineOutlineMaterialProperty.prototype.equals=function(e){return this===e||e instanceof PolylineOutlineMaterialProperty&&Property.equals(this._color,e._color)&&Property.equals(this._outlineColor,e._outlineColor)&&Property.equals(this._outlineWidth,e._outlineWidth)};function PositionPropertyArray(e,t){this._value=void 0,this._definitionChanged=new Event,this._eventHelper=new EventHelper,this._referenceFrame=defaultValue(t,ReferenceFrame.FIXED),this.setValue(e)}Object.defineProperties(PositionPropertyArray.prototype,{isConstant:{get:function(){const e=this._value;if(!defined(e))return!0;const t=e.length;for(let n=0;n<t;n++)if(!Property.isConstant(e[n]))return!1;return!0}},definitionChanged:{get:function(){return this._definitionChanged}},referenceFrame:{get:function(){return this._referenceFrame}}});PositionPropertyArray.prototype.getValue=function(e,t){return this.getValueInReferenceFrame(e,ReferenceFrame.FIXED,t)};PositionPropertyArray.prototype.getValueInReferenceFrame=function(e,t,n){if(!defined(e))throw new DeveloperError("time is required.");if(!defined(t))throw new DeveloperError("referenceFrame is required.");const i=this._value;if(!defined(i))return;const r=i.length;defined(n)||(n=new Array(r));let o=0,a=0;for(;o<r;){const l=i[o].getValueInReferenceFrame(e,t,n[o]);defined(l)&&(n[a]=l,a++),o++}return n.length=a,n};PositionPropertyArray.prototype.setValue=function(e){const t=this._eventHelper;if(t.removeAll(),defined(e)){this._value=e.slice();const n=e.length;for(let i=0;i<n;i++){const r=e[i];defined(r)&&t.add(r.definitionChanged,PositionPropertyArray.prototype._raiseDefinitionChanged,this)}}else this._value=void 0;this._definitionChanged.raiseEvent(this)};PositionPropertyArray.prototype.equals=function(e){return this===e||e instanceof PositionPropertyArray&&this._referenceFrame===e._referenceFrame&&Property.arrayEquals(this._value,e._value)};PositionPropertyArray.prototype._raiseDefinitionChanged=function(){this._definitionChanged.raiseEvent(this)};function PropertyArray(e){this._value=void 0,this._definitionChanged=new Event,this._eventHelper=new EventHelper,this.setValue(e)}Object.defineProperties(PropertyArray.prototype,{isConstant:{get:function(){const e=this._value;if(!defined(e))return!0;const t=e.length;for(let n=0;n<t;n++)if(!Property.isConstant(e[n]))return!1;return!0}},definitionChanged:{get:function(){return this._definitionChanged}}});PropertyArray.prototype.getValue=function(e,t){if(!defined(e))throw new DeveloperError("time is required.");const n=this._value;if(!defined(n))return;const i=n.length;defined(t)||(t=new Array(i));let r=0,o=0;for(;r<i;){const s=this._value[r].getValue(e,t[r]);defined(s)&&(t[o]=s,o++),r++}return t.length=o,t};PropertyArray.prototype.setValue=function(e){const t=this._eventHelper;if(t.removeAll(),defined(e)){this._value=e.slice();const n=e.length;for(let i=0;i<n;i++){const r=e[i];defined(r)&&t.add(r.definitionChanged,PropertyArray.prototype._raiseDefinitionChanged,this)}}else this._value=void 0;this._definitionChanged.raiseEvent(this)};PropertyArray.prototype.equals=function(e){return this===e||e instanceof PropertyArray&&Property.arrayEquals(this._value,e._value)};PropertyArray.prototype._raiseDefinitionChanged=function(){this._definitionChanged.raiseEvent(this)};function resolve(e){let t=e._targetProperty;if(!defined(t)){let n=e._targetEntity;if(!defined(n)){if(n=e._targetCollection.getById(e._targetId),!defined(n)){e._targetEntity=e._targetProperty=void 0;return}n.definitionChanged.addEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged,e),e._targetEntity=n}const i=e._targetPropertyNames;t=e._targetEntity;for(let r=0,o=i.length;r<o&&defined(t);++r)t=t[i[r]];e._targetProperty=t}return t}function ReferenceProperty(e,t,n){if(!defined(e))throw new DeveloperError("targetCollection is required.");if(!defined(t)||t==="")throw new DeveloperError("targetId is required.");if(!defined(n)||n.length===0)throw new DeveloperError("targetPropertyNames is required.");for(let i=0;i<n.length;i++){const r=n[i];if(!defined(r)||r==="")throw new DeveloperError("reference contains invalid properties.")}this._targetCollection=e,this._targetId=t,this._targetPropertyNames=n,this._targetProperty=void 0,this._targetEntity=void 0,this._definitionChanged=new Event,e.collectionChanged.addEventListener(ReferenceProperty.prototype._onCollectionChanged,this)}Object.defineProperties(ReferenceProperty.prototype,{isConstant:{get:function(){return Property.isConstant(resolve(this))}},definitionChanged:{get:function(){return this._definitionChanged}},referenceFrame:{get:function(){const e=resolve(this);return defined(e)?e.referenceFrame:void 0}},targetId:{get:function(){return this._targetId}},targetCollection:{get:function(){return this._targetCollection}},targetPropertyNames:{get:function(){return this._targetPropertyNames}},resolvedProperty:{get:function(){return resolve(this)}}});ReferenceProperty.fromString=function(e,t){if(!defined(e))throw new DeveloperError("targetCollection is required.");if(!defined(t))throw new DeveloperError("referenceString is required.");let n;const i=[];let r=!0,o=!1,a="";for(let s=0;s<t.length;++s){const l=t.charAt(s);o?(a+=l,o=!1):l==="\\"?o=!0:r&&l==="#"?(n=a,r=!1,a=""):!r&&l==="."?(i.push(a),a=""):a+=l}return i.push(a),new ReferenceProperty(e,n,i)};ReferenceProperty.prototype.getValue=function(e,t){const n=resolve(this);return defined(n)?n.getValue(e,t):void 0};ReferenceProperty.prototype.getValueInReferenceFrame=function(e,t,n){const i=resolve(this);return defined(i)?i.getValueInReferenceFrame(e,t,n):void 0};ReferenceProperty.prototype.getType=function(e){const t=resolve(this);return defined(t)?t.getType(e):void 0};ReferenceProperty.prototype.equals=function(e){if(this===e)return!0;const t=this._targetPropertyNames,n=e._targetPropertyNames;if(this._targetCollection!==e._targetCollection||this._targetId!==e._targetId||t.length!==n.length)return!1;const i=this._targetPropertyNames.length;for(let r=0;r<i;r++)if(t[r]!==n[r])return!1;return!0};ReferenceProperty.prototype._onTargetEntityDefinitionChanged=function(e,t,n,i){defined(this._targetProperty)&&this._targetPropertyNames[0]===t&&(this._targetProperty=void 0,this._definitionChanged.raiseEvent(this))};ReferenceProperty.prototype._onCollectionChanged=function(e,t,n){let i=this._targetEntity;defined(i)&&n.indexOf(i)!==-1?(i.definitionChanged.removeEventListener(ReferenceProperty.prototype._onTargetEntityDefinitionChanged,this),this._targetEntity=this._targetProperty=void 0):defined(i)||(i=resolve(this),defined(i)&&this._definitionChanged.raiseEvent(this))};const Rotation={packedLength:1,pack:function(e,t,n){if(!defined(e))throw new DeveloperError("value is required");if(!defined(t))throw new DeveloperError("array is required");return n=defaultValue(n,0),t[n]=e,t},unpack:function(e,t,n){if(!defined(e))throw new DeveloperError("array is required");return t=defaultValue(t,0),e[t]},convertPackedArrayForInterpolation:function(e,t,n,i){if(!defined(e))throw new DeveloperError("packedArray is required");defined(i)||(i=[]),t=defaultValue(t,0),n=defaultValue(n,e.length);let r;for(let o=0,a=n-t+1;o<a;o++){const s=e[t+o];o===0||Math.abs(r-s)<Math.PI?i[o]=s:i[o]=s-CesiumMath.TWO_PI,r=s}},unpackInterpolationResult:function(e,t,n,i,r){if(!defined(e))throw new DeveloperError("array is required");if(!defined(t))throw new DeveloperError("sourceArray is required");return r=e[0],r<0?r+CesiumMath.TWO_PI:r}},Rotation$1=Rotation,StripeOrientation={HORIZONTAL:0,VERTICAL:1},StripeOrientation$1=Object.freeze(StripeOrientation),defaultOrientation=StripeOrientation$1.HORIZONTAL,defaultEvenColor=Color.WHITE,defaultOddColor=Color.BLACK,defaultOffset$7=0,defaultRepeat=1;function StripeMaterialProperty(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._definitionChanged=new Event,this._orientation=void 0,this._orientationSubscription=void 0,this._evenColor=void 0,this._evenColorSubscription=void 0,this._oddColor=void 0,this._oddColorSubscription=void 0,this._offset=void 0,this._offsetSubscription=void 0,this._repeat=void 0,this._repeatSubscription=void 0,this.orientation=e.orientation,this.evenColor=e.evenColor,this.oddColor=e.oddColor,this.offset=e.offset,this.repeat=e.repeat}Object.defineProperties(StripeMaterialProperty.prototype,{isConstant:{get:function(){return Property.isConstant(this._orientation)&&Property.isConstant(this._evenColor)&&Property.isConstant(this._oddColor)&&Property.isConstant(this._offset)&&Property.isConstant(this._repeat)}},definitionChanged:{get:function(){return this._definitionChanged}},orientation:createPropertyDescriptor("orientation"),evenColor:createPropertyDescriptor("evenColor"),oddColor:createPropertyDescriptor("oddColor"),offset:createPropertyDescriptor("offset"),repeat:createPropertyDescriptor("repeat")});StripeMaterialProperty.prototype.getType=function(e){return"Stripe"};StripeMaterialProperty.prototype.getValue=function(e,t){return defined(t)||(t={}),t.horizontal=Property.getValueOrDefault(this._orientation,e,defaultOrientation)===StripeOrientation$1.HORIZONTAL,t.evenColor=Property.getValueOrClonedDefault(this._evenColor,e,defaultEvenColor,t.evenColor),t.oddColor=Property.getValueOrClonedDefault(this._oddColor,e,defaultOddColor,t.oddColor),t.offset=Property.getValueOrDefault(this._offset,e,defaultOffset$7),t.repeat=Property.getValueOrDefault(this._repeat,e,defaultRepeat),t};StripeMaterialProperty.prototype.equals=function(e){return this===e||e instanceof StripeMaterialProperty&&Property.equals(this._orientation,e._orientation)&&Property.equals(this._evenColor,e._evenColor)&&Property.equals(this._oddColor,e._oddColor)&&Property.equals(this._offset,e._offset)&&Property.equals(this._repeat,e._repeat)};function TimeIntervalCollectionPositionProperty(e){this._definitionChanged=new Event,this._intervals=new TimeIntervalCollection,this._intervals.changedEvent.addEventListener(TimeIntervalCollectionPositionProperty.prototype._intervalsChanged,this),this._referenceFrame=defaultValue(e,ReferenceFrame.FIXED)}Object.defineProperties(TimeIntervalCollectionPositionProperty.prototype,{isConstant:{get:function(){return this._intervals.isEmpty}},definitionChanged:{get:function(){return this._definitionChanged}},intervals:{get:function(){return this._intervals}},referenceFrame:{get:function(){return this._referenceFrame}}});TimeIntervalCollectionPositionProperty.prototype.getValue=function(e,t){return this.getValueInReferenceFrame(e,ReferenceFrame.FIXED,t)};TimeIntervalCollectionPositionProperty.prototype.getValueInReferenceFrame=function(e,t,n){if(!defined(e))throw new DeveloperError("time is required.");if(!defined(t))throw new DeveloperError("referenceFrame is required.");const i=this._intervals.findDataForIntervalContainingDate(e);if(defined(i))return PositionProperty.convertToReferenceFrame(e,i,this._referenceFrame,t,n)};TimeIntervalCollectionPositionProperty.prototype.equals=function(e){return this===e||e instanceof TimeIntervalCollectionPositionProperty&&this._intervals.equals(e._intervals,Property.equals)&&this._referenceFrame===e._referenceFrame};TimeIntervalCollectionPositionProperty.prototype._intervalsChanged=function(){this._definitionChanged.raiseEvent(this)};function TimeIntervalCollectionProperty(){this._definitionChanged=new Event,this._intervals=new TimeIntervalCollection,this._intervals.changedEvent.addEventListener(TimeIntervalCollectionProperty.prototype._intervalsChanged,this)}Object.defineProperties(TimeIntervalCollectionProperty.prototype,{isConstant:{get:function(){return this._intervals.isEmpty}},definitionChanged:{get:function(){return this._definitionChanged}},intervals:{get:function(){return this._intervals}}});TimeIntervalCollectionProperty.prototype.getValue=function(e,t){if(!defined(e))throw new DeveloperError("time is required");const n=this._intervals.findDataForIntervalContainingDate(e);return defined(n)&&typeof n.clone=="function"?n.clone(t):n};TimeIntervalCollectionProperty.prototype.equals=function(e){return this===e||e instanceof TimeIntervalCollectionProperty&&this._intervals.equals(e._intervals,Property.equals)};TimeIntervalCollectionProperty.prototype._intervalsChanged=function(){this._definitionChanged.raiseEvent(this)};function VelocityVectorProperty(e,t){this._position=void 0,this._subscription=void 0,this._definitionChanged=new Event,this._normalize=defaultValue(t,!0),this.position=e}Object.defineProperties(VelocityVectorProperty.prototype,{isConstant:{get:function(){return Property.isConstant(this._position)}},definitionChanged:{get:function(){return this._definitionChanged}},position:{get:function(){return this._position},set:function(e){const t=this._position;t!==e&&(defined(t)&&this._subscription(),this._position=e,defined(e)&&(this._subscription=e._definitionChanged.addEventListener(function(){this._definitionChanged.raiseEvent(this)},this)),this._definitionChanged.raiseEvent(this))}},normalize:{get:function(){return this._normalize},set:function(e){this._normalize!==e&&(this._normalize=e,this._definitionChanged.raiseEvent(this))}}});const position1Scratch=new Cartesian3,position2Scratch=new Cartesian3,timeScratch=new JulianDate,step=1/60;VelocityVectorProperty.prototype.getValue=function(e,t){return this._getValue(e,t)};VelocityVectorProperty.prototype._getValue=function(e,t,n){if(!defined(e))throw new DeveloperError("time is required");defined(t)||(t=new Cartesian3);const i=this._position;if(Property.isConstant(i))return this._normalize?void 0:Cartesian3.clone(Cartesian3.ZERO,t);let r=i.getValue(e,position1Scratch),o=i.getValue(JulianDate.addSeconds(e,step,timeScratch),position2Scratch);if(!defined(r)||!defined(o)&&(o=r,r=i.getValue(JulianDate.addSeconds(e,-step,timeScratch),position2Scratch),!defined(r)))return;if(Cartesian3.equals(r,o))return this._normalize?void 0:Cartesian3.clone(Cartesian3.ZERO,t);defined(n)&&r.clone(n);const a=Cartesian3.subtract(o,r,t);return this._normalize?Cartesian3.normalize(a,t):Cartesian3.divideByScalar(a,step,t)};VelocityVectorProperty.prototype.equals=function(e){return this===e||e instanceof VelocityVectorProperty&&Property.equals(this._position,e._position)};function VelocityOrientationProperty(e,t){this._velocityVectorProperty=new VelocityVectorProperty(e,!0),this._subscription=void 0,this._ellipsoid=void 0,this._definitionChanged=new Event,this.ellipsoid=defaultValue(t,Ellipsoid.default);const n=this;this._velocityVectorProperty.definitionChanged.addEventListener(function(){n._definitionChanged.raiseEvent(n)})}Object.defineProperties(VelocityOrientationProperty.prototype,{isConstant:{get:function(){return Property.isConstant(this._velocityVectorProperty)}},definitionChanged:{get:function(){return this._definitionChanged}},position:{get:function(){return this._velocityVectorProperty.position},set:function(e){this._velocityVectorProperty.position=e}},ellipsoid:{get:function(){return this._ellipsoid},set:function(e){this._ellipsoid!==e&&(this._ellipsoid=e,this._definitionChanged.raiseEvent(this))}}});const positionScratch$4=new Cartesian3,velocityScratch=new Cartesian3,rotationScratch$1=new Matrix3;VelocityOrientationProperty.prototype.getValue=function(e,t){const n=this._velocityVectorProperty._getValue(e,velocityScratch,positionScratch$4);if(defined(n))return Transforms.rotationMatrixFromPositionVelocity(positionScratch$4,n,this._ellipsoid,rotationScratch$1),Quaternion.fromRotationMatrix(rotationScratch$1,t)};VelocityOrientationProperty.prototype.equals=function(e){return this===e||e instanceof VelocityOrientationProperty&&Property.equals(this._velocityVectorProperty,e._velocityVectorProperty)&&(this._ellipsoid===e._ellipsoid||this._ellipsoid.equals(e._ellipsoid))};const SensorVolumePortionToDisplay={COMPLETE:0,BELOW_ELLIPSOID_HORIZON:1,ABOVE_ELLIPSOID_HORIZON:2};SensorVolumePortionToDisplay.validate=function(e){return e===SensorVolumePortionToDisplay.COMPLETE||e===SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON||e===SensorVolumePortionToDisplay.ABOVE_ELLIPSOID_HORIZON};SensorVolumePortionToDisplay.toString=function(e){switch(e){case SensorVolumePortionToDisplay.COMPLETE:return"COMPLETE";case SensorVolumePortionToDisplay.BELOW_ELLIPSOID_HORIZON:return"BELOW_ELLIPSOID_HORIZON";case SensorVolumePortionToDisplay.ABOVE_ELLIPSOID_HORIZON:return"ABOVE_ELLIPSOID_HORIZON";default:throw new DeveloperError("SensorVolumePortionToDisplay value is not valid and cannot be converted to a String.")}};const SensorVolumePortionToDisplay$1=SensorVolumePortionToDisplay;function UnitCartesian3(){}UnitCartesian3.packedLength=Cartesian3.packedLength;UnitCartesian3.unpack=Cartesian3.unpack;UnitCartesian3.pack=Cartesian3.pack;let currentId;function createReferenceProperty(e,t){return t[0]==="#"&&(t=currentId+t),ReferenceProperty.fromString(e,t)}function createSpecializedProperty(e,t,n){if(defined(n.reference))return createReferenceProperty(t,n.reference);if(defined(n.velocityReference)){const i=createReferenceProperty(t,n.velocityReference);switch(e){case Cartesian3:case UnitCartesian3:return new VelocityVectorProperty(i,e===UnitCartesian3);case Quaternion:return new VelocityOrientationProperty(i)}}throw new RuntimeError(`${JSON.stringify(n)} is not valid CZML.`)}function createAdapterProperty(e,t){return new CallbackProperty(function(n,i){return t(e.getValue(n,i))},e.isConstant)}const scratchCartesian$4=new Cartesian3,scratchSpherical=new Spherical,scratchCartographic$9=new Cartographic,scratchTimeInterval$1=new TimeInterval,scratchQuaternion=new Quaternion;function unwrapColorInterval(e){let t=e.rgbaf;if(defined(t))return t;const n=e.rgba;if(!defined(n))return;const i=n.length;if(i===Color.packedLength)return[Color.byteToFloat(n[0]),Color.byteToFloat(n[1]),Color.byteToFloat(n[2]),Color.byteToFloat(n[3])];t=new Array(i);for(let r=0;r<i;r+=5)t[r]=n[r],t[r+1]=Color.byteToFloat(n[r+1]),t[r+2]=Color.byteToFloat(n[r+2]),t[r+3]=Color.byteToFloat(n[r+3]),t[r+4]=Color.byteToFloat(n[r+4]);return t}function unwrapUriInterval(e,t){const n=defaultValue(e.uri,e);return defined(t)?t.getDerivedResource({url:n}):Resource.createIfNeeded(n)}function unwrapRectangleInterval(e){let t=e.wsen;if(defined(t))return t;const n=e.wsenDegrees;if(!defined(n))return;const i=n.length;if(i===Rectangle.packedLength)return[CesiumMath.toRadians(n[0]),CesiumMath.toRadians(n[1]),CesiumMath.toRadians(n[2]),CesiumMath.toRadians(n[3])];t=new Array(i);for(let r=0;r<i;r+=5)t[r]=n[r],t[r+1]=CesiumMath.toRadians(n[r+1]),t[r+2]=CesiumMath.toRadians(n[r+2]),t[r+3]=CesiumMath.toRadians(n[r+3]),t[r+4]=CesiumMath.toRadians(n[r+4]);return t}function convertUnitSphericalToCartesian(e){const t=e.length;if(scratchSpherical.magnitude=1,t===2)return scratchSpherical.clock=e[0],scratchSpherical.cone=e[1],Cartesian3.fromSpherical(scratchSpherical,scratchCartesian$4),[scratchCartesian$4.x,scratchCartesian$4.y,scratchCartesian$4.z];const n=new Array(t/3*4);for(let i=0,r=0;i<t;i+=3,r+=4)n[r]=e[i],scratchSpherical.clock=e[i+1],scratchSpherical.cone=e[i+2],Cartesian3.fromSpherical(scratchSpherical,scratchCartesian$4),n[r+1]=scratchCartesian$4.x,n[r+2]=scratchCartesian$4.y,n[r+3]=scratchCartesian$4.z;return n}function convertSphericalToCartesian(e){const t=e.length;if(t===3)return scratchSpherical.clock=e[0],scratchSpherical.cone=e[1],scratchSpherical.magnitude=e[2],Cartesian3.fromSpherical(scratchSpherical,scratchCartesian$4),[scratchCartesian$4.x,scratchCartesian$4.y,scratchCartesian$4.z];const n=new Array(t);for(let i=0;i<t;i+=4)n[i]=e[i],scratchSpherical.clock=e[i+1],scratchSpherical.cone=e[i+2],scratchSpherical.magnitude=e[i+3],Cartesian3.fromSpherical(scratchSpherical,scratchCartesian$4),n[i+1]=scratchCartesian$4.x,n[i+2]=scratchCartesian$4.y,n[i+3]=scratchCartesian$4.z;return n}function convertCartographicRadiansToCartesian(e){const t=e.length;if(t===3)return scratchCartographic$9.longitude=e[0],scratchCartographic$9.latitude=e[1],scratchCartographic$9.height=e[2],Ellipsoid.default.cartographicToCartesian(scratchCartographic$9,scratchCartesian$4),[scratchCartesian$4.x,scratchCartesian$4.y,scratchCartesian$4.z];const n=new Array(t);for(let i=0;i<t;i+=4)n[i]=e[i],scratchCartographic$9.longitude=e[i+1],scratchCartographic$9.latitude=e[i+2],scratchCartographic$9.height=e[i+3],Ellipsoid.default.cartographicToCartesian(scratchCartographic$9,scratchCartesian$4),n[i+1]=scratchCartesian$4.x,n[i+2]=scratchCartesian$4.y,n[i+3]=scratchCartesian$4.z;return n}function convertCartographicDegreesToCartesian(e){const t=e.length;if(t===3)return scratchCartographic$9.longitude=CesiumMath.toRadians(e[0]),scratchCartographic$9.latitude=CesiumMath.toRadians(e[1]),scratchCartographic$9.height=e[2],Ellipsoid.default.cartographicToCartesian(scratchCartographic$9,scratchCartesian$4),[scratchCartesian$4.x,scratchCartesian$4.y,scratchCartesian$4.z];const n=new Array(t);for(let i=0;i<t;i+=4)n[i]=e[i],scratchCartographic$9.longitude=CesiumMath.toRadians(e[i+1]),scratchCartographic$9.latitude=CesiumMath.toRadians(e[i+2]),scratchCartographic$9.height=e[i+3],Ellipsoid.default.cartographicToCartesian(scratchCartographic$9,scratchCartesian$4),n[i+1]=scratchCartesian$4.x,n[i+2]=scratchCartesian$4.y,n[i+3]=scratchCartesian$4.z;return n}function unwrapCartesianInterval(e){const t=e.cartesian;if(defined(t))return t;const n=e.cartesianVelocity;if(defined(n))return n;const i=e.unitCartesian;if(defined(i))return i;const r=e.unitSpherical;if(defined(r))return convertUnitSphericalToCartesian(r);const o=e.spherical;if(defined(o))return convertSphericalToCartesian(o);const a=e.cartographicRadians;if(defined(a))return convertCartographicRadiansToCartesian(a);const s=e.cartographicDegrees;if(defined(s))return convertCartographicDegreesToCartesian(s);throw new RuntimeError(`${JSON.stringify(e)} is not a valid CZML interval.`)}function normalizePackedCartesianArray(e,t){Cartesian3.unpack(e,t,scratchCartesian$4),Cartesian3.normalize(scratchCartesian$4,scratchCartesian$4),Cartesian3.pack(scratchCartesian$4,e,t)}function unwrapUnitCartesianInterval(e){const t=unwrapCartesianInterval(e);if(t.length===3)return normalizePackedCartesianArray(t,0),t;for(let n=1;n<t.length;n+=4)normalizePackedCartesianArray(t,n);return t}function normalizePackedQuaternionArray(e,t){Quaternion.unpack(e,t,scratchQuaternion),Quaternion.normalize(scratchQuaternion,scratchQuaternion),Quaternion.pack(scratchQuaternion,e,t)}function unwrapQuaternionInterval(e){const t=e.unitQuaternion;if(defined(t)){if(t.length===4)return normalizePackedQuaternionArray(t,0),t;for(let n=1;n<t.length;n+=5)normalizePackedQuaternionArray(t,n)}return t}function getPropertyType(e){return typeof e=="boolean"?Boolean:typeof e=="number"?Number:typeof e=="string"?String:e.hasOwnProperty("array")?Array:e.hasOwnProperty("boolean")?Boolean:e.hasOwnProperty("boundingRectangle")?BoundingRectangle:e.hasOwnProperty("cartesian2")?Cartesian2:e.hasOwnProperty("cartesian")||e.hasOwnProperty("spherical")||e.hasOwnProperty("cartographicRadians")||e.hasOwnProperty("cartographicDegrees")?Cartesian3:e.hasOwnProperty("unitCartesian")||e.hasOwnProperty("unitSpherical")?UnitCartesian3:e.hasOwnProperty("rgba")||e.hasOwnProperty("rgbaf")?Color:e.hasOwnProperty("arcType")?ArcType:e.hasOwnProperty("classificationType")?ClassificationType:e.hasOwnProperty("colorBlendMode")?ColorBlendMode:e.hasOwnProperty("cornerType")?CornerType$1:e.hasOwnProperty("heightReference")?HeightReference:e.hasOwnProperty("horizontalOrigin")?HorizontalOrigin:e.hasOwnProperty("date")?JulianDate:e.hasOwnProperty("labelStyle")?LabelStyle:e.hasOwnProperty("number")?Number:e.hasOwnProperty("nearFarScalar")?NearFarScalar:e.hasOwnProperty("distanceDisplayCondition")?DistanceDisplayCondition:e.hasOwnProperty("object")||e.hasOwnProperty("value")?Object:e.hasOwnProperty("unitQuaternion")?Quaternion:e.hasOwnProperty("shadowMode")?ShadowMode:e.hasOwnProperty("string")?String:e.hasOwnProperty("stripeOrientation")?StripeOrientation$1:e.hasOwnProperty("wsen")||e.hasOwnProperty("wsenDegrees")?Rectangle:e.hasOwnProperty("uri")?Uri:e.hasOwnProperty("verticalOrigin")?VerticalOrigin:Object}function unwrapInterval(e,t,n){switch(e){case ArcType:return ArcType[defaultValue(t.arcType,t)];case Array:return t.array;case Boolean:return defaultValue(t.boolean,t);case BoundingRectangle:return t.boundingRectangle;case Cartesian2:return t.cartesian2;case Cartesian3:return unwrapCartesianInterval(t);case UnitCartesian3:return unwrapUnitCartesianInterval(t);case Color:return unwrapColorInterval(t);case ClassificationType:return ClassificationType[defaultValue(t.classificationType,t)];case ColorBlendMode:return ColorBlendMode[defaultValue(t.colorBlendMode,t)];case CornerType$1:return CornerType$1[defaultValue(t.cornerType,t)];case HeightReference:return HeightReference[defaultValue(t.heightReference,t)];case HorizontalOrigin:return HorizontalOrigin[defaultValue(t.horizontalOrigin,t)];case Image:return unwrapUriInterval(t,n);case JulianDate:return JulianDate.fromIso8601(defaultValue(t.date,t));case LabelStyle:return LabelStyle[defaultValue(t.labelStyle,t)];case Number:return defaultValue(t.number,t);case NearFarScalar:return t.nearFarScalar;case DistanceDisplayCondition:return t.distanceDisplayCondition;case Object:return defaultValue(defaultValue(t.object,t.value),t);case Quaternion:return unwrapQuaternionInterval(t);case Rotation$1:return defaultValue(t.number,t);case SensorVolumePortionToDisplay$1:return SensorVolumePortionToDisplay$1[defaultValue(t.portionToDisplay,t)];case ShadowMode:return ShadowMode[defaultValue(defaultValue(t.shadowMode,t.shadows),t)];case String:return defaultValue(t.string,t);case StripeOrientation$1:return StripeOrientation$1[defaultValue(t.stripeOrientation,t)];case Rectangle:return unwrapRectangleInterval(t);case Uri:return unwrapUriInterval(t,n);case VerticalOrigin:return VerticalOrigin[defaultValue(t.verticalOrigin,t)];default:throw new RuntimeError(`Unknown CzmlDataSource interval type: ${e}`)}}const interpolators={HERMITE:HermitePolynomialApproximation$1,LAGRANGE:LagrangePolynomialApproximation$1,LINEAR:LinearApproximation};function updateInterpolationSettings(e,t){const n=e.interpolationAlgorithm,i=e.interpolationDegree;(defined(n)||defined(i))&&t.setInterpolationOptions({interpolationAlgorithm:interpolators[n],interpolationDegree:i});const r=e.forwardExtrapolationType;defined(r)&&(t.forwardExtrapolationType=ExtrapolationType[r]);const o=e.forwardExtrapolationDuration;defined(o)&&(t.forwardExtrapolationDuration=o);const a=e.backwardExtrapolationType;defined(a)&&(t.backwardExtrapolationType=ExtrapolationType[a]);const s=e.backwardExtrapolationDuration;defined(s)&&(t.backwardExtrapolationDuration=s)}const iso8601Scratch={iso8601:void 0};function intervalFromString(e){if(defined(e))return iso8601Scratch.iso8601=e,TimeInterval.fromIso8601(iso8601Scratch)}function wrapPropertyInInfiniteInterval(e){const t=Iso8601.MAXIMUM_INTERVAL.clone();return t.data=e,t}function convertPropertyToComposite(e){const t=new CompositeProperty;return t.intervals.addInterval(wrapPropertyInInfiniteInterval(e)),t}function convertPositionPropertyToComposite(e){const t=new CompositePositionProperty(e.referenceFrame);return t.intervals.addInterval(wrapPropertyInInfiniteInterval(e)),t}function processProperty(e,t,n,i,r,o,a){let s=intervalFromString(i.interval);defined(r)&&(defined(s)?s=TimeInterval.intersect(s,r,scratchTimeInterval$1):s=r);let l,c,d;const h=!defined(i.reference)&&!defined(i.velocityReference),f=defined(s)&&!s.equals(Iso8601.MAXIMUM_INTERVAL);if(i.delete===!0){if(!f){t[n]=void 0;return}return removePropertyData(t[n],s)}let p=!1;if(h){if(c=unwrapInterval(e,i,o),!defined(c))return;l=defaultValue(e.packedLength,1),d=defaultValue(c.length,1),p=!defined(i.array)&&typeof c!="string"&&d>l&&e!==Object}const u=typeof e.unpack=="function"&&e!==Rotation$1;if(!p&&!f){h?t[n]=new ConstantProperty(u?e.unpack(c,0):c):t[n]=createSpecializedProperty(e,a,i);return}let m=t[n],g;const _=i.epoch;if(defined(_)&&(g=JulianDate.fromIso8601(_)),p&&!f){m instanceof SampledProperty||(t[n]=m=new SampledProperty(e)),m.addSamplesPackedArray(c,g),updateInterpolationSettings(i,m);return}let C;if(!p&&f){s=s.clone(),h?s.data=u?e.unpack(c,0):c:s.data=createSpecializedProperty(e,a,i),defined(m)||(t[n]=m=h?new TimeIntervalCollectionProperty:new CompositeProperty),h&&m instanceof TimeIntervalCollectionProperty?m.intervals.addInterval(s):m instanceof CompositeProperty?(h&&(s.data=new ConstantProperty(s.data)),m.intervals.addInterval(s)):(t[n]=m=convertPropertyToComposite(m),h&&(s.data=new ConstantProperty(s.data)),m.intervals.addInterval(s));return}defined(m)||(t[n]=m=new CompositeProperty),m instanceof CompositeProperty||(t[n]=m=convertPropertyToComposite(m));const A=m.intervals;C=A.findInterval(s),(!defined(C)||!(C.data instanceof SampledProperty))&&(C=s.clone(),C.data=new SampledProperty(e),A.addInterval(C)),C.data.addSamplesPackedArray(c,g),updateInterpolationSettings(i,C.data)}function removePropertyData(e,t){if(e instanceof SampledProperty){e.removeSamples(t);return}else if(e instanceof TimeIntervalCollectionProperty){e.intervals.removeInterval(t);return}else if(e instanceof CompositeProperty){const n=e.intervals;for(let i=0;i<n.length;++i){const r=TimeInterval.intersect(n.get(i),t,scratchTimeInterval$1);r.isEmpty||removePropertyData(r.data,t)}n.removeInterval(t);return}}function processPacketData(e,t,n,i,r,o,a){if(defined(i))if(Array.isArray(i))for(let s=0,l=i.length;s<l;++s)processProperty(e,t,n,i[s],r,o,a);else processProperty(e,t,n,i,r,o,a)}function processPositionProperty(e,t,n,i,r,o){let a=intervalFromString(n.interval);defined(i)&&(defined(a)?a=TimeInterval.intersect(a,i,scratchTimeInterval$1):a=i);const s=defined(n.cartesianVelocity)?1:0,l=Cartesian3.packedLength*(s+1);let c,d;const h=!defined(n.reference),f=defined(a)&&!a.equals(Iso8601.MAXIMUM_INTERVAL);if(n.delete===!0){if(!f){e[t]=void 0;return}return removePositionPropertyData(e[t],a)}let p,u=!1;if(h&&(defined(n.referenceFrame)&&(p=ReferenceFrame[n.referenceFrame]),p=defaultValue(p,ReferenceFrame.FIXED),c=unwrapCartesianInterval(n),d=defaultValue(c.length,1),u=d>l),!u&&!f){h?e[t]=new ConstantPositionProperty(Cartesian3.unpack(c),p):e[t]=createReferenceProperty(o,n.reference);return}let m=e[t],g;const _=n.epoch;if(defined(_)&&(g=JulianDate.fromIso8601(_)),u&&!f){(!(m instanceof SampledPositionProperty)||defined(p)&&m.referenceFrame!==p)&&(e[t]=m=new SampledPositionProperty(p,s)),m.addSamplesPackedArray(c,g),updateInterpolationSettings(n,m);return}let C;if(!u&&f){a=a.clone(),h?a.data=Cartesian3.unpack(c):a.data=createReferenceProperty(o,n.reference),defined(m)||(h?m=new TimeIntervalCollectionPositionProperty(p):m=new CompositePositionProperty(p),e[t]=m),h&&m instanceof TimeIntervalCollectionPositionProperty&&defined(p)&&m.referenceFrame===p?m.intervals.addInterval(a):m instanceof CompositePositionProperty?(h&&(a.data=new ConstantPositionProperty(a.data,p)),m.intervals.addInterval(a)):(e[t]=m=convertPositionPropertyToComposite(m),h&&(a.data=new ConstantPositionProperty(a.data,p)),m.intervals.addInterval(a));return}defined(m)?m instanceof CompositePositionProperty||(e[t]=m=convertPositionPropertyToComposite(m)):e[t]=m=new CompositePositionProperty(p);const A=m.intervals;C=A.findInterval(a),(!defined(C)||!(C.data instanceof SampledPositionProperty)||defined(p)&&C.data.referenceFrame!==p)&&(C=a.clone(),C.data=new SampledPositionProperty(p,s),A.addInterval(C)),C.data.addSamplesPackedArray(c,g),updateInterpolationSettings(n,C.data)}function removePositionPropertyData(e,t){if(e instanceof SampledPositionProperty){e.removeSamples(t);return}else if(e instanceof TimeIntervalCollectionPositionProperty){e.intervals.removeInterval(t);return}else if(e instanceof CompositePositionProperty){const n=e.intervals;for(let i=0;i<n.length;++i){const r=TimeInterval.intersect(n.get(i),t,scratchTimeInterval$1);r.isEmpty||removePositionPropertyData(r.data,t)}n.removeInterval(t);return}}function processPositionPacketData(e,t,n,i,r,o){if(defined(n))if(Array.isArray(n))for(let a=0,s=n.length;a<s;++a)processPositionProperty(e,t,n[a],i,r,o);else processPositionProperty(e,t,n,i,r,o)}function processShapePacketData(e,t,n,i){defined(n.references)?processReferencesArrayPacketData(e,t,n.references,n.interval,i,PropertyArray,CompositeProperty):(defined(n.cartesian2)?n.array=Cartesian2.unpackArray(n.cartesian2):defined(n.cartesian)&&(n.array=Cartesian2.unpackArray(n.cartesian)),defined(n.array)&&processPacketData(Array,e,t,n,void 0,void 0,i))}function processMaterialProperty(e,t,n,i,r,o){let a=intervalFromString(n.interval);defined(i)&&(defined(a)?a=TimeInterval.intersect(a,i,scratchTimeInterval$1):a=i);let s=e[t],l,c;if(defined(a)){s instanceof CompositeMaterialProperty||(s=new CompositeMaterialProperty,e[t]=s);const h=s.intervals;c=h.findInterval({start:a.start,stop:a.stop}),defined(c)?l=c.data:(c=a.clone(),h.addInterval(c))}else l=s;let d;defined(n.solidColor)?(l instanceof ColorMaterialProperty||(l=new ColorMaterialProperty),d=n.solidColor,processPacketData(Color,l,"color",d.color,void 0,void 0,o)):defined(n.grid)?(l instanceof GridMaterialProperty||(l=new GridMaterialProperty),d=n.grid,processPacketData(Color,l,"color",d.color,void 0,r,o),processPacketData(Number,l,"cellAlpha",d.cellAlpha,void 0,r,o),processPacketData(Cartesian2,l,"lineCount",d.lineCount,void 0,r,o),processPacketData(Cartesian2,l,"lineThickness",d.lineThickness,void 0,r,o),processPacketData(Cartesian2,l,"lineOffset",d.lineOffset,void 0,r,o)):defined(n.image)?(l instanceof ImageMaterialProperty||(l=new ImageMaterialProperty),d=n.image,processPacketData(Image,l,"image",d.image,void 0,r,o),processPacketData(Cartesian2,l,"repeat",d.repeat,void 0,r,o),processPacketData(Color,l,"color",d.color,void 0,r,o),processPacketData(Boolean,l,"transparent",d.transparent,void 0,r,o)):defined(n.stripe)?(l instanceof StripeMaterialProperty||(l=new StripeMaterialProperty),d=n.stripe,processPacketData(StripeOrientation$1,l,"orientation",d.orientation,void 0,r,o),processPacketData(Color,l,"evenColor",d.evenColor,void 0,r,o),processPacketData(Color,l,"oddColor",d.oddColor,void 0,r,o),processPacketData(Number,l,"offset",d.offset,void 0,r,o),processPacketData(Number,l,"repeat",d.repeat,void 0,r,o)):defined(n.polylineOutline)?(l instanceof PolylineOutlineMaterialProperty||(l=new PolylineOutlineMaterialProperty),d=n.polylineOutline,processPacketData(Color,l,"color",d.color,void 0,r,o),processPacketData(Color,l,"outlineColor",d.outlineColor,void 0,r,o),processPacketData(Number,l,"outlineWidth",d.outlineWidth,void 0,r,o)):defined(n.polylineGlow)?(l instanceof PolylineGlowMaterialProperty||(l=new PolylineGlowMaterialProperty),d=n.polylineGlow,processPacketData(Color,l,"color",d.color,void 0,r,o),processPacketData(Number,l,"glowPower",d.glowPower,void 0,r,o),processPacketData(Number,l,"taperPower",d.taperPower,void 0,r,o)):defined(n.polylineArrow)?(l instanceof PolylineArrowMaterialProperty||(l=new PolylineArrowMaterialProperty),d=n.polylineArrow,processPacketData(Color,l,"color",d.color,void 0,void 0,o)):defined(n.polylineDash)?(l instanceof PolylineDashMaterialProperty||(l=new PolylineDashMaterialProperty),d=n.polylineDash,processPacketData(Color,l,"color",d.color,void 0,void 0,o),processPacketData(Color,l,"gapColor",d.gapColor,void 0,void 0,o),processPacketData(Number,l,"dashLength",d.dashLength,void 0,r,o),processPacketData(Number,l,"dashPattern",d.dashPattern,void 0,r,o)):defined(n.checkerboard)&&(l instanceof CheckerboardMaterialProperty||(l=new CheckerboardMaterialProperty),d=n.checkerboard,processPacketData(Color,l,"evenColor",d.evenColor,void 0,r,o),processPacketData(Color,l,"oddColor",d.oddColor,void 0,r,o),processPacketData(Cartesian2,l,"repeat",d.repeat,void 0,r,o)),defined(c)?c.data=l:e[t]=l}function processMaterialPacketData(e,t,n,i,r,o){if(defined(n))if(Array.isArray(n))for(let a=0,s=n.length;a<s;++a)processMaterialProperty(e,t,n[a],i,r,o);else processMaterialProperty(e,t,n,i,r,o)}function processName(e,t,n,i){const r=t.name;defined(r)&&(e.name=t.name)}function processDescription$2(e,t,n,i){const r=t.description;defined(r)&&processPacketData(String,e,"description",r,void 0,i,n)}function processPosition(e,t,n,i){const r=t.position;defined(r)&&processPositionPacketData(e,"position",r,void 0,i,n)}function processViewFrom(e,t,n,i){const r=t.viewFrom;defined(r)&&processPacketData(Cartesian3,e,"viewFrom",r,void 0,i,n)}function processOrientation(e,t,n,i){const r=t.orientation;defined(r)&&processPacketData(Quaternion,e,"orientation",r,void 0,i,n)}function processProperties(e,t,n,i){const r=t.properties;if(defined(r)){defined(e.properties)||(e.properties=new PropertyBag);for(const o in r)if(r.hasOwnProperty(o)){e.properties.hasProperty(o)||e.properties.addProperty(o);const a=r[o];if(Array.isArray(a))for(let s=0,l=a.length;s<l;++s)processProperty(getPropertyType(a[s]),e.properties,o,a[s],void 0,i,n);else processProperty(getPropertyType(a),e.properties,o,a,void 0,i,n)}}}function processReferencesArrayPacketData(e,t,n,i,r,o,a){const s=n.map(function(l){return createReferenceProperty(r,l)});if(defined(i)){i=intervalFromString(i);let l=e[t];if(!(l instanceof a)){const c=new a;c.intervals.addInterval(wrapPropertyInInfiniteInterval(l)),e[t]=l=c}i.data=new o(s),l.intervals.addInterval(i)}else e[t]=new o(s)}function processArrayPacketData(e,t,n,i){const r=n.references;defined(r)?processReferencesArrayPacketData(e,t,r,n.interval,i,PropertyArray,CompositeProperty):processPacketData(Array,e,t,n,void 0,void 0,i)}function processArray(e,t,n,i){if(defined(n))if(Array.isArray(n))for(let r=0,o=n.length;r<o;++r)processArrayPacketData(e,t,n[r],i);else processArrayPacketData(e,t,n,i)}function processPositionArrayPacketData(e,t,n,i){const r=n.references;defined(r)?processReferencesArrayPacketData(e,t,r,n.interval,i,PositionPropertyArray,CompositePositionProperty):(defined(n.cartesian)?n.array=Cartesian3.unpackArray(n.cartesian):defined(n.cartographicRadians)?n.array=Cartesian3.fromRadiansArrayHeights(n.cartographicRadians,Ellipsoid.default):defined(n.cartographicDegrees)&&(n.array=Cartesian3.fromDegreesArrayHeights(n.cartographicDegrees,Ellipsoid.default)),defined(n.array)&&processPacketData(Array,e,t,n,void 0,void 0,i))}function processPositionArray(e,t,n,i){if(defined(n))if(Array.isArray(n))for(let r=0,o=n.length;r<o;++r)processPositionArrayPacketData(e,t,n[r],i);else processPositionArrayPacketData(e,t,n,i)}function unpackCartesianArray(e){return Cartesian3.unpackArray(e)}function unpackCartographicRadiansArray(e){return Cartesian3.fromRadiansArrayHeights(e,Ellipsoid.default)}function unpackCartographicDegreesArray(e){return Cartesian3.fromDegreesArrayHeights(e,Ellipsoid.default)}function processPositionArrayOfArraysPacketData(e,t,n,i){const r=n.references;if(defined(r)){const o=r.map(function(a){const s={};return processReferencesArrayPacketData(s,"positions",a,n.interval,i,PositionPropertyArray,CompositePositionProperty),s.positions});e[t]=new PositionPropertyArray(o)}else defined(n.cartesian)?n.array=n.cartesian.map(unpackCartesianArray):defined(n.cartographicRadians)?n.array=n.cartographicRadians.map(unpackCartographicRadiansArray):defined(n.cartographicDegrees)&&(n.array=n.cartographicDegrees.map(unpackCartographicDegreesArray)),defined(n.array)&&processPacketData(Array,e,t,n,void 0,void 0,i)}function processPositionArrayOfArrays(e,t,n,i){if(defined(n))if(Array.isArray(n))for(let r=0,o=n.length;r<o;++r)processPositionArrayOfArraysPacketData(e,t,n[r],i);else processPositionArrayOfArraysPacketData(e,t,n,i)}function processShape(e,t,n,i){if(defined(n))if(Array.isArray(n))for(let r=0,o=n.length;r<o;r++)processShapePacketData(e,t,n[r],i);else processShapePacketData(e,t,n,i)}function processAvailability(e,t,n,i){const r=t.availability;if(!defined(r))return;let o;if(Array.isArray(r))for(let a=0,s=r.length;a<s;++a)defined(o)||(o=new TimeIntervalCollection),o.addInterval(intervalFromString(r[a]));else o=new TimeIntervalCollection,o.addInterval(intervalFromString(r));e.availability=o}function processAlignedAxis(e,t,n,i,r){defined(t)&&processPacketData(UnitCartesian3,e,"alignedAxis",t,n,i,r)}function processBillboard(e,t,n,i){const r=t.billboard;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.billboard;defined(a)||(e.billboard=a=new BillboardGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(Image,a,"image",r.image,o,i,n),processPacketData(Number,a,"scale",r.scale,o,i,n),processPacketData(Cartesian2,a,"pixelOffset",r.pixelOffset,o,i,n),processPacketData(Cartesian3,a,"eyeOffset",r.eyeOffset,o,i,n),processPacketData(HorizontalOrigin,a,"horizontalOrigin",r.horizontalOrigin,o,i,n),processPacketData(VerticalOrigin,a,"verticalOrigin",r.verticalOrigin,o,i,n),processPacketData(HeightReference,a,"heightReference",r.heightReference,o,i,n),processPacketData(Color,a,"color",r.color,o,i,n),processPacketData(Rotation$1,a,"rotation",r.rotation,o,i,n),processAlignedAxis(a,r.alignedAxis,o,i,n),processPacketData(Boolean,a,"sizeInMeters",r.sizeInMeters,o,i,n),processPacketData(Number,a,"width",r.width,o,i,n),processPacketData(Number,a,"height",r.height,o,i,n),processPacketData(NearFarScalar,a,"scaleByDistance",r.scaleByDistance,o,i,n),processPacketData(NearFarScalar,a,"translucencyByDistance",r.translucencyByDistance,o,i,n),processPacketData(NearFarScalar,a,"pixelOffsetScaleByDistance",r.pixelOffsetScaleByDistance,o,i,n),processPacketData(BoundingRectangle,a,"imageSubRegion",r.imageSubRegion,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n),processPacketData(Number,a,"disableDepthTestDistance",r.disableDepthTestDistance,o,i,n)}function processBox(e,t,n,i){const r=t.box;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.box;defined(a)||(e.box=a=new BoxGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(Cartesian3,a,"dimensions",r.dimensions,o,i,n),processPacketData(HeightReference,a,"heightReference",r.heightReference,o,i,n),processPacketData(Boolean,a,"fill",r.fill,o,i,n),processMaterialPacketData(a,"material",r.material,o,i,n),processPacketData(Boolean,a,"outline",r.outline,o,i,n),processPacketData(Color,a,"outlineColor",r.outlineColor,o,i,n),processPacketData(Number,a,"outlineWidth",r.outlineWidth,o,i,n),processPacketData(ShadowMode,a,"shadows",r.shadows,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n)}function processCorridor(e,t,n,i){const r=t.corridor;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.corridor;defined(a)||(e.corridor=a=new CorridorGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPositionArray(a,"positions",r.positions,n),processPacketData(Number,a,"width",r.width,o,i,n),processPacketData(Number,a,"height",r.height,o,i,n),processPacketData(HeightReference,a,"heightReference",r.heightReference,o,i,n),processPacketData(Number,a,"extrudedHeight",r.extrudedHeight,o,i,n),processPacketData(HeightReference,a,"extrudedHeightReference",r.extrudedHeightReference,o,i,n),processPacketData(CornerType$1,a,"cornerType",r.cornerType,o,i,n),processPacketData(Number,a,"granularity",r.granularity,o,i,n),processPacketData(Boolean,a,"fill",r.fill,o,i,n),processMaterialPacketData(a,"material",r.material,o,i,n),processPacketData(Boolean,a,"outline",r.outline,o,i,n),processPacketData(Color,a,"outlineColor",r.outlineColor,o,i,n),processPacketData(Number,a,"outlineWidth",r.outlineWidth,o,i,n),processPacketData(ShadowMode,a,"shadows",r.shadows,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n),processPacketData(ClassificationType,a,"classificationType",r.classificationType,o,i,n),processPacketData(Number,a,"zIndex",r.zIndex,o,i,n)}function processCylinder(e,t,n,i){const r=t.cylinder;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.cylinder;defined(a)||(e.cylinder=a=new CylinderGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(Number,a,"length",r.length,o,i,n),processPacketData(Number,a,"topRadius",r.topRadius,o,i,n),processPacketData(Number,a,"bottomRadius",r.bottomRadius,o,i,n),processPacketData(HeightReference,a,"heightReference",r.heightReference,o,i,n),processPacketData(Boolean,a,"fill",r.fill,o,i,n),processMaterialPacketData(a,"material",r.material,o,i,n),processPacketData(Boolean,a,"outline",r.outline,o,i,n),processPacketData(Color,a,"outlineColor",r.outlineColor,o,i,n),processPacketData(Number,a,"outlineWidth",r.outlineWidth,o,i,n),processPacketData(Number,a,"numberOfVerticalLines",r.numberOfVerticalLines,o,i,n),processPacketData(Number,a,"slices",r.slices,o,i,n),processPacketData(ShadowMode,a,"shadows",r.shadows,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n)}function processDocument$1(e,t){const n=e.version;if(defined(n)&&typeof n=="string"){const o=n.split(".");if(o.length===2){if(o[0]!=="1")throw new RuntimeError("Cesium only supports CZML version 1.");t._version=n}}if(!defined(t._version))throw new RuntimeError("CZML version information invalid.  It is expected to be a property on the document object in the <Major>.<Minor> version format.");const i=t._documentPacket;defined(e.name)&&(i.name=e.name);const r=e.clock;if(defined(r)){const o=i.clock;defined(o)?(o.interval=defaultValue(r.interval,o.interval),o.currentTime=defaultValue(r.currentTime,o.currentTime),o.range=defaultValue(r.range,o.range),o.step=defaultValue(r.step,o.step),o.multiplier=defaultValue(r.multiplier,o.multiplier)):i.clock={interval:r.interval,currentTime:r.currentTime,range:r.range,step:r.step,multiplier:r.multiplier}}}function processEllipse(e,t,n,i){const r=t.ellipse;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.ellipse;defined(a)||(e.ellipse=a=new EllipseGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(Number,a,"semiMajorAxis",r.semiMajorAxis,o,i,n),processPacketData(Number,a,"semiMinorAxis",r.semiMinorAxis,o,i,n),processPacketData(Number,a,"height",r.height,o,i,n),processPacketData(HeightReference,a,"heightReference",r.heightReference,o,i,n),processPacketData(Number,a,"extrudedHeight",r.extrudedHeight,o,i,n),processPacketData(HeightReference,a,"extrudedHeightReference",r.extrudedHeightReference,o,i,n),processPacketData(Rotation$1,a,"rotation",r.rotation,o,i,n),processPacketData(Rotation$1,a,"stRotation",r.stRotation,o,i,n),processPacketData(Number,a,"granularity",r.granularity,o,i,n),processPacketData(Boolean,a,"fill",r.fill,o,i,n),processMaterialPacketData(a,"material",r.material,o,i,n),processPacketData(Boolean,a,"outline",r.outline,o,i,n),processPacketData(Color,a,"outlineColor",r.outlineColor,o,i,n),processPacketData(Number,a,"outlineWidth",r.outlineWidth,o,i,n),processPacketData(Number,a,"numberOfVerticalLines",r.numberOfVerticalLines,o,i,n),processPacketData(ShadowMode,a,"shadows",r.shadows,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n),processPacketData(ClassificationType,a,"classificationType",r.classificationType,o,i,n),processPacketData(Number,a,"zIndex",r.zIndex,o,i,n)}function processEllipsoid(e,t,n,i){const r=t.ellipsoid;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.ellipsoid;defined(a)||(e.ellipsoid=a=new EllipsoidGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(Cartesian3,a,"radii",r.radii,o,i,n),processPacketData(Cartesian3,a,"innerRadii",r.innerRadii,o,i,n),processPacketData(Number,a,"minimumClock",r.minimumClock,o,i,n),processPacketData(Number,a,"maximumClock",r.maximumClock,o,i,n),processPacketData(Number,a,"minimumCone",r.minimumCone,o,i,n),processPacketData(Number,a,"maximumCone",r.maximumCone,o,i,n),processPacketData(HeightReference,a,"heightReference",r.heightReference,o,i,n),processPacketData(Boolean,a,"fill",r.fill,o,i,n),processMaterialPacketData(a,"material",r.material,o,i,n),processPacketData(Boolean,a,"outline",r.outline,o,i,n),processPacketData(Color,a,"outlineColor",r.outlineColor,o,i,n),processPacketData(Number,a,"outlineWidth",r.outlineWidth,o,i,n),processPacketData(Number,a,"stackPartitions",r.stackPartitions,o,i,n),processPacketData(Number,a,"slicePartitions",r.slicePartitions,o,i,n),processPacketData(Number,a,"subdivisions",r.subdivisions,o,i,n),processPacketData(ShadowMode,a,"shadows",r.shadows,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n)}function processLabel(e,t,n,i){const r=t.label;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.label;defined(a)||(e.label=a=new LabelGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(String,a,"text",r.text,o,i,n),processPacketData(String,a,"font",r.font,o,i,n),processPacketData(LabelStyle,a,"style",r.style,o,i,n),processPacketData(Number,a,"scale",r.scale,o,i,n),processPacketData(Boolean,a,"showBackground",r.showBackground,o,i,n),processPacketData(Color,a,"backgroundColor",r.backgroundColor,o,i,n),processPacketData(Cartesian2,a,"backgroundPadding",r.backgroundPadding,o,i,n),processPacketData(Cartesian2,a,"pixelOffset",r.pixelOffset,o,i,n),processPacketData(Cartesian3,a,"eyeOffset",r.eyeOffset,o,i,n),processPacketData(HorizontalOrigin,a,"horizontalOrigin",r.horizontalOrigin,o,i,n),processPacketData(VerticalOrigin,a,"verticalOrigin",r.verticalOrigin,o,i,n),processPacketData(HeightReference,a,"heightReference",r.heightReference,o,i,n),processPacketData(Color,a,"fillColor",r.fillColor,o,i,n),processPacketData(Color,a,"outlineColor",r.outlineColor,o,i,n),processPacketData(Number,a,"outlineWidth",r.outlineWidth,o,i,n),processPacketData(NearFarScalar,a,"translucencyByDistance",r.translucencyByDistance,o,i,n),processPacketData(NearFarScalar,a,"pixelOffsetScaleByDistance",r.pixelOffsetScaleByDistance,o,i,n),processPacketData(NearFarScalar,a,"scaleByDistance",r.scaleByDistance,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n),processPacketData(Number,a,"disableDepthTestDistance",r.disableDepthTestDistance,o,i,n)}function processModel(e,t,n,i){const r=t.model;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.model;defined(a)||(e.model=a=new ModelGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(Uri,a,"uri",r.gltf,o,i,n),processPacketData(Number,a,"scale",r.scale,o,i,n),processPacketData(Number,a,"minimumPixelSize",r.minimumPixelSize,o,i,n),processPacketData(Number,a,"maximumScale",r.maximumScale,o,i,n),processPacketData(Boolean,a,"incrementallyLoadTextures",r.incrementallyLoadTextures,o,i,n),processPacketData(Boolean,a,"runAnimations",r.runAnimations,o,i,n),processPacketData(Boolean,a,"clampAnimations",r.clampAnimations,o,i,n),processPacketData(ShadowMode,a,"shadows",r.shadows,o,i,n),processPacketData(HeightReference,a,"heightReference",r.heightReference,o,i,n),processPacketData(Color,a,"silhouetteColor",r.silhouetteColor,o,i,n),processPacketData(Number,a,"silhouetteSize",r.silhouetteSize,o,i,n),processPacketData(Color,a,"color",r.color,o,i,n),processPacketData(ColorBlendMode,a,"colorBlendMode",r.colorBlendMode,o,i,n),processPacketData(Number,a,"colorBlendAmount",r.colorBlendAmount,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n);let s,l;const c=r.nodeTransformations;if(defined(c))if(Array.isArray(c))for(s=0,l=c.length;s<l;++s)processNodeTransformations(a,c[s],o,i,n);else processNodeTransformations(a,c,o,i,n);const d=r.articulations;if(defined(d))if(Array.isArray(d))for(s=0,l=d.length;s<l;++s)processArticulations(a,d[s],o,i,n);else processArticulations(a,d,o,i,n)}function processNodeTransformations(e,t,n,i,r){let o=intervalFromString(t.interval);defined(n)&&(defined(o)?o=TimeInterval.intersect(o,n,scratchTimeInterval$1):o=n);let a=e.nodeTransformations;const s=Object.keys(t);for(let l=0,c=s.length;l<c;++l){const d=s[l];if(d==="interval")continue;const h=t[d];if(!defined(h))continue;defined(a)||(e.nodeTransformations=a=new PropertyBag),a.hasProperty(d)||a.addProperty(d);let f=a[d];defined(f)||(a[d]=f=new NodeTransformationProperty),processPacketData(Cartesian3,f,"translation",h.translation,o,i,r),processPacketData(Quaternion,f,"rotation",h.rotation,o,i,r),processPacketData(Cartesian3,f,"scale",h.scale,o,i,r)}}function processArticulations(e,t,n,i,r){let o=intervalFromString(t.interval);defined(n)&&(defined(o)?o=TimeInterval.intersect(o,n,scratchTimeInterval$1):o=n);let a=e.articulations;const s=Object.keys(t);for(let l=0,c=s.length;l<c;++l){const d=s[l];if(d==="interval")continue;const h=t[d];defined(h)&&(defined(a)||(e.articulations=a=new PropertyBag),a.hasProperty(d)||a.addProperty(d),processPacketData(Number,a,d,h,o,i,r))}}function processPath(e,t,n,i){const r=t.path;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.path;defined(a)||(e.path=a=new PathGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(Number,a,"leadTime",r.leadTime,o,i,n),processPacketData(Number,a,"trailTime",r.trailTime,o,i,n),processPacketData(Number,a,"width",r.width,o,i,n),processPacketData(Number,a,"resolution",r.resolution,o,i,n),processMaterialPacketData(a,"material",r.material,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n)}function processPoint$2(e,t,n,i){const r=t.point;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.point;defined(a)||(e.point=a=new PointGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(Number,a,"pixelSize",r.pixelSize,o,i,n),processPacketData(HeightReference,a,"heightReference",r.heightReference,o,i,n),processPacketData(Color,a,"color",r.color,o,i,n),processPacketData(Color,a,"outlineColor",r.outlineColor,o,i,n),processPacketData(Number,a,"outlineWidth",r.outlineWidth,o,i,n),processPacketData(NearFarScalar,a,"scaleByDistance",r.scaleByDistance,o,i,n),processPacketData(NearFarScalar,a,"translucencyByDistance",r.translucencyByDistance,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n),processPacketData(Number,a,"disableDepthTestDistance",r.disableDepthTestDistance,o,i,n)}function PolygonHierarchyProperty(e){this.polygon=e,this._definitionChanged=new Event}Object.defineProperties(PolygonHierarchyProperty.prototype,{isConstant:{get:function(){const e=this.polygon._positions,t=this.polygon._holes;return(!defined(e)||e.isConstant)&&(!defined(t)||t.isConstant)}},definitionChanged:{get:function(){return this._definitionChanged}}});PolygonHierarchyProperty.prototype.getValue=function(e,t){let n;defined(this.polygon._positions)&&(n=this.polygon._positions.getValue(e));let i;return defined(this.polygon._holes)&&(i=this.polygon._holes.getValue(e),defined(i)&&(i=i.map(function(r){return new PolygonHierarchy(r)}))),defined(t)?(t.positions=n,t.holes=i,t):new PolygonHierarchy(n,i)};PolygonHierarchyProperty.prototype.equals=function(e){return this===e||e instanceof PolygonHierarchyProperty&&Property.equals(this.polygon._positions,e.polygon._positions)&&Property.equals(this.polygon._holes,e.polygon._holes)};function processPolygon$2(e,t,n,i){const r=t.polygon;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.polygon;defined(a)||(e.polygon=a=new PolygonGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPositionArray(a,"_positions",r.positions,n),processPositionArrayOfArrays(a,"_holes",r.holes,n),(defined(a._positions)||defined(a._holes))&&(a.hierarchy=new PolygonHierarchyProperty(a)),processPacketData(Number,a,"height",r.height,o,i,n),processPacketData(HeightReference,a,"heightReference",r.heightReference,o,i,n),processPacketData(Number,a,"extrudedHeight",r.extrudedHeight,o,i,n),processPacketData(HeightReference,a,"extrudedHeightReference",r.extrudedHeightReference,o,i,n),processPacketData(Rotation$1,a,"stRotation",r.stRotation,o,i,n),processPacketData(Number,a,"granularity",r.granularity,o,i,n),processPacketData(Boolean,a,"fill",r.fill,o,i,n),processMaterialPacketData(a,"material",r.material,o,i,n),processPacketData(Boolean,a,"outline",r.outline,o,i,n),processPacketData(Color,a,"outlineColor",r.outlineColor,o,i,n),processPacketData(Number,a,"outlineWidth",r.outlineWidth,o,i,n),processPacketData(Boolean,a,"perPositionHeight",r.perPositionHeight,o,i,n),processPacketData(Boolean,a,"closeTop",r.closeTop,o,i,n),processPacketData(Boolean,a,"closeBottom",r.closeBottom,o,i,n),processPacketData(ArcType,a,"arcType",r.arcType,o,i,n),processPacketData(ShadowMode,a,"shadows",r.shadows,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n),processPacketData(ClassificationType,a,"classificationType",r.classificationType,o,i,n),processPacketData(Number,a,"zIndex",r.zIndex,o,i,n)}function adaptFollowSurfaceToArcType(e){return e?ArcType.GEODESIC:ArcType.NONE}function processPolyline(e,t,n,i){const r=t.polyline;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.polyline;if(defined(a)||(e.polyline=a=new PolylineGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPositionArray(a,"positions",r.positions,n),processPacketData(Number,a,"width",r.width,o,i,n),processPacketData(Number,a,"granularity",r.granularity,o,i,n),processMaterialPacketData(a,"material",r.material,o,i,n),processMaterialPacketData(a,"depthFailMaterial",r.depthFailMaterial,o,i,n),processPacketData(ArcType,a,"arcType",r.arcType,o,i,n),processPacketData(Boolean,a,"clampToGround",r.clampToGround,o,i,n),processPacketData(ShadowMode,a,"shadows",r.shadows,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n),processPacketData(ClassificationType,a,"classificationType",r.classificationType,o,i,n),processPacketData(Number,a,"zIndex",r.zIndex,o,i,n),defined(r.followSurface)&&!defined(r.arcType)){const s={};processPacketData(Boolean,s,"followSurface",r.followSurface,o,i,n),a.arcType=createAdapterProperty(s.followSurface,adaptFollowSurfaceToArcType)}}function processPolylineVolume(e,t,n,i){const r=t.polylineVolume;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.polylineVolume;defined(a)||(e.polylineVolume=a=new PolylineVolumeGraphics),processPositionArray(a,"positions",r.positions,n),processShape(a,"shape",r.shape,n),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(CornerType$1,a,"cornerType",r.cornerType,o,i,n),processPacketData(Boolean,a,"fill",r.fill,o,i,n),processMaterialPacketData(a,"material",r.material,o,i,n),processPacketData(Boolean,a,"outline",r.outline,o,i,n),processPacketData(Color,a,"outlineColor",r.outlineColor,o,i,n),processPacketData(Number,a,"outlineWidth",r.outlineWidth,o,i,n),processPacketData(Number,a,"granularity",r.granularity,o,i,n),processPacketData(ShadowMode,a,"shadows",r.shadows,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n)}function processRectangle(e,t,n,i){const r=t.rectangle;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.rectangle;defined(a)||(e.rectangle=a=new RectangleGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(Rectangle,a,"coordinates",r.coordinates,o,i,n),processPacketData(Number,a,"height",r.height,o,i,n),processPacketData(HeightReference,a,"heightReference",r.heightReference,o,i,n),processPacketData(Number,a,"extrudedHeight",r.extrudedHeight,o,i,n),processPacketData(HeightReference,a,"extrudedHeightReference",r.extrudedHeightReference,o,i,n),processPacketData(Rotation$1,a,"rotation",r.rotation,o,i,n),processPacketData(Rotation$1,a,"stRotation",r.stRotation,o,i,n),processPacketData(Number,a,"granularity",r.granularity,o,i,n),processPacketData(Boolean,a,"fill",r.fill,o,i,n),processMaterialPacketData(a,"material",r.material,o,i,n),processPacketData(Boolean,a,"outline",r.outline,o,i,n),processPacketData(Color,a,"outlineColor",r.outlineColor,o,i,n),processPacketData(Number,a,"outlineWidth",r.outlineWidth,o,i,n),processPacketData(ShadowMode,a,"shadows",r.shadows,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n),processPacketData(ClassificationType,a,"classificationType",r.classificationType,o,i,n),processPacketData(Number,a,"zIndex",r.zIndex,o,i,n)}function processTileset(e,t,n,i){const r=t.tileset;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.tileset;defined(a)||(e.tileset=a=new Cesium3DTilesetGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPacketData(Uri,a,"uri",r.uri,o,i,n),processPacketData(Number,a,"maximumScreenSpaceError",r.maximumScreenSpaceError,o,i,n)}function processWall(e,t,n,i){const r=t.wall;if(!defined(r))return;const o=intervalFromString(r.interval);let a=e.wall;defined(a)||(e.wall=a=new WallGraphics),processPacketData(Boolean,a,"show",r.show,o,i,n),processPositionArray(a,"positions",r.positions,n),processArray(a,"minimumHeights",r.minimumHeights,n),processArray(a,"maximumHeights",r.maximumHeights,n),processPacketData(Number,a,"granularity",r.granularity,o,i,n),processPacketData(Boolean,a,"fill",r.fill,o,i,n),processMaterialPacketData(a,"material",r.material,o,i,n),processPacketData(Boolean,a,"outline",r.outline,o,i,n),processPacketData(Color,a,"outlineColor",r.outlineColor,o,i,n),processPacketData(Number,a,"outlineWidth",r.outlineWidth,o,i,n),processPacketData(ShadowMode,a,"shadows",r.shadows,o,i,n),processPacketData(DistanceDisplayCondition,a,"distanceDisplayCondition",r.distanceDisplayCondition,o,i,n)}function processCzmlPacket(e,t,n,i,r){let o=e.id;if(defined(o)||(o=createGuid()),currentId=o,!defined(r._version)&&o!=="document")throw new RuntimeError("The first CZML packet is required to be the document object.");if(e.delete===!0)t.removeById(o);else if(o==="document")processDocument$1(e,r);else{const a=t.getOrCreateEntity(o),s=e.parent;defined(s)&&(a.parent=t.getOrCreateEntity(s));for(let l=n.length-1;l>-1;l--)n[l](a,e,t,i)}currentId=void 0}function updateClock(e){let t;const n=e._documentPacket.clock;if(!defined(n)){if(!defined(e._clock)){const r=e._entityCollection.computeAvailability();if(!r.start.equals(Iso8601.MINIMUM_VALUE)){const o=r.start,a=r.stop,s=JulianDate.secondsDifference(a,o),l=Math.round(s/120);return t=new DataSourceClock,t.startTime=JulianDate.clone(o),t.stopTime=JulianDate.clone(a),t.clockRange=ClockRange$1.LOOP_STOP,t.multiplier=l,t.currentTime=JulianDate.clone(o),t.clockStep=ClockStep$1.SYSTEM_CLOCK_MULTIPLIER,e._clock=t,!0}}return!1}defined(e._clock)?t=e._clock.clone():(t=new DataSourceClock,t.startTime=Iso8601.MINIMUM_VALUE.clone(),t.stopTime=Iso8601.MAXIMUM_VALUE.clone(),t.currentTime=Iso8601.MINIMUM_VALUE.clone(),t.clockRange=ClockRange$1.LOOP_STOP,t.clockStep=ClockStep$1.SYSTEM_CLOCK_MULTIPLIER,t.multiplier=1);const i=intervalFromString(n.interval);return defined(i)&&(t.startTime=i.start,t.stopTime=i.stop),defined(n.currentTime)&&(t.currentTime=JulianDate.fromIso8601(n.currentTime)),defined(n.range)&&(t.clockRange=defaultValue(ClockRange$1[n.range],ClockRange$1.LOOP_STOP)),defined(n.step)&&(t.clockStep=defaultValue(ClockStep$1[n.step],ClockStep$1.SYSTEM_CLOCK_MULTIPLIER)),defined(n.multiplier)&&(t.multiplier=n.multiplier),t.equals(e._clock)?!1:(e._clock=t.clone(e._clock),!0)}function load$4(e,t,n,i){if(!defined(t))throw new DeveloperError("czml is required.");n=defaultValue(n,defaultValue.EMPTY_OBJECT);let r=t,o=n.sourceUri,a=n.credit;if(typeof a=="string"&&(a=new Credit(a)),e._credit=a,typeof t=="string"||t instanceof Resource){t=Resource.createIfNeeded(t),r=t.fetchJson(),o=defaultValue(o,t.clone());const s=e._resourceCredits,l=t.credits;if(defined(l)){const c=l.length;for(let d=0;d<c;d++)s.push(l[d])}}return o=Resource.createIfNeeded(o),DataSource.setLoading(e,!0),Promise.resolve(r).then(function(s){return loadCzml(e,s,o,i)}).catch(function(s){return DataSource.setLoading(e,!1),e._error.raiseEvent(e,s),console.log(s),Promise.reject(s)})}function loadCzml(e,t,n,i){DataSource.setLoading(e,!0);const r=e._entityCollection;i&&(e._version=void 0,e._documentPacket=new DocumentPacket,r.removeAll()),CzmlDataSource._processCzml(t,r,n,void 0,e);let o=updateClock(e);const a=e._documentPacket;return defined(a.name)&&e._name!==a.name?(e._name=a.name,o=!0):!defined(e._name)&&defined(n)&&(e._name=getFilenameFromUri(n.getUrlComponent()),o=!0),DataSource.setLoading(e,!1),o&&e._changed.raiseEvent(e),e}function DocumentPacket(){this.name=void 0,this.clock=void 0}function CzmlDataSource(e){this._name=e,this._changed=new Event,this._error=new Event,this._isLoading=!1,this._loading=new Event,this._clock=void 0,this._documentPacket=new DocumentPacket,this._version=void 0,this._entityCollection=new EntityCollection(this),this._entityCluster=new EntityCluster,this._credit=void 0,this._resourceCredits=[]}CzmlDataSource.load=function(e,t){return new CzmlDataSource().load(e,t)};Object.defineProperties(CzmlDataSource.prototype,{name:{get:function(){return this._name}},clock:{get:function(){return this._clock}},entities:{get:function(){return this._entityCollection}},isLoading:{get:function(){return this._isLoading}},changedEvent:{get:function(){return this._changed}},errorEvent:{get:function(){return this._error}},loadingEvent:{get:function(){return this._loading}},show:{get:function(){return this._entityCollection.show},set:function(e){this._entityCollection.show=e}},clustering:{get:function(){return this._entityCluster},set:function(e){if(!defined(e))throw new DeveloperError("value must be defined.");this._entityCluster=e}},credit:{get:function(){return this._credit}}});CzmlDataSource.updaters=[processBillboard,processBox,processCorridor,processCylinder,processEllipse,processEllipsoid,processLabel,processModel,processName,processDescription$2,processPath,processPoint$2,processPolygon$2,processPolyline,processPolylineVolume,processProperties,processRectangle,processPosition,processTileset,processViewFrom,processWall,processOrientation,processAvailability];CzmlDataSource.registerUpdater=function(e){CzmlDataSource.updaters.includes(e)||CzmlDataSource.updaters.push(e)};CzmlDataSource.unregisterUpdater=function(e){if(CzmlDataSource.updaters.includes(e)){const t=CzmlDataSource.updaters.indexOf(e);CzmlDataSource.updaters.splice(t,1)}};CzmlDataSource.prototype.process=function(e,t){return load$4(this,e,t,!1)};CzmlDataSource.prototype.load=function(e,t){return load$4(this,e,t,!0)};CzmlDataSource.prototype.update=function(e){return!0};CzmlDataSource.processPacketData=processPacketData;CzmlDataSource.processPositionPacketData=processPositionPacketData;CzmlDataSource.processMaterialPacketData=processMaterialPacketData;CzmlDataSource._processCzml=function(e,t,n,i,r){if(i=defaultValue(i,CzmlDataSource.updaters),Array.isArray(e))for(let o=0,a=e.length;o<a;++o)processCzmlPacket(e[o],t,i,n,r);else processCzmlPacket(e,t,i,n,r)};function DataSourceCollection(){this._dataSources=[],this._dataSourceAdded=new Event,this._dataSourceRemoved=new Event,this._dataSourceMoved=new Event}Object.defineProperties(DataSourceCollection.prototype,{length:{get:function(){return this._dataSources.length}},dataSourceAdded:{get:function(){return this._dataSourceAdded}},dataSourceRemoved:{get:function(){return this._dataSourceRemoved}},dataSourceMoved:{get:function(){return this._dataSourceMoved}}});DataSourceCollection.prototype.add=function(e){if(!defined(e))throw new DeveloperError("dataSource is required.");const t=this,n=this._dataSources;return Promise.resolve(e).then(function(i){return n===t._dataSources&&(t._dataSources.push(i),t._dataSourceAdded.raiseEvent(t,i)),i})};DataSourceCollection.prototype.remove=function(e,t){t=defaultValue(t,!1);const n=this._dataSources.indexOf(e);return n!==-1?(this._dataSources.splice(n,1),this._dataSourceRemoved.raiseEvent(this,e),t&&typeof e.destroy=="function"&&e.destroy(),!0):!1};DataSourceCollection.prototype.removeAll=function(e){e=defaultValue(e,!1);const t=this._dataSources;for(let n=0,i=t.length;n<i;++n){const r=t[n];this._dataSourceRemoved.raiseEvent(this,r),e&&typeof r.destroy=="function"&&r.destroy()}this._dataSources=[]};DataSourceCollection.prototype.contains=function(e){return this.indexOf(e)!==-1};DataSourceCollection.prototype.indexOf=function(e){return this._dataSources.indexOf(e)};DataSourceCollection.prototype.get=function(e){if(!defined(e))throw new DeveloperError("index is required.");return this._dataSources[e]};DataSourceCollection.prototype.getByName=function(e){if(!defined(e))throw new DeveloperError("name is required.");return this._dataSources.filter(function(t){return t.name===e})};function getIndex(e,t){if(!defined(t))throw new DeveloperError("dataSource is required.");const n=e.indexOf(t);if(n===-1)throw new DeveloperError("dataSource is not in this collection.");return n}function swapDataSources(e,t,n){const i=e._dataSources,r=i.length-1;if(t=CesiumMath.clamp(t,0,r),n=CesiumMath.clamp(n,0,r),t===n)return;const o=i[t];i[t]=i[n],i[n]=o,e.dataSourceMoved.raiseEvent(o,n,t)}DataSourceCollection.prototype.raise=function(e){const t=getIndex(this._dataSources,e);swapDataSources(this,t,t+1)};DataSourceCollection.prototype.lower=function(e){const t=getIndex(this._dataSources,e);swapDataSources(this,t,t-1)};DataSourceCollection.prototype.raiseToTop=function(e){const t=getIndex(this._dataSources,e);t!==this._dataSources.length-1&&(this._dataSources.splice(t,1),this._dataSources.push(e),this.dataSourceMoved.raiseEvent(e,this._dataSources.length-1,t))};DataSourceCollection.prototype.lowerToBottom=function(e){const t=getIndex(this._dataSources,e);t!==0&&(this._dataSources.splice(t,1),this._dataSources.splice(0,0,e),this.dataSourceMoved.raiseEvent(e,0,t))};DataSourceCollection.prototype.isDestroyed=function(){return!1};DataSourceCollection.prototype.destroy=function(){return this.removeAll(!0),destroyObject(this)};function PrimitiveCollection(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._primitives=[],this._guid=createGuid(),this._primitiveAdded=new Event,this._primitiveRemoved=new Event,this._zIndex=void 0,this.show=defaultValue(e.show,!0),this.destroyPrimitives=defaultValue(e.destroyPrimitives,!0)}Object.defineProperties(PrimitiveCollection.prototype,{length:{get:function(){return this._primitives.length}},primitiveAdded:{get:function(){return this._primitiveAdded}},primitiveRemoved:{get:function(){return this._primitiveRemoved}}});PrimitiveCollection.prototype.add=function(e,t){const n=defined(t);if(!defined(e))throw new DeveloperError("primitive is required.");if(n){if(t<0)throw new DeveloperError("index must be greater than or equal to zero.");if(t>this._primitives.length)throw new DeveloperError("index must be less than or equal to the number of primitives.")}const i=e._external=e._external||{},r=i._composites=i._composites||{};return r[this._guid]={collection:this},n?this._primitives.splice(t,0,e):this._primitives.push(e),this._primitiveAdded.raiseEvent(e),e};PrimitiveCollection.prototype.remove=function(e){if(this.contains(e)){const t=this._primitives.indexOf(e);if(t!==-1)return this._primitives.splice(t,1),delete e._external._composites[this._guid],this.destroyPrimitives&&e.destroy(),this._primitiveRemoved.raiseEvent(e),!0}return!1};PrimitiveCollection.prototype.removeAndDestroy=function(e){const t=this.remove(e);return t&&!this.destroyPrimitives&&e.destroy(),t};PrimitiveCollection.prototype.removeAll=function(){const e=this._primitives,t=e.length;for(let n=0;n<t;++n)delete e[n]._external._composites[this._guid],this.destroyPrimitives&&e[n].destroy(),this._primitiveRemoved.raiseEvent(e[n]);this._primitives=[]};PrimitiveCollection.prototype.contains=function(e){return!!(defined(e)&&e._external&&e._external._composites&&e._external._composites[this._guid])};function getPrimitiveIndex(e,t){if(!e.contains(t))throw new DeveloperError("primitive is not in this collection.");return e._primitives.indexOf(t)}PrimitiveCollection.prototype.raise=function(e){if(defined(e)){const t=getPrimitiveIndex(this,e),n=this._primitives;if(t!==n.length-1){const i=n[t];n[t]=n[t+1],n[t+1]=i}}};PrimitiveCollection.prototype.raiseToTop=function(e){if(defined(e)){const t=getPrimitiveIndex(this,e),n=this._primitives;t!==n.length-1&&(n.splice(t,1),n.push(e))}};PrimitiveCollection.prototype.lower=function(e){if(defined(e)){const t=getPrimitiveIndex(this,e),n=this._primitives;if(t!==0){const i=n[t];n[t]=n[t-1],n[t-1]=i}}};PrimitiveCollection.prototype.lowerToBottom=function(e){if(defined(e)){const t=getPrimitiveIndex(this,e),n=this._primitives;t!==0&&(n.splice(t,1),n.unshift(e))}};PrimitiveCollection.prototype.get=function(e){if(!defined(e))throw new DeveloperError("index is required.");return this._primitives[e]};PrimitiveCollection.prototype.update=function(e){if(!this.show)return;const t=this._primitives;for(let n=0;n<t.length;++n)t[n].update(e)};PrimitiveCollection.prototype.prePassesUpdate=function(e){const t=this._primitives;for(let n=0;n<t.length;++n){const i=t[n];defined(i.prePassesUpdate)&&i.prePassesUpdate(e)}};PrimitiveCollection.prototype.updateForPass=function(e,t){const n=this._primitives;for(let i=0;i<n.length;++i){const r=n[i];defined(r.updateForPass)&&r.updateForPass(e,t)}};PrimitiveCollection.prototype.postPassesUpdate=function(e){const t=this._primitives;for(let n=0;n<t.length;++n){const i=t[n];defined(i.postPassesUpdate)&&i.postPassesUpdate(e)}};PrimitiveCollection.prototype.isDestroyed=function(){return!1};PrimitiveCollection.prototype.destroy=function(){return this.removeAll(),destroyObject(this)};function OrderedGroundPrimitiveCollection(){this._length=0,this._collections={},this._collectionsArray=[],this.show=!0}Object.defineProperties(OrderedGroundPrimitiveCollection.prototype,{length:{get:function(){return this._length}}});OrderedGroundPrimitiveCollection.prototype.add=function(e,t){Check.defined("primitive",e),defined(t)&&Check.typeOf.number("zIndex",t),t=defaultValue(t,0);let n=this._collections[t];if(!defined(n)){n=new PrimitiveCollection({destroyPrimitives:!1}),n._zIndex=t,this._collections[t]=n;const i=this._collectionsArray;let r=0;for(;r<i.length&&i[r]._zIndex<t;)r++;i.splice(r,0,n)}return n.add(e),this._length++,e._zIndex=t,e};OrderedGroundPrimitiveCollection.prototype.set=function(e,t){return Check.defined("primitive",e),Check.typeOf.number("zIndex",t),t===e._zIndex||(this.remove(e,!0),this.add(e,t)),e};OrderedGroundPrimitiveCollection.prototype.remove=function(e,t){if(this.contains(e)){const n=e._zIndex,i=this._collections[n];let r;return t?r=i.remove(e):r=i.removeAndDestroy(e),r&&this._length--,i.length===0&&(this._collectionsArray.splice(this._collectionsArray.indexOf(i),1),this._collections[n]=void 0,i.destroy()),r}return!1};OrderedGroundPrimitiveCollection.prototype.removeAll=function(){const e=this._collectionsArray;for(let t=0;t<e.length;t++){const n=e[t];n.destroyPrimitives=!0,n.destroy()}this._collections={},this._collectionsArray=[],this._length=0};OrderedGroundPrimitiveCollection.prototype.contains=function(e){if(!defined(e))return!1;const t=this._collections[e._zIndex];return defined(t)&&t.contains(e)};OrderedGroundPrimitiveCollection.prototype.update=function(e){if(!this.show)return;const t=this._collectionsArray;for(let n=0;n<t.length;n++)t[n].update(e)};OrderedGroundPrimitiveCollection.prototype.isDestroyed=function(){return!1};OrderedGroundPrimitiveCollection.prototype.destroy=function(){return this.removeAll(),destroyObject(this)};function DynamicGeometryBatch(e,t){this._primitives=e,this._orderedGroundPrimitives=t,this._dynamicUpdaters=new AssociativeArray}DynamicGeometryBatch.prototype.add=function(e,t){this._dynamicUpdaters.set(t.id,t.createDynamicUpdater(this._primitives,this._orderedGroundPrimitives))};DynamicGeometryBatch.prototype.remove=function(e){const t=e.id,n=this._dynamicUpdaters.get(t);defined(n)&&(this._dynamicUpdaters.remove(t),n.destroy())};DynamicGeometryBatch.prototype.update=function(e){const t=this._dynamicUpdaters.values;for(let n=0,i=t.length;n<i;n++)t[n].update(e);return!0};DynamicGeometryBatch.prototype.removeAllPrimitives=function(){const e=this._dynamicUpdaters.values;for(let t=0,n=e.length;t<n;t++)e[t].destroy();this._dynamicUpdaters.removeAll()};DynamicGeometryBatch.prototype.getBoundingSphere=function(e,t){return e=this._dynamicUpdaters.get(e.id),defined(e)&&defined(e.getBoundingSphere)?e.getBoundingSphere(t):BoundingSphereState$1.FAILED};const EllipseGeometryLibrary={},rotAxis=new Cartesian3,tempVec=new Cartesian3,unitQuat=new Quaternion,rotMtx=new Matrix3;function pointOnEllipsoid(e,t,n,i,r,o,a,s,l,c){const d=e+t;Cartesian3.multiplyByScalar(i,Math.cos(d),rotAxis),Cartesian3.multiplyByScalar(n,Math.sin(d),tempVec),Cartesian3.add(rotAxis,tempVec,rotAxis);let h=Math.cos(e);h=h*h;let f=Math.sin(e);f=f*f;const u=o/Math.sqrt(a*h+r*f)/s;return Quaternion.fromAxisAngle(rotAxis,u,unitQuat),Matrix3.fromQuaternion(unitQuat,rotMtx),Matrix3.multiplyByVector(rotMtx,l,c),Cartesian3.normalize(c,c),Cartesian3.multiplyByScalar(c,s,c),c}const scratchCartesian1$4=new Cartesian3,scratchCartesian2$6=new Cartesian3,scratchCartesian3$6=new Cartesian3,scratchNormal$6=new Cartesian3;EllipseGeometryLibrary.raisePositionsToHeight=function(e,t,n){const i=t.ellipsoid,r=t.height,o=t.extrudedHeight,a=n?e.length/3*2:e.length/3,s=new Float64Array(a*3),l=e.length,c=n?l:0;for(let d=0;d<l;d+=3){const h=d+1,f=d+2,p=Cartesian3.fromArray(e,d,scratchCartesian1$4);i.scaleToGeodeticSurface(p,p);const u=Cartesian3.clone(p,scratchCartesian2$6),m=i.geodeticSurfaceNormal(p,scratchNormal$6),g=Cartesian3.multiplyByScalar(m,r,scratchCartesian3$6);Cartesian3.add(p,g,p),n&&(Cartesian3.multiplyByScalar(m,o,g),Cartesian3.add(u,g,u),s[d+c]=u.x,s[h+c]=u.y,s[f+c]=u.z),s[d]=p.x,s[h]=p.y,s[f]=p.z}return s};const unitPosScratch=new Cartesian3,eastVecScratch=new Cartesian3,northVecScratch=new Cartesian3;EllipseGeometryLibrary.computeEllipsePositions=function(e,t,n){const i=e.semiMinorAxis,r=e.semiMajorAxis,o=e.rotation,a=e.center,s=e.granularity*8,l=i*i,c=r*r,d=r*i,h=Cartesian3.magnitude(a),f=Cartesian3.normalize(a,unitPosScratch);let p=Cartesian3.cross(Cartesian3.UNIT_Z,a,eastVecScratch);p=Cartesian3.normalize(p,p);const u=Cartesian3.cross(f,p,northVecScratch);let m=1+Math.ceil(CesiumMath.PI_OVER_TWO/s);const g=CesiumMath.PI_OVER_TWO/(m-1);let _=CesiumMath.PI_OVER_TWO-m*g;_<0&&(m-=Math.ceil(Math.abs(_)/g));const C=2*(m*(m+2)),A=t?new Array(C*3):void 0;let S=0,v=scratchCartesian1$4,b=scratchCartesian2$6;const D=m*4*3;let I=D-1,L=0;const N=n?new Array(D):void 0;let y,x,T,E,P;for(_=CesiumMath.PI_OVER_TWO,v=pointOnEllipsoid(_,o,u,p,l,d,c,h,f,v),t&&(A[S++]=v.x,A[S++]=v.y,A[S++]=v.z),n&&(N[I--]=v.z,N[I--]=v.y,N[I--]=v.x),_=CesiumMath.PI_OVER_TWO-g,y=1;y<m+1;++y){if(v=pointOnEllipsoid(_,o,u,p,l,d,c,h,f,v),b=pointOnEllipsoid(Math.PI-_,o,u,p,l,d,c,h,f,b),t){for(A[S++]=v.x,A[S++]=v.y,A[S++]=v.z,T=2*y+2,x=1;x<T-1;++x)E=x/(T-1),P=Cartesian3.lerp(v,b,E,scratchCartesian3$6),A[S++]=P.x,A[S++]=P.y,A[S++]=P.z;A[S++]=b.x,A[S++]=b.y,A[S++]=b.z}n&&(N[I--]=v.z,N[I--]=v.y,N[I--]=v.x,N[L++]=b.x,N[L++]=b.y,N[L++]=b.z),_=CesiumMath.PI_OVER_TWO-(y+1)*g}for(y=m;y>1;--y){if(_=CesiumMath.PI_OVER_TWO-(y-1)*g,v=pointOnEllipsoid(-_,o,u,p,l,d,c,h,f,v),b=pointOnEllipsoid(_+Math.PI,o,u,p,l,d,c,h,f,b),t){for(A[S++]=v.x,A[S++]=v.y,A[S++]=v.z,T=2*(y-1)+2,x=1;x<T-1;++x)E=x/(T-1),P=Cartesian3.lerp(v,b,E,scratchCartesian3$6),A[S++]=P.x,A[S++]=P.y,A[S++]=P.z;A[S++]=b.x,A[S++]=b.y,A[S++]=b.z}n&&(N[I--]=v.z,N[I--]=v.y,N[I--]=v.x,N[L++]=b.x,N[L++]=b.y,N[L++]=b.z)}_=CesiumMath.PI_OVER_TWO,v=pointOnEllipsoid(-_,o,u,p,l,d,c,h,f,v);const M={};return t&&(A[S++]=v.x,A[S++]=v.y,A[S++]=v.z,M.positions=A,M.numPts=m),n&&(N[I--]=v.z,N[I--]=v.y,N[I--]=v.x,M.outerPositions=N),M};const EllipseGeometryLibrary$1=EllipseGeometryLibrary,scratchCartesian1$3=new Cartesian3,scratchCartesian2$5=new Cartesian3,scratchCartesian3$5=new Cartesian3,scratchCartesian4$2=new Cartesian3,texCoordScratch=new Cartesian2,textureMatrixScratch$1=new Matrix3,tangentMatrixScratch=new Matrix3,quaternionScratch$2=new Quaternion,scratchNormal$5=new Cartesian3,scratchTangent$3=new Cartesian3,scratchBitangent$3=new Cartesian3,scratchCartographic$8=new Cartographic,projectedCenterScratch=new Cartesian3,scratchMinTexCoord=new Cartesian2,scratchMaxTexCoord=new Cartesian2;function computeTopBottomAttributes(e,t,n){const i=t.vertexFormat,r=t.center,o=t.semiMajorAxis,a=t.semiMinorAxis,s=t.ellipsoid,l=t.stRotation,c=n?e.length/3*2:e.length/3,d=t.shadowVolume,h=i.st?new Float32Array(c*2):void 0,f=i.normal?new Float32Array(c*3):void 0,p=i.tangent?new Float32Array(c*3):void 0,u=i.bitangent?new Float32Array(c*3):void 0,m=d?new Float32Array(c*3):void 0;let g=0,_=scratchNormal$5,C=scratchTangent$3,A=scratchBitangent$3;const S=new GeographicProjection(s),v=S.project(s.cartesianToCartographic(r,scratchCartographic$8),projectedCenterScratch),b=s.scaleToGeodeticSurface(r,scratchCartesian1$3);s.geodeticSurfaceNormal(b,b);let D=textureMatrixScratch$1,I=tangentMatrixScratch;if(l!==0){let P=Quaternion.fromAxisAngle(b,l,quaternionScratch$2);D=Matrix3.fromQuaternion(P,D),P=Quaternion.fromAxisAngle(b,-l,quaternionScratch$2),I=Matrix3.fromQuaternion(P,I)}else D=Matrix3.clone(Matrix3.IDENTITY,D),I=Matrix3.clone(Matrix3.IDENTITY,I);const L=Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,scratchMinTexCoord),N=Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,scratchMaxTexCoord);let y=e.length;const x=n?y:0,T=x/3*2;for(let P=0;P<y;P+=3){const M=P+1,O=P+2,V=Cartesian3.fromArray(e,P,scratchCartesian1$3);if(i.st){const R=Matrix3.multiplyByVector(D,V,scratchCartesian2$5),w=S.project(s.cartesianToCartographic(R,scratchCartographic$8),scratchCartesian3$5);Cartesian3.subtract(w,v,w),texCoordScratch.x=(w.x+o)/(2*o),texCoordScratch.y=(w.y+a)/(2*a),L.x=Math.min(texCoordScratch.x,L.x),L.y=Math.min(texCoordScratch.y,L.y),N.x=Math.max(texCoordScratch.x,N.x),N.y=Math.max(texCoordScratch.y,N.y),n&&(h[g+T]=texCoordScratch.x,h[g+1+T]=texCoordScratch.y),h[g++]=texCoordScratch.x,h[g++]=texCoordScratch.y}(i.normal||i.tangent||i.bitangent||d)&&(_=s.geodeticSurfaceNormal(V,_),d&&(m[P+x]=-_.x,m[M+x]=-_.y,m[O+x]=-_.z),(i.normal||i.tangent||i.bitangent)&&((i.tangent||i.bitangent)&&(C=Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z,_,C),C),Matrix3.multiplyByVector(I,C,C)),i.normal&&(f[P]=_.x,f[M]=_.y,f[O]=_.z,n&&(f[P+x]=-_.x,f[M+x]=-_.y,f[O+x]=-_.z)),i.tangent&&(p[P]=C.x,p[M]=C.y,p[O]=C.z,n&&(p[P+x]=-C.x,p[M+x]=-C.y,p[O+x]=-C.z)),i.bitangent&&(A=Cartesian3.normalize(Cartesian3.cross(_,C,A),A),u[P]=A.x,u[M]=A.y,u[O]=A.z,n&&(u[P+x]=A.x,u[M+x]=A.y,u[O+x]=A.z))))}if(i.st){y=h.length;for(let P=0;P<y;P+=2)h[P]=(h[P]-L.x)/(N.x-L.x),h[P+1]=(h[P+1]-L.y)/(N.y-L.y)}const E=new GeometryAttributes;if(i.position){const P=EllipseGeometryLibrary$1.raisePositionsToHeight(e,t,n);E.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:P})}if(i.st&&(E.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:h})),i.normal&&(E.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:f})),i.tangent&&(E.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),i.bitangent&&(E.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:u})),d&&(E.extrudeDirection=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:m})),n&&defined(t.offsetAttribute)){let P=new Uint8Array(c);if(t.offsetAttribute===GeometryOffsetAttribute.TOP)P=P.fill(1,0,c/2);else{const M=t.offsetAttribute===GeometryOffsetAttribute.NONE?0:1;P=P.fill(M)}E.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:P})}return E}function topIndices(e){const t=new Array(12*(e*(e+1))-6);let n=0,i,r,o,a,s;for(i=0,o=1,a=0;a<3;a++)t[n++]=o++,t[n++]=i,t[n++]=o;for(a=2;a<e+1;++a){for(o=a*(a+1)-1,i=(a-1)*a-1,t[n++]=o++,t[n++]=i,t[n++]=o,r=2*a,s=0;s<r-1;++s)t[n++]=o,t[n++]=i++,t[n++]=i,t[n++]=o++,t[n++]=i,t[n++]=o;t[n++]=o++,t[n++]=i,t[n++]=o}for(r=e*2,++o,++i,a=0;a<r-1;++a)t[n++]=o,t[n++]=i++,t[n++]=i,t[n++]=o++,t[n++]=i,t[n++]=o;for(t[n++]=o,t[n++]=i++,t[n++]=i,t[n++]=o++,t[n++]=i++,t[n++]=i,++i,a=e-1;a>1;--a){for(t[n++]=i++,t[n++]=i,t[n++]=o,r=2*a,s=0;s<r-1;++s)t[n++]=o,t[n++]=i++,t[n++]=i,t[n++]=o++,t[n++]=i,t[n++]=o;t[n++]=i++,t[n++]=i++,t[n++]=o++}for(a=0;a<3;a++)t[n++]=i++,t[n++]=i,t[n++]=o;return t}let boundingSphereCenter$1=new Cartesian3;function computeEllipse$1(e){const t=e.center;boundingSphereCenter$1=Cartesian3.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(t,boundingSphereCenter$1),e.height,boundingSphereCenter$1),boundingSphereCenter$1=Cartesian3.add(t,boundingSphereCenter$1,boundingSphereCenter$1);const n=new BoundingSphere(boundingSphereCenter$1,e.semiMajorAxis),i=EllipseGeometryLibrary$1.computeEllipsePositions(e,!0,!1),r=i.positions,o=i.numPts,a=computeTopBottomAttributes(r,e,!1);let s=topIndices(o);return s=IndexDatatype.createTypedArray(r.length/3,s),{boundingSphere:n,attributes:a,indices:s}}function computeWallAttributes(e,t){const n=t.vertexFormat,i=t.center,r=t.semiMajorAxis,o=t.semiMinorAxis,a=t.ellipsoid,s=t.height,l=t.extrudedHeight,c=t.stRotation,d=e.length/3*2,h=new Float64Array(d*3),f=n.st?new Float32Array(d*2):void 0,p=n.normal?new Float32Array(d*3):void 0,u=n.tangent?new Float32Array(d*3):void 0,m=n.bitangent?new Float32Array(d*3):void 0,g=t.shadowVolume,_=g?new Float32Array(d*3):void 0;let C=0,A=scratchNormal$5,S=scratchTangent$3,v=scratchBitangent$3;const b=new GeographicProjection(a),D=b.project(a.cartesianToCartographic(i,scratchCartographic$8),projectedCenterScratch),I=a.scaleToGeodeticSurface(i,scratchCartesian1$3);a.geodeticSurfaceNormal(I,I);const L=Quaternion.fromAxisAngle(I,c,quaternionScratch$2),N=Matrix3.fromQuaternion(L,textureMatrixScratch$1),y=Cartesian2.fromElements(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,scratchMinTexCoord),x=Cartesian2.fromElements(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,scratchMaxTexCoord);let T=e.length;const E=T/3*2;for(let M=0;M<T;M+=3){const O=M+1,V=M+2;let R=Cartesian3.fromArray(e,M,scratchCartesian1$3),w;if(n.st){const k=Matrix3.multiplyByVector(N,R,scratchCartesian2$5),H=b.project(a.cartesianToCartographic(k,scratchCartographic$8),scratchCartesian3$5);Cartesian3.subtract(H,D,H),texCoordScratch.x=(H.x+r)/(2*r),texCoordScratch.y=(H.y+o)/(2*o),y.x=Math.min(texCoordScratch.x,y.x),y.y=Math.min(texCoordScratch.y,y.y),x.x=Math.max(texCoordScratch.x,x.x),x.y=Math.max(texCoordScratch.y,x.y),f[C+E]=texCoordScratch.x,f[C+1+E]=texCoordScratch.y,f[C++]=texCoordScratch.x,f[C++]=texCoordScratch.y}R=a.scaleToGeodeticSurface(R,R),w=Cartesian3.clone(R,scratchCartesian2$5),A=a.geodeticSurfaceNormal(R,A),g&&(_[M+T]=-A.x,_[O+T]=-A.y,_[V+T]=-A.z);let U=Cartesian3.multiplyByScalar(A,s,scratchCartesian4$2);if(R=Cartesian3.add(R,U,R),U=Cartesian3.multiplyByScalar(A,l,U),w=Cartesian3.add(w,U,w),n.position&&(h[M+T]=w.x,h[O+T]=w.y,h[V+T]=w.z,h[M]=R.x,h[O]=R.y,h[V]=R.z),n.normal||n.tangent||n.bitangent){v=Cartesian3.clone(A,v);const k=Cartesian3.fromArray(e,(M+3)%T,scratchCartesian4$2);Cartesian3.subtract(k,R,k);const H=Cartesian3.subtract(w,R,scratchCartesian3$5);A=Cartesian3.normalize(Cartesian3.cross(H,k,A),A),n.normal&&(p[M]=A.x,p[O]=A.y,p[V]=A.z,p[M+T]=A.x,p[O+T]=A.y,p[V+T]=A.z),n.tangent&&(S=Cartesian3.normalize(Cartesian3.cross(v,A,S),S),u[M]=S.x,u[O]=S.y,u[V]=S.z,u[M+T]=S.x,u[M+1+T]=S.y,u[M+2+T]=S.z),n.bitangent&&(m[M]=v.x,m[O]=v.y,m[V]=v.z,m[M+T]=v.x,m[O+T]=v.y,m[V+T]=v.z)}}if(n.st){T=f.length;for(let M=0;M<T;M+=2)f[M]=(f[M]-y.x)/(x.x-y.x),f[M+1]=(f[M+1]-y.y)/(x.y-y.y)}const P=new GeometryAttributes;if(n.position&&(P.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:h})),n.st&&(P.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:f})),n.normal&&(P.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),n.tangent&&(P.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:u})),n.bitangent&&(P.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:m})),g&&(P.extrudeDirection=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:_})),defined(t.offsetAttribute)){let M=new Uint8Array(d);if(t.offsetAttribute===GeometryOffsetAttribute.TOP)M=M.fill(1,0,d/2);else{const O=t.offsetAttribute===GeometryOffsetAttribute.NONE?0:1;M=M.fill(O)}P.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:M})}return P}function computeWallIndices(e){const t=e.length/3,n=IndexDatatype.createTypedArray(t,t*6);let i=0;for(let r=0;r<t;r++){const o=r,a=r+t,s=(o+1)%t,l=s+t;n[i++]=o,n[i++]=a,n[i++]=s,n[i++]=s,n[i++]=a,n[i++]=l}return n}const topBoundingSphere$2=new BoundingSphere,bottomBoundingSphere$2=new BoundingSphere;function computeExtrudedEllipse$1(e){const t=e.center,n=e.ellipsoid,i=e.semiMajorAxis;let r=Cartesian3.multiplyByScalar(n.geodeticSurfaceNormal(t,scratchCartesian1$3),e.height,scratchCartesian1$3);topBoundingSphere$2.center=Cartesian3.add(t,r,topBoundingSphere$2.center),topBoundingSphere$2.radius=i,r=Cartesian3.multiplyByScalar(n.geodeticSurfaceNormal(t,r),e.extrudedHeight,r),bottomBoundingSphere$2.center=Cartesian3.add(t,r,bottomBoundingSphere$2.center),bottomBoundingSphere$2.radius=i;const o=EllipseGeometryLibrary$1.computeEllipsePositions(e,!0,!0),a=o.positions,s=o.numPts,l=o.outerPositions,c=BoundingSphere.union(topBoundingSphere$2,bottomBoundingSphere$2),d=computeTopBottomAttributes(a,e,!0);let h=topIndices(s);const f=h.length;h.length=f*2;const p=a.length/3;for(let S=0;S<f;S+=3)h[S+f]=h[S+2]+p,h[S+1+f]=h[S+1]+p,h[S+2+f]=h[S]+p;const u=IndexDatatype.createTypedArray(p*2/3,h),m=new Geometry({attributes:d,indices:u,primitiveType:PrimitiveType.TRIANGLES}),g=computeWallAttributes(l,e);h=computeWallIndices(l);const _=IndexDatatype.createTypedArray(l.length*2/3,h),C=new Geometry({attributes:g,indices:_,primitiveType:PrimitiveType.TRIANGLES}),A=GeometryPipeline.combineInstances([new GeometryInstance({geometry:m}),new GeometryInstance({geometry:C})]);return{boundingSphere:c,attributes:A[0].attributes,indices:A[0].indices}}function computeRectangle$1(e,t,n,i,r,o,a){const l=EllipseGeometryLibrary$1.computeEllipsePositions({center:e,semiMajorAxis:t,semiMinorAxis:n,rotation:i,granularity:r},!1,!0).outerPositions,c=l.length/3,d=new Array(c);for(let f=0;f<c;++f)d[f]=Cartesian3.fromArray(l,f*3);const h=Rectangle.fromCartesianArray(d,o,a);return h.width>CesiumMath.PI&&(h.north=h.north>0?CesiumMath.PI_OVER_TWO-CesiumMath.EPSILON7:h.north,h.south=h.south<0?CesiumMath.EPSILON7-CesiumMath.PI_OVER_TWO:h.south,h.east=CesiumMath.PI,h.west=-CesiumMath.PI),h}function EllipseGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.center,n=defaultValue(e.ellipsoid,Ellipsoid.default),i=e.semiMajorAxis,r=e.semiMinorAxis,o=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),a=defaultValue(e.vertexFormat,VertexFormat.DEFAULT);if(Check.defined("options.center",t),Check.typeOf.number("options.semiMajorAxis",i),Check.typeOf.number("options.semiMinorAxis",r),i<r)throw new DeveloperError("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(o<=0)throw new DeveloperError("granularity must be greater than zero.");const s=defaultValue(e.height,0),l=defaultValue(e.extrudedHeight,s);this._center=Cartesian3.clone(t),this._semiMajorAxis=i,this._semiMinorAxis=r,this._ellipsoid=Ellipsoid.clone(n),this._rotation=defaultValue(e.rotation,0),this._stRotation=defaultValue(e.stRotation,0),this._height=Math.max(l,s),this._granularity=o,this._vertexFormat=VertexFormat.clone(a),this._extrudedHeight=Math.min(l,s),this._shadowVolume=defaultValue(e.shadowVolume,!1),this._workerName="createEllipseGeometry",this._offsetAttribute=e.offsetAttribute,this._rectangle=void 0,this._textureCoordinateRotationPoints=void 0}EllipseGeometry.packedLength=Cartesian3.packedLength+Ellipsoid.packedLength+VertexFormat.packedLength+9;EllipseGeometry.pack=function(e,t,n){return Check.defined("value",e),Check.defined("array",t),n=defaultValue(n,0),Cartesian3.pack(e._center,t,n),n+=Cartesian3.packedLength,Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,VertexFormat.pack(e._vertexFormat,t,n),n+=VertexFormat.packedLength,t[n++]=e._semiMajorAxis,t[n++]=e._semiMinorAxis,t[n++]=e._rotation,t[n++]=e._stRotation,t[n++]=e._height,t[n++]=e._granularity,t[n++]=e._extrudedHeight,t[n++]=e._shadowVolume?1:0,t[n]=defaultValue(e._offsetAttribute,-1),t};const scratchCenter$5=new Cartesian3,scratchEllipsoid$a=new Ellipsoid,scratchVertexFormat$8=new VertexFormat,scratchOptions$d={center:scratchCenter$5,ellipsoid:scratchEllipsoid$a,vertexFormat:scratchVertexFormat$8,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,stRotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};EllipseGeometry.unpack=function(e,t,n){Check.defined("array",e),t=defaultValue(t,0);const i=Cartesian3.unpack(e,t,scratchCenter$5);t+=Cartesian3.packedLength;const r=Ellipsoid.unpack(e,t,scratchEllipsoid$a);t+=Ellipsoid.packedLength;const o=VertexFormat.unpack(e,t,scratchVertexFormat$8);t+=VertexFormat.packedLength;const a=e[t++],s=e[t++],l=e[t++],c=e[t++],d=e[t++],h=e[t++],f=e[t++],p=e[t++]===1,u=e[t];return defined(n)?(n._center=Cartesian3.clone(i,n._center),n._ellipsoid=Ellipsoid.clone(r,n._ellipsoid),n._vertexFormat=VertexFormat.clone(o,n._vertexFormat),n._semiMajorAxis=a,n._semiMinorAxis=s,n._rotation=l,n._stRotation=c,n._height=d,n._granularity=h,n._extrudedHeight=f,n._shadowVolume=p,n._offsetAttribute=u===-1?void 0:u,n):(scratchOptions$d.height=d,scratchOptions$d.extrudedHeight=f,scratchOptions$d.granularity=h,scratchOptions$d.stRotation=c,scratchOptions$d.rotation=l,scratchOptions$d.semiMajorAxis=a,scratchOptions$d.semiMinorAxis=s,scratchOptions$d.shadowVolume=p,scratchOptions$d.offsetAttribute=u===-1?void 0:u,new EllipseGeometry(scratchOptions$d))};EllipseGeometry.computeRectangle=function(e,t){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const n=e.center,i=defaultValue(e.ellipsoid,Ellipsoid.default),r=e.semiMajorAxis,o=e.semiMinorAxis,a=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),s=defaultValue(e.rotation,0);if(Check.defined("options.center",n),Check.typeOf.number("options.semiMajorAxis",r),Check.typeOf.number("options.semiMinorAxis",o),r<o)throw new DeveloperError("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(a<=0)throw new DeveloperError("granularity must be greater than zero.");return computeRectangle$1(n,r,o,s,a,i,t)};EllipseGeometry.createGeometry=function(e){if(e._semiMajorAxis<=0||e._semiMinorAxis<=0)return;const t=e._height,n=e._extrudedHeight,i=!CesiumMath.equalsEpsilon(t,n,0,CesiumMath.EPSILON2);e._center=e._ellipsoid.scaleToGeodeticSurface(e._center,e._center);const r={center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:e._ellipsoid,rotation:e._rotation,height:t,granularity:e._granularity,vertexFormat:e._vertexFormat,stRotation:e._stRotation};let o;if(i)r.extrudedHeight=n,r.shadowVolume=e._shadowVolume,r.offsetAttribute=e._offsetAttribute,o=computeExtrudedEllipse$1(r);else if(o=computeEllipse$1(r),defined(e._offsetAttribute)){const a=o.attributes.position.values.length,s=e._offsetAttribute===GeometryOffsetAttribute.NONE?0:1,l=new Uint8Array(a/3).fill(s);o.attributes.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:l})}return new Geometry({attributes:o.attributes,indices:o.indices,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:o.boundingSphere,offsetAttribute:e._offsetAttribute})};EllipseGeometry.createShadowVolume=function(e,t,n){const i=e._granularity,r=e._ellipsoid,o=t(i,r),a=n(i,r);return new EllipseGeometry({center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:r,rotation:e._rotation,stRotation:e._stRotation,granularity:i,extrudedHeight:o,height:a,vertexFormat:VertexFormat.POSITION_ONLY,shadowVolume:!0})};function textureCoordinateRotationPoints$1(e){const t=-e._stRotation;if(t===0)return[0,0,0,1,1,0];const i=EllipseGeometryLibrary$1.computeEllipsePositions({center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,rotation:e._rotation,granularity:e._granularity},!1,!0).outerPositions,r=i.length/3,o=new Array(r);for(let l=0;l<r;++l)o[l]=Cartesian3.fromArray(i,l*3);const a=e._ellipsoid,s=e.rectangle;return Geometry._textureCoordinateRotationPoints(o,t,a,s)}Object.defineProperties(EllipseGeometry.prototype,{rectangle:{get:function(){return defined(this._rectangle)||(this._rectangle=computeRectangle$1(this._center,this._semiMajorAxis,this._semiMinorAxis,this._rotation,this._granularity,this._ellipsoid)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=textureCoordinateRotationPoints$1(this)),this._textureCoordinateRotationPoints}}});const scratchCartesian1$2=new Cartesian3;let boundingSphereCenter=new Cartesian3;function computeEllipse(e){const t=e.center;boundingSphereCenter=Cartesian3.multiplyByScalar(e.ellipsoid.geodeticSurfaceNormal(t,boundingSphereCenter),e.height,boundingSphereCenter),boundingSphereCenter=Cartesian3.add(t,boundingSphereCenter,boundingSphereCenter);const n=new BoundingSphere(boundingSphereCenter,e.semiMajorAxis),i=EllipseGeometryLibrary$1.computeEllipsePositions(e,!1,!0).outerPositions,r=new GeometryAttributes({position:new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:EllipseGeometryLibrary$1.raisePositionsToHeight(i,e,!1)})}),o=i.length/3,a=IndexDatatype.createTypedArray(o,o*2);let s=0;for(let l=0;l<o;++l)a[s++]=l,a[s++]=(l+1)%o;return{boundingSphere:n,attributes:r,indices:a}}const topBoundingSphere$1=new BoundingSphere,bottomBoundingSphere$1=new BoundingSphere;function computeExtrudedEllipse(e){const t=e.center,n=e.ellipsoid,i=e.semiMajorAxis;let r=Cartesian3.multiplyByScalar(n.geodeticSurfaceNormal(t,scratchCartesian1$2),e.height,scratchCartesian1$2);topBoundingSphere$1.center=Cartesian3.add(t,r,topBoundingSphere$1.center),topBoundingSphere$1.radius=i,r=Cartesian3.multiplyByScalar(n.geodeticSurfaceNormal(t,r),e.extrudedHeight,r),bottomBoundingSphere$1.center=Cartesian3.add(t,r,bottomBoundingSphere$1.center),bottomBoundingSphere$1.radius=i;let o=EllipseGeometryLibrary$1.computeEllipsePositions(e,!1,!0).outerPositions;const a=new GeometryAttributes({position:new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:EllipseGeometryLibrary$1.raisePositionsToHeight(o,e,!0)})});o=a.position.values;const s=BoundingSphere.union(topBoundingSphere$1,bottomBoundingSphere$1);let l=o.length/3;if(defined(e.offsetAttribute)){let u=new Uint8Array(l);if(e.offsetAttribute===GeometryOffsetAttribute.TOP)u=u.fill(1,0,l/2);else{const m=e.offsetAttribute===GeometryOffsetAttribute.NONE?0:1;u=u.fill(m)}a.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:u})}let c=defaultValue(e.numberOfVerticalLines,16);c=CesiumMath.clamp(c,0,l/2);const d=IndexDatatype.createTypedArray(l,l*2+c*2);l/=2;let h=0,f;for(f=0;f<l;++f)d[h++]=f,d[h++]=(f+1)%l,d[h++]=f+l,d[h++]=(f+1)%l+l;let p;if(c>0){const u=Math.min(c,l);p=Math.round(l/u);const m=Math.min(p*c,l);for(f=0;f<m;f+=p)d[h++]=f,d[h++]=f+l}return{boundingSphere:s,attributes:a,indices:d}}function EllipseOutlineGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.center,n=defaultValue(e.ellipsoid,Ellipsoid.default),i=e.semiMajorAxis,r=e.semiMinorAxis,o=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE);if(!defined(t))throw new DeveloperError("center is required.");if(!defined(i))throw new DeveloperError("semiMajorAxis is required.");if(!defined(r))throw new DeveloperError("semiMinorAxis is required.");if(i<r)throw new DeveloperError("semiMajorAxis must be greater than or equal to the semiMinorAxis.");if(o<=0)throw new DeveloperError("granularity must be greater than zero.");const a=defaultValue(e.height,0),s=defaultValue(e.extrudedHeight,a);this._center=Cartesian3.clone(t),this._semiMajorAxis=i,this._semiMinorAxis=r,this._ellipsoid=Ellipsoid.clone(n),this._rotation=defaultValue(e.rotation,0),this._height=Math.max(s,a),this._granularity=o,this._extrudedHeight=Math.min(s,a),this._numberOfVerticalLines=Math.max(defaultValue(e.numberOfVerticalLines,16),0),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipseOutlineGeometry"}EllipseOutlineGeometry.packedLength=Cartesian3.packedLength+Ellipsoid.packedLength+8;EllipseOutlineGeometry.pack=function(e,t,n){if(!defined(e))throw new DeveloperError("value is required");if(!defined(t))throw new DeveloperError("array is required");return n=defaultValue(n,0),Cartesian3.pack(e._center,t,n),n+=Cartesian3.packedLength,Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,t[n++]=e._semiMajorAxis,t[n++]=e._semiMinorAxis,t[n++]=e._rotation,t[n++]=e._height,t[n++]=e._granularity,t[n++]=e._extrudedHeight,t[n++]=e._numberOfVerticalLines,t[n]=defaultValue(e._offsetAttribute,-1),t};const scratchCenter$4=new Cartesian3,scratchEllipsoid$9=new Ellipsoid,scratchOptions$c={center:scratchCenter$4,ellipsoid:scratchEllipsoid$9,semiMajorAxis:void 0,semiMinorAxis:void 0,rotation:void 0,height:void 0,granularity:void 0,extrudedHeight:void 0,numberOfVerticalLines:void 0,offsetAttribute:void 0};EllipseOutlineGeometry.unpack=function(e,t,n){if(!defined(e))throw new DeveloperError("array is required");t=defaultValue(t,0);const i=Cartesian3.unpack(e,t,scratchCenter$4);t+=Cartesian3.packedLength;const r=Ellipsoid.unpack(e,t,scratchEllipsoid$9);t+=Ellipsoid.packedLength;const o=e[t++],a=e[t++],s=e[t++],l=e[t++],c=e[t++],d=e[t++],h=e[t++],f=e[t];return defined(n)?(n._center=Cartesian3.clone(i,n._center),n._ellipsoid=Ellipsoid.clone(r,n._ellipsoid),n._semiMajorAxis=o,n._semiMinorAxis=a,n._rotation=s,n._height=l,n._granularity=c,n._extrudedHeight=d,n._numberOfVerticalLines=h,n._offsetAttribute=f===-1?void 0:f,n):(scratchOptions$c.height=l,scratchOptions$c.extrudedHeight=d,scratchOptions$c.granularity=c,scratchOptions$c.rotation=s,scratchOptions$c.semiMajorAxis=o,scratchOptions$c.semiMinorAxis=a,scratchOptions$c.numberOfVerticalLines=h,scratchOptions$c.offsetAttribute=f===-1?void 0:f,new EllipseOutlineGeometry(scratchOptions$c))};EllipseOutlineGeometry.createGeometry=function(e){if(e._semiMajorAxis<=0||e._semiMinorAxis<=0)return;const t=e._height,n=e._extrudedHeight,i=!CesiumMath.equalsEpsilon(t,n,0,CesiumMath.EPSILON2);e._center=e._ellipsoid.scaleToGeodeticSurface(e._center,e._center);const r={center:e._center,semiMajorAxis:e._semiMajorAxis,semiMinorAxis:e._semiMinorAxis,ellipsoid:e._ellipsoid,rotation:e._rotation,height:t,granularity:e._granularity,numberOfVerticalLines:e._numberOfVerticalLines};let o;if(i)r.extrudedHeight=n,r.offsetAttribute=e._offsetAttribute,o=computeExtrudedEllipse(r);else if(o=computeEllipse(r),defined(e._offsetAttribute)){const a=o.attributes.position.values.length,s=e._offsetAttribute===GeometryOffsetAttribute.NONE?0:1,l=new Uint8Array(a/3).fill(s);o.attributes.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:l})}return new Geometry({attributes:o.attributes,indices:o.indices,primitiveType:PrimitiveType.LINES,boundingSphere:o.boundingSphere,offsetAttribute:e._offsetAttribute})};const scratchColor$d=new Color,defaultOffset$6=Cartesian3.ZERO,offsetScratch$6=new Cartesian3,scratchRectangle$5=new Rectangle;function EllipseGeometryOptions(e){this.id=e,this.vertexFormat=void 0,this.center=void 0,this.semiMajorAxis=void 0,this.semiMinorAxis=void 0,this.rotation=void 0,this.height=void 0,this.extrudedHeight=void 0,this.granularity=void 0,this.stRotation=void 0,this.numberOfVerticalLines=void 0,this.offsetAttribute=void 0}function EllipseGeometryUpdater(e,t){GroundGeometryUpdater.call(this,{entity:e,scene:t,geometryOptions:new EllipseGeometryOptions(e),geometryPropertyName:"ellipse",observedPropertyNames:["availability","position","ellipse"]}),this._onEntityPropertyChanged(e,"ellipse",e.ellipse,void 0)}defined(Object.create)&&(EllipseGeometryUpdater.prototype=Object.create(GroundGeometryUpdater.prototype),EllipseGeometryUpdater.prototype.constructor=EllipseGeometryUpdater);EllipseGeometryUpdater.prototype.createFillGeometryInstance=function(e){if(Check.defined("time",e),!this._fillEnabled)throw new DeveloperError("This instance does not represent a filled geometry.");const t=this._entity,n=t.isAvailable(e),i={show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._fillProperty.getValue(e)),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(e)),offset:void 0,color:void 0};if(this._materialProperty instanceof ColorMaterialProperty){let r;defined(this._materialProperty.color)&&(this._materialProperty.color.isConstant||n)&&(r=this._materialProperty.color.getValue(e,scratchColor$d)),defined(r)||(r=Color.WHITE),i.color=ColorGeometryInstanceAttribute.fromColor(r)}return defined(this._options.offsetAttribute)&&(i.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$6,offsetScratch$6))),new GeometryInstance({id:t,geometry:new EllipseGeometry(this._options),attributes:i})};EllipseGeometryUpdater.prototype.createOutlineGeometryInstance=function(e){if(Check.defined("time",e),!this._outlineEnabled)throw new DeveloperError("This instance does not represent an outlined geometry.");const t=this._entity,n=t.isAvailable(e),i=Property.getValueOrDefault(this._outlineColorProperty,e,Color.BLACK,scratchColor$d),r=this._distanceDisplayConditionProperty.getValue(e),o={show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._showOutlineProperty.getValue(e)),color:ColorGeometryInstanceAttribute.fromColor(i),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(r),offset:void 0};return defined(this._options.offsetAttribute)&&(o.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$6,offsetScratch$6))),new GeometryInstance({id:t,geometry:new EllipseOutlineGeometry(this._options),attributes:o})};EllipseGeometryUpdater.prototype._computeCenter=function(e,t){return Property.getValueOrUndefined(this._entity.position,e,t)};EllipseGeometryUpdater.prototype._isHidden=function(e,t){const n=e.position;return!defined(n)||!defined(t.semiMajorAxis)||!defined(t.semiMinorAxis)||GeometryUpdater.prototype._isHidden.call(this,e,t)};EllipseGeometryUpdater.prototype._isDynamic=function(e,t){return!e.position.isConstant||!t.semiMajorAxis.isConstant||!t.semiMinorAxis.isConstant||!Property.isConstant(t.rotation)||!Property.isConstant(t.height)||!Property.isConstant(t.extrudedHeight)||!Property.isConstant(t.granularity)||!Property.isConstant(t.stRotation)||!Property.isConstant(t.outlineWidth)||!Property.isConstant(t.numberOfVerticalLines)||!Property.isConstant(t.zIndex)||this._onTerrain&&!Property.isConstant(this._materialProperty)&&!(this._materialProperty instanceof ColorMaterialProperty)};EllipseGeometryUpdater.prototype._setStaticOptions=function(e,t){let n=Property.getValueOrUndefined(t.height,Iso8601.MINIMUM_VALUE);const i=Property.getValueOrDefault(t.heightReference,Iso8601.MINIMUM_VALUE,HeightReference.NONE);let r=Property.getValueOrUndefined(t.extrudedHeight,Iso8601.MINIMUM_VALUE);const o=Property.getValueOrDefault(t.extrudedHeightReference,Iso8601.MINIMUM_VALUE,HeightReference.NONE);defined(r)&&!defined(n)&&(n=0);const a=this._options;a.vertexFormat=this._materialProperty instanceof ColorMaterialProperty?PerInstanceColorAppearance.VERTEX_FORMAT:MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat,a.center=e.position.getValue(Iso8601.MINIMUM_VALUE,a.center),a.semiMajorAxis=t.semiMajorAxis.getValue(Iso8601.MINIMUM_VALUE,a.semiMajorAxis),a.semiMinorAxis=t.semiMinorAxis.getValue(Iso8601.MINIMUM_VALUE,a.semiMinorAxis),a.rotation=Property.getValueOrUndefined(t.rotation,Iso8601.MINIMUM_VALUE),a.granularity=Property.getValueOrUndefined(t.granularity,Iso8601.MINIMUM_VALUE),a.stRotation=Property.getValueOrUndefined(t.stRotation,Iso8601.MINIMUM_VALUE),a.numberOfVerticalLines=Property.getValueOrUndefined(t.numberOfVerticalLines,Iso8601.MINIMUM_VALUE),a.offsetAttribute=GroundGeometryUpdater.computeGeometryOffsetAttribute(n,i,r,o),a.height=GroundGeometryUpdater.getGeometryHeight(n,i),r=GroundGeometryUpdater.getGeometryExtrudedHeight(r,o),r===GroundGeometryUpdater.CLAMP_TO_GROUND&&(r=ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(a,scratchRectangle$5)).minimumTerrainHeight),a.extrudedHeight=r};EllipseGeometryUpdater.DynamicGeometryUpdater=DynamicEllipseGeometryUpdater;function DynamicEllipseGeometryUpdater(e,t,n){DynamicGeometryUpdater$1.call(this,e,t,n)}defined(Object.create)&&(DynamicEllipseGeometryUpdater.prototype=Object.create(DynamicGeometryUpdater$1.prototype),DynamicEllipseGeometryUpdater.prototype.constructor=DynamicEllipseGeometryUpdater);DynamicEllipseGeometryUpdater.prototype._isHidden=function(e,t,n){const i=this._options;return!defined(i.center)||!defined(i.semiMajorAxis)||!defined(i.semiMinorAxis)||DynamicGeometryUpdater$1.prototype._isHidden.call(this,e,t,n)};DynamicEllipseGeometryUpdater.prototype._setOptions=function(e,t,n){const i=this._options;let r=Property.getValueOrUndefined(t.height,n);const o=Property.getValueOrDefault(t.heightReference,n,HeightReference.NONE);let a=Property.getValueOrUndefined(t.extrudedHeight,n);const s=Property.getValueOrDefault(t.extrudedHeightReference,n,HeightReference.NONE);defined(a)&&!defined(r)&&(r=0),i.center=Property.getValueOrUndefined(e.position,n,i.center),i.semiMajorAxis=Property.getValueOrUndefined(t.semiMajorAxis,n),i.semiMinorAxis=Property.getValueOrUndefined(t.semiMinorAxis,n),i.rotation=Property.getValueOrUndefined(t.rotation,n),i.granularity=Property.getValueOrUndefined(t.granularity,n),i.stRotation=Property.getValueOrUndefined(t.stRotation,n),i.numberOfVerticalLines=Property.getValueOrUndefined(t.numberOfVerticalLines,n),i.offsetAttribute=GroundGeometryUpdater.computeGeometryOffsetAttribute(r,o,a,s),i.height=GroundGeometryUpdater.getGeometryHeight(r,o),a=GroundGeometryUpdater.getGeometryExtrudedHeight(a,s),a===GroundGeometryUpdater.CLAMP_TO_GROUND&&(a=ApproximateTerrainHeights.getMinimumMaximumHeights(EllipseGeometry.computeRectangle(i,scratchRectangle$5)).minimumTerrainHeight),i.extrudedHeight=a};const scratchPosition$7=new Cartesian3,scratchNormal$4=new Cartesian3,scratchTangent$2=new Cartesian3,scratchBitangent$2=new Cartesian3,scratchNormalST=new Cartesian3,defaultRadii=new Cartesian3(1,1,1),cos=Math.cos,sin=Math.sin;function EllipsoidGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=defaultValue(e.radii,defaultRadii),n=defaultValue(e.innerRadii,t),i=defaultValue(e.minimumClock,0),r=defaultValue(e.maximumClock,CesiumMath.TWO_PI),o=defaultValue(e.minimumCone,0),a=defaultValue(e.maximumCone,CesiumMath.PI),s=Math.round(defaultValue(e.stackPartitions,64)),l=Math.round(defaultValue(e.slicePartitions,64)),c=defaultValue(e.vertexFormat,VertexFormat.DEFAULT);if(l<3)throw new DeveloperError("options.slicePartitions cannot be less than three.");if(s<3)throw new DeveloperError("options.stackPartitions cannot be less than three.");this._radii=Cartesian3.clone(t),this._innerRadii=Cartesian3.clone(n),this._minimumClock=i,this._maximumClock=r,this._minimumCone=o,this._maximumCone=a,this._stackPartitions=s,this._slicePartitions=l,this._vertexFormat=VertexFormat.clone(c),this._offsetAttribute=e.offsetAttribute,this._workerName="createEllipsoidGeometry"}EllipsoidGeometry.packedLength=2*Cartesian3.packedLength+VertexFormat.packedLength+7;EllipsoidGeometry.pack=function(e,t,n){if(!defined(e))throw new DeveloperError("value is required");if(!defined(t))throw new DeveloperError("array is required");return n=defaultValue(n,0),Cartesian3.pack(e._radii,t,n),n+=Cartesian3.packedLength,Cartesian3.pack(e._innerRadii,t,n),n+=Cartesian3.packedLength,VertexFormat.pack(e._vertexFormat,t,n),n+=VertexFormat.packedLength,t[n++]=e._minimumClock,t[n++]=e._maximumClock,t[n++]=e._minimumCone,t[n++]=e._maximumCone,t[n++]=e._stackPartitions,t[n++]=e._slicePartitions,t[n]=defaultValue(e._offsetAttribute,-1),t};const scratchRadii$1=new Cartesian3,scratchInnerRadii=new Cartesian3,scratchVertexFormat$7=new VertexFormat,scratchOptions$b={radii:scratchRadii$1,innerRadii:scratchInnerRadii,vertexFormat:scratchVertexFormat$7,minimumClock:void 0,maximumClock:void 0,minimumCone:void 0,maximumCone:void 0,stackPartitions:void 0,slicePartitions:void 0,offsetAttribute:void 0};EllipsoidGeometry.unpack=function(e,t,n){if(!defined(e))throw new DeveloperError("array is required");t=defaultValue(t,0);const i=Cartesian3.unpack(e,t,scratchRadii$1);t+=Cartesian3.packedLength;const r=Cartesian3.unpack(e,t,scratchInnerRadii);t+=Cartesian3.packedLength;const o=VertexFormat.unpack(e,t,scratchVertexFormat$7);t+=VertexFormat.packedLength;const a=e[t++],s=e[t++],l=e[t++],c=e[t++],d=e[t++],h=e[t++],f=e[t];return defined(n)?(n._radii=Cartesian3.clone(i,n._radii),n._innerRadii=Cartesian3.clone(r,n._innerRadii),n._vertexFormat=VertexFormat.clone(o,n._vertexFormat),n._minimumClock=a,n._maximumClock=s,n._minimumCone=l,n._maximumCone=c,n._stackPartitions=d,n._slicePartitions=h,n._offsetAttribute=f===-1?void 0:f,n):(scratchOptions$b.minimumClock=a,scratchOptions$b.maximumClock=s,scratchOptions$b.minimumCone=l,scratchOptions$b.maximumCone=c,scratchOptions$b.stackPartitions=d,scratchOptions$b.slicePartitions=h,scratchOptions$b.offsetAttribute=f===-1?void 0:f,new EllipsoidGeometry(scratchOptions$b))};EllipsoidGeometry.createGeometry=function(e){const t=e._radii;if(t.x<=0||t.y<=0||t.z<=0)return;const n=e._innerRadii;if(n.x<=0||n.y<=0||n.z<=0)return;const i=e._minimumClock,r=e._maximumClock,o=e._minimumCone,a=e._maximumCone,s=e._vertexFormat;let l=e._slicePartitions+1,c=e._stackPartitions+1;l=Math.round(l*Math.abs(r-i)/CesiumMath.TWO_PI),c=Math.round(c*Math.abs(a-o)/CesiumMath.PI),l<2&&(l=2),c<2&&(c=2);let d,h,f=0;const p=[o],u=[i];for(d=0;d<c;d++)p.push(o+d*(a-o)/(c-1));for(p.push(a),h=0;h<l;h++)u.push(i+h*(r-i)/(l-1));u.push(r);const m=p.length,g=u.length;let _=0,C=1;const A=n.x!==t.x||n.y!==t.y||n.z!==t.z;let S=!1,v=!1,b=!1;A&&(C=2,o>0&&(S=!0,_+=l-1),a<Math.PI&&(v=!0,_+=l-1),(r-i)%CesiumMath.TWO_PI?(b=!0,_+=(c-1)*2+1):_+=1);const D=g*m*C,I=new Float64Array(D*3),L=new Array(D).fill(!1),N=new Array(D).fill(!1),y=l*c*C,x=6*(y+_+1-(l+c)*C),T=IndexDatatype.createTypedArray(y,x),E=s.normal?new Float32Array(D*3):void 0,P=s.tangent?new Float32Array(D*3):void 0,M=s.bitangent?new Float32Array(D*3):void 0,O=s.st?new Float32Array(D*2):void 0,V=new Array(m),R=new Array(m);for(d=0;d<m;d++)V[d]=sin(p[d]),R[d]=cos(p[d]);const w=new Array(g),U=new Array(g);for(h=0;h<g;h++)U[h]=cos(u[h]),w[h]=sin(u[h]);for(d=0;d<m;d++)for(h=0;h<g;h++)I[f++]=t.x*V[d]*U[h],I[f++]=t.y*V[d]*w[h],I[f++]=t.z*R[d];let k=D/2;if(A)for(d=0;d<m;d++)for(h=0;h<g;h++)I[f++]=n.x*V[d]*U[h],I[f++]=n.y*V[d]*w[h],I[f++]=n.z*R[d],L[k]=!0,d>0&&d!==m-1&&h!==0&&h!==g-1&&(N[k]=!0),k++;f=0;let H,F;for(d=1;d<m-2;d++)for(H=d*g,F=(d+1)*g,h=1;h<g-2;h++)T[f++]=F+h,T[f++]=F+h+1,T[f++]=H+h+1,T[f++]=F+h,T[f++]=H+h+1,T[f++]=H+h;if(A){const se=m*g;for(d=1;d<m-2;d++)for(H=se+d*g,F=se+(d+1)*g,h=1;h<g-2;h++)T[f++]=F+h,T[f++]=H+h,T[f++]=H+h+1,T[f++]=F+h,T[f++]=H+h+1,T[f++]=F+h+1}let G,B;if(A){if(S)for(B=m*g,d=1;d<g-2;d++)T[f++]=d,T[f++]=d+1,T[f++]=B+d+1,T[f++]=d,T[f++]=B+d+1,T[f++]=B+d;if(v)for(G=m*g-g,B=m*g*C-g,d=1;d<g-2;d++)T[f++]=G+d+1,T[f++]=G+d,T[f++]=B+d,T[f++]=G+d+1,T[f++]=B+d,T[f++]=B+d+1}if(b){for(d=1;d<m-2;d++)B=g*m+g*d,G=g*d,T[f++]=B,T[f++]=G+g,T[f++]=G,T[f++]=B,T[f++]=B+g,T[f++]=G+g;for(d=1;d<m-2;d++)B=g*m+g*(d+1)-1,G=g*(d+1)-1,T[f++]=G+g,T[f++]=B,T[f++]=G,T[f++]=G+g,T[f++]=B+g,T[f++]=B}const W=new GeometryAttributes;s.position&&(W.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:I}));let Y=0,z=0,X=0,q=0;const Q=D/2;let Z;const K=Ellipsoid.fromCartesian3(t),J=Ellipsoid.fromCartesian3(n);if(s.st||s.normal||s.tangent||s.bitangent){for(d=0;d<D;d++){Z=L[d]?J:K;const se=Cartesian3.fromArray(I,d*3,scratchPosition$7),ae=Z.geodeticSurfaceNormal(se,scratchNormal$4);if(N[d]&&Cartesian3.negate(ae,ae),s.st){const te=Cartesian2.negate(ae,scratchNormalST);O[Y++]=Math.atan2(te.y,te.x)/CesiumMath.TWO_PI+.5,O[Y++]=Math.asin(ae.z)/Math.PI+.5}if(s.normal&&(E[z++]=ae.x,E[z++]=ae.y,E[z++]=ae.z),s.tangent||s.bitangent){const te=scratchTangent$2;let ee=0,ce;if(L[d]&&(ee=Q),!S&&d>=ee&&d<ee+g*2?ce=Cartesian3.UNIT_X:ce=Cartesian3.UNIT_Z,Cartesian3.cross(ce,ae,te),Cartesian3.normalize(te,te),s.tangent&&(P[X++]=te.x,P[X++]=te.y,P[X++]=te.z),s.bitangent){const re=Cartesian3.cross(ae,te,scratchBitangent$2);Cartesian3.normalize(re,re),M[q++]=re.x,M[q++]=re.y,M[q++]=re.z}}}s.st&&(W.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:O})),s.normal&&(W.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:E})),s.tangent&&(W.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:P})),s.bitangent&&(W.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:M}))}if(defined(e._offsetAttribute)){const se=I.length,ae=e._offsetAttribute===GeometryOffsetAttribute.NONE?0:1,te=new Uint8Array(se/3).fill(ae);W.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:te})}return new Geometry({attributes:W,indices:T,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:BoundingSphere.fromEllipsoid(K),offsetAttribute:e._offsetAttribute})};let unitEllipsoidGeometry;EllipsoidGeometry.getUnitEllipsoid=function(){return defined(unitEllipsoidGeometry)||(unitEllipsoidGeometry=EllipsoidGeometry.createGeometry(new EllipsoidGeometry({radii:new Cartesian3(1,1,1),vertexFormat:VertexFormat.POSITION_ONLY}))),unitEllipsoidGeometry};const defaultMaterial$1=new ColorMaterialProperty(Color.WHITE),defaultOffset$5=Cartesian3.ZERO,offsetScratch$5=new Cartesian3,radiiScratch=new Cartesian3,innerRadiiScratch=new Cartesian3,scratchColor$c=new Color,unitSphere=new Cartesian3(1,1,1);function EllipsoidGeometryOptions(e){this.id=e,this.vertexFormat=void 0,this.radii=void 0,this.innerRadii=void 0,this.minimumClock=void 0,this.maximumClock=void 0,this.minimumCone=void 0,this.maximumCone=void 0,this.stackPartitions=void 0,this.slicePartitions=void 0,this.subdivisions=void 0,this.offsetAttribute=void 0}function EllipsoidGeometryUpdater(e,t){GeometryUpdater.call(this,{entity:e,scene:t,geometryOptions:new EllipsoidGeometryOptions(e),geometryPropertyName:"ellipsoid",observedPropertyNames:["availability","position","orientation","ellipsoid"]}),this._onEntityPropertyChanged(e,"ellipsoid",e.ellipsoid,void 0)}defined(Object.create)&&(EllipsoidGeometryUpdater.prototype=Object.create(GeometryUpdater.prototype),EllipsoidGeometryUpdater.prototype.constructor=EllipsoidGeometryUpdater);Object.defineProperties(EllipsoidGeometryUpdater.prototype,{terrainOffsetProperty:{get:function(){return this._terrainOffsetProperty}}});EllipsoidGeometryUpdater.prototype.createFillGeometryInstance=function(e,t,n){Check.defined("time",e);const i=this._entity,r=i.isAvailable(e);let o;const a=new ShowGeometryInstanceAttribute(r&&i.isShowing&&this._showProperty.getValue(e)&&this._fillProperty.getValue(e)),s=this._distanceDisplayConditionProperty.getValue(e),l=DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(s),c={show:a,distanceDisplayCondition:l,color:void 0,offset:void 0};if(this._materialProperty instanceof ColorMaterialProperty){let d;defined(this._materialProperty.color)&&(this._materialProperty.color.isConstant||r)&&(d=this._materialProperty.color.getValue(e,scratchColor$c)),defined(d)||(d=Color.WHITE),o=ColorGeometryInstanceAttribute.fromColor(d),c.color=o}return defined(this._options.offsetAttribute)&&(c.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$5,offsetScratch$5))),new GeometryInstance({id:i,geometry:new EllipsoidGeometry(this._options),modelMatrix:t?void 0:i.computeModelMatrixForHeightReference(e,i.ellipsoid.heightReference,this._options.radii.z*.5,this._scene.ellipsoid,n),attributes:c})};EllipsoidGeometryUpdater.prototype.createOutlineGeometryInstance=function(e,t,n){Check.defined("time",e);const i=this._entity,r=i.isAvailable(e),o=Property.getValueOrDefault(this._outlineColorProperty,e,Color.BLACK,scratchColor$c),a=this._distanceDisplayConditionProperty.getValue(e),s={show:new ShowGeometryInstanceAttribute(r&&i.isShowing&&this._showProperty.getValue(e)&&this._showOutlineProperty.getValue(e)),color:ColorGeometryInstanceAttribute.fromColor(o),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(a),offset:void 0};return defined(this._options.offsetAttribute)&&(s.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$5,offsetScratch$5))),new GeometryInstance({id:i,geometry:new EllipsoidOutlineGeometry(this._options),modelMatrix:t?void 0:i.computeModelMatrixForHeightReference(e,i.ellipsoid.heightReference,this._options.radii.z*.5,this._scene.ellipsoid,n),attributes:s})};EllipsoidGeometryUpdater.prototype._computeCenter=function(e,t){return Property.getValueOrUndefined(this._entity.position,e,t)};EllipsoidGeometryUpdater.prototype._isHidden=function(e,t){return!defined(e.position)||!defined(t.radii)||GeometryUpdater.prototype._isHidden.call(this,e,t)};EllipsoidGeometryUpdater.prototype._isDynamic=function(e,t){return!e.position.isConstant||!Property.isConstant(e.orientation)||!t.radii.isConstant||!Property.isConstant(t.innerRadii)||!Property.isConstant(t.stackPartitions)||!Property.isConstant(t.slicePartitions)||!Property.isConstant(t.outlineWidth)||!Property.isConstant(t.minimumClock)||!Property.isConstant(t.maximumClock)||!Property.isConstant(t.minimumCone)||!Property.isConstant(t.maximumCone)||!Property.isConstant(t.subdivisions)};EllipsoidGeometryUpdater.prototype._setStaticOptions=function(e,t){const n=Property.getValueOrDefault(t.heightReference,Iso8601.MINIMUM_VALUE,HeightReference.NONE),i=this._options;i.vertexFormat=this._materialProperty instanceof ColorMaterialProperty?PerInstanceColorAppearance.VERTEX_FORMAT:MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat,i.radii=t.radii.getValue(Iso8601.MINIMUM_VALUE,i.radii),i.innerRadii=Property.getValueOrUndefined(t.innerRadii,i.radii),i.minimumClock=Property.getValueOrUndefined(t.minimumClock,Iso8601.MINIMUM_VALUE),i.maximumClock=Property.getValueOrUndefined(t.maximumClock,Iso8601.MINIMUM_VALUE),i.minimumCone=Property.getValueOrUndefined(t.minimumCone,Iso8601.MINIMUM_VALUE),i.maximumCone=Property.getValueOrUndefined(t.maximumCone,Iso8601.MINIMUM_VALUE),i.stackPartitions=Property.getValueOrUndefined(t.stackPartitions,Iso8601.MINIMUM_VALUE),i.slicePartitions=Property.getValueOrUndefined(t.slicePartitions,Iso8601.MINIMUM_VALUE),i.subdivisions=Property.getValueOrUndefined(t.subdivisions,Iso8601.MINIMUM_VALUE),i.offsetAttribute=n!==HeightReference.NONE?GeometryOffsetAttribute.ALL:void 0};EllipsoidGeometryUpdater.prototype._onEntityPropertyChanged=heightReferenceOnEntityPropertyChanged;EllipsoidGeometryUpdater.DynamicGeometryUpdater=DynamicEllipsoidGeometryUpdater;function DynamicEllipsoidGeometryUpdater(e,t,n){DynamicGeometryUpdater$1.call(this,e,t,n),this._scene=e._scene,this._modelMatrix=new Matrix4,this._attributes=void 0,this._outlineAttributes=void 0,this._lastSceneMode=void 0,this._lastShow=void 0,this._lastOutlineShow=void 0,this._lastOutlineWidth=void 0,this._lastOutlineColor=void 0,this._lastOffset=new Cartesian3,this._material={}}defined(Object.create)&&(DynamicEllipsoidGeometryUpdater.prototype=Object.create(DynamicGeometryUpdater$1.prototype),DynamicEllipsoidGeometryUpdater.prototype.constructor=DynamicEllipsoidGeometryUpdater);DynamicEllipsoidGeometryUpdater.prototype.update=function(e){Check.defined("time",e);const t=this._entity,n=t.ellipsoid;if(!t.isShowing||!t.isAvailable(e)||!Property.getValueOrDefault(n.show,e,!0)){defined(this._primitive)&&(this._primitive.show=!1),defined(this._outlinePrimitive)&&(this._outlinePrimitive.show=!1);return}const i=Property.getValueOrUndefined(n.radii,e,radiiScratch);let r=defined(i)?t.computeModelMatrixForHeightReference(e,n.heightReference,i.z*.5,this._scene.ellipsoid,this._modelMatrix):void 0;if(!defined(r)||!defined(i)){defined(this._primitive)&&(this._primitive.show=!1),defined(this._outlinePrimitive)&&(this._outlinePrimitive.show=!1);return}const o=Property.getValueOrDefault(n.fill,e,!0),a=Property.getValueOrDefault(n.outline,e,!1),s=Property.getValueOrClonedDefault(n.outlineColor,e,Color.BLACK,scratchColor$c),l=MaterialProperty.getValue(e,defaultValue(n.material,defaultMaterial$1),this._material),c=Property.getValueOrUndefined(n.innerRadii,e,innerRadiiScratch),d=Property.getValueOrUndefined(n.minimumClock,e),h=Property.getValueOrUndefined(n.maximumClock,e),f=Property.getValueOrUndefined(n.minimumCone,e),p=Property.getValueOrUndefined(n.maximumCone,e),u=Property.getValueOrUndefined(n.stackPartitions,e),m=Property.getValueOrUndefined(n.slicePartitions,e),g=Property.getValueOrUndefined(n.subdivisions,e),_=Property.getValueOrDefault(n.outlineWidth,e,1),C=Property.getValueOrDefault(n.heightReference,e,HeightReference.NONE),A=C!==HeightReference.NONE?GeometryOffsetAttribute.ALL:void 0,S=this._scene.mode,v=S===SceneMode.SCENE3D&&C===HeightReference.NONE,b=this._options,D=this._geometryUpdater.shadowsProperty.getValue(e),L=this._geometryUpdater.distanceDisplayConditionProperty.getValue(e),N=Property.getValueOrDefault(this._geometryUpdater.terrainOffsetProperty,e,defaultOffset$5,offsetScratch$5);if(!v||this._lastSceneMode!==S||!defined(this._primitive)||b.stackPartitions!==u||b.slicePartitions!==m||defined(c)&&!Cartesian3.equals(b.innerRadii!==c)||b.minimumClock!==d||b.maximumClock!==h||b.minimumCone!==f||b.maximumCone!==p||b.subdivisions!==g||this._lastOutlineWidth!==_||b.offsetAttribute!==A){const x=this._primitives;x.removeAndDestroy(this._primitive),x.removeAndDestroy(this._outlinePrimitive),this._primitive=void 0,this._outlinePrimitive=void 0,this._lastSceneMode=S,this._lastOutlineWidth=_,b.stackPartitions=u,b.slicePartitions=m,b.subdivisions=g,b.offsetAttribute=A,b.radii=Cartesian3.clone(v?unitSphere:i,b.radii),defined(c)?v?b.innerRadii=Cartesian3.fromElements(c.x/i.x,c.y/i.y,c.z/i.z,b.innerRadii):b.innerRadii=Cartesian3.clone(c,b.innerRadii):b.innerRadii=void 0,b.minimumClock=d,b.maximumClock=h,b.minimumCone=f,b.maximumCone=p;const T=new MaterialAppearance({material:l,translucent:l.isTranslucent(),closed:!0});b.vertexFormat=T.vertexFormat;const E=this._geometryUpdater.createFillGeometryInstance(e,v,this._modelMatrix);this._primitive=x.add(new Primitive({geometryInstances:E,appearance:T,asynchronous:!1,shadows:D}));const P=this._geometryUpdater.createOutlineGeometryInstance(e,v,this._modelMatrix);this._outlinePrimitive=x.add(new Primitive({geometryInstances:P,appearance:new PerInstanceColorAppearance({flat:!0,translucent:P.attributes.color.value[3]!==255,renderState:{lineWidth:this._geometryUpdater._scene.clampLineWidth(_)}}),asynchronous:!1,shadows:D})),this._lastShow=o,this._lastOutlineShow=a,this._lastOutlineColor=Color.clone(s,this._lastOutlineColor),this._lastDistanceDisplayCondition=L,this._lastOffset=Cartesian3.clone(N,this._lastOffset)}else if(this._primitive.ready){const x=this._primitive,T=this._outlinePrimitive;x.show=!0,T.show=!0,x.appearance.material=l;let E=this._attributes;defined(E)||(E=x.getGeometryInstanceAttributes(t),this._attributes=E),o!==this._lastShow&&(E.show=ShowGeometryInstanceAttribute.toValue(o,E.show),this._lastShow=o);let P=this._outlineAttributes;defined(P)||(P=T.getGeometryInstanceAttributes(t),this._outlineAttributes=P),a!==this._lastOutlineShow&&(P.show=ShowGeometryInstanceAttribute.toValue(a,P.show),this._lastOutlineShow=a),Color.equals(s,this._lastOutlineColor)||(P.color=ColorGeometryInstanceAttribute.toValue(s,P.color),Color.clone(s,this._lastOutlineColor)),DistanceDisplayCondition.equals(L,this._lastDistanceDisplayCondition)||(E.distanceDisplayCondition=DistanceDisplayConditionGeometryInstanceAttribute.toValue(L,E.distanceDisplayCondition),P.distanceDisplayCondition=DistanceDisplayConditionGeometryInstanceAttribute.toValue(L,P.distanceDisplayCondition),DistanceDisplayCondition.clone(L,this._lastDistanceDisplayCondition)),Cartesian3.equals(N,this._lastOffset)||(E.offset=OffsetGeometryInstanceAttribute.toValue(N,E.offset),P.offset=OffsetGeometryInstanceAttribute.toValue(N,E.offset),Cartesian3.clone(N,this._lastOffset))}v&&(i.x=Math.max(i.x,.001),i.y=Math.max(i.y,.001),i.z=Math.max(i.z,.001),r=Matrix4.multiplyByScale(r,i,r),this._primitive.modelMatrix=r,this._outlinePrimitive.modelMatrix=r)};function PlaneGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=defaultValue(e.vertexFormat,VertexFormat.DEFAULT);this._vertexFormat=t,this._workerName="createPlaneGeometry"}PlaneGeometry.packedLength=VertexFormat.packedLength;PlaneGeometry.pack=function(e,t,n){return Check.typeOf.object("value",e),Check.defined("array",t),n=defaultValue(n,0),VertexFormat.pack(e._vertexFormat,t,n),t};const scratchVertexFormat$6=new VertexFormat,scratchOptions$a={vertexFormat:scratchVertexFormat$6};PlaneGeometry.unpack=function(e,t,n){Check.defined("array",e),t=defaultValue(t,0);const i=VertexFormat.unpack(e,t,scratchVertexFormat$6);return defined(n)?(n._vertexFormat=VertexFormat.clone(i,n._vertexFormat),n):new PlaneGeometry(scratchOptions$a)};const min$1=new Cartesian3(-.5,-.5,0),max$1=new Cartesian3(.5,.5,0);PlaneGeometry.createGeometry=function(e){const t=e._vertexFormat,n=new GeometryAttributes;let i,r;if(t.position){if(r=new Float64Array(4*3),r[0]=min$1.x,r[1]=min$1.y,r[2]=0,r[3]=max$1.x,r[4]=min$1.y,r[5]=0,r[6]=max$1.x,r[7]=max$1.y,r[8]=0,r[9]=min$1.x,r[10]=max$1.y,r[11]=0,n.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:r}),t.normal){const o=new Float32Array(12);o[0]=0,o[1]=0,o[2]=1,o[3]=0,o[4]=0,o[5]=1,o[6]=0,o[7]=0,o[8]=1,o[9]=0,o[10]=0,o[11]=1,n.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:o})}if(t.st){const o=new Float32Array(8);o[0]=0,o[1]=0,o[2]=1,o[3]=0,o[4]=1,o[5]=1,o[6]=0,o[7]=1,n.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:o})}if(t.tangent){const o=new Float32Array(12);o[0]=1,o[1]=0,o[2]=0,o[3]=1,o[4]=0,o[5]=0,o[6]=1,o[7]=0,o[8]=0,o[9]=1,o[10]=0,o[11]=0,n.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:o})}if(t.bitangent){const o=new Float32Array(12);o[0]=0,o[1]=1,o[2]=0,o[3]=0,o[4]=1,o[5]=0,o[6]=0,o[7]=1,o[8]=0,o[9]=0,o[10]=1,o[11]=0,n.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:o})}i=new Uint16Array(2*3),i[0]=0,i[1]=1,i[2]=2,i[3]=0,i[4]=2,i[5]=3}return new Geometry({attributes:n,indices:i,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:new BoundingSphere(Cartesian3.ZERO,Math.sqrt(2))})};function PlaneOutlineGeometry(){this._workerName="createPlaneOutlineGeometry"}PlaneOutlineGeometry.packedLength=0;PlaneOutlineGeometry.pack=function(e,t){return Check.defined("value",e),Check.defined("array",t),t};PlaneOutlineGeometry.unpack=function(e,t,n){return Check.defined("array",e),defined(n)?n:new PlaneOutlineGeometry};const min=new Cartesian3(-.5,-.5,0),max=new Cartesian3(.5,.5,0);PlaneOutlineGeometry.createGeometry=function(){const e=new GeometryAttributes,t=new Uint16Array(4*2),n=new Float64Array(4*3);return n[0]=min.x,n[1]=min.y,n[2]=min.z,n[3]=max.x,n[4]=min.y,n[5]=min.z,n[6]=max.x,n[7]=max.y,n[8]=min.z,n[9]=min.x,n[10]=max.y,n[11]=min.z,e.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:n}),t[0]=0,t[1]=1,t[2]=1,t[3]=2,t[4]=2,t[5]=3,t[6]=3,t[7]=0,new Geometry({attributes:e,indices:t,primitiveType:PrimitiveType.LINES,boundingSphere:new BoundingSphere(Cartesian3.ZERO,Math.sqrt(2))})};const positionScratch$3=new Cartesian3,scratchColor$b=new Color;function PlaneGeometryOptions(e){this.id=e,this.vertexFormat=void 0,this.plane=void 0,this.dimensions=void 0}function PlaneGeometryUpdater(e,t){GeometryUpdater.call(this,{entity:e,scene:t,geometryOptions:new PlaneGeometryOptions(e),geometryPropertyName:"plane",observedPropertyNames:["availability","position","orientation","plane"]}),this._onEntityPropertyChanged(e,"plane",e.plane,void 0)}defined(Object.create)&&(PlaneGeometryUpdater.prototype=Object.create(GeometryUpdater.prototype),PlaneGeometryUpdater.prototype.constructor=PlaneGeometryUpdater);PlaneGeometryUpdater.prototype.createFillGeometryInstance=function(e){if(Check.defined("time",e),!this._fillEnabled)throw new DeveloperError("This instance does not represent a filled geometry.");const t=this._entity,n=t.isAvailable(e);let i,r;const o=new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._fillProperty.getValue(e)),a=this._distanceDisplayConditionProperty.getValue(e),s=DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(a);if(this._materialProperty instanceof ColorMaterialProperty){let p;defined(this._materialProperty.color)&&(this._materialProperty.color.isConstant||n)&&(p=this._materialProperty.color.getValue(e,scratchColor$b)),defined(p)||(p=Color.WHITE),r=ColorGeometryInstanceAttribute.fromColor(p),i={show:o,distanceDisplayCondition:s,color:r}}else i={show:o,distanceDisplayCondition:s};const l=t.plane,c=this._options;let d=t.computeModelMatrix(e);const h=Property.getValueOrDefault(l.plane,e,c.plane),f=Property.getValueOrUndefined(l.dimensions,e,c.dimensions);return c.plane=h,c.dimensions=f,d=createPrimitiveMatrix(h,f,d,d),new GeometryInstance({id:t,geometry:new PlaneGeometry(this._options),modelMatrix:d,attributes:i})};PlaneGeometryUpdater.prototype.createOutlineGeometryInstance=function(e){if(Check.defined("time",e),!this._outlineEnabled)throw new DeveloperError("This instance does not represent an outlined geometry.");const t=this._entity,n=t.isAvailable(e),i=Property.getValueOrDefault(this._outlineColorProperty,e,Color.BLACK,scratchColor$b),r=this._distanceDisplayConditionProperty.getValue(e),o=t.plane,a=this._options;let s=t.computeModelMatrix(e);const l=Property.getValueOrDefault(o.plane,e,a.plane),c=Property.getValueOrUndefined(o.dimensions,e,a.dimensions);return a.plane=l,a.dimensions=c,s=createPrimitiveMatrix(l,c,s,s),new GeometryInstance({id:t,geometry:new PlaneOutlineGeometry,modelMatrix:s,attributes:{show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._showOutlineProperty.getValue(e)),color:ColorGeometryInstanceAttribute.fromColor(i),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(r)}})};PlaneGeometryUpdater.prototype._isHidden=function(e,t){return!defined(t.plane)||!defined(t.dimensions)||!defined(e.position)||GeometryUpdater.prototype._isHidden.call(this,e,t)};PlaneGeometryUpdater.prototype._getIsClosed=function(e){return!1};PlaneGeometryUpdater.prototype._isDynamic=function(e,t){return!e.position.isConstant||!Property.isConstant(e.orientation)||!t.plane.isConstant||!t.dimensions.isConstant||!Property.isConstant(t.outlineWidth)};PlaneGeometryUpdater.prototype._setStaticOptions=function(e,t){const n=this._materialProperty instanceof ColorMaterialProperty,i=this._options;i.vertexFormat=n?PerInstanceColorAppearance.VERTEX_FORMAT:MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat,i.plane=t.plane.getValue(Iso8601.MINIMUM_VALUE,i.plane),i.dimensions=t.dimensions.getValue(Iso8601.MINIMUM_VALUE,i.dimensions)};PlaneGeometryUpdater.DynamicGeometryUpdater=DynamicPlaneGeometryUpdater;function DynamicPlaneGeometryUpdater(e,t,n){DynamicGeometryUpdater$1.call(this,e,t,n)}defined(Object.create)&&(DynamicPlaneGeometryUpdater.prototype=Object.create(DynamicGeometryUpdater$1.prototype),DynamicPlaneGeometryUpdater.prototype.constructor=DynamicPlaneGeometryUpdater);DynamicPlaneGeometryUpdater.prototype._isHidden=function(e,t,n){const i=this._options,r=Property.getValueOrUndefined(e.position,n,positionScratch$3);return!defined(r)||!defined(i.plane)||!defined(i.dimensions)||DynamicGeometryUpdater$1.prototype._isHidden.call(this,e,t,n)};DynamicPlaneGeometryUpdater.prototype._setOptions=function(e,t,n){const i=this._options;i.plane=Property.getValueOrDefault(t.plane,n,i.plane),i.dimensions=Property.getValueOrUndefined(t.dimensions,n,i.dimensions)};const scratchAxis=new Cartesian3,scratchUp$2=new Cartesian3,scratchTranslation$3=new Cartesian3,scratchScale$7=new Cartesian3,scratchRotation$5=new Matrix3,scratchRotationScale$1=new Matrix3,scratchLocalTransform=new Matrix4;function createPrimitiveMatrix(e,t,n,i){const r=e.normal,o=e.distance,a=Cartesian3.multiplyByScalar(r,-o,scratchTranslation$3);let s=Cartesian3.clone(Cartesian3.UNIT_Z,scratchUp$2);CesiumMath.equalsEpsilon(Math.abs(Cartesian3.dot(s,r)),1,CesiumMath.EPSILON8)&&(s=Cartesian3.clone(Cartesian3.UNIT_Y,s));const l=Cartesian3.cross(s,r,scratchAxis);s=Cartesian3.cross(r,l,s),Cartesian3.normalize(l,l),Cartesian3.normalize(s,s);const c=scratchRotation$5;Matrix3.setColumn(c,0,l,c),Matrix3.setColumn(c,1,s,c),Matrix3.setColumn(c,2,r,c);const d=Cartesian3.fromElements(t.x,t.y,1,scratchScale$7),h=Matrix3.multiplyByScale(c,d,scratchRotationScale$1),f=Matrix4.fromRotationTranslation(h,a,scratchLocalTransform);return Matrix4.multiplyTransformation(n,f,i)}PlaneGeometryUpdater.createPrimitiveMatrix=createPrimitiveMatrix;const scratchPosition$6=new Cartesian3,scratchBR=new BoundingRectangle,stScratch$1=new Cartesian2,textureCoordinatesOrigin=new Cartesian2,scratchNormal$3=new Cartesian3,scratchTangent$1=new Cartesian3,scratchBitangent$1=new Cartesian3,centerScratch$3=new Cartesian3,axis1Scratch=new Cartesian3,axis2Scratch=new Cartesian3,quaternionScratch$1=new Quaternion,textureMatrixScratch=new Matrix3,tangentRotationScratch=new Matrix3,surfaceNormalScratch=new Cartesian3;function createGeometryFromPolygon(e,t,n,i,r,o,a,s,l){const c=e.positions;let d=PolygonPipeline.triangulate(e.positions2D,e.holes);d.length<3&&(d=[0,1,2]);const h=IndexDatatype.createTypedArray(c.length,d.length);h.set(d);let f=textureMatrixScratch;if(i!==0){let y=Quaternion.fromAxisAngle(a,i,quaternionScratch$1);if(f=Matrix3.fromQuaternion(y,f),t.tangent||t.bitangent){y=Quaternion.fromAxisAngle(a,-i,quaternionScratch$1);const x=Matrix3.fromQuaternion(y,tangentRotationScratch);s=Cartesian3.normalize(Matrix3.multiplyByVector(x,s,s),s),t.bitangent&&(l=Cartesian3.normalize(Cartesian3.cross(a,s,l),l))}}else f=Matrix3.clone(Matrix3.IDENTITY,f);const p=textureCoordinatesOrigin;t.st&&(p.x=n.x,p.y=n.y);const u=c.length,m=u*3,g=new Float64Array(m),_=t.normal?new Float32Array(m):void 0,C=t.tangent?new Float32Array(m):void 0,A=t.bitangent?new Float32Array(m):void 0,S=t.st?new Float32Array(u*2):void 0;let v=0,b=0,D=0,I=0,L=0;for(let y=0;y<u;y++){const x=c[y];if(g[v++]=x.x,g[v++]=x.y,g[v++]=x.z,t.st)if(defined(r)&&r.positions.length===u)S[L++]=r.positions[y].x,S[L++]=r.positions[y].y;else{const T=Matrix3.multiplyByVector(f,x,scratchPosition$6),E=o(T,stScratch$1);Cartesian2.subtract(E,p,E);const P=CesiumMath.clamp(E.x/n.width,0,1),M=CesiumMath.clamp(E.y/n.height,0,1);S[L++]=P,S[L++]=M}t.normal&&(_[b++]=a.x,_[b++]=a.y,_[b++]=a.z),t.tangent&&(C[I++]=s.x,C[I++]=s.y,C[I++]=s.z),t.bitangent&&(A[D++]=l.x,A[D++]=l.y,A[D++]=l.z)}const N=new GeometryAttributes;return t.position&&(N.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:g})),t.normal&&(N.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:_})),t.tangent&&(N.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C})),t.bitangent&&(N.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:A})),t.st&&(N.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:S})),new Geometry({attributes:N,indices:h,primitiveType:PrimitiveType.TRIANGLES})}function CoplanarPolygonGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.polygonHierarchy,n=e.textureCoordinates;Check.defined("options.polygonHierarchy",t);const i=defaultValue(e.vertexFormat,VertexFormat.DEFAULT);this._vertexFormat=VertexFormat.clone(i),this._polygonHierarchy=t,this._stRotation=defaultValue(e.stRotation,0),this._ellipsoid=Ellipsoid.clone(defaultValue(e.ellipsoid,Ellipsoid.default)),this._workerName="createCoplanarPolygonGeometry",this._textureCoordinates=n,this.packedLength=PolygonGeometryLibrary.computeHierarchyPackedLength(t,Cartesian3)+VertexFormat.packedLength+Ellipsoid.packedLength+(defined(n)?PolygonGeometryLibrary.computeHierarchyPackedLength(n,Cartesian2):1)+2}CoplanarPolygonGeometry.fromPositions=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),Check.defined("options.positions",e.positions);const t={polygonHierarchy:{positions:e.positions},vertexFormat:e.vertexFormat,stRotation:e.stRotation,ellipsoid:e.ellipsoid,textureCoordinates:e.textureCoordinates};return new CoplanarPolygonGeometry(t)};CoplanarPolygonGeometry.pack=function(e,t,n){return Check.typeOf.object("value",e),Check.defined("array",t),n=defaultValue(n,0),n=PolygonGeometryLibrary.packPolygonHierarchy(e._polygonHierarchy,t,n,Cartesian3),Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,VertexFormat.pack(e._vertexFormat,t,n),n+=VertexFormat.packedLength,t[n++]=e._stRotation,defined(e._textureCoordinates)?n=PolygonGeometryLibrary.packPolygonHierarchy(e._textureCoordinates,t,n,Cartesian2):t[n++]=-1,t[n++]=e.packedLength,t};const scratchEllipsoid$8=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchVertexFormat$5=new VertexFormat,scratchOptions$9={polygonHierarchy:{}};CoplanarPolygonGeometry.unpack=function(e,t,n){Check.defined("array",e),t=defaultValue(t,0);const i=PolygonGeometryLibrary.unpackPolygonHierarchy(e,t,Cartesian3);t=i.startingIndex,delete i.startingIndex;const r=Ellipsoid.unpack(e,t,scratchEllipsoid$8);t+=Ellipsoid.packedLength;const o=VertexFormat.unpack(e,t,scratchVertexFormat$5);t+=VertexFormat.packedLength;const a=e[t++],s=e[t]===-1?void 0:PolygonGeometryLibrary.unpackPolygonHierarchy(e,t,Cartesian2);defined(s)?(t=s.startingIndex,delete s.startingIndex):t++;const l=e[t++];return defined(n)||(n=new CoplanarPolygonGeometry(scratchOptions$9)),n._polygonHierarchy=i,n._ellipsoid=Ellipsoid.clone(r,n._ellipsoid),n._vertexFormat=VertexFormat.clone(o,n._vertexFormat),n._stRotation=a,n._textureCoordinates=s,n.packedLength=l,n};CoplanarPolygonGeometry.createGeometry=function(e){const t=e._vertexFormat,n=e._polygonHierarchy,i=e._stRotation,r=e._textureCoordinates,o=defined(r);let a=n.positions;if(a=arrayRemoveDuplicates(a,Cartesian3.equalsEpsilon,!0),a.length<3)return;let s=scratchNormal$3,l=scratchTangent$1,c=scratchBitangent$1,d=axis1Scratch;const h=axis2Scratch;if(!CoplanarPolygonGeometryLibrary.computeProjectTo2DArguments(a,centerScratch$3,d,h))return;if(s=Cartesian3.cross(d,h,s),s=Cartesian3.normalize(s,s),!Cartesian3.equalsEpsilon(centerScratch$3,Cartesian3.ZERO,CesiumMath.EPSILON6)){const L=e._ellipsoid.geodeticSurfaceNormal(centerScratch$3,surfaceNormalScratch);Cartesian3.dot(s,L)<0&&(s=Cartesian3.negate(s,s),d=Cartesian3.negate(d,d))}const p=CoplanarPolygonGeometryLibrary.createProjectPointsTo2DFunction(centerScratch$3,d,h),u=CoplanarPolygonGeometryLibrary.createProjectPointTo2DFunction(centerScratch$3,d,h);t.tangent&&(l=Cartesian3.clone(d,l)),t.bitangent&&(c=Cartesian3.clone(h,c));const m=PolygonGeometryLibrary.polygonsFromHierarchy(n,o,p,!1),g=m.hierarchy,_=m.polygons,C=function(L){return L},A=o?PolygonGeometryLibrary.polygonsFromHierarchy(r,!0,C,!1).polygons:void 0;if(g.length===0)return;a=g[0].outerRing;const S=BoundingSphere.fromPoints(a),v=PolygonGeometryLibrary.computeBoundingRectangle(s,u,a,i,scratchBR),b=[];for(let L=0;L<_.length;L++){const N=new GeometryInstance({geometry:createGeometryFromPolygon(_[L],t,v,i,o?A[L]:void 0,u,s,l,c)});b.push(N)}const D=GeometryPipeline.combineInstances(b)[0];D.attributes.position.values=new Float64Array(D.attributes.position.values),D.indices=IndexDatatype.createTypedArray(D.attributes.position.values.length/3,D.indices);const I=D.attributes;return t.position||delete I.position,new Geometry({attributes:I,indices:D.indices,primitiveType:D.primitiveType,boundingSphere:S})};const createGeometryFromPositionsPositions=[],createGeometryFromPositionsSubdivided=[];function createGeometryFromPositions(e,t,n,i,r){const a=EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,createGeometryFromPositionsPositions);PolygonPipeline.computeWindingOrder2D(a)===WindingOrder.CLOCKWISE&&(a.reverse(),t=t.slice().reverse());let l,c,d=t.length,h=0;if(i)for(l=new Float64Array(d*2*3),c=0;c<d;c++){const u=t[c],m=t[(c+1)%d];l[h++]=u.x,l[h++]=u.y,l[h++]=u.z,l[h++]=m.x,l[h++]=m.y,l[h++]=m.z}else{let u=0;if(r===ArcType.GEODESIC)for(c=0;c<d;c++)u+=PolygonGeometryLibrary.subdivideLineCount(t[c],t[(c+1)%d],n);else if(r===ArcType.RHUMB)for(c=0;c<d;c++)u+=PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[c],t[(c+1)%d],n);for(l=new Float64Array(u*3),c=0;c<d;c++){let m;r===ArcType.GEODESIC?m=PolygonGeometryLibrary.subdivideLine(t[c],t[(c+1)%d],n,createGeometryFromPositionsSubdivided):r===ArcType.RHUMB&&(m=PolygonGeometryLibrary.subdivideRhumbLine(e,t[c],t[(c+1)%d],n,createGeometryFromPositionsSubdivided));const g=m.length;for(let _=0;_<g;++_)l[h++]=m[_]}}d=l.length/3;const f=d*2,p=IndexDatatype.createTypedArray(d,f);for(h=0,c=0;c<d-1;c++)p[h++]=c,p[h++]=c+1;return p[h++]=d-1,p[h++]=0,new GeometryInstance({geometry:new Geometry({attributes:new GeometryAttributes({position:new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:l})}),indices:p,primitiveType:PrimitiveType.LINES})})}function createGeometryFromPositionsExtruded(e,t,n,i,r){const a=EllipsoidTangentPlane.fromPoints(t,e).projectPointsOntoPlane(t,createGeometryFromPositionsPositions);PolygonPipeline.computeWindingOrder2D(a)===WindingOrder.CLOCKWISE&&(a.reverse(),t=t.slice().reverse());let l,c,d=t.length;const h=new Array(d);let f=0;if(i)for(l=new Float64Array(d*2*3*2),c=0;c<d;++c){h[c]=f/3;const g=t[c],_=t[(c+1)%d];l[f++]=g.x,l[f++]=g.y,l[f++]=g.z,l[f++]=_.x,l[f++]=_.y,l[f++]=_.z}else{let g=0;if(r===ArcType.GEODESIC)for(c=0;c<d;c++)g+=PolygonGeometryLibrary.subdivideLineCount(t[c],t[(c+1)%d],n);else if(r===ArcType.RHUMB)for(c=0;c<d;c++)g+=PolygonGeometryLibrary.subdivideRhumbLineCount(e,t[c],t[(c+1)%d],n);for(l=new Float64Array(g*3*2),c=0;c<d;++c){h[c]=f/3;let _;r===ArcType.GEODESIC?_=PolygonGeometryLibrary.subdivideLine(t[c],t[(c+1)%d],n,createGeometryFromPositionsSubdivided):r===ArcType.RHUMB&&(_=PolygonGeometryLibrary.subdivideRhumbLine(e,t[c],t[(c+1)%d],n,createGeometryFromPositionsSubdivided));const C=_.length;for(let A=0;A<C;++A)l[f++]=_[A]}}d=l.length/(3*2);const p=h.length,u=(d*2+p)*2,m=IndexDatatype.createTypedArray(d+p,u);for(f=0,c=0;c<d;++c)m[f++]=c,m[f++]=(c+1)%d,m[f++]=c+d,m[f++]=(c+1)%d+d;for(c=0;c<p;c++){const g=h[c];m[f++]=g,m[f++]=g+d}return new GeometryInstance({geometry:new Geometry({attributes:new GeometryAttributes({position:new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:l})}),indices:m,primitiveType:PrimitiveType.LINES})})}function PolygonOutlineGeometry(e){if(Check.typeOf.object("options",e),Check.typeOf.object("options.polygonHierarchy",e.polygonHierarchy),e.perPositionHeight&&defined(e.height))throw new DeveloperError("Cannot use both options.perPositionHeight and options.height");if(defined(e.arcType)&&e.arcType!==ArcType.GEODESIC&&e.arcType!==ArcType.RHUMB)throw new DeveloperError("Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.");const t=e.polygonHierarchy,n=defaultValue(e.ellipsoid,Ellipsoid.default),i=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),r=defaultValue(e.perPositionHeight,!1),o=r&&defined(e.extrudedHeight),a=defaultValue(e.arcType,ArcType.GEODESIC);let s=defaultValue(e.height,0),l=defaultValue(e.extrudedHeight,s);if(!o){const c=Math.max(s,l);l=Math.min(s,l),s=c}this._ellipsoid=Ellipsoid.clone(n),this._granularity=i,this._height=s,this._extrudedHeight=l,this._arcType=a,this._polygonHierarchy=t,this._perPositionHeight=r,this._perPositionHeightExtrude=o,this._offsetAttribute=e.offsetAttribute,this._workerName="createPolygonOutlineGeometry",this.packedLength=PolygonGeometryLibrary.computeHierarchyPackedLength(t,Cartesian3)+Ellipsoid.packedLength+8}PolygonOutlineGeometry.pack=function(e,t,n){return Check.typeOf.object("value",e),Check.defined("array",t),n=defaultValue(n,0),n=PolygonGeometryLibrary.packPolygonHierarchy(e._polygonHierarchy,t,n,Cartesian3),Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,t[n++]=e._height,t[n++]=e._extrudedHeight,t[n++]=e._granularity,t[n++]=e._perPositionHeightExtrude?1:0,t[n++]=e._perPositionHeight?1:0,t[n++]=e._arcType,t[n++]=defaultValue(e._offsetAttribute,-1),t[n]=e.packedLength,t};const scratchEllipsoid$7=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),dummyOptions={polygonHierarchy:{}};PolygonOutlineGeometry.unpack=function(e,t,n){Check.defined("array",e),t=defaultValue(t,0);const i=PolygonGeometryLibrary.unpackPolygonHierarchy(e,t,Cartesian3);t=i.startingIndex,delete i.startingIndex;const r=Ellipsoid.unpack(e,t,scratchEllipsoid$7);t+=Ellipsoid.packedLength;const o=e[t++],a=e[t++],s=e[t++],l=e[t++]===1,c=e[t++]===1,d=e[t++],h=e[t++],f=e[t];return defined(n)||(n=new PolygonOutlineGeometry(dummyOptions)),n._polygonHierarchy=i,n._ellipsoid=Ellipsoid.clone(r,n._ellipsoid),n._height=o,n._extrudedHeight=a,n._granularity=s,n._perPositionHeight=c,n._perPositionHeightExtrude=l,n._arcType=d,n._offsetAttribute=h===-1?void 0:h,n.packedLength=f,n};PolygonOutlineGeometry.fromPositions=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),Check.defined("options.positions",e.positions);const t={polygonHierarchy:{positions:e.positions},height:e.height,extrudedHeight:e.extrudedHeight,ellipsoid:e.ellipsoid,granularity:e.granularity,perPositionHeight:e.perPositionHeight,arcType:e.arcType,offsetAttribute:e.offsetAttribute};return new PolygonOutlineGeometry(t)};PolygonOutlineGeometry.createGeometry=function(e){const t=e._ellipsoid,n=e._granularity,i=e._polygonHierarchy,r=e._perPositionHeight,o=e._arcType,a=PolygonGeometryLibrary.polygonOutlinesFromHierarchy(i,!r,t);if(a.length===0)return;let s;const l=[],c=CesiumMath.chordLength(n,t.maximumRadius),d=e._height,h=e._extrudedHeight,f=e._perPositionHeightExtrude||!CesiumMath.equalsEpsilon(d,h,0,CesiumMath.EPSILON2);let p,u;if(f)for(u=0;u<a.length;u++){if(s=createGeometryFromPositionsExtruded(t,a[u],c,r,o),s.geometry=PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(s.geometry,d,h,t,r),defined(e._offsetAttribute)){const _=s.geometry.attributes.position.values.length/3;let C=new Uint8Array(_);e._offsetAttribute===GeometryOffsetAttribute.TOP?C=C.fill(1,0,_/2):(p=e._offsetAttribute===GeometryOffsetAttribute.NONE?0:1,C=C.fill(p)),s.geometry.attributes.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:C})}l.push(s)}else for(u=0;u<a.length;u++){if(s=createGeometryFromPositions(t,a[u],c,r,o),s.geometry.attributes.position.values=PolygonPipeline.scaleToGeodeticHeight(s.geometry.attributes.position.values,d,t,!r),defined(e._offsetAttribute)){const _=s.geometry.attributes.position.values.length;p=e._offsetAttribute===GeometryOffsetAttribute.NONE?0:1;const C=new Uint8Array(_/3).fill(p);s.geometry.attributes.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:C})}l.push(s)}const m=GeometryPipeline.combineInstances(l)[0],g=BoundingSphere.fromVertices(m.attributes.position.values);return new Geometry({attributes:m.attributes,indices:m.indices,primitiveType:m.primitiveType,boundingSphere:g,offsetAttribute:e._offsetAttribute})};const heightAndPerPositionHeightWarning="Entity polygons cannot have both height and perPositionHeight.  height will be ignored",heightReferenceAndPerPositionHeightWarning="heightReference is not supported for entity polygons with perPositionHeight. heightReference will be ignored",scratchColor$a=new Color,defaultOffset$4=Cartesian3.ZERO,offsetScratch$4=new Cartesian3,scratchRectangle$4=new Rectangle,scratch2DPositions=[],cart2Scratch=new Cartesian2;function PolygonGeometryOptions(e){this.id=e,this.vertexFormat=void 0,this.polygonHierarchy=void 0,this.perPositionHeight=void 0,this.closeTop=void 0,this.closeBottom=void 0,this.height=void 0,this.extrudedHeight=void 0,this.granularity=void 0,this.stRotation=void 0,this.offsetAttribute=void 0,this.arcType=void 0,this.textureCoordinates=void 0}function PolygonGeometryUpdater(e,t){GroundGeometryUpdater.call(this,{entity:e,scene:t,geometryOptions:new PolygonGeometryOptions(e),geometryPropertyName:"polygon",observedPropertyNames:["availability","polygon"]}),this._onEntityPropertyChanged(e,"polygon",e.polygon,void 0)}defined(Object.create)&&(PolygonGeometryUpdater.prototype=Object.create(GroundGeometryUpdater.prototype),PolygonGeometryUpdater.prototype.constructor=PolygonGeometryUpdater);PolygonGeometryUpdater.prototype.createFillGeometryInstance=function(e){if(Check.defined("time",e),!this._fillEnabled)throw new DeveloperError("This instance does not represent a filled geometry.");const t=this._entity,n=t.isAvailable(e),i=this._options,r={show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._fillProperty.getValue(e)),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(e)),offset:void 0,color:void 0};if(this._materialProperty instanceof ColorMaterialProperty){let a;defined(this._materialProperty.color)&&(this._materialProperty.color.isConstant||n)&&(a=this._materialProperty.color.getValue(e,scratchColor$a)),defined(a)||(a=Color.WHITE),r.color=ColorGeometryInstanceAttribute.fromColor(a)}defined(i.offsetAttribute)&&(r.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$4,offsetScratch$4)));let o;return i.perPositionHeight&&!defined(i.extrudedHeight)?o=new CoplanarPolygonGeometry(i):o=new PolygonGeometry(i),new GeometryInstance({id:t,geometry:o,attributes:r})};PolygonGeometryUpdater.prototype.createOutlineGeometryInstance=function(e){if(Check.defined("time",e),!this._outlineEnabled)throw new DeveloperError("This instance does not represent an outlined geometry.");const t=this._entity,n=t.isAvailable(e),i=this._options,r=Property.getValueOrDefault(this._outlineColorProperty,e,Color.BLACK,scratchColor$a),o=this._distanceDisplayConditionProperty.getValue(e),a={show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._showOutlineProperty.getValue(e)),color:ColorGeometryInstanceAttribute.fromColor(r),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(o),offset:void 0};defined(i.offsetAttribute)&&(a.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$4,offsetScratch$4)));let s;return i.perPositionHeight&&!defined(i.extrudedHeight)?s=new CoplanarPolygonOutlineGeometry(i):s=new PolygonOutlineGeometry(i),new GeometryInstance({id:t,geometry:s,attributes:a})};PolygonGeometryUpdater.prototype._computeCenter=function(e,t){const n=Property.getValueOrUndefined(this._entity.polygon.hierarchy,e);if(!defined(n))return;const i=n.positions;if(i.length===0)return;const r=this._scene.ellipsoid,o=EllipsoidTangentPlane.fromPoints(i,r),a=o.projectPointsOntoPlane(i,scratch2DPositions),s=a.length;let l=0,c=s-1,d=new Cartesian2;for(let f=0;f<s;c=f++){const p=a[f],u=a[c],m=p.x*u.y-u.x*p.y;let g=Cartesian2.add(p,u,cart2Scratch);g=Cartesian2.multiplyByScalar(g,m,g),d=Cartesian2.add(d,g,d),l+=m}const h=1/(l*3);return d=Cartesian2.multiplyByScalar(d,h,d),o.projectPointOntoEllipsoid(d,t)};PolygonGeometryUpdater.prototype._isHidden=function(e,t){return!defined(t.hierarchy)||GeometryUpdater.prototype._isHidden.call(this,e,t)};PolygonGeometryUpdater.prototype._isOnTerrain=function(e,t){const n=GroundGeometryUpdater.prototype._isOnTerrain.call(this,e,t),i=t.perPositionHeight,r=defined(i)&&(i.isConstant?i.getValue(Iso8601.MINIMUM_VALUE):!0);return n&&!r};PolygonGeometryUpdater.prototype._isDynamic=function(e,t){return!t.hierarchy.isConstant||!Property.isConstant(t.height)||!Property.isConstant(t.extrudedHeight)||!Property.isConstant(t.granularity)||!Property.isConstant(t.stRotation)||!Property.isConstant(t.textureCoordinates)||!Property.isConstant(t.outlineWidth)||!Property.isConstant(t.perPositionHeight)||!Property.isConstant(t.closeTop)||!Property.isConstant(t.closeBottom)||!Property.isConstant(t.zIndex)||!Property.isConstant(t.arcType)||this._onTerrain&&!Property.isConstant(this._materialProperty)&&!(this._materialProperty instanceof ColorMaterialProperty)};PolygonGeometryUpdater.prototype._setStaticOptions=function(e,t){const n=this._materialProperty instanceof ColorMaterialProperty,i=this._options;i.vertexFormat=n?PerInstanceColorAppearance.VERTEX_FORMAT:MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat;const r=t.hierarchy.getValue(Iso8601.MINIMUM_VALUE);let o=Property.getValueOrUndefined(t.height,Iso8601.MINIMUM_VALUE);const a=Property.getValueOrDefault(t.heightReference,Iso8601.MINIMUM_VALUE,HeightReference.NONE);let s=Property.getValueOrUndefined(t.extrudedHeight,Iso8601.MINIMUM_VALUE);const l=Property.getValueOrDefault(t.extrudedHeightReference,Iso8601.MINIMUM_VALUE,HeightReference.NONE),c=Property.getValueOrDefault(t.perPositionHeight,Iso8601.MINIMUM_VALUE,!1);o=GroundGeometryUpdater.getGeometryHeight(o,a);let d;if(c?(defined(o)&&(o=void 0,oneTimeWarning(heightAndPerPositionHeightWarning)),a!==HeightReference.NONE&&c&&(o=void 0,oneTimeWarning(heightReferenceAndPerPositionHeightWarning))):(defined(s)&&!defined(o)&&(o=0),d=GroundGeometryUpdater.computeGeometryOffsetAttribute(o,a,s,l)),i.polygonHierarchy=r,i.granularity=Property.getValueOrUndefined(t.granularity,Iso8601.MINIMUM_VALUE),i.stRotation=Property.getValueOrUndefined(t.stRotation,Iso8601.MINIMUM_VALUE),i.perPositionHeight=c,i.closeTop=Property.getValueOrDefault(t.closeTop,Iso8601.MINIMUM_VALUE,!0),i.closeBottom=Property.getValueOrDefault(t.closeBottom,Iso8601.MINIMUM_VALUE,!0),i.offsetAttribute=d,i.height=o,i.arcType=Property.getValueOrDefault(t.arcType,Iso8601.MINIMUM_VALUE,ArcType.GEODESIC),i.textureCoordinates=Property.getValueOrUndefined(t.textureCoordinates,Iso8601.MINIMUM_VALUE),s=GroundGeometryUpdater.getGeometryExtrudedHeight(s,l),s===GroundGeometryUpdater.CLAMP_TO_GROUND){const h=PolygonGeometry.computeRectangleFromPositions(i.polygonHierarchy.positions,i.ellipsoid,i.arcType,scratchRectangle$4);s=ApproximateTerrainHeights.getMinimumMaximumHeights(h).minimumTerrainHeight}i.extrudedHeight=s};PolygonGeometryUpdater.prototype._getIsClosed=function(e){const t=e.height,n=e.extrudedHeight,i=defined(n)&&n!==t;return!e.perPositionHeight&&(!i&&t===0||i&&e.closeTop&&e.closeBottom)};PolygonGeometryUpdater.DynamicGeometryUpdater=DyanmicPolygonGeometryUpdater;function DyanmicPolygonGeometryUpdater(e,t,n){DynamicGeometryUpdater$1.call(this,e,t,n)}defined(Object.create)&&(DyanmicPolygonGeometryUpdater.prototype=Object.create(DynamicGeometryUpdater$1.prototype),DyanmicPolygonGeometryUpdater.prototype.constructor=DyanmicPolygonGeometryUpdater);DyanmicPolygonGeometryUpdater.prototype._isHidden=function(e,t,n){return!defined(this._options.polygonHierarchy)||DynamicGeometryUpdater$1.prototype._isHidden.call(this,e,t,n)};DyanmicPolygonGeometryUpdater.prototype._setOptions=function(e,t,n){const i=this._options;i.polygonHierarchy=Property.getValueOrUndefined(t.hierarchy,n);let r=Property.getValueOrUndefined(t.height,n);const o=Property.getValueOrDefault(t.heightReference,n,HeightReference.NONE),a=Property.getValueOrDefault(t.extrudedHeightReference,n,HeightReference.NONE);let s=Property.getValueOrUndefined(t.extrudedHeight,n);const l=Property.getValueOrUndefined(t.perPositionHeight,n);r=GroundGeometryUpdater.getGeometryHeight(r,a);let c;if(l?(defined(r)&&(r=void 0,oneTimeWarning(heightAndPerPositionHeightWarning)),o!==HeightReference.NONE&&l&&(r=void 0,oneTimeWarning(heightReferenceAndPerPositionHeightWarning))):(defined(s)&&!defined(r)&&(r=0),c=GroundGeometryUpdater.computeGeometryOffsetAttribute(r,o,s,a)),i.granularity=Property.getValueOrUndefined(t.granularity,n),i.stRotation=Property.getValueOrUndefined(t.stRotation,n),i.textureCoordinates=Property.getValueOrUndefined(t.textureCoordinates,n),i.perPositionHeight=Property.getValueOrUndefined(t.perPositionHeight,n),i.closeTop=Property.getValueOrDefault(t.closeTop,n,!0),i.closeBottom=Property.getValueOrDefault(t.closeBottom,n,!0),i.offsetAttribute=c,i.height=r,i.arcType=Property.getValueOrDefault(t.arcType,n,ArcType.GEODESIC),s=GroundGeometryUpdater.getGeometryExtrudedHeight(s,a),s===GroundGeometryUpdater.CLAMP_TO_GROUND){const d=PolygonGeometry.computeRectangleFromPositions(i.polygonHierarchy.positions,i.ellipsoid,i.arcType,scratchRectangle$4);s=ApproximateTerrainHeights.getMinimumMaximumHeights(d).minimumTerrainHeight}i.extrudedHeight=s};function computeAttributes$1(e,t,n,i){const r=new GeometryAttributes;i.position&&(r.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e}));const o=t.length,a=e.length/3,s=(a-o*2)/(o*2),l=PolygonPipeline.triangulate(t),c=(s-1)*o*6+l.length*2,d=IndexDatatype.createTypedArray(a,c);let h,f,p,u,m,g;const _=o*2;let C=0;for(h=0;h<s-1;h++){for(f=0;f<o-1;f++)p=f*2+h*o*2,g=p+_,u=p+1,m=u+_,d[C++]=u,d[C++]=p,d[C++]=m,d[C++]=m,d[C++]=p,d[C++]=g;p=o*2-2+h*o*2,u=p+1,m=u+_,g=p+_,d[C++]=u,d[C++]=p,d[C++]=m,d[C++]=m,d[C++]=p,d[C++]=g}if(i.st||i.tangent||i.bitangent){const v=new Float32Array(a*2),b=1/(s-1),D=1/n.height,I=n.height/2;let L,N,y=0;for(h=0;h<s;h++){for(L=h*b,N=D*(t[0].y+I),v[y++]=L,v[y++]=N,f=1;f<o;f++)N=D*(t[f].y+I),v[y++]=L,v[y++]=N,v[y++]=L,v[y++]=N;N=D*(t[0].y+I),v[y++]=L,v[y++]=N}for(f=0;f<o;f++)L=0,N=D*(t[f].y+I),v[y++]=L,v[y++]=N;for(f=0;f<o;f++)L=(s-1)*b,N=D*(t[f].y+I),v[y++]=L,v[y++]=N;r.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:new Float32Array(v)})}const A=a-o*2;for(h=0;h<l.length;h+=3){const v=l[h]+A,b=l[h+1]+A,D=l[h+2]+A;d[C++]=v,d[C++]=b,d[C++]=D,d[C++]=D+o,d[C++]=b+o,d[C++]=v+o}let S=new Geometry({attributes:r,indices:d,boundingSphere:BoundingSphere.fromVertices(e),primitiveType:PrimitiveType.TRIANGLES});if(i.normal&&(S=GeometryPipeline.computeNormal(S)),i.tangent||i.bitangent){try{S=GeometryPipeline.computeTangentAndBitangent(S)}catch{oneTimeWarning("polyline-volume-tangent-bitangent","Unable to compute tangents and bitangents for polyline volume geometry")}i.tangent||(S.attributes.tangent=void 0),i.bitangent||(S.attributes.bitangent=void 0),i.st||(S.attributes.st=void 0)}return S}function PolylineVolumeGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.polylinePositions,n=e.shapePositions;if(!defined(t))throw new DeveloperError("options.polylinePositions is required.");if(!defined(n))throw new DeveloperError("options.shapePositions is required.");this._positions=t,this._shape=n,this._ellipsoid=Ellipsoid.clone(defaultValue(e.ellipsoid,Ellipsoid.default)),this._cornerType=defaultValue(e.cornerType,CornerType$1.ROUNDED),this._vertexFormat=VertexFormat.clone(defaultValue(e.vertexFormat,VertexFormat.DEFAULT)),this._granularity=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeGeometry";let i=1+t.length*Cartesian3.packedLength;i+=1+n.length*Cartesian2.packedLength,this.packedLength=i+Ellipsoid.packedLength+VertexFormat.packedLength+2}PolylineVolumeGeometry.pack=function(e,t,n){if(!defined(e))throw new DeveloperError("value is required");if(!defined(t))throw new DeveloperError("array is required");n=defaultValue(n,0);let i;const r=e._positions;let o=r.length;for(t[n++]=o,i=0;i<o;++i,n+=Cartesian3.packedLength)Cartesian3.pack(r[i],t,n);const a=e._shape;for(o=a.length,t[n++]=o,i=0;i<o;++i,n+=Cartesian2.packedLength)Cartesian2.pack(a[i],t,n);return Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,VertexFormat.pack(e._vertexFormat,t,n),n+=VertexFormat.packedLength,t[n++]=e._cornerType,t[n]=e._granularity,t};const scratchEllipsoid$6=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchVertexFormat$4=new VertexFormat,scratchOptions$8={polylinePositions:void 0,shapePositions:void 0,ellipsoid:scratchEllipsoid$6,vertexFormat:scratchVertexFormat$4,cornerType:void 0,granularity:void 0};PolylineVolumeGeometry.unpack=function(e,t,n){if(!defined(e))throw new DeveloperError("array is required");t=defaultValue(t,0);let i,r=e[t++];const o=new Array(r);for(i=0;i<r;++i,t+=Cartesian3.packedLength)o[i]=Cartesian3.unpack(e,t);r=e[t++];const a=new Array(r);for(i=0;i<r;++i,t+=Cartesian2.packedLength)a[i]=Cartesian2.unpack(e,t);const s=Ellipsoid.unpack(e,t,scratchEllipsoid$6);t+=Ellipsoid.packedLength;const l=VertexFormat.unpack(e,t,scratchVertexFormat$4);t+=VertexFormat.packedLength;const c=e[t++],d=e[t];return defined(n)?(n._positions=o,n._shape=a,n._ellipsoid=Ellipsoid.clone(s,n._ellipsoid),n._vertexFormat=VertexFormat.clone(l,n._vertexFormat),n._cornerType=c,n._granularity=d,n):(scratchOptions$8.polylinePositions=o,scratchOptions$8.shapePositions=a,scratchOptions$8.cornerType=c,scratchOptions$8.granularity=d,new PolylineVolumeGeometry(scratchOptions$8))};const brScratch$1=new BoundingRectangle;PolylineVolumeGeometry.createGeometry=function(e){const t=e._positions,n=arrayRemoveDuplicates(t,Cartesian3.equalsEpsilon);let i=e._shape;if(i=PolylineVolumeGeometryLibrary$1.removeDuplicatesFromShape(i),n.length<2||i.length<3)return;PolygonPipeline.computeWindingOrder2D(i)===WindingOrder.CLOCKWISE&&i.reverse();const r=BoundingRectangle.fromPoints(i,brScratch$1),o=PolylineVolumeGeometryLibrary$1.computePositions(n,i,r,e,!0);return computeAttributes$1(o,i,r,e._vertexFormat)};function computeAttributes(e,t){const n=new GeometryAttributes;n.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e});const i=t.length,r=n.position.values.length/3,a=e.length/3/i,s=IndexDatatype.createTypedArray(r,2*i*(a+1));let l,c,d=0;l=0;let h=l*i;for(c=0;c<i-1;c++)s[d++]=c+h,s[d++]=c+h+1;for(s[d++]=i-1+h,s[d++]=h,l=a-1,h=l*i,c=0;c<i-1;c++)s[d++]=c+h,s[d++]=c+h+1;for(s[d++]=i-1+h,s[d++]=h,l=0;l<a-1;l++){const p=i*l,u=p+i;for(c=0;c<i;c++)s[d++]=c+p,s[d++]=c+u}return new Geometry({attributes:n,indices:IndexDatatype.createTypedArray(r,s),boundingSphere:BoundingSphere.fromVertices(e),primitiveType:PrimitiveType.LINES})}function PolylineVolumeOutlineGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.polylinePositions,n=e.shapePositions;if(!defined(t))throw new DeveloperError("options.polylinePositions is required.");if(!defined(n))throw new DeveloperError("options.shapePositions is required.");this._positions=t,this._shape=n,this._ellipsoid=Ellipsoid.clone(defaultValue(e.ellipsoid,Ellipsoid.default)),this._cornerType=defaultValue(e.cornerType,CornerType$1.ROUNDED),this._granularity=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeOutlineGeometry";let i=1+t.length*Cartesian3.packedLength;i+=1+n.length*Cartesian2.packedLength,this.packedLength=i+Ellipsoid.packedLength+2}PolylineVolumeOutlineGeometry.pack=function(e,t,n){if(!defined(e))throw new DeveloperError("value is required");if(!defined(t))throw new DeveloperError("array is required");n=defaultValue(n,0);let i;const r=e._positions;let o=r.length;for(t[n++]=o,i=0;i<o;++i,n+=Cartesian3.packedLength)Cartesian3.pack(r[i],t,n);const a=e._shape;for(o=a.length,t[n++]=o,i=0;i<o;++i,n+=Cartesian2.packedLength)Cartesian2.pack(a[i],t,n);return Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,t[n++]=e._cornerType,t[n]=e._granularity,t};const scratchEllipsoid$5=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchOptions$7={polylinePositions:void 0,shapePositions:void 0,ellipsoid:scratchEllipsoid$5,height:void 0,cornerType:void 0,granularity:void 0};PolylineVolumeOutlineGeometry.unpack=function(e,t,n){if(!defined(e))throw new DeveloperError("array is required");t=defaultValue(t,0);let i,r=e[t++];const o=new Array(r);for(i=0;i<r;++i,t+=Cartesian3.packedLength)o[i]=Cartesian3.unpack(e,t);r=e[t++];const a=new Array(r);for(i=0;i<r;++i,t+=Cartesian2.packedLength)a[i]=Cartesian2.unpack(e,t);const s=Ellipsoid.unpack(e,t,scratchEllipsoid$5);t+=Ellipsoid.packedLength;const l=e[t++],c=e[t];return defined(n)?(n._positions=o,n._shape=a,n._ellipsoid=Ellipsoid.clone(s,n._ellipsoid),n._cornerType=l,n._granularity=c,n):(scratchOptions$7.polylinePositions=o,scratchOptions$7.shapePositions=a,scratchOptions$7.cornerType=l,scratchOptions$7.granularity=c,new PolylineVolumeOutlineGeometry(scratchOptions$7))};const brScratch=new BoundingRectangle;PolylineVolumeOutlineGeometry.createGeometry=function(e){const t=e._positions,n=arrayRemoveDuplicates(t,Cartesian3.equalsEpsilon);let i=e._shape;if(i=PolylineVolumeGeometryLibrary$1.removeDuplicatesFromShape(i),n.length<2||i.length<3)return;PolygonPipeline.computeWindingOrder2D(i)===WindingOrder.CLOCKWISE&&i.reverse();const r=BoundingRectangle.fromPoints(i,brScratch),o=PolylineVolumeGeometryLibrary$1.computePositions(n,i,r,e,!1);return computeAttributes(o,i)};const scratchColor$9=new Color;function PolylineVolumeGeometryOptions(e){this.id=e,this.vertexFormat=void 0,this.polylinePositions=void 0,this.shapePositions=void 0,this.cornerType=void 0,this.granularity=void 0}function PolylineVolumeGeometryUpdater(e,t){GeometryUpdater.call(this,{entity:e,scene:t,geometryOptions:new PolylineVolumeGeometryOptions(e),geometryPropertyName:"polylineVolume",observedPropertyNames:["availability","polylineVolume"]}),this._onEntityPropertyChanged(e,"polylineVolume",e.polylineVolume,void 0)}defined(Object.create)&&(PolylineVolumeGeometryUpdater.prototype=Object.create(GeometryUpdater.prototype),PolylineVolumeGeometryUpdater.prototype.constructor=PolylineVolumeGeometryUpdater);PolylineVolumeGeometryUpdater.prototype.createFillGeometryInstance=function(e){if(Check.defined("time",e),!this._fillEnabled)throw new DeveloperError("This instance does not represent a filled geometry.");const t=this._entity,n=t.isAvailable(e);let i,r;const o=new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._fillProperty.getValue(e)),a=this._distanceDisplayConditionProperty.getValue(e),s=DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(a);if(this._materialProperty instanceof ColorMaterialProperty){let l;defined(this._materialProperty.color)&&(this._materialProperty.color.isConstant||n)&&(l=this._materialProperty.color.getValue(e,scratchColor$9)),defined(l)||(l=Color.WHITE),r=ColorGeometryInstanceAttribute.fromColor(l),i={show:o,distanceDisplayCondition:s,color:r}}else i={show:o,distanceDisplayCondition:s};return new GeometryInstance({id:t,geometry:new PolylineVolumeGeometry(this._options),attributes:i})};PolylineVolumeGeometryUpdater.prototype.createOutlineGeometryInstance=function(e){if(Check.defined("time",e),!this._outlineEnabled)throw new DeveloperError("This instance does not represent an outlined geometry.");const t=this._entity,n=t.isAvailable(e),i=Property.getValueOrDefault(this._outlineColorProperty,e,Color.BLACK,scratchColor$9),r=this._distanceDisplayConditionProperty.getValue(e);return new GeometryInstance({id:t,geometry:new PolylineVolumeOutlineGeometry(this._options),attributes:{show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._showOutlineProperty.getValue(e)),color:ColorGeometryInstanceAttribute.fromColor(i),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(r)}})};PolylineVolumeGeometryUpdater.prototype._isHidden=function(e,t){return!defined(t.positions)||!defined(t.shape)||GeometryUpdater.prototype._isHidden.call(this,e,t)};PolylineVolumeGeometryUpdater.prototype._isDynamic=function(e,t){return!t.positions.isConstant||!t.shape.isConstant||!Property.isConstant(t.granularity)||!Property.isConstant(t.outlineWidth)||!Property.isConstant(t.cornerType)};PolylineVolumeGeometryUpdater.prototype._setStaticOptions=function(e,t){const n=t.granularity,i=t.cornerType,r=this._options,o=this._materialProperty instanceof ColorMaterialProperty;r.vertexFormat=o?PerInstanceColorAppearance.VERTEX_FORMAT:MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat,r.polylinePositions=t.positions.getValue(Iso8601.MINIMUM_VALUE,r.polylinePositions),r.shapePositions=t.shape.getValue(Iso8601.MINIMUM_VALUE,r.shape),r.granularity=defined(n)?n.getValue(Iso8601.MINIMUM_VALUE):void 0,r.cornerType=defined(i)?i.getValue(Iso8601.MINIMUM_VALUE):void 0};PolylineVolumeGeometryUpdater.DynamicGeometryUpdater=DynamicPolylineVolumeGeometryUpdater;function DynamicPolylineVolumeGeometryUpdater(e,t,n){DynamicGeometryUpdater$1.call(this,e,t,n)}defined(Object.create)&&(DynamicPolylineVolumeGeometryUpdater.prototype=Object.create(DynamicGeometryUpdater$1.prototype),DynamicPolylineVolumeGeometryUpdater.prototype.constructor=DynamicPolylineVolumeGeometryUpdater);DynamicPolylineVolumeGeometryUpdater.prototype._isHidden=function(e,t,n){const i=this._options;return!defined(i.polylinePositions)||!defined(i.shapePositions)||DynamicGeometryUpdater$1.prototype._isHidden.call(this,e,t,n)};DynamicPolylineVolumeGeometryUpdater.prototype._setOptions=function(e,t,n){const i=this._options;i.polylinePositions=Property.getValueOrUndefined(t.positions,n,i.polylinePositions),i.shapePositions=Property.getValueOrUndefined(t.shape,n),i.granularity=Property.getValueOrUndefined(t.granularity,n),i.cornerType=Property.getValueOrUndefined(t.cornerType,n)};const positionScratch$2=new Cartesian3,normalScratch$2=new Cartesian3,tangentScratch=new Cartesian3,bitangentScratch=new Cartesian3,rectangleScratch$3=new Rectangle,stScratch=new Cartesian2,bottomBoundingSphere=new BoundingSphere,topBoundingSphere=new BoundingSphere;function createAttributes(e,t){const n=new Geometry({attributes:new GeometryAttributes,primitiveType:PrimitiveType.TRIANGLES});return n.attributes.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:t.positions}),e.normal&&(n.attributes.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t.normals})),e.tangent&&(n.attributes.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t.tangents})),e.bitangent&&(n.attributes.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t.bitangents})),n}function calculateAttributes(e,t,n,i){const r=e.length,o=t.normal?new Float32Array(r):void 0,a=t.tangent?new Float32Array(r):void 0,s=t.bitangent?new Float32Array(r):void 0;let l=0;const c=bitangentScratch,d=tangentScratch;let h=normalScratch$2;if(t.normal||t.tangent||t.bitangent)for(let f=0;f<r;f+=3){const p=Cartesian3.fromArray(e,f,positionScratch$2),u=l+1,m=l+2;h=n.geodeticSurfaceNormal(p,h),(t.tangent||t.bitangent)&&(Cartesian3.cross(Cartesian3.UNIT_Z,h,d),Matrix3.multiplyByVector(i,d,d),Cartesian3.normalize(d,d),t.bitangent&&Cartesian3.normalize(Cartesian3.cross(h,d,c),c)),t.normal&&(o[l]=h.x,o[u]=h.y,o[m]=h.z),t.tangent&&(a[l]=d.x,a[u]=d.y,a[m]=d.z),t.bitangent&&(s[l]=c.x,s[u]=c.y,s[m]=c.z),l+=3}return createAttributes(t,{positions:e,normals:o,tangents:a,bitangents:s})}const v1Scratch=new Cartesian3,v2Scratch=new Cartesian3;function calculateAttributesWall(e,t,n){const i=e.length,r=t.normal?new Float32Array(i):void 0,o=t.tangent?new Float32Array(i):void 0,a=t.bitangent?new Float32Array(i):void 0;let s=0,l=0,c=0,d=!0,h=bitangentScratch,f=tangentScratch,p=normalScratch$2;if(t.normal||t.tangent||t.bitangent)for(let u=0;u<i;u+=6){const m=Cartesian3.fromArray(e,u,positionScratch$2),g=Cartesian3.fromArray(e,(u+6)%i,v1Scratch);if(d){const _=Cartesian3.fromArray(e,(u+3)%i,v2Scratch);Cartesian3.subtract(g,m,g),Cartesian3.subtract(_,m,_),p=Cartesian3.normalize(Cartesian3.cross(_,g,p),p),d=!1}Cartesian3.equalsEpsilon(g,m,CesiumMath.EPSILON10)&&(d=!0),(t.tangent||t.bitangent)&&(h=n.geodeticSurfaceNormal(m,h),t.tangent&&(f=Cartesian3.normalize(Cartesian3.cross(h,p,f),f))),t.normal&&(r[s++]=p.x,r[s++]=p.y,r[s++]=p.z,r[s++]=p.x,r[s++]=p.y,r[s++]=p.z),t.tangent&&(o[l++]=f.x,o[l++]=f.y,o[l++]=f.z,o[l++]=f.x,o[l++]=f.y,o[l++]=f.z),t.bitangent&&(a[c++]=h.x,a[c++]=h.y,a[c++]=h.z,a[c++]=h.x,a[c++]=h.y,a[c++]=h.z)}return createAttributes(t,{positions:e,normals:r,tangents:o,bitangents:a})}function constructRectangle(e,t){const n=e._vertexFormat,i=e._ellipsoid,r=t.height,o=t.width,a=t.northCap,s=t.southCap;let l=0,c=r,d=r,h=0;a&&(l=1,d-=1,h+=1),s&&(c-=1,d-=1,h+=1),h+=o*d;const f=n.position?new Float64Array(h*3):void 0,p=n.st?new Float32Array(h*2):void 0;let u=0,m=0;const g=positionScratch$2,_=stScratch;let C=Number.MAX_VALUE,A=Number.MAX_VALUE,S=-Number.MAX_VALUE,v=-Number.MAX_VALUE;for(let x=l;x<c;++x)for(let T=0;T<o;++T)RectangleGeometryLibrary.computePosition(t,i,n.st,x,T,g,_),f[u++]=g.x,f[u++]=g.y,f[u++]=g.z,n.st&&(p[m++]=_.x,p[m++]=_.y,C=Math.min(C,_.x),A=Math.min(A,_.y),S=Math.max(S,_.x),v=Math.max(v,_.y));if(a&&(RectangleGeometryLibrary.computePosition(t,i,n.st,0,0,g,_),f[u++]=g.x,f[u++]=g.y,f[u++]=g.z,n.st&&(p[m++]=_.x,p[m++]=_.y,C=_.x,A=_.y,S=_.x,v=_.y)),s&&(RectangleGeometryLibrary.computePosition(t,i,n.st,r-1,0,g,_),f[u++]=g.x,f[u++]=g.y,f[u]=g.z,n.st&&(p[m++]=_.x,p[m]=_.y,C=Math.min(C,_.x),A=Math.min(A,_.y),S=Math.max(S,_.x),v=Math.max(v,_.y))),n.st&&(C<0||A<0||S>1||v>1))for(let x=0;x<p.length;x+=2)p[x]=(p[x]-C)/(S-C),p[x+1]=(p[x+1]-A)/(v-A);const b=calculateAttributes(f,n,i,t.tangentRotationMatrix);let D=6*(o-1)*(d-1);a&&(D+=3*(o-1)),s&&(D+=3*(o-1));const I=IndexDatatype.createTypedArray(h,D);let L=0,N=0,y;for(y=0;y<d-1;++y){for(let x=0;x<o-1;++x){const T=L,E=T+o,P=E+1,M=T+1;I[N++]=T,I[N++]=E,I[N++]=M,I[N++]=M,I[N++]=E,I[N++]=P,++L}++L}if(a||s){let x=h-1;const T=h-1;a&&s&&(x=h-2);let E,P;if(L=0,a)for(y=0;y<o-1;y++)E=L,P=E+1,I[N++]=x,I[N++]=E,I[N++]=P,++L;if(s)for(L=(d-1)*o,y=0;y<o-1;y++)E=L,P=E+1,I[N++]=E,I[N++]=T,I[N++]=P,++L}return b.indices=I,n.st&&(b.attributes.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:p})),b}function addWallPositions(e,t,n,i,r){return e[t++]=i[n],e[t++]=i[n+1],e[t++]=i[n+2],e[t++]=r[n],e[t++]=r[n+1],e[t]=r[n+2],e}function addWallTextureCoordinates(e,t,n,i){return e[t++]=i[n],e[t++]=i[n+1],e[t++]=i[n],e[t]=i[n+1],e}const scratchVertexFormat$3=new VertexFormat;function constructExtrudedRectangle(e,t){const n=e._shadowVolume,i=e._offsetAttribute,r=e._vertexFormat,o=e._extrudedHeight,a=e._surfaceHeight,s=e._ellipsoid,l=t.height,c=t.width;let d;if(n){const ee=VertexFormat.clone(r,scratchVertexFormat$3);ee.normal=!0,e._vertexFormat=ee}const h=constructRectangle(e,t);n&&(e._vertexFormat=r);let f=PolygonPipeline.scaleToGeodeticHeight(h.attributes.position.values,a,s,!1);f=new Float64Array(f);let p=f.length;const u=p*2,m=new Float64Array(u);m.set(f);const g=PolygonPipeline.scaleToGeodeticHeight(h.attributes.position.values,o,s);m.set(g,p),h.attributes.position.values=m;const _=r.normal?new Float32Array(u):void 0,C=r.tangent?new Float32Array(u):void 0,A=r.bitangent?new Float32Array(u):void 0,S=r.st?new Float32Array(u/3*2):void 0;let v,b;if(r.normal){for(b=h.attributes.normal.values,_.set(b),d=0;d<p;d++)b[d]=-b[d];_.set(b,p),h.attributes.normal.values=_}if(n){b=h.attributes.normal.values,r.normal||(h.attributes.normal=void 0);const ee=new Float32Array(u);for(d=0;d<p;d++)b[d]=-b[d];ee.set(b,p),h.attributes.extrudeDirection=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:ee})}let D;const I=defined(i);if(I){const ee=p/3*2;let ce=new Uint8Array(ee);i===GeometryOffsetAttribute.TOP?ce=ce.fill(1,0,ee/2):(D=i===GeometryOffsetAttribute.NONE?0:1,ce=ce.fill(D)),h.attributes.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:ce})}if(r.tangent){const ee=h.attributes.tangent.values;for(C.set(ee),d=0;d<p;d++)ee[d]=-ee[d];C.set(ee,p),h.attributes.tangent.values=C}if(r.bitangent){const ee=h.attributes.bitangent.values;A.set(ee),A.set(ee,p),h.attributes.bitangent.values=A}r.st&&(v=h.attributes.st.values,S.set(v),S.set(v,p/3*2),h.attributes.st.values=S);const L=h.indices,N=L.length,y=p/3,x=IndexDatatype.createTypedArray(u/3,N*2);for(x.set(L),d=0;d<N;d+=3)x[d+N]=L[d+2]+y,x[d+1+N]=L[d+1]+y,x[d+2+N]=L[d]+y;h.indices=x;const T=t.northCap,E=t.southCap;let P=l,M=2,O=0,V=4,R=4;T&&(M-=1,P-=1,O+=1,V-=2,R-=1),E&&(M-=1,P-=1,O+=1,V-=2,R-=1),O+=M*c+2*P-V;const w=(O+R)*2;let U=new Float64Array(w*3);const k=n?new Float32Array(w*3):void 0;let H=I?new Uint8Array(w):void 0,F=r.st?new Float32Array(w*2):void 0;const G=i===GeometryOffsetAttribute.TOP;I&&!G&&(D=i===GeometryOffsetAttribute.ALL?1:0,H=H.fill(D));let B=0,W=0,Y=0,z=0;const X=c*P;let q;for(d=0;d<X;d+=c)q=d*3,U=addWallPositions(U,B,q,f,g),B+=6,r.st&&(F=addWallTextureCoordinates(F,W,d*2,v),W+=4),n&&(Y+=3,k[Y++]=b[q],k[Y++]=b[q+1],k[Y++]=b[q+2]),G&&(H[z++]=1,z+=1);if(E){const ee=T?X+1:X;for(q=ee*3,d=0;d<2;d++)U=addWallPositions(U,B,q,f,g),B+=6,r.st&&(F=addWallTextureCoordinates(F,W,ee*2,v),W+=4),n&&(Y+=3,k[Y++]=b[q],k[Y++]=b[q+1],k[Y++]=b[q+2]),G&&(H[z++]=1,z+=1)}else for(d=X-c;d<X;d++)q=d*3,U=addWallPositions(U,B,q,f,g),B+=6,r.st&&(F=addWallTextureCoordinates(F,W,d*2,v),W+=4),n&&(Y+=3,k[Y++]=b[q],k[Y++]=b[q+1],k[Y++]=b[q+2]),G&&(H[z++]=1,z+=1);for(d=X-1;d>0;d-=c)q=d*3,U=addWallPositions(U,B,q,f,g),B+=6,r.st&&(F=addWallTextureCoordinates(F,W,d*2,v),W+=4),n&&(Y+=3,k[Y++]=b[q],k[Y++]=b[q+1],k[Y++]=b[q+2]),G&&(H[z++]=1,z+=1);if(T){const ee=X;for(q=ee*3,d=0;d<2;d++)U=addWallPositions(U,B,q,f,g),B+=6,r.st&&(F=addWallTextureCoordinates(F,W,ee*2,v),W+=4),n&&(Y+=3,k[Y++]=b[q],k[Y++]=b[q+1],k[Y++]=b[q+2]),G&&(H[z++]=1,z+=1)}else for(d=c-1;d>=0;d--)q=d*3,U=addWallPositions(U,B,q,f,g),B+=6,r.st&&(F=addWallTextureCoordinates(F,W,d*2,v),W+=4),n&&(Y+=3,k[Y++]=b[q],k[Y++]=b[q+1],k[Y++]=b[q+2]),G&&(H[z++]=1,z+=1);let Q=calculateAttributesWall(U,r,s);r.st&&(Q.attributes.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:F})),n&&(Q.attributes.extrudeDirection=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:k})),I&&(Q.attributes.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:H}));const Z=IndexDatatype.createTypedArray(w,O*6);let K,J,se,ae;p=U.length/3;let te=0;for(d=0;d<p-1;d+=2){K=d,ae=(K+2)%p;const ee=Cartesian3.fromArray(U,K*3,v1Scratch),ce=Cartesian3.fromArray(U,ae*3,v2Scratch);Cartesian3.equalsEpsilon(ee,ce,CesiumMath.EPSILON10)||(J=(K+1)%p,se=(J+2)%p,Z[te++]=K,Z[te++]=J,Z[te++]=ae,Z[te++]=ae,Z[te++]=J,Z[te++]=se)}return Q.indices=Z,Q=GeometryPipeline.combineInstances([new GeometryInstance({geometry:h}),new GeometryInstance({geometry:Q})]),Q[0]}const scratchRectanglePoints=[new Cartesian3,new Cartesian3,new Cartesian3,new Cartesian3],nwScratch=new Cartographic,stNwScratch=new Cartographic;function computeRectangle(e,t,n,i,r){if(n===0)return Rectangle.clone(e,r);const o=RectangleGeometryLibrary.computeOptions(e,t,n,0,rectangleScratch$3,nwScratch),a=o.height,s=o.width,l=scratchRectanglePoints;return RectangleGeometryLibrary.computePosition(o,i,!1,0,0,l[0]),RectangleGeometryLibrary.computePosition(o,i,!1,0,s-1,l[1]),RectangleGeometryLibrary.computePosition(o,i,!1,a-1,0,l[2]),RectangleGeometryLibrary.computePosition(o,i,!1,a-1,s-1,l[3]),Rectangle.fromCartesianArray(l,i,r)}function RectangleGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.rectangle;if(Check.typeOf.object("rectangle",t),Rectangle.validate(t),t.north<t.south)throw new DeveloperError("options.rectangle.north must be greater than or equal to options.rectangle.south");const n=defaultValue(e.height,0),i=defaultValue(e.extrudedHeight,n);this._rectangle=Rectangle.clone(t),this._granularity=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=Ellipsoid.clone(defaultValue(e.ellipsoid,Ellipsoid.default)),this._surfaceHeight=Math.max(n,i),this._rotation=defaultValue(e.rotation,0),this._stRotation=defaultValue(e.stRotation,0),this._vertexFormat=VertexFormat.clone(defaultValue(e.vertexFormat,VertexFormat.DEFAULT)),this._extrudedHeight=Math.min(n,i),this._shadowVolume=defaultValue(e.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=e.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}RectangleGeometry.packedLength=Rectangle.packedLength+Ellipsoid.packedLength+VertexFormat.packedLength+7;RectangleGeometry.pack=function(e,t,n){return Check.typeOf.object("value",e),Check.defined("array",t),n=defaultValue(n,0),Rectangle.pack(e._rectangle,t,n),n+=Rectangle.packedLength,Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,VertexFormat.pack(e._vertexFormat,t,n),n+=VertexFormat.packedLength,t[n++]=e._granularity,t[n++]=e._surfaceHeight,t[n++]=e._rotation,t[n++]=e._stRotation,t[n++]=e._extrudedHeight,t[n++]=e._shadowVolume?1:0,t[n]=defaultValue(e._offsetAttribute,-1),t};const scratchRectangle$3=new Rectangle,scratchEllipsoid$4=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchOptions$6={rectangle:scratchRectangle$3,ellipsoid:scratchEllipsoid$4,vertexFormat:scratchVertexFormat$3,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};RectangleGeometry.unpack=function(e,t,n){Check.defined("array",e),t=defaultValue(t,0);const i=Rectangle.unpack(e,t,scratchRectangle$3);t+=Rectangle.packedLength;const r=Ellipsoid.unpack(e,t,scratchEllipsoid$4);t+=Ellipsoid.packedLength;const o=VertexFormat.unpack(e,t,scratchVertexFormat$3);t+=VertexFormat.packedLength;const a=e[t++],s=e[t++],l=e[t++],c=e[t++],d=e[t++],h=e[t++]===1,f=e[t];return defined(n)?(n._rectangle=Rectangle.clone(i,n._rectangle),n._ellipsoid=Ellipsoid.clone(r,n._ellipsoid),n._vertexFormat=VertexFormat.clone(o,n._vertexFormat),n._granularity=a,n._surfaceHeight=s,n._rotation=l,n._stRotation=c,n._extrudedHeight=d,n._shadowVolume=h,n._offsetAttribute=f===-1?void 0:f,n):(scratchOptions$6.granularity=a,scratchOptions$6.height=s,scratchOptions$6.rotation=l,scratchOptions$6.stRotation=c,scratchOptions$6.extrudedHeight=d,scratchOptions$6.shadowVolume=h,scratchOptions$6.offsetAttribute=f===-1?void 0:f,new RectangleGeometry(scratchOptions$6))};RectangleGeometry.computeRectangle=function(e,t){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const n=e.rectangle;if(Check.typeOf.object("rectangle",n),Rectangle.validate(n),n.north<n.south)throw new DeveloperError("options.rectangle.north must be greater than or equal to options.rectangle.south");const i=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),r=defaultValue(e.ellipsoid,Ellipsoid.default),o=defaultValue(e.rotation,0);return computeRectangle(n,i,o,r,t)};const tangentRotationMatrixScratch=new Matrix3,quaternionScratch=new Quaternion,centerScratch$2=new Cartographic;RectangleGeometry.createGeometry=function(e){if(CesiumMath.equalsEpsilon(e._rectangle.north,e._rectangle.south,CesiumMath.EPSILON10)||CesiumMath.equalsEpsilon(e._rectangle.east,e._rectangle.west,CesiumMath.EPSILON10))return;let t=e._rectangle;const n=e._ellipsoid,i=e._rotation,r=e._stRotation,o=e._vertexFormat,a=RectangleGeometryLibrary.computeOptions(t,e._granularity,i,r,rectangleScratch$3,nwScratch,stNwScratch),s=tangentRotationMatrixScratch;if(r!==0||i!==0){const p=Rectangle.center(t,centerScratch$2),u=n.geodeticSurfaceNormalCartographic(p,v1Scratch);Quaternion.fromAxisAngle(u,-r,quaternionScratch),Matrix3.fromQuaternion(quaternionScratch,s)}else Matrix3.clone(Matrix3.IDENTITY,s);const l=e._surfaceHeight,c=e._extrudedHeight,d=!CesiumMath.equalsEpsilon(l,c,0,CesiumMath.EPSILON2);a.lonScalar=1/e._rectangle.width,a.latScalar=1/e._rectangle.height,a.tangentRotationMatrix=s;let h,f;if(t=e._rectangle,d){h=constructExtrudedRectangle(e,a);const p=BoundingSphere.fromRectangle3D(t,n,l,topBoundingSphere),u=BoundingSphere.fromRectangle3D(t,n,c,bottomBoundingSphere);f=BoundingSphere.union(p,u)}else{if(h=constructRectangle(e,a),h.attributes.position.values=PolygonPipeline.scaleToGeodeticHeight(h.attributes.position.values,l,n,!1),defined(e._offsetAttribute)){const p=h.attributes.position.values.length,u=e._offsetAttribute===GeometryOffsetAttribute.NONE?0:1,m=new Uint8Array(p/3).fill(u);h.attributes.applyOffset=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:m})}f=BoundingSphere.fromRectangle3D(t,n,l)}return o.position||delete h.attributes.position,new Geometry({attributes:h.attributes,indices:h.indices,primitiveType:h.primitiveType,boundingSphere:f,offsetAttribute:e._offsetAttribute})};RectangleGeometry.createShadowVolume=function(e,t,n){const i=e._granularity,r=e._ellipsoid,o=t(i,r),a=n(i,r);return new RectangleGeometry({rectangle:e._rectangle,rotation:e._rotation,ellipsoid:r,stRotation:e._stRotation,granularity:i,extrudedHeight:a,height:o,vertexFormat:VertexFormat.POSITION_ONLY,shadowVolume:!0})};const unrotatedTextureRectangleScratch=new Rectangle,points2DScratch=[new Cartesian2,new Cartesian2,new Cartesian2],rotation2DScratch=new Matrix2,rectangleCenterScratch$1=new Cartographic;function textureCoordinateRotationPoints(e){if(e._stRotation===0)return[0,0,0,1,1,0];const t=Rectangle.clone(e._rectangle,unrotatedTextureRectangleScratch),n=e._granularity,i=e._ellipsoid,r=e._rotation-e._stRotation,o=computeRectangle(t,n,r,i,unrotatedTextureRectangleScratch),a=points2DScratch;a[0].x=o.west,a[0].y=o.south,a[1].x=o.west,a[1].y=o.north,a[2].x=o.east,a[2].y=o.south;const s=e.rectangle,l=Matrix2.fromRotation(e._stRotation,rotation2DScratch),c=Rectangle.center(s,rectangleCenterScratch$1);for(let u=0;u<3;++u){const m=a[u];m.x-=c.longitude,m.y-=c.latitude,Matrix2.multiplyByVector(l,m,m),m.x+=c.longitude,m.y+=c.latitude,m.x=(m.x-s.west)/s.width,m.y=(m.y-s.south)/s.height}const d=a[0],h=a[1],f=a[2],p=new Array(6);return Cartesian2.pack(d,p),Cartesian2.pack(h,p,2),Cartesian2.pack(f,p,4),p}Object.defineProperties(RectangleGeometry.prototype,{rectangle:{get:function(){return defined(this._rotatedRectangle)||(this._rotatedRectangle=computeRectangle(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=textureCoordinateRotationPoints(this)),this._textureCoordinateRotationPoints}}});const scratchColor$8=new Color,defaultOffset$3=Cartesian3.ZERO,offsetScratch$3=new Cartesian3,scratchRectangle$2=new Rectangle,scratchCenterRect=new Rectangle,scratchCarto=new Cartographic;function RectangleGeometryOptions(e){this.id=e,this.vertexFormat=void 0,this.rectangle=void 0,this.height=void 0,this.extrudedHeight=void 0,this.granularity=void 0,this.stRotation=void 0,this.rotation=void 0,this.offsetAttribute=void 0}function RectangleGeometryUpdater(e,t){GroundGeometryUpdater.call(this,{entity:e,scene:t,geometryOptions:new RectangleGeometryOptions(e),geometryPropertyName:"rectangle",observedPropertyNames:["availability","rectangle"]}),this._onEntityPropertyChanged(e,"rectangle",e.rectangle,void 0)}defined(Object.create)&&(RectangleGeometryUpdater.prototype=Object.create(GroundGeometryUpdater.prototype),RectangleGeometryUpdater.prototype.constructor=RectangleGeometryUpdater);RectangleGeometryUpdater.prototype.createFillGeometryInstance=function(e){if(Check.defined("time",e),!this._fillEnabled)throw new DeveloperError("This instance does not represent a filled geometry.");const t=this._entity,n=t.isAvailable(e),i={show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._fillProperty.getValue(e)),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(this._distanceDisplayConditionProperty.getValue(e)),offset:void 0,color:void 0};if(this._materialProperty instanceof ColorMaterialProperty){let r;defined(this._materialProperty.color)&&(this._materialProperty.color.isConstant||n)&&(r=this._materialProperty.color.getValue(e,scratchColor$8)),defined(r)||(r=Color.WHITE),i.color=ColorGeometryInstanceAttribute.fromColor(r)}return defined(this._options.offsetAttribute)&&(i.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$3,offsetScratch$3))),new GeometryInstance({id:t,geometry:new RectangleGeometry(this._options),attributes:i})};RectangleGeometryUpdater.prototype.createOutlineGeometryInstance=function(e){if(Check.defined("time",e),!this._outlineEnabled)throw new DeveloperError("This instance does not represent an outlined geometry.");const t=this._entity,n=t.isAvailable(e),i=Property.getValueOrDefault(this._outlineColorProperty,e,Color.BLACK,scratchColor$8),r=this._distanceDisplayConditionProperty.getValue(e),o={show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._showOutlineProperty.getValue(e)),color:ColorGeometryInstanceAttribute.fromColor(i),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(r),offset:void 0};return defined(this._options.offsetAttribute)&&(o.offset=OffsetGeometryInstanceAttribute.fromCartesian3(Property.getValueOrDefault(this._terrainOffsetProperty,e,defaultOffset$3,offsetScratch$3))),new GeometryInstance({id:t,geometry:new RectangleOutlineGeometry(this._options),attributes:o})};RectangleGeometryUpdater.prototype._computeCenter=function(e,t){const n=Property.getValueOrUndefined(this._entity.rectangle.coordinates,e,scratchCenterRect);if(!defined(n))return;const i=Rectangle.center(n,scratchCarto);return Cartographic.toCartesian(i,Ellipsoid.default,t)};RectangleGeometryUpdater.prototype._isHidden=function(e,t){return!defined(t.coordinates)||GeometryUpdater.prototype._isHidden.call(this,e,t)};RectangleGeometryUpdater.prototype._isDynamic=function(e,t){return!t.coordinates.isConstant||!Property.isConstant(t.height)||!Property.isConstant(t.extrudedHeight)||!Property.isConstant(t.granularity)||!Property.isConstant(t.stRotation)||!Property.isConstant(t.rotation)||!Property.isConstant(t.outlineWidth)||!Property.isConstant(t.zIndex)||this._onTerrain&&!Property.isConstant(this._materialProperty)&&!(this._materialProperty instanceof ColorMaterialProperty)};RectangleGeometryUpdater.prototype._setStaticOptions=function(e,t){const n=this._materialProperty instanceof ColorMaterialProperty;let i=Property.getValueOrUndefined(t.height,Iso8601.MINIMUM_VALUE);const r=Property.getValueOrDefault(t.heightReference,Iso8601.MINIMUM_VALUE,HeightReference.NONE);let o=Property.getValueOrUndefined(t.extrudedHeight,Iso8601.MINIMUM_VALUE);const a=Property.getValueOrDefault(t.extrudedHeightReference,Iso8601.MINIMUM_VALUE,HeightReference.NONE);defined(o)&&!defined(i)&&(i=0);const s=this._options;s.vertexFormat=n?PerInstanceColorAppearance.VERTEX_FORMAT:MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat,s.rectangle=t.coordinates.getValue(Iso8601.MINIMUM_VALUE,s.rectangle),s.granularity=Property.getValueOrUndefined(t.granularity,Iso8601.MINIMUM_VALUE),s.stRotation=Property.getValueOrUndefined(t.stRotation,Iso8601.MINIMUM_VALUE),s.rotation=Property.getValueOrUndefined(t.rotation,Iso8601.MINIMUM_VALUE),s.offsetAttribute=GroundGeometryUpdater.computeGeometryOffsetAttribute(i,r,o,a),s.height=GroundGeometryUpdater.getGeometryHeight(i,r),o=GroundGeometryUpdater.getGeometryExtrudedHeight(o,a),o===GroundGeometryUpdater.CLAMP_TO_GROUND&&(o=ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(s,scratchRectangle$2)).minimumTerrainHeight),s.extrudedHeight=o};RectangleGeometryUpdater.DynamicGeometryUpdater=DynamicRectangleGeometryUpdater;function DynamicRectangleGeometryUpdater(e,t,n){DynamicGeometryUpdater$1.call(this,e,t,n)}defined(Object.create)&&(DynamicRectangleGeometryUpdater.prototype=Object.create(DynamicGeometryUpdater$1.prototype),DynamicRectangleGeometryUpdater.prototype.constructor=DynamicRectangleGeometryUpdater);DynamicRectangleGeometryUpdater.prototype._isHidden=function(e,t,n){return!defined(this._options.rectangle)||DynamicGeometryUpdater$1.prototype._isHidden.call(this,e,t,n)};DynamicRectangleGeometryUpdater.prototype._setOptions=function(e,t,n){const i=this._options;let r=Property.getValueOrUndefined(t.height,n);const o=Property.getValueOrDefault(t.heightReference,n,HeightReference.NONE);let a=Property.getValueOrUndefined(t.extrudedHeight,n);const s=Property.getValueOrDefault(t.extrudedHeightReference,n,HeightReference.NONE);defined(a)&&!defined(r)&&(r=0),i.rectangle=Property.getValueOrUndefined(t.coordinates,n,i.rectangle),i.granularity=Property.getValueOrUndefined(t.granularity,n),i.stRotation=Property.getValueOrUndefined(t.stRotation,n),i.rotation=Property.getValueOrUndefined(t.rotation,n),i.offsetAttribute=GroundGeometryUpdater.computeGeometryOffsetAttribute(r,o,a,s),i.height=GroundGeometryUpdater.getGeometryHeight(r,o),a=GroundGeometryUpdater.getGeometryExtrudedHeight(a,s),a===GroundGeometryUpdater.CLAMP_TO_GROUND&&(a=ApproximateTerrainHeights.getMinimumMaximumHeights(RectangleGeometry.computeRectangle(i,scratchRectangle$2)).minimumTerrainHeight),i.extrudedHeight=a};const WallGeometryLibrary={};function latLonEquals(e,t){return CesiumMath.equalsEpsilon(e.latitude,t.latitude,CesiumMath.EPSILON10)&&CesiumMath.equalsEpsilon(e.longitude,t.longitude,CesiumMath.EPSILON10)}const scratchCartographic1=new Cartographic,scratchCartographic2=new Cartographic;function removeDuplicates$1(e,t,n,i){t=arrayRemoveDuplicates(t,Cartesian3.equalsEpsilon);const r=t.length;if(r<2)return;const o=defined(i),a=defined(n),s=new Array(r),l=new Array(r),c=new Array(r),d=t[0];s[0]=d;const h=e.cartesianToCartographic(d,scratchCartographic1);a&&(h.height=n[0]),l[0]=h.height,o?c[0]=i[0]:c[0]=0;const f=l[0],p=c[0];let u=f===p,m=1;for(let g=1;g<r;++g){const _=t[g],C=e.cartesianToCartographic(_,scratchCartographic2);a&&(C.height=n[g]),u=u&&C.height===0,latLonEquals(h,C)?h.height<C.height&&(l[m-1]=C.height):(s[m]=_,l[m]=C.height,o?c[m]=i[g]:c[m]=0,u=u&&l[m]===c[m],Cartographic.clone(C,h),++m)}if(!(u||m<2))return s.length=m,l.length=m,c.length=m,{positions:s,topHeights:l,bottomHeights:c}}const positionsArrayScratch=new Array(2),heightsArrayScratch=new Array(2),generateArcOptionsScratch$1={positions:void 0,height:void 0,granularity:void 0,ellipsoid:void 0};WallGeometryLibrary.computePositions=function(e,t,n,i,r,o){const a=removeDuplicates$1(e,t,n,i);if(!defined(a))return;t=a.positions,n=a.topHeights,i=a.bottomHeights;const s=t.length,l=s-2;let c,d;const h=CesiumMath.chordLength(r,e.maximumRadius),f=generateArcOptionsScratch$1;if(f.minDistance=h,f.ellipsoid=e,o){let p=0,u;for(u=0;u<s-1;u++)p+=PolylinePipeline.numberOfPoints(t[u],t[u+1],h)+1;c=new Float64Array(p*3),d=new Float64Array(p*3);const m=positionsArrayScratch,g=heightsArrayScratch;f.positions=m,f.height=g;let _=0;for(u=0;u<s-1;u++){m[0]=t[u],m[1]=t[u+1],g[0]=n[u],g[1]=n[u+1];const C=PolylinePipeline.generateArc(f);c.set(C,_),g[0]=i[u],g[1]=i[u+1],d.set(PolylinePipeline.generateArc(f),_),_+=C.length}}else f.positions=t,f.height=n,c=new Float64Array(PolylinePipeline.generateArc(f)),f.height=i,d=new Float64Array(PolylinePipeline.generateArc(f));return{bottomPositions:d,topPositions:c,numCorners:l}};const WallGeometryLibrary$1=WallGeometryLibrary,scratchCartesian3Position1$1=new Cartesian3,scratchCartesian3Position2$1=new Cartesian3,scratchCartesian3Position4=new Cartesian3,scratchCartesian3Position5=new Cartesian3,scratchBitangent=new Cartesian3,scratchTangent=new Cartesian3,scratchNormal$2=new Cartesian3;function WallGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.positions,n=e.maximumHeights,i=e.minimumHeights;if(!defined(t))throw new DeveloperError("options.positions is required.");if(defined(n)&&n.length!==t.length)throw new DeveloperError("options.positions and options.maximumHeights must have the same length.");if(defined(i)&&i.length!==t.length)throw new DeveloperError("options.positions and options.minimumHeights must have the same length.");const r=defaultValue(e.vertexFormat,VertexFormat.DEFAULT),o=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),a=defaultValue(e.ellipsoid,Ellipsoid.default);this._positions=t,this._minimumHeights=i,this._maximumHeights=n,this._vertexFormat=VertexFormat.clone(r),this._granularity=o,this._ellipsoid=Ellipsoid.clone(a),this._workerName="createWallGeometry";let s=1+t.length*Cartesian3.packedLength+2;defined(i)&&(s+=i.length),defined(n)&&(s+=n.length),this.packedLength=s+Ellipsoid.packedLength+VertexFormat.packedLength+1}WallGeometry.pack=function(e,t,n){if(!defined(e))throw new DeveloperError("value is required");if(!defined(t))throw new DeveloperError("array is required");n=defaultValue(n,0);let i;const r=e._positions;let o=r.length;for(t[n++]=o,i=0;i<o;++i,n+=Cartesian3.packedLength)Cartesian3.pack(r[i],t,n);const a=e._minimumHeights;if(o=defined(a)?a.length:0,t[n++]=o,defined(a))for(i=0;i<o;++i)t[n++]=a[i];const s=e._maximumHeights;if(o=defined(s)?s.length:0,t[n++]=o,defined(s))for(i=0;i<o;++i)t[n++]=s[i];return Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,VertexFormat.pack(e._vertexFormat,t,n),n+=VertexFormat.packedLength,t[n]=e._granularity,t};const scratchEllipsoid$3=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchVertexFormat$2=new VertexFormat,scratchOptions$5={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:scratchEllipsoid$3,vertexFormat:scratchVertexFormat$2,granularity:void 0};WallGeometry.unpack=function(e,t,n){if(!defined(e))throw new DeveloperError("array is required");t=defaultValue(t,0);let i,r=e[t++];const o=new Array(r);for(i=0;i<r;++i,t+=Cartesian3.packedLength)o[i]=Cartesian3.unpack(e,t);r=e[t++];let a;if(r>0)for(a=new Array(r),i=0;i<r;++i)a[i]=e[t++];r=e[t++];let s;if(r>0)for(s=new Array(r),i=0;i<r;++i)s[i]=e[t++];const l=Ellipsoid.unpack(e,t,scratchEllipsoid$3);t+=Ellipsoid.packedLength;const c=VertexFormat.unpack(e,t,scratchVertexFormat$2);t+=VertexFormat.packedLength;const d=e[t];return defined(n)?(n._positions=o,n._minimumHeights=a,n._maximumHeights=s,n._ellipsoid=Ellipsoid.clone(l,n._ellipsoid),n._vertexFormat=VertexFormat.clone(c,n._vertexFormat),n._granularity=d,n):(scratchOptions$5.positions=o,scratchOptions$5.minimumHeights=a,scratchOptions$5.maximumHeights=s,scratchOptions$5.granularity=d,new WallGeometry(scratchOptions$5))};WallGeometry.fromConstantHeights=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.positions;if(!defined(t))throw new DeveloperError("options.positions is required.");let n,i;const r=e.minimumHeight,o=e.maximumHeight,a=defined(r),s=defined(o);if(a||s){const c=t.length;n=a?new Array(c):void 0,i=s?new Array(c):void 0;for(let d=0;d<c;++d)a&&(n[d]=r),s&&(i[d]=o)}const l={positions:t,maximumHeights:i,minimumHeights:n,ellipsoid:e.ellipsoid,vertexFormat:e.vertexFormat};return new WallGeometry(l)};WallGeometry.createGeometry=function(e){const t=e._positions,n=e._minimumHeights,i=e._maximumHeights,r=e._vertexFormat,o=e._granularity,a=e._ellipsoid,s=WallGeometryLibrary$1.computePositions(a,t,i,n,o,!0);if(!defined(s))return;const l=s.bottomPositions,c=s.topPositions,d=s.numCorners;let h=c.length,f=h*2;const p=r.position?new Float64Array(f):void 0,u=r.normal?new Float32Array(f):void 0,m=r.tangent?new Float32Array(f):void 0,g=r.bitangent?new Float32Array(f):void 0,_=r.st?new Float32Array(f/3*2):void 0;let C=0,A=0,S=0,v=0,b=0,D=scratchNormal$2,I=scratchTangent,L=scratchBitangent,N=!0;h/=3;let y,x=0;const T=1/(h-d-1);for(y=0;y<h;++y){const V=y*3,R=Cartesian3.fromArray(c,V,scratchCartesian3Position1$1),w=Cartesian3.fromArray(l,V,scratchCartesian3Position2$1);if(r.position&&(p[C++]=w.x,p[C++]=w.y,p[C++]=w.z,p[C++]=R.x,p[C++]=R.y,p[C++]=R.z),r.st&&(_[b++]=x,_[b++]=0,_[b++]=x,_[b++]=1),r.normal||r.tangent||r.bitangent){let U=Cartesian3.clone(Cartesian3.ZERO,scratchCartesian3Position5);const k=Cartesian3.subtract(R,a.geodeticSurfaceNormal(R,scratchCartesian3Position2$1),scratchCartesian3Position2$1);if(y+1<h&&(U=Cartesian3.fromArray(c,V+3,scratchCartesian3Position5)),N){const H=Cartesian3.subtract(U,R,scratchCartesian3Position4),F=Cartesian3.subtract(k,R,scratchCartesian3Position1$1);D=Cartesian3.normalize(Cartesian3.cross(F,H,D),D),N=!1}Cartesian3.equalsEpsilon(R,U,CesiumMath.EPSILON10)?N=!0:(x+=T,r.tangent&&(I=Cartesian3.normalize(Cartesian3.subtract(U,R,I),I)),r.bitangent&&(L=Cartesian3.normalize(Cartesian3.cross(D,I,L),L))),r.normal&&(u[A++]=D.x,u[A++]=D.y,u[A++]=D.z,u[A++]=D.x,u[A++]=D.y,u[A++]=D.z),r.tangent&&(m[v++]=I.x,m[v++]=I.y,m[v++]=I.z,m[v++]=I.x,m[v++]=I.y,m[v++]=I.z),r.bitangent&&(g[S++]=L.x,g[S++]=L.y,g[S++]=L.z,g[S++]=L.x,g[S++]=L.y,g[S++]=L.z)}}const E=new GeometryAttributes;r.position&&(E.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:p})),r.normal&&(E.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:u})),r.tangent&&(E.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:m})),r.bitangent&&(E.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:g})),r.st&&(E.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:_}));const P=f/3;f-=6*(d+1);const M=IndexDatatype.createTypedArray(P,f);let O=0;for(y=0;y<P-2;y+=2){const V=y,R=y+2,w=Cartesian3.fromArray(p,V*3,scratchCartesian3Position1$1),U=Cartesian3.fromArray(p,R*3,scratchCartesian3Position2$1);if(Cartesian3.equalsEpsilon(w,U,CesiumMath.EPSILON10))continue;const k=y+1,H=y+3;M[O++]=k,M[O++]=V,M[O++]=H,M[O++]=H,M[O++]=V,M[O++]=R}return new Geometry({attributes:E,indices:M,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:new BoundingSphere.fromVertices(p)})};const scratchCartesian3Position1=new Cartesian3,scratchCartesian3Position2=new Cartesian3;function WallOutlineGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.positions,n=e.maximumHeights,i=e.minimumHeights;if(!defined(t))throw new DeveloperError("options.positions is required.");if(defined(n)&&n.length!==t.length)throw new DeveloperError("options.positions and options.maximumHeights must have the same length.");if(defined(i)&&i.length!==t.length)throw new DeveloperError("options.positions and options.minimumHeights must have the same length.");const r=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),o=defaultValue(e.ellipsoid,Ellipsoid.default);this._positions=t,this._minimumHeights=i,this._maximumHeights=n,this._granularity=r,this._ellipsoid=Ellipsoid.clone(o),this._workerName="createWallOutlineGeometry";let a=1+t.length*Cartesian3.packedLength+2;defined(i)&&(a+=i.length),defined(n)&&(a+=n.length),this.packedLength=a+Ellipsoid.packedLength+1}WallOutlineGeometry.pack=function(e,t,n){if(!defined(e))throw new DeveloperError("value is required");if(!defined(t))throw new DeveloperError("array is required");n=defaultValue(n,0);let i;const r=e._positions;let o=r.length;for(t[n++]=o,i=0;i<o;++i,n+=Cartesian3.packedLength)Cartesian3.pack(r[i],t,n);const a=e._minimumHeights;if(o=defined(a)?a.length:0,t[n++]=o,defined(a))for(i=0;i<o;++i)t[n++]=a[i];const s=e._maximumHeights;if(o=defined(s)?s.length:0,t[n++]=o,defined(s))for(i=0;i<o;++i)t[n++]=s[i];return Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,t[n]=e._granularity,t};const scratchEllipsoid$2=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchOptions$4={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:scratchEllipsoid$2,granularity:void 0};WallOutlineGeometry.unpack=function(e,t,n){if(!defined(e))throw new DeveloperError("array is required");t=defaultValue(t,0);let i,r=e[t++];const o=new Array(r);for(i=0;i<r;++i,t+=Cartesian3.packedLength)o[i]=Cartesian3.unpack(e,t);r=e[t++];let a;if(r>0)for(a=new Array(r),i=0;i<r;++i)a[i]=e[t++];r=e[t++];let s;if(r>0)for(s=new Array(r),i=0;i<r;++i)s[i]=e[t++];const l=Ellipsoid.unpack(e,t,scratchEllipsoid$2);t+=Ellipsoid.packedLength;const c=e[t];return defined(n)?(n._positions=o,n._minimumHeights=a,n._maximumHeights=s,n._ellipsoid=Ellipsoid.clone(l,n._ellipsoid),n._granularity=c,n):(scratchOptions$4.positions=o,scratchOptions$4.minimumHeights=a,scratchOptions$4.maximumHeights=s,scratchOptions$4.granularity=c,new WallOutlineGeometry(scratchOptions$4))};WallOutlineGeometry.fromConstantHeights=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.positions;if(!defined(t))throw new DeveloperError("options.positions is required.");let n,i;const r=e.minimumHeight,o=e.maximumHeight,a=defined(r),s=defined(o);if(a||s){const c=t.length;n=a?new Array(c):void 0,i=s?new Array(c):void 0;for(let d=0;d<c;++d)a&&(n[d]=r),s&&(i[d]=o)}const l={positions:t,maximumHeights:i,minimumHeights:n,ellipsoid:e.ellipsoid};return new WallOutlineGeometry(l)};WallOutlineGeometry.createGeometry=function(e){const t=e._positions,n=e._minimumHeights,i=e._maximumHeights,r=e._granularity,o=e._ellipsoid,a=WallGeometryLibrary$1.computePositions(o,t,i,n,r,!1);if(!defined(a))return;const s=a.bottomPositions,l=a.topPositions;let c=l.length,d=c*2;const h=new Float64Array(d);let f=0;c/=3;let p;for(p=0;p<c;++p){const C=p*3,A=Cartesian3.fromArray(l,C,scratchCartesian3Position1),S=Cartesian3.fromArray(s,C,scratchCartesian3Position2);h[f++]=S.x,h[f++]=S.y,h[f++]=S.z,h[f++]=A.x,h[f++]=A.y,h[f++]=A.z}const u=new GeometryAttributes({position:new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:h})}),m=d/3;d=2*m-4+m;const g=IndexDatatype.createTypedArray(m,d);let _=0;for(p=0;p<m-2;p+=2){const C=p,A=p+2,S=Cartesian3.fromArray(h,C*3,scratchCartesian3Position1),v=Cartesian3.fromArray(h,A*3,scratchCartesian3Position2);if(Cartesian3.equalsEpsilon(S,v,CesiumMath.EPSILON10))continue;const b=p+1,D=p+3;g[_++]=b,g[_++]=C,g[_++]=b,g[_++]=D,g[_++]=C,g[_++]=A}return g[_++]=m-2,g[_++]=m-1,new Geometry({attributes:u,indices:g,primitiveType:PrimitiveType.LINES,boundingSphere:new BoundingSphere.fromVertices(h)})};const scratchColor$7=new Color;function WallGeometryOptions(e){this.id=e,this.vertexFormat=void 0,this.positions=void 0,this.minimumHeights=void 0,this.maximumHeights=void 0,this.granularity=void 0}function WallGeometryUpdater(e,t){GeometryUpdater.call(this,{entity:e,scene:t,geometryOptions:new WallGeometryOptions(e),geometryPropertyName:"wall",observedPropertyNames:["availability","wall"]}),this._onEntityPropertyChanged(e,"wall",e.wall,void 0)}defined(Object.create)&&(WallGeometryUpdater.prototype=Object.create(GeometryUpdater.prototype),WallGeometryUpdater.prototype.constructor=WallGeometryUpdater);WallGeometryUpdater.prototype.createFillGeometryInstance=function(e){if(Check.defined("time",e),!this._fillEnabled)throw new DeveloperError("This instance does not represent a filled geometry.");const t=this._entity,n=t.isAvailable(e);let i,r;const o=new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._fillProperty.getValue(e)),a=this._distanceDisplayConditionProperty.getValue(e),s=DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(a);if(this._materialProperty instanceof ColorMaterialProperty){let l;defined(this._materialProperty.color)&&(this._materialProperty.color.isConstant||n)&&(l=this._materialProperty.color.getValue(e,scratchColor$7)),defined(l)||(l=Color.WHITE),r=ColorGeometryInstanceAttribute.fromColor(l),i={show:o,distanceDisplayCondition:s,color:r}}else i={show:o,distanceDisplayCondition:s};return new GeometryInstance({id:t,geometry:new WallGeometry(this._options),attributes:i})};WallGeometryUpdater.prototype.createOutlineGeometryInstance=function(e){if(Check.defined("time",e),!this._outlineEnabled)throw new DeveloperError("This instance does not represent an outlined geometry.");const t=this._entity,n=t.isAvailable(e),i=Property.getValueOrDefault(this._outlineColorProperty,e,Color.BLACK,scratchColor$7),r=this._distanceDisplayConditionProperty.getValue(e);return new GeometryInstance({id:t,geometry:new WallOutlineGeometry(this._options),attributes:{show:new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)&&this._showOutlineProperty.getValue(e)),color:ColorGeometryInstanceAttribute.fromColor(i),distanceDisplayCondition:DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(r)}})};WallGeometryUpdater.prototype._isHidden=function(e,t){return!defined(t.positions)||GeometryUpdater.prototype._isHidden.call(this,e,t)};WallGeometryUpdater.prototype._getIsClosed=function(e){return!1};WallGeometryUpdater.prototype._isDynamic=function(e,t){return!t.positions.isConstant||!Property.isConstant(t.minimumHeights)||!Property.isConstant(t.maximumHeights)||!Property.isConstant(t.outlineWidth)||!Property.isConstant(t.granularity)};WallGeometryUpdater.prototype._setStaticOptions=function(e,t){const n=t.minimumHeights,i=t.maximumHeights,r=t.granularity,o=this._materialProperty instanceof ColorMaterialProperty,a=this._options;a.vertexFormat=o?PerInstanceColorAppearance.VERTEX_FORMAT:MaterialAppearance.MaterialSupport.TEXTURED.vertexFormat,a.positions=t.positions.getValue(Iso8601.MINIMUM_VALUE,a.positions),a.minimumHeights=defined(n)?n.getValue(Iso8601.MINIMUM_VALUE,a.minimumHeights):void 0,a.maximumHeights=defined(i)?i.getValue(Iso8601.MINIMUM_VALUE,a.maximumHeights):void 0,a.granularity=defined(r)?r.getValue(Iso8601.MINIMUM_VALUE):void 0};WallGeometryUpdater.DynamicGeometryUpdater=DynamicWallGeometryUpdater;function DynamicWallGeometryUpdater(e,t,n){DynamicGeometryUpdater$1.call(this,e,t,n)}defined(Object.create)&&(DynamicWallGeometryUpdater.prototype=Object.create(DynamicGeometryUpdater$1.prototype),DynamicWallGeometryUpdater.prototype.constructor=DynamicWallGeometryUpdater);DynamicWallGeometryUpdater.prototype._isHidden=function(e,t,n){return!defined(this._options.positions)||DynamicGeometryUpdater$1.prototype._isHidden.call(this,e,t,n)};DynamicWallGeometryUpdater.prototype._setOptions=function(e,t,n){const i=this._options;i.positions=Property.getValueOrUndefined(t.positions,n,i.positions),i.minimumHeights=Property.getValueOrUndefined(t.minimumHeights,n,i.minimumHeights),i.maximumHeights=Property.getValueOrUndefined(t.maximumHeights,n,i.maximumHeights),i.granularity=Property.getValueOrUndefined(t.granularity,n)};const geometryUpdaters=[BoxGeometryUpdater,CylinderGeometryUpdater,CorridorGeometryUpdater,EllipseGeometryUpdater,EllipsoidGeometryUpdater,PlaneGeometryUpdater,PolygonGeometryUpdater,PolylineVolumeGeometryUpdater,RectangleGeometryUpdater,WallGeometryUpdater];function GeometryUpdaterSet(e,t){this.entity=e,this.scene=t;const n=new Array(geometryUpdaters.length),i=new Event,r=new EventHelper;for(let o=0;o<n.length;o++){const a=new geometryUpdaters[o](e,t);r.add(a.geometryChanged,s=>{i.raiseEvent(s)}),n[o]=a}this.updaters=n,this.geometryChanged=i,this.eventHelper=r,this._removeEntitySubscription=e.definitionChanged.addEventListener(GeometryUpdaterSet.prototype._onEntityPropertyChanged,this)}GeometryUpdaterSet.prototype._onEntityPropertyChanged=function(e,t,n,i){const r=this.updaters;for(let o=0;o<r.length;o++)r[o]._onEntityPropertyChanged(e,t,n,i)};GeometryUpdaterSet.prototype.forEach=function(e){const t=this.updaters;for(let n=0;n<t.length;n++)e(t[n])};GeometryUpdaterSet.prototype.destroy=function(){this.eventHelper.removeAll();const e=this.updaters;for(let t=0;t<e.length;t++)e[t].destroy();this._removeEntitySubscription(),destroyObject(this)};GeometryUpdaterSet.registerUpdater=function(e){geometryUpdaters.includes(e)||geometryUpdaters.push(e)};GeometryUpdaterSet.unregisterUpdater=function(e){if(geometryUpdaters.includes(e)){const t=geometryUpdaters.indexOf(e);geometryUpdaters.splice(t,1)}};const colorScratch$6=new Color,distanceDisplayConditionScratch$7=new DistanceDisplayCondition,defaultDistanceDisplayCondition$6=new DistanceDisplayCondition,defaultOffset$2=Cartesian3.ZERO,offsetScratch$2=new Cartesian3;function Batch$5(e,t,n,i,r,o,a){this.translucent=t,this.appearanceType=n,this.depthFailAppearanceType=i,this.depthFailMaterialProperty=r,this.depthFailMaterial=void 0,this.closed=o,this.shadows=a,this.primitives=e,this.createPrimitive=!1,this.waitingOnCreate=!1,this.primitive=void 0,this.oldPrimitive=void 0,this.geometry=new AssociativeArray,this.updaters=new AssociativeArray,this.updatersWithAttributes=new AssociativeArray,this.attributes=new AssociativeArray,this.subscriptions=new AssociativeArray,this.showsUpdated=new AssociativeArray,this.itemsToRemove=[],this.invalidated=!1;let s;defined(r)&&(s=r.definitionChanged.addEventListener(Batch$5.prototype.onMaterialChanged,this)),this.removeMaterialSubscription=s}Batch$5.prototype.onMaterialChanged=function(){this.invalidated=!0};Batch$5.prototype.isMaterial=function(e){const t=this.depthFailMaterialProperty,n=e.depthFailMaterialProperty;return n===t?!0:defined(t)?t.equals(n):!1};Batch$5.prototype.add=function(e,t){const n=e.id;if(this.createPrimitive=!0,this.geometry.set(n,t),this.updaters.set(n,e),!e.hasConstantFill||!e.fillMaterialProperty.isConstant||!Property.isConstant(e.distanceDisplayConditionProperty)||!Property.isConstant(e.terrainOffsetProperty))this.updatersWithAttributes.set(n,e);else{const i=this;this.subscriptions.set(n,e.entity.definitionChanged.addEventListener(function(r,o,a,s){o==="isShowing"&&i.showsUpdated.set(e.id,e)}))}};Batch$5.prototype.remove=function(e){const t=e.id;if(this.createPrimitive=this.geometry.remove(t)||this.createPrimitive,this.updaters.remove(t)){this.updatersWithAttributes.remove(t);const n=this.subscriptions.get(t);return defined(n)&&(n(),this.subscriptions.remove(t),this.showsUpdated.remove(t)),!0}return!1};Batch$5.prototype.update=function(e){let t=!0,n=0,i=this.primitive;const r=this.primitives;let o;if(this.createPrimitive){const a=this.geometry.values;if(a.length>0){defined(i)&&(defined(this.oldPrimitive)?r.remove(i):this.oldPrimitive=i);let l;defined(this.depthFailAppearanceType)&&(defined(this.depthFailMaterialProperty)&&(this.depthFailMaterial=MaterialProperty.getValue(e,this.depthFailMaterialProperty,this.depthFailMaterial)),l=new this.depthFailAppearanceType({material:this.depthFailMaterial,translucent:this.translucent,closed:this.closed})),i=new Primitive({show:!1,asynchronous:!0,geometryInstances:a.slice(),appearance:new this.appearanceType({translucent:this.translucent,closed:this.closed}),depthFailAppearance:l,shadows:this.shadows}),r.add(i),t=!1}else{defined(i)&&(r.remove(i),i=void 0);const l=this.oldPrimitive;defined(l)&&(r.remove(l),this.oldPrimitive=void 0)}this.attributes.removeAll(),this.primitive=i,this.createPrimitive=!1,this.waitingOnCreate=!0}else if(defined(i)&&i.ready){i.show=!0,defined(this.oldPrimitive)&&(r.remove(this.oldPrimitive),this.oldPrimitive=void 0),defined(this.depthFailAppearanceType)&&!(this.depthFailMaterialProperty instanceof ColorMaterialProperty)&&(this.depthFailMaterial=MaterialProperty.getValue(e,this.depthFailMaterialProperty,this.depthFailMaterial),this.primitive.depthFailAppearance.material=this.depthFailMaterial);const a=this.updatersWithAttributes.values,s=a.length,l=this.waitingOnCreate;for(o=0;o<s;o++){const c=a[o],d=this.geometry.get(c.id);let h=this.attributes.get(d.id.id);if(defined(h)||(h=i.getGeometryInstanceAttributes(d.id),this.attributes.set(d.id.id,h)),!c.fillMaterialProperty.isConstant||l){const g=c.fillMaterialProperty.color,_=Property.getValueOrDefault(g,e,Color.WHITE,colorScratch$6);Color.equals(h._lastColor,_)||(h._lastColor=Color.clone(_,h._lastColor),h.color=ColorGeometryInstanceAttribute.toValue(_,h.color),(this.translucent&&h.color[3]===255||!this.translucent&&h.color[3]!==255)&&(this.itemsToRemove[n++]=c))}if(defined(this.depthFailAppearanceType)&&c.depthFailMaterialProperty instanceof ColorMaterialProperty&&(!c.depthFailMaterialProperty.isConstant||l)){const g=c.depthFailMaterialProperty.color,_=Property.getValueOrDefault(g,e,Color.WHITE,colorScratch$6);Color.equals(h._lastDepthFailColor,_)||(h._lastDepthFailColor=Color.clone(_,h._lastDepthFailColor),h.depthFailColor=ColorGeometryInstanceAttribute.toValue(_,h.depthFailColor))}const f=c.entity.isShowing&&(c.hasConstantFill||c.isFilled(e)),p=h.show[0]===1;f!==p&&(h.show=ShowGeometryInstanceAttribute.toValue(f,h.show));const u=c.distanceDisplayConditionProperty;if(!Property.isConstant(u)){const g=Property.getValueOrDefault(u,e,defaultDistanceDisplayCondition$6,distanceDisplayConditionScratch$7);DistanceDisplayCondition.equals(g,h._lastDistanceDisplayCondition)||(h._lastDistanceDisplayCondition=DistanceDisplayCondition.clone(g,h._lastDistanceDisplayCondition),h.distanceDisplayCondition=DistanceDisplayConditionGeometryInstanceAttribute.toValue(g,h.distanceDisplayCondition))}const m=c.terrainOffsetProperty;if(!Property.isConstant(m)){const g=Property.getValueOrDefault(m,e,defaultOffset$2,offsetScratch$2);Cartesian3.equals(g,h._lastOffset)||(h._lastOffset=Cartesian3.clone(g,h._lastOffset),h.offset=OffsetGeometryInstanceAttribute.toValue(g,h.offset))}}this.updateShows(i),this.waitingOnCreate=!1}else defined(i)&&!i.ready&&(t=!1);return this.itemsToRemove.length=n,t};Batch$5.prototype.updateShows=function(e){const t=this.showsUpdated.values,n=t.length;for(let i=0;i<n;i++){const r=t[i],o=this.geometry.get(r.id);let a=this.attributes.get(o.id.id);defined(a)||(a=e.getGeometryInstanceAttributes(o.id),this.attributes.set(o.id.id,a));const s=r.entity.isShowing,l=a.show[0]===1;s!==l&&(a.show=ShowGeometryInstanceAttribute.toValue(s,a.show),o.attributes.show.value[0]=a.show[0])}this.showsUpdated.removeAll()};Batch$5.prototype.contains=function(e){return this.updaters.contains(e.id)};Batch$5.prototype.getBoundingSphere=function(e,t){const n=this.primitive;if(!n.ready)return BoundingSphereState$1.PENDING;const i=n.getGeometryInstanceAttributes(e.entity);return!defined(i)||!defined(i.boundingSphere)||defined(i.show)&&i.show[0]===0?BoundingSphereState$1.FAILED:(i.boundingSphere.clone(t),BoundingSphereState$1.DONE)};Batch$5.prototype.destroy=function(){const e=this.primitive,t=this.primitives;defined(e)&&t.remove(e);const n=this.oldPrimitive;defined(n)&&t.remove(n),defined(this.removeMaterialSubscription)&&this.removeMaterialSubscription()};function StaticGeometryColorBatch(e,t,n,i,r){this._solidItems=[],this._translucentItems=[],this._primitives=e,this._appearanceType=t,this._depthFailAppearanceType=n,this._closed=i,this._shadows=r}StaticGeometryColorBatch.prototype.add=function(e,t){let n,i;const r=t.createFillGeometryInstance(e);r.attributes.color.value[3]===255?(n=this._solidItems,i=!1):(n=this._translucentItems,i=!0);const o=n.length;for(let s=0;s<o;s++){const l=n[s];if(l.isMaterial(t)){l.add(t,r);return}}const a=new Batch$5(this._primitives,i,this._appearanceType,this._depthFailAppearanceType,t.depthFailMaterialProperty,this._closed,this._shadows);a.add(t,r),n.push(a)};function removeItem(e,t){const n=e.length;for(let i=n-1;i>=0;i--){const r=e[i];if(r.remove(t))return r.updaters.length===0&&(e.splice(i,1),r.destroy()),!0}return!1}StaticGeometryColorBatch.prototype.remove=function(e){removeItem(this._solidItems,e)||removeItem(this._translucentItems,e)};function moveItems(e,t,n){let i=!1;const r=t.length;for(let o=0;o<r;++o){const a=t[o],s=a.itemsToRemove,l=s.length;if(l>0)for(o=0;o<l;o++){const c=s[o];a.remove(c),e.add(n,c),i=!0}}return i}function updateItems(e,t,n,i){let r=t.length,o;for(o=r-1;o>=0;o--){const a=t[o];if(a.invalidated){t.splice(o,1);const s=a.updaters.values,l=s.length;for(let c=0;c<l;c++)e.add(n,s[c]);a.destroy()}}for(r=t.length,o=0;o<r;++o)i=t[o].update(n)&&i;return i}StaticGeometryColorBatch.prototype.update=function(e){let t=updateItems(this,this._solidItems,e,!0);t=updateItems(this,this._translucentItems,e,t)&&t;const n=moveItems(this,this._solidItems,e),i=moveItems(this,this._translucentItems,e);return(n||i)&&(t=updateItems(this,this._solidItems,e,t)&&t,t=updateItems(this,this._translucentItems,e,t)&&t),t};function getBoundingSphere(e,t,n){const i=e.length;for(let r=0;r<i;r++){const o=e[r];if(o.contains(t))return o.getBoundingSphere(t,n)}return BoundingSphereState$1.FAILED}StaticGeometryColorBatch.prototype.getBoundingSphere=function(e,t){const n=getBoundingSphere(this._solidItems,e,t);return n===BoundingSphereState$1.FAILED?getBoundingSphere(this._translucentItems,e,t):n};function removeAllPrimitives(e){const t=e.length;for(let n=0;n<t;n++)e[n].destroy();e.length=0}StaticGeometryColorBatch.prototype.removeAllPrimitives=function(){removeAllPrimitives(this._solidItems),removeAllPrimitives(this._translucentItems)};const distanceDisplayConditionScratch$6=new DistanceDisplayCondition,defaultDistanceDisplayCondition$5=new DistanceDisplayCondition,defaultOffset$1=Cartesian3.ZERO,offsetScratch$1=new Cartesian3;function Batch$4(e,t,n,i,r,o,a){this.primitives=e,this.appearanceType=t,this.materialProperty=n,this.depthFailAppearanceType=i,this.depthFailMaterialProperty=r,this.closed=o,this.shadows=a,this.updaters=new AssociativeArray,this.createPrimitive=!0,this.primitive=void 0,this.oldPrimitive=void 0,this.geometry=new AssociativeArray,this.material=void 0,this.depthFailMaterial=void 0,this.updatersWithAttributes=new AssociativeArray,this.attributes=new AssociativeArray,this.invalidated=!1,this.removeMaterialSubscription=n.definitionChanged.addEventListener(Batch$4.prototype.onMaterialChanged,this),this.subscriptions=new AssociativeArray,this.showsUpdated=new AssociativeArray}Batch$4.prototype.onMaterialChanged=function(){this.invalidated=!0};Batch$4.prototype.isMaterial=function(e){const t=this.materialProperty,n=e.fillMaterialProperty,i=this.depthFailMaterialProperty,r=e.depthFailMaterialProperty;if(n===t&&r===i)return!0;let o=defined(t)&&t.equals(n);return o=(!defined(i)&&!defined(r)||defined(i)&&i.equals(r))&&o,o};Batch$4.prototype.add=function(e,t){const n=t.id;if(this.updaters.set(n,t),this.geometry.set(n,t.createFillGeometryInstance(e)),!t.hasConstantFill||!t.fillMaterialProperty.isConstant||!Property.isConstant(t.distanceDisplayConditionProperty)||!Property.isConstant(t.terrainOffsetProperty))this.updatersWithAttributes.set(n,t);else{const i=this;this.subscriptions.set(n,t.entity.definitionChanged.addEventListener(function(r,o,a,s){o==="isShowing"&&i.showsUpdated.set(t.id,t)}))}this.createPrimitive=!0};Batch$4.prototype.remove=function(e){const t=e.id;if(this.createPrimitive=this.geometry.remove(t)||this.createPrimitive,this.updaters.remove(t)){this.updatersWithAttributes.remove(t);const n=this.subscriptions.get(t);return defined(n)&&(n(),this.subscriptions.remove(t),this.showsUpdated.remove(t)),!0}return!1};const colorScratch$5=new Color;Batch$4.prototype.update=function(e){let t=!0,n=this.primitive;const i=this.primitives,r=this.geometry.values;let o;if(this.createPrimitive){if(r.length>0){defined(n)&&(defined(this.oldPrimitive)?i.remove(n):this.oldPrimitive=n),this.material=MaterialProperty.getValue(e,this.materialProperty,this.material);let s;defined(this.depthFailMaterialProperty)&&(this.depthFailMaterial=MaterialProperty.getValue(e,this.depthFailMaterialProperty,this.depthFailMaterial),s=new this.depthFailAppearanceType({material:this.depthFailMaterial,translucent:this.depthFailMaterial.isTranslucent(),closed:this.closed})),n=new Primitive({show:!1,asynchronous:!0,geometryInstances:r.slice(),appearance:new this.appearanceType({material:this.material,translucent:this.material.isTranslucent(),closed:this.closed}),depthFailAppearance:s,shadows:this.shadows}),i.add(n),t=!1}else{defined(n)&&(i.remove(n),n=void 0);const s=this.oldPrimitive;defined(s)&&(i.remove(s),this.oldPrimitive=void 0)}this.attributes.removeAll(),this.primitive=n,this.createPrimitive=!1}else if(defined(n)&&n.ready){n.show=!0,defined(this.oldPrimitive)&&(i.remove(this.oldPrimitive),this.oldPrimitive=void 0),this.material=MaterialProperty.getValue(e,this.materialProperty,this.material),this.primitive.appearance.material=this.material,defined(this.depthFailAppearanceType)&&!(this.depthFailMaterialProperty instanceof ColorMaterialProperty)&&(this.depthFailMaterial=MaterialProperty.getValue(e,this.depthFailMaterialProperty,this.depthFailMaterial),this.primitive.depthFailAppearance.material=this.depthFailMaterial);const a=this.updatersWithAttributes.values,s=a.length;for(o=0;o<s;o++){const l=a[o],c=l.entity,d=this.geometry.get(l.id);let h=this.attributes.get(d.id.id);if(defined(h)||(h=n.getGeometryInstanceAttributes(d.id),this.attributes.set(d.id.id,h)),defined(this.depthFailAppearanceType)&&this.depthFailMaterialProperty instanceof ColorMaterialProperty&&!l.depthFailMaterialProperty.isConstant){const g=l.depthFailMaterialProperty.color,_=Property.getValueOrDefault(g,e,Color.WHITE,colorScratch$5);Color.equals(h._lastDepthFailColor,_)||(h._lastDepthFailColor=Color.clone(_,h._lastDepthFailColor),h.depthFailColor=ColorGeometryInstanceAttribute.toValue(_,h.depthFailColor))}const f=c.isShowing&&(l.hasConstantFill||l.isFilled(e)),p=h.show[0]===1;f!==p&&(h.show=ShowGeometryInstanceAttribute.toValue(f,h.show));const u=l.distanceDisplayConditionProperty;if(!Property.isConstant(u)){const g=Property.getValueOrDefault(u,e,defaultDistanceDisplayCondition$5,distanceDisplayConditionScratch$6);DistanceDisplayCondition.equals(g,h._lastDistanceDisplayCondition)||(h._lastDistanceDisplayCondition=DistanceDisplayCondition.clone(g,h._lastDistanceDisplayCondition),h.distanceDisplayCondition=DistanceDisplayConditionGeometryInstanceAttribute.toValue(g,h.distanceDisplayCondition))}const m=l.terrainOffsetProperty;if(!Property.isConstant(m)){const g=Property.getValueOrDefault(m,e,defaultOffset$1,offsetScratch$1);Cartesian3.equals(g,h._lastOffset)||(h._lastOffset=Cartesian3.clone(g,h._lastOffset),h.offset=OffsetGeometryInstanceAttribute.toValue(g,h.offset))}}this.updateShows(n)}else defined(n)&&!n.ready&&(t=!1);return t};Batch$4.prototype.updateShows=function(e){const t=this.showsUpdated.values,n=t.length;for(let i=0;i<n;i++){const r=t[i],o=r.entity,a=this.geometry.get(r.id);let s=this.attributes.get(a.id.id);defined(s)||(s=e.getGeometryInstanceAttributes(a.id),this.attributes.set(a.id.id,s));const l=o.isShowing,c=s.show[0]===1;l!==c&&(s.show=ShowGeometryInstanceAttribute.toValue(l,s.show),a.attributes.show.value[0]=s.show[0])}this.showsUpdated.removeAll()};Batch$4.prototype.contains=function(e){return this.updaters.contains(e.id)};Batch$4.prototype.getBoundingSphere=function(e,t){const n=this.primitive;if(!n.ready)return BoundingSphereState$1.PENDING;const i=n.getGeometryInstanceAttributes(e.entity);return!defined(i)||!defined(i.boundingSphere)||defined(i.show)&&i.show[0]===0?BoundingSphereState$1.FAILED:(i.boundingSphere.clone(t),BoundingSphereState$1.DONE)};Batch$4.prototype.destroy=function(){const e=this.primitive,t=this.primitives;defined(e)&&t.remove(e);const n=this.oldPrimitive;defined(n)&&t.remove(n),this.removeMaterialSubscription()};function StaticGeometryPerMaterialBatch(e,t,n,i,r){this._items=[],this._primitives=e,this._appearanceType=t,this._depthFailAppearanceType=n,this._closed=i,this._shadows=r}StaticGeometryPerMaterialBatch.prototype.add=function(e,t){const n=this._items,i=n.length;for(let o=0;o<i;o++){const a=n[o];if(a.isMaterial(t)){a.add(e,t);return}}const r=new Batch$4(this._primitives,this._appearanceType,t.fillMaterialProperty,this._depthFailAppearanceType,t.depthFailMaterialProperty,this._closed,this._shadows);r.add(e,t),n.push(r)};StaticGeometryPerMaterialBatch.prototype.remove=function(e){const t=this._items,n=t.length;for(let i=n-1;i>=0;i--){const r=t[i];if(r.remove(e)){r.updaters.length===0&&(t.splice(i,1),r.destroy());break}}};StaticGeometryPerMaterialBatch.prototype.update=function(e){let t;const n=this._items,i=n.length;for(t=i-1;t>=0;t--){const o=n[t];if(o.invalidated){n.splice(t,1);const a=o.updaters.values,s=a.length;for(let l=0;l<s;l++)this.add(e,a[l]);o.destroy()}}let r=!0;for(t=0;t<n.length;t++)r=n[t].update(e)&&r;return r};StaticGeometryPerMaterialBatch.prototype.getBoundingSphere=function(e,t){const n=this._items,i=n.length;for(let r=0;r<i;r++){const o=n[r];if(o.contains(e))return o.getBoundingSphere(e,t)}return BoundingSphereState$1.FAILED};StaticGeometryPerMaterialBatch.prototype.removeAllPrimitives=function(){const e=this._items,t=e.length;for(let n=0;n<t;n++)e[n].destroy();this._items.length=0};function RectangleCollisionChecker(){this._tree=new RBush$1}function RectangleWithId(){this.minX=0,this.minY=0,this.maxX=0,this.maxY=0,this.id=""}RectangleWithId.fromRectangleAndId=function(e,t,n){return n.minX=t.west,n.minY=t.south,n.maxX=t.east,n.maxY=t.north,n.id=e,n};RectangleCollisionChecker.prototype.insert=function(e,t){Check.typeOf.string("id",e),Check.typeOf.object("rectangle",t);const n=RectangleWithId.fromRectangleAndId(e,t,new RectangleWithId);this._tree.insert(n)};function idCompare(e,t){return e.id===t.id}const removalScratch=new RectangleWithId;RectangleCollisionChecker.prototype.remove=function(e,t){Check.typeOf.string("id",e),Check.typeOf.object("rectangle",t);const n=RectangleWithId.fromRectangleAndId(e,t,removalScratch);this._tree.remove(n,idCompare)};const collisionScratch=new RectangleWithId;RectangleCollisionChecker.prototype.collides=function(e){Check.typeOf.object("rectangle",e);const t=RectangleWithId.fromRectangleAndId("",e,collisionScratch);return this._tree.collides(t)};const colorScratch$4=new Color,distanceDisplayConditionScratch$5=new DistanceDisplayCondition,defaultDistanceDisplayCondition$4=new DistanceDisplayCondition;function Batch$3(e,t,n,i){this.primitives=e,this.zIndex=i,this.classificationType=t,this.color=n,this.createPrimitive=!1,this.waitingOnCreate=!1,this.primitive=void 0,this.oldPrimitive=void 0,this.geometry=new AssociativeArray,this.updaters=new AssociativeArray,this.updatersWithAttributes=new AssociativeArray,this.attributes=new AssociativeArray,this.subscriptions=new AssociativeArray,this.showsUpdated=new AssociativeArray,this.itemsToRemove=[],this.isDirty=!1,this.rectangleCollisionCheck=new RectangleCollisionChecker}Batch$3.prototype.overlapping=function(e){return this.rectangleCollisionCheck.collides(e)};Batch$3.prototype.add=function(e,t){const n=e.id;if(this.createPrimitive=!0,this.geometry.set(n,t),this.updaters.set(n,e),this.rectangleCollisionCheck.insert(n,t.geometry.rectangle),!e.hasConstantFill||!e.fillMaterialProperty.isConstant||!Property.isConstant(e.distanceDisplayConditionProperty))this.updatersWithAttributes.set(n,e);else{const i=this;this.subscriptions.set(n,e.entity.definitionChanged.addEventListener(function(r,o,a,s){o==="isShowing"&&i.showsUpdated.set(e.id,e)}))}};Batch$3.prototype.remove=function(e){const t=e.id,n=this.geometry.get(t);if(this.createPrimitive=this.geometry.remove(t)||this.createPrimitive,this.updaters.remove(t)){this.rectangleCollisionCheck.remove(t,n.geometry.rectangle),this.updatersWithAttributes.remove(t);const i=this.subscriptions.get(t);return defined(i)&&(i(),this.subscriptions.remove(t),this.showsUpdated.remove(t)),!0}return!1};Batch$3.prototype.update=function(e){let t=!0;const n=0;let i=this.primitive;const r=this.primitives;let o;if(this.createPrimitive){const a=this.geometry.values;if(a.length>0)defined(i)&&(defined(this.oldPrimitive)?r.remove(i):this.oldPrimitive=i),i=new GroundPrimitive({show:!1,asynchronous:!0,geometryInstances:a.slice(),classificationType:this.classificationType}),r.add(i,this.zIndex),t=!1;else{defined(i)&&(r.remove(i),i=void 0);const l=this.oldPrimitive;defined(l)&&(r.remove(l),this.oldPrimitive=void 0)}this.attributes.removeAll(),this.primitive=i,this.createPrimitive=!1,this.waitingOnCreate=!0}else if(defined(i)&&i.ready){i.show=!0,defined(this.oldPrimitive)&&(r.remove(this.oldPrimitive),this.oldPrimitive=void 0);const a=this.updatersWithAttributes.values,s=a.length,l=this.waitingOnCreate;for(o=0;o<s;o++){const c=a[o],d=this.geometry.get(c.id);let h=this.attributes.get(d.id.id);if(defined(h)||(h=i.getGeometryInstanceAttributes(d.id),this.attributes.set(d.id.id,h)),!c.fillMaterialProperty.isConstant||l){const m=c.fillMaterialProperty.color,g=Property.getValueOrDefault(m,e,Color.WHITE,colorScratch$4);Color.equals(h._lastColor,g)||(h._lastColor=Color.clone(g,h._lastColor),h.color=ColorGeometryInstanceAttribute.toValue(g,h.color))}const f=c.entity.isShowing&&(c.hasConstantFill||c.isFilled(e)),p=h.show[0]===1;f!==p&&(h.show=ShowGeometryInstanceAttribute.toValue(f,h.show));const u=c.distanceDisplayConditionProperty;if(!Property.isConstant(u)){const m=Property.getValueOrDefault(u,e,defaultDistanceDisplayCondition$4,distanceDisplayConditionScratch$5);DistanceDisplayCondition.equals(m,h._lastDistanceDisplayCondition)||(h._lastDistanceDisplayCondition=DistanceDisplayCondition.clone(m,h._lastDistanceDisplayCondition),h.distanceDisplayCondition=DistanceDisplayConditionGeometryInstanceAttribute.toValue(m,h.distanceDisplayCondition))}}this.updateShows(i),this.waitingOnCreate=!1}else defined(i)&&!i.ready&&(t=!1);return this.itemsToRemove.length=n,t};Batch$3.prototype.updateShows=function(e){const t=this.showsUpdated.values,n=t.length;for(let i=0;i<n;i++){const r=t[i],o=this.geometry.get(r.id);let a=this.attributes.get(o.id.id);defined(a)||(a=e.getGeometryInstanceAttributes(o.id),this.attributes.set(o.id.id,a));const s=r.entity.isShowing,l=a.show[0]===1;s!==l&&(a.show=ShowGeometryInstanceAttribute.toValue(s,a.show),o.attributes.show.value[0]=a.show[0])}this.showsUpdated.removeAll()};Batch$3.prototype.contains=function(e){return this.updaters.contains(e.id)};Batch$3.prototype.getBoundingSphere=function(e,t){const n=this.primitive;if(!n.ready)return BoundingSphereState$1.PENDING;const i=n.getBoundingSphere(e.entity);return defined(i)?(i.clone(t),BoundingSphereState$1.DONE):BoundingSphereState$1.FAILED};Batch$3.prototype.removeAllPrimitives=function(){const e=this.primitives,t=this.primitive;defined(t)&&(e.remove(t),this.primitive=void 0,this.geometry.removeAll(),this.updaters.removeAll());const n=this.oldPrimitive;defined(n)&&(e.remove(n),this.oldPrimitive=void 0)};function StaticGroundGeometryColorBatch(e,t){this._batches=[],this._primitives=e,this._classificationType=t}StaticGroundGeometryColorBatch.prototype.add=function(e,t){const n=t.createFillGeometryInstance(e),i=this._batches,r=Property.getValueOrDefault(t.zIndex,0);let o;const a=i.length;for(let s=0;s<a;++s){const l=i[s];if(l.zIndex===r&&!l.overlapping(n.geometry.rectangle)){o=l;break}}return defined(o)||(o=new Batch$3(this._primitives,this._classificationType,n.attributes.color.value,r),i.push(o)),o.add(t,n),o};StaticGroundGeometryColorBatch.prototype.remove=function(e){const t=this._batches,n=t.length;for(let i=0;i<n;++i)if(t[i].remove(e))return};StaticGroundGeometryColorBatch.prototype.update=function(e){let t,n,i=!0;const r=this._batches,o=r.length;for(t=0;t<o;++t)i=r[t].update(e)&&i;for(t=0;t<o;++t){const a=r[t],s=a.itemsToRemove,l=s.length;for(let c=0;c<l;c++){n=s[c],a.remove(n);const d=this.add(e,n);a.isDirty=!0,d.isDirty=!0}}for(t=o-1;t>=0;--t){const a=r[t];a.isDirty&&(i=r[t].update(e)&&i,a.isDirty=!1),a.geometry.length===0&&r.splice(t,1)}return i};StaticGroundGeometryColorBatch.prototype.getBoundingSphere=function(e,t){const n=this._batches,i=n.length;for(let r=0;r<i;++r){const o=n[r];if(o.contains(e))return o.getBoundingSphere(e,t)}return BoundingSphereState$1.FAILED};StaticGroundGeometryColorBatch.prototype.removeAllPrimitives=function(){const e=this._batches,t=e.length;for(let n=0;n<t;++n)e[n].removeAllPrimitives()};const distanceDisplayConditionScratch$4=new DistanceDisplayCondition,defaultDistanceDisplayCondition$3=new DistanceDisplayCondition;function Batch$2(e,t,n,i,r,o){this.primitives=e,this.classificationType=t,this.appearanceType=n,this.materialProperty=i,this.updaters=new AssociativeArray,this.createPrimitive=!0,this.primitive=void 0,this.oldPrimitive=void 0,this.geometry=new AssociativeArray,this.material=void 0,this.updatersWithAttributes=new AssociativeArray,this.attributes=new AssociativeArray,this.invalidated=!1,this.removeMaterialSubscription=i.definitionChanged.addEventListener(Batch$2.prototype.onMaterialChanged,this),this.subscriptions=new AssociativeArray,this.showsUpdated=new AssociativeArray,this.usingSphericalTextureCoordinates=r,this.zIndex=o,this.rectangleCollisionCheck=new RectangleCollisionChecker}Batch$2.prototype.onMaterialChanged=function(){this.invalidated=!0};Batch$2.prototype.overlapping=function(e){return this.rectangleCollisionCheck.collides(e)};Batch$2.prototype.isMaterial=function(e){const t=this.materialProperty,n=e.fillMaterialProperty;return n===t||n instanceof ColorMaterialProperty&&t instanceof ColorMaterialProperty?!0:defined(t)&&t.equals(n)};Batch$2.prototype.add=function(e,t,n){const i=t.id;if(this.updaters.set(i,t),this.geometry.set(i,n),this.rectangleCollisionCheck.insert(i,n.geometry.rectangle),!t.hasConstantFill||!t.fillMaterialProperty.isConstant||!Property.isConstant(t.distanceDisplayConditionProperty))this.updatersWithAttributes.set(i,t);else{const r=this;this.subscriptions.set(i,t.entity.definitionChanged.addEventListener(function(o,a,s,l){a==="isShowing"&&r.showsUpdated.set(t.id,t)}))}this.createPrimitive=!0};Batch$2.prototype.remove=function(e){const t=e.id,n=this.geometry.get(t);if(this.createPrimitive=this.geometry.remove(t)||this.createPrimitive,this.updaters.remove(t)){this.rectangleCollisionCheck.remove(t,n.geometry.rectangle),this.updatersWithAttributes.remove(t);const i=this.subscriptions.get(t);return defined(i)&&(i(),this.subscriptions.remove(t)),!0}return!1};Batch$2.prototype.update=function(e){let t=!0,n=this.primitive;const i=this.primitives,r=this.geometry.values;let o;if(this.createPrimitive){if(r.length>0)defined(n)&&(defined(this.oldPrimitive)?i.remove(n):this.oldPrimitive=n),this.material=MaterialProperty.getValue(e,this.materialProperty,this.material),n=new GroundPrimitive({show:!1,asynchronous:!0,geometryInstances:r.slice(),appearance:new this.appearanceType({material:this.material}),classificationType:this.classificationType}),i.add(n,this.zIndex),t=!1;else{defined(n)&&(i.remove(n),n=void 0);const s=this.oldPrimitive;defined(s)&&(i.remove(s),this.oldPrimitive=void 0)}this.attributes.removeAll(),this.primitive=n,this.createPrimitive=!1}else if(defined(n)&&n.ready){n.show=!0,defined(this.oldPrimitive)&&(i.remove(this.oldPrimitive),this.oldPrimitive=void 0),this.material=MaterialProperty.getValue(e,this.materialProperty,this.material),this.primitive.appearance.material=this.material;const a=this.updatersWithAttributes.values,s=a.length;for(o=0;o<s;o++){const l=a[o],c=l.entity,d=this.geometry.get(l.id);let h=this.attributes.get(d.id.id);defined(h)||(h=n.getGeometryInstanceAttributes(d.id),this.attributes.set(d.id.id,h));const f=c.isShowing&&(l.hasConstantFill||l.isFilled(e)),p=h.show[0]===1;f!==p&&(h.show=ShowGeometryInstanceAttribute.toValue(f,h.show));const u=l.distanceDisplayConditionProperty;if(!Property.isConstant(u)){const m=Property.getValueOrDefault(u,e,defaultDistanceDisplayCondition$3,distanceDisplayConditionScratch$4);DistanceDisplayCondition.equals(m,h._lastDistanceDisplayCondition)||(h._lastDistanceDisplayCondition=DistanceDisplayCondition.clone(m,h._lastDistanceDisplayCondition),h.distanceDisplayCondition=DistanceDisplayConditionGeometryInstanceAttribute.toValue(m,h.distanceDisplayCondition))}}this.updateShows(n)}else defined(n)&&!n.ready&&(t=!1);return t};Batch$2.prototype.updateShows=function(e){const t=this.showsUpdated.values,n=t.length;for(let i=0;i<n;i++){const r=t[i],o=r.entity,a=this.geometry.get(r.id);let s=this.attributes.get(a.id.id);defined(s)||(s=e.getGeometryInstanceAttributes(a.id),this.attributes.set(a.id.id,s));const l=o.isShowing,c=s.show[0]===1;l!==c&&(s.show=ShowGeometryInstanceAttribute.toValue(l,s.show),a.attributes.show.value[0]=s.show[0])}this.showsUpdated.removeAll()};Batch$2.prototype.contains=function(e){return this.updaters.contains(e.id)};Batch$2.prototype.getBoundingSphere=function(e,t){const n=this.primitive;if(!n.ready)return BoundingSphereState$1.PENDING;const i=n.getGeometryInstanceAttributes(e.entity);return!defined(i)||!defined(i.boundingSphere)||defined(i.show)&&i.show[0]===0?BoundingSphereState$1.FAILED:(i.boundingSphere.clone(t),BoundingSphereState$1.DONE)};Batch$2.prototype.destroy=function(){const e=this.primitive,t=this.primitives;defined(e)&&t.remove(e);const n=this.oldPrimitive;defined(n)&&t.remove(n),this.removeMaterialSubscription()};function StaticGroundGeometryPerMaterialBatch(e,t,n){this._items=[],this._primitives=e,this._classificationType=t,this._appearanceType=n}StaticGroundGeometryPerMaterialBatch.prototype.add=function(e,t){const n=this._items,i=n.length,r=t.createFillGeometryInstance(e),o=ShadowVolumeAppearance.shouldUseSphericalCoordinates(r.geometry.rectangle),a=Property.getValueOrDefault(t.zIndex,0);for(let l=0;l<i;++l){const c=n[l];if(c.isMaterial(t)&&c.usingSphericalTextureCoordinates===o&&c.zIndex===a&&!c.overlapping(r.geometry.rectangle)){c.add(e,t,r);return}}const s=new Batch$2(this._primitives,this._classificationType,this._appearanceType,t.fillMaterialProperty,o,a);s.add(e,t,r),n.push(s)};StaticGroundGeometryPerMaterialBatch.prototype.remove=function(e){const t=this._items,n=t.length;for(let i=n-1;i>=0;i--){const r=t[i];if(r.remove(e)){r.updaters.length===0&&(t.splice(i,1),r.destroy());break}}};StaticGroundGeometryPerMaterialBatch.prototype.update=function(e){let t;const n=this._items,i=n.length;for(t=i-1;t>=0;t--){const o=n[t];if(o.invalidated){n.splice(t,1);const a=o.updaters.values,s=a.length;for(let l=0;l<s;l++)this.add(e,a[l]);o.destroy()}}let r=!0;for(t=0;t<n.length;t++)r=n[t].update(e)&&r;return r};StaticGroundGeometryPerMaterialBatch.prototype.getBoundingSphere=function(e,t){const n=this._items,i=n.length;for(let r=0;r<i;r++){const o=n[r];if(o.contains(e))return o.getBoundingSphere(e,t)}return BoundingSphereState$1.FAILED};StaticGroundGeometryPerMaterialBatch.prototype.removeAllPrimitives=function(){const e=this._items,t=e.length;for(let n=0;n<t;n++)e[n].destroy();this._items.length=0};const colorScratch$3=new Color,distanceDisplayConditionScratch$3=new DistanceDisplayCondition,defaultDistanceDisplayCondition$2=new DistanceDisplayCondition,defaultOffset=Cartesian3.ZERO,offsetScratch=new Cartesian3;function Batch$1(e,t,n,i){this.translucent=t,this.width=n,this.shadows=i,this.primitives=e,this.createPrimitive=!1,this.waitingOnCreate=!1,this.primitive=void 0,this.oldPrimitive=void 0,this.geometry=new AssociativeArray,this.updaters=new AssociativeArray,this.updatersWithAttributes=new AssociativeArray,this.attributes=new AssociativeArray,this.itemsToRemove=[],this.subscriptions=new AssociativeArray,this.showsUpdated=new AssociativeArray}Batch$1.prototype.add=function(e,t){const n=e.id;if(this.createPrimitive=!0,this.geometry.set(n,t),this.updaters.set(n,e),!e.hasConstantOutline||!e.outlineColorProperty.isConstant||!Property.isConstant(e.distanceDisplayConditionProperty)||!Property.isConstant(e.terrainOffsetProperty))this.updatersWithAttributes.set(n,e);else{const i=this;this.subscriptions.set(n,e.entity.definitionChanged.addEventListener(function(r,o,a,s){o==="isShowing"&&i.showsUpdated.set(e.id,e)}))}};Batch$1.prototype.remove=function(e){const t=e.id;if(this.createPrimitive=this.geometry.remove(t)||this.createPrimitive,this.updaters.remove(t)){this.updatersWithAttributes.remove(t);const n=this.subscriptions.get(t);return defined(n)&&(n(),this.subscriptions.remove(t),this.showsUpdated.remove(t)),!0}return!1};Batch$1.prototype.update=function(e){let t=!0,n=0,i=this.primitive;const r=this.primitives;let o;if(this.createPrimitive){const a=this.geometry.values;if(a.length>0)defined(i)&&(defined(this.oldPrimitive)?r.remove(i):this.oldPrimitive=i),i=new Primitive({show:!1,asynchronous:!0,geometryInstances:a.slice(),appearance:new PerInstanceColorAppearance({flat:!0,translucent:this.translucent,renderState:{lineWidth:this.width}}),shadows:this.shadows}),r.add(i),t=!1;else{defined(i)&&(r.remove(i),i=void 0);const l=this.oldPrimitive;defined(l)&&(r.remove(l),this.oldPrimitive=void 0)}this.attributes.removeAll(),this.primitive=i,this.createPrimitive=!1,this.waitingOnCreate=!0}else if(defined(i)&&i.ready){i.show=!0,defined(this.oldPrimitive)&&(r.remove(this.oldPrimitive),this.oldPrimitive=void 0);const a=this.updatersWithAttributes.values,s=a.length,l=this.waitingOnCreate;for(o=0;o<s;o++){const c=a[o],d=this.geometry.get(c.id);let h=this.attributes.get(d.id.id);if(defined(h)||(h=i.getGeometryInstanceAttributes(d.id),this.attributes.set(d.id.id,h)),!c.outlineColorProperty.isConstant||l){const g=c.outlineColorProperty,_=Property.getValueOrDefault(g,e,Color.WHITE,colorScratch$3);Color.equals(h._lastColor,_)||(h._lastColor=Color.clone(_,h._lastColor),h.color=ColorGeometryInstanceAttribute.toValue(_,h.color),(this.translucent&&h.color[3]===255||!this.translucent&&h.color[3]!==255)&&(this.itemsToRemove[n++]=c))}const f=c.entity.isShowing&&(c.hasConstantOutline||c.isOutlineVisible(e)),p=h.show[0]===1;f!==p&&(h.show=ShowGeometryInstanceAttribute.toValue(f,h.show));const u=c.distanceDisplayConditionProperty;if(!Property.isConstant(u)){const g=Property.getValueOrDefault(u,e,defaultDistanceDisplayCondition$2,distanceDisplayConditionScratch$3);DistanceDisplayCondition.equals(g,h._lastDistanceDisplayCondition)||(h._lastDistanceDisplayCondition=DistanceDisplayCondition.clone(g,h._lastDistanceDisplayCondition),h.distanceDisplayCondition=DistanceDisplayConditionGeometryInstanceAttribute.toValue(g,h.distanceDisplayCondition))}const m=c.terrainOffsetProperty;if(!Property.isConstant(m)){const g=Property.getValueOrDefault(m,e,defaultOffset,offsetScratch);Cartesian3.equals(g,h._lastOffset)||(h._lastOffset=Cartesian3.clone(g,h._lastOffset),h.offset=OffsetGeometryInstanceAttribute.toValue(g,h.offset))}}this.updateShows(i),this.waitingOnCreate=!1}else defined(i)&&!i.ready&&(t=!1);return this.itemsToRemove.length=n,t};Batch$1.prototype.updateShows=function(e){const t=this.showsUpdated.values,n=t.length;for(let i=0;i<n;i++){const r=t[i],o=this.geometry.get(r.id);let a=this.attributes.get(o.id.id);defined(a)||(a=e.getGeometryInstanceAttributes(o.id),this.attributes.set(o.id.id,a));const s=r.entity.isShowing,l=a.show[0]===1;s!==l&&(a.show=ShowGeometryInstanceAttribute.toValue(s,a.show),o.attributes.show.value[0]=a.show[0])}this.showsUpdated.removeAll()};Batch$1.prototype.contains=function(e){return this.updaters.contains(e.id)};Batch$1.prototype.getBoundingSphere=function(e,t){const n=this.primitive;if(!n.ready)return BoundingSphereState$1.PENDING;const i=n.getGeometryInstanceAttributes(e.entity);return!defined(i)||!defined(i.boundingSphere)||defined(i.show)&&i.show[0]===0?BoundingSphereState$1.FAILED:(i.boundingSphere.clone(t),BoundingSphereState$1.DONE)};Batch$1.prototype.removeAllPrimitives=function(){const e=this.primitives,t=this.primitive;defined(t)&&(e.remove(t),this.primitive=void 0,this.geometry.removeAll(),this.updaters.removeAll());const n=this.oldPrimitive;defined(n)&&(e.remove(n),this.oldPrimitive=void 0)};function StaticOutlineGeometryBatch(e,t,n){this._primitives=e,this._scene=t,this._shadows=n,this._solidBatches=new AssociativeArray,this._translucentBatches=new AssociativeArray}StaticOutlineGeometryBatch.prototype.add=function(e,t){const n=t.createOutlineGeometryInstance(e),i=this._scene.clampLineWidth(t.outlineWidth);let r,o;n.attributes.color.value[3]===255?(r=this._solidBatches,o=r.get(i),defined(o)||(o=new Batch$1(this._primitives,!1,i,this._shadows),r.set(i,o)),o.add(t,n)):(r=this._translucentBatches,o=r.get(i),defined(o)||(o=new Batch$1(this._primitives,!0,i,this._shadows),r.set(i,o)),o.add(t,n))};StaticOutlineGeometryBatch.prototype.remove=function(e){let t;const n=this._solidBatches.values,i=n.length;for(t=0;t<i;t++)if(n[t].remove(e))return;const r=this._translucentBatches.values,o=r.length;for(t=0;t<o;t++)if(r[t].remove(e))return};StaticOutlineGeometryBatch.prototype.update=function(e){let t,n,i,r;const o=this._solidBatches.values,a=o.length,s=this._translucentBatches.values,l=s.length;let c,d=!0,h=!1;do{for(h=!1,n=0;n<a;n++){r=o[n],d=r.update(e),c=r.itemsToRemove;const f=c.length;if(f>0)for(h=!0,t=0;t<f;t++)i=c[t],r.remove(i),this.add(e,i)}for(n=0;n<l;n++){r=s[n],d=r.update(e),c=r.itemsToRemove;const f=c.length;if(f>0)for(h=!0,t=0;t<f;t++)i=c[t],r.remove(i),this.add(e,i)}}while(h);return d};StaticOutlineGeometryBatch.prototype.getBoundingSphere=function(e,t){let n;const i=this._solidBatches.values,r=i.length;for(n=0;n<r;n++){const s=i[n];if(s.contains(e))return s.getBoundingSphere(e,t)}const o=this._translucentBatches.values,a=o.length;for(n=0;n<a;n++){const s=o[n];if(s.contains(e))return s.getBoundingSphere(e,t)}return BoundingSphereState$1.FAILED};StaticOutlineGeometryBatch.prototype.removeAllPrimitives=function(){let e;const t=this._solidBatches.values,n=t.length;for(e=0;e<n;e++)t[e].removeAllPrimitives();const i=this._translucentBatches.values,r=i.length;for(e=0;e<r;e++)i[e].removeAllPrimitives()};const emptyArray$1=[];function GeometryVisualizer(e,t,n,i){Check.defined("scene",e),Check.defined("entityCollection",t),n=defaultValue(n,e.primitives),i=defaultValue(i,e.groundPrimitives),this._scene=e,this._primitives=n,this._groundPrimitives=i,this._entityCollection=void 0,this._addedObjects=new AssociativeArray,this._removedObjects=new AssociativeArray,this._changedObjects=new AssociativeArray;const r=ShadowMode.NUMBER_OF_SHADOW_MODES;this._outlineBatches=new Array(r*2),this._closedColorBatches=new Array(r*2),this._closedMaterialBatches=new Array(r*2),this._openColorBatches=new Array(r*2),this._openMaterialBatches=new Array(r*2);const o=Entity.supportsMaterialsforEntitiesOnTerrain(e);this._supportsMaterialsforEntitiesOnTerrain=o;let a;for(a=0;a<r;++a)this._outlineBatches[a]=new StaticOutlineGeometryBatch(n,e,a),this._outlineBatches[r+a]=new StaticOutlineGeometryBatch(n,e,a),this._closedColorBatches[a]=new StaticGeometryColorBatch(n,PerInstanceColorAppearance,void 0,!0,a),this._closedColorBatches[r+a]=new StaticGeometryColorBatch(n,PerInstanceColorAppearance,void 0,!0,a),this._closedMaterialBatches[a]=new StaticGeometryPerMaterialBatch(n,MaterialAppearance,void 0,!0,a),this._closedMaterialBatches[r+a]=new StaticGeometryPerMaterialBatch(n,MaterialAppearance,void 0,!0,a),this._openColorBatches[a]=new StaticGeometryColorBatch(n,PerInstanceColorAppearance,void 0,!1,a),this._openColorBatches[r+a]=new StaticGeometryColorBatch(n,PerInstanceColorAppearance,void 0,!1,a),this._openMaterialBatches[a]=new StaticGeometryPerMaterialBatch(n,MaterialAppearance,void 0,!1,a),this._openMaterialBatches[r+a]=new StaticGeometryPerMaterialBatch(n,MaterialAppearance,void 0,!1,a);const s=ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES,l=new Array(s),c=[];if(o)for(a=0;a<s;++a)c.push(new StaticGroundGeometryPerMaterialBatch(i,a,MaterialAppearance)),l[a]=new StaticGroundGeometryColorBatch(i,a);else for(a=0;a<s;++a)l[a]=new StaticGroundGeometryColorBatch(i,a);this._groundColorBatches=l,this._groundMaterialBatches=c,this._dynamicBatch=new DynamicGeometryBatch(n,i),this._batches=this._outlineBatches.concat(this._closedColorBatches,this._closedMaterialBatches,this._openColorBatches,this._openMaterialBatches,this._groundColorBatches,this._groundMaterialBatches,this._dynamicBatch),this._subscriptions=new AssociativeArray,this._updaterSets=new AssociativeArray,this._entityCollection=t,t.collectionChanged.addEventListener(GeometryVisualizer.prototype._onCollectionChanged,this),this._onCollectionChanged(t,t.values,emptyArray$1)}GeometryVisualizer.registerUpdater=function(e){GeometryUpdaterSet.registerUpdater(e)};GeometryVisualizer.unregisterUpdater=function(e){GeometryUpdaterSet.unregisterUpdater(e)};GeometryVisualizer.prototype.update=function(e){Check.defined("time",e);const t=this._addedObjects,n=t.values,i=this._removedObjects,r=i.values,o=this._changedObjects,a=o.values;let s,l,c,d;const h=this;for(s=a.length-1;s>-1;s--)l=a[s],c=l.id,d=this._updaterSets.get(c),d.entity===l?d.forEach(function(m){h._removeUpdater(m),h._insertUpdaterIntoBatch(e,m)}):(r.push(l),n.push(l));for(s=r.length-1;s>-1;s--)l=r[s],c=l.id,d=this._updaterSets.get(c),d.forEach(this._removeUpdater.bind(this)),d.destroy(),this._updaterSets.remove(c),this._subscriptions.get(c)(),this._subscriptions.remove(c);for(s=n.length-1;s>-1;s--)l=n[s],c=l.id,d=new GeometryUpdaterSet(l,this._scene),this._updaterSets.set(c,d),d.forEach(function(m){h._insertUpdaterIntoBatch(e,m)}),this._subscriptions.set(c,d.geometryChanged.addEventListener(GeometryVisualizer._onGeometryChanged,this));t.removeAll(),i.removeAll(),o.removeAll();let f=!0;const p=this._batches,u=p.length;for(s=0;s<u;s++)f=p[s].update(e)&&f;return f};const getBoundingSphereArrayScratch$2=[],getBoundingSphereBoundingSphereScratch$2=new BoundingSphere;GeometryVisualizer.prototype.getBoundingSphere=function(e,t){Check.defined("entity",e),Check.defined("result",t);const n=getBoundingSphereArrayScratch$2,i=getBoundingSphereBoundingSphereScratch$2;let r=0,o=BoundingSphereState$1.DONE;const a=this._batches,s=a.length,l=e.id,c=this._updaterSets.get(l).updaters;for(let d=0;d<c.length;d++){const h=c[d];for(let f=0;f<s;f++){if(o=a[f].getBoundingSphere(h,i),o===BoundingSphereState$1.PENDING)return BoundingSphereState$1.PENDING;o===BoundingSphereState$1.DONE&&(n[r]=BoundingSphere.clone(i,n[r]),r++)}}return r===0?BoundingSphereState$1.FAILED:(n.length=r,BoundingSphere.fromBoundingSpheres(n,t),BoundingSphereState$1.DONE)};GeometryVisualizer.prototype.isDestroyed=function(){return!1};GeometryVisualizer.prototype.destroy=function(){this._entityCollection.collectionChanged.removeEventListener(GeometryVisualizer.prototype._onCollectionChanged,this),this._addedObjects.removeAll(),this._removedObjects.removeAll();let e;const t=this._batches;let n=t.length;for(e=0;e<n;e++)t[e].removeAllPrimitives();const i=this._subscriptions.values;for(n=i.length,e=0;e<n;e++)i[e]();this._subscriptions.removeAll();const r=this._updaterSets.values;for(n=r.length,e=0;e<n;e++)r[e].destroy();return this._updaterSets.removeAll(),destroyObject(this)};GeometryVisualizer.prototype._removeUpdater=function(e){const t=this._batches,n=t.length;for(let i=0;i<n;i++)t[i].remove(e)};GeometryVisualizer.prototype._insertUpdaterIntoBatch=function(e,t){if(t.isDynamic){this._dynamicBatch.add(e,t);return}let n;(t.outlineEnabled||t.fillEnabled)&&(n=t.shadowsProperty.getValue(e));const i=ShadowMode.NUMBER_OF_SHADOW_MODES;if(t.outlineEnabled&&(defined(t.terrainOffsetProperty)?this._outlineBatches[i+n].add(e,t):this._outlineBatches[n].add(e,t)),t.fillEnabled)if(t.onTerrain){const r=t.classificationTypeProperty.getValue(e);t.fillMaterialProperty instanceof ColorMaterialProperty?this._groundColorBatches[r].add(e,t):this._groundMaterialBatches[r].add(e,t)}else t.isClosed?t.fillMaterialProperty instanceof ColorMaterialProperty?defined(t.terrainOffsetProperty)?this._closedColorBatches[i+n].add(e,t):this._closedColorBatches[n].add(e,t):defined(t.terrainOffsetProperty)?this._closedMaterialBatches[i+n].add(e,t):this._closedMaterialBatches[n].add(e,t):t.fillMaterialProperty instanceof ColorMaterialProperty?defined(t.terrainOffsetProperty)?this._openColorBatches[i+n].add(e,t):this._openColorBatches[n].add(e,t):defined(t.terrainOffsetProperty)?this._openMaterialBatches[i+n].add(e,t):this._openMaterialBatches[n].add(e,t)};GeometryVisualizer._onGeometryChanged=function(e){const t=this._removedObjects,n=this._changedObjects,i=e.entity,r=i.id;!defined(t.get(r))&&!defined(n.get(r))&&n.set(r,i)};GeometryVisualizer.prototype._onCollectionChanged=function(e,t,n){const i=this._addedObjects,r=this._removedObjects,o=this._changedObjects;let a,s,l;for(a=n.length-1;a>-1;a--)l=n[a],s=l.id,i.remove(s)||(r.set(s,l),o.remove(s));for(a=t.length-1;a>-1;a--)l=t[a],s=l.id,r.remove(s)?o.set(s,l):i.set(s,l)};const defaultScale$1=1,defaultFont="30px sans-serif",defaultStyle=LabelStyle.FILL,defaultFillColor=Color.WHITE,defaultOutlineColor$1=Color.BLACK,defaultOutlineWidth$1=1,defaultShowBackground=!1,defaultBackgroundColor$1=new Color(.165,.165,.165,.8),defaultBackgroundPadding=new Cartesian2(7,5),defaultPixelOffset=Cartesian2.ZERO,defaultEyeOffset=Cartesian3.ZERO,defaultHeightReference$1=HeightReference.NONE,defaultHorizontalOrigin=HorizontalOrigin.CENTER,defaultVerticalOrigin=VerticalOrigin.CENTER,positionScratch$1=new Cartesian3,fillColorScratch=new Color,outlineColorScratch$1=new Color,backgroundColorScratch=new Color,backgroundPaddingScratch=new Cartesian2,eyeOffsetScratch=new Cartesian3,pixelOffsetScratch=new Cartesian2,translucencyByDistanceScratch$1=new NearFarScalar,pixelOffsetScaleByDistanceScratch=new NearFarScalar,scaleByDistanceScratch$1=new NearFarScalar,distanceDisplayConditionScratch$2=new DistanceDisplayCondition;function EntityData$2(e){this.entity=e,this.label=void 0,this.index=void 0}function LabelVisualizer(e,t){if(!defined(e))throw new DeveloperError("entityCluster is required.");if(!defined(t))throw new DeveloperError("entityCollection is required.");t.collectionChanged.addEventListener(LabelVisualizer.prototype._onCollectionChanged,this),this._cluster=e,this._entityCollection=t,this._items=new AssociativeArray,this._onCollectionChanged(t,t.values,[],[])}LabelVisualizer.prototype.update=function(e){if(!defined(e))throw new DeveloperError("time is required.");const t=this._items.values,n=this._cluster;for(let i=0,r=t.length;i<r;i++){const o=t[i],a=o.entity,s=a._label;let l,c=o.label,d=a.isShowing&&a.isAvailable(e)&&Property.getValueOrDefault(s._show,e,!0),h;if(d&&(h=Property.getValueOrUndefined(a._position,e,positionScratch$1),l=Property.getValueOrUndefined(s._text,e),d=defined(h)&&defined(l)),!d){returnPrimitive$1(o,a,n);continue}Property.isConstant(a._position)||(n._clusterDirty=!0);let f=!1;const p=Property.getValueOrDefault(s._heightReference,e,defaultHeightReference$1);defined(c)||(c=n.getLabel(a),c.id=a,o.label=c,f=Cartesian3.equals(c.position,h)&&c.heightReference===p),c.show=!0,c.position=h,c.text=l,c.scale=Property.getValueOrDefault(s._scale,e,defaultScale$1),c.font=Property.getValueOrDefault(s._font,e,defaultFont),c.style=Property.getValueOrDefault(s._style,e,defaultStyle),c.fillColor=Property.getValueOrDefault(s._fillColor,e,defaultFillColor,fillColorScratch),c.outlineColor=Property.getValueOrDefault(s._outlineColor,e,defaultOutlineColor$1,outlineColorScratch$1),c.outlineWidth=Property.getValueOrDefault(s._outlineWidth,e,defaultOutlineWidth$1),c.showBackground=Property.getValueOrDefault(s._showBackground,e,defaultShowBackground),c.backgroundColor=Property.getValueOrDefault(s._backgroundColor,e,defaultBackgroundColor$1,backgroundColorScratch),c.backgroundPadding=Property.getValueOrDefault(s._backgroundPadding,e,defaultBackgroundPadding,backgroundPaddingScratch),c.pixelOffset=Property.getValueOrDefault(s._pixelOffset,e,defaultPixelOffset,pixelOffsetScratch),c.eyeOffset=Property.getValueOrDefault(s._eyeOffset,e,defaultEyeOffset,eyeOffsetScratch),c.heightReference=p,c.horizontalOrigin=Property.getValueOrDefault(s._horizontalOrigin,e,defaultHorizontalOrigin),c.verticalOrigin=Property.getValueOrDefault(s._verticalOrigin,e,defaultVerticalOrigin),c.translucencyByDistance=Property.getValueOrUndefined(s._translucencyByDistance,e,translucencyByDistanceScratch$1),c.pixelOffsetScaleByDistance=Property.getValueOrUndefined(s._pixelOffsetScaleByDistance,e,pixelOffsetScaleByDistanceScratch),c.scaleByDistance=Property.getValueOrUndefined(s._scaleByDistance,e,scaleByDistanceScratch$1),c.distanceDisplayCondition=Property.getValueOrUndefined(s._distanceDisplayCondition,e,distanceDisplayConditionScratch$2),c.disableDepthTestDistance=Property.getValueOrUndefined(s._disableDepthTestDistance,e),f&&c._updateClamping()}return!0};LabelVisualizer.prototype.getBoundingSphere=function(e,t){if(!defined(e))throw new DeveloperError("entity is required.");if(!defined(t))throw new DeveloperError("result is required.");const n=this._items.get(e.id);if(!defined(n)||!defined(n.label))return BoundingSphereState$1.FAILED;const i=n.label;return t.center=Cartesian3.clone(defaultValue(i._clampedPosition,i.position),t.center),t.radius=0,BoundingSphereState$1.DONE};LabelVisualizer.prototype.isDestroyed=function(){return!1};LabelVisualizer.prototype.destroy=function(){this._entityCollection.collectionChanged.removeEventListener(LabelVisualizer.prototype._onCollectionChanged,this);const e=this._entityCollection.values;for(let t=0;t<e.length;t++)this._cluster.removeLabel(e[t]);return destroyObject(this)};LabelVisualizer.prototype._onCollectionChanged=function(e,t,n,i){let r,o;const a=this._items,s=this._cluster;for(r=t.length-1;r>-1;r--)o=t[r],defined(o._label)&&defined(o._position)&&a.set(o.id,new EntityData$2(o));for(r=i.length-1;r>-1;r--)o=i[r],defined(o._label)&&defined(o._position)?a.contains(o.id)||a.set(o.id,new EntityData$2(o)):(returnPrimitive$1(a.get(o.id),o,s),a.remove(o.id));for(r=n.length-1;r>-1;r--)o=n[r],returnPrimitive$1(a.get(o.id),o,s),a.remove(o.id)};function returnPrimitive$1(e,t,n){defined(e)&&(e.label=void 0,n.removeLabel(t))}const defaultScale=1,defaultMinimumPixelSize=0,defaultIncrementallyLoadTextures=!0,defaultClampAnimations=!0,defaultShadows$1=ShadowMode.ENABLED,defaultHeightReference=HeightReference.NONE,defaultSilhouetteColor=Color.RED,defaultSilhouetteSize=0,defaultColor$2=Color.WHITE,defaultColorBlendMode=ColorBlendMode.HIGHLIGHT,defaultColorBlendAmount=.5,defaultImageBasedLightingFactor=new Cartesian2(1,1),modelMatrixScratch=new Matrix4,nodeMatrixScratch=new Matrix4,scratchColor$6=new Color,scratchArray$2=new Array(4),scratchCartesian$3=new Cartesian3;function ModelVisualizer(e,t){Check.typeOf.object("scene",e),Check.typeOf.object("entityCollection",t),t.collectionChanged.addEventListener(ModelVisualizer.prototype._onCollectionChanged,this),this._scene=e,this._primitives=e.primitives,this._entityCollection=t,this._modelHash={},this._entitiesToVisualize=new AssociativeArray,this._onCollectionChanged(t,t.values,[],[])}async function createModelPrimitive(e,t,n,i){const r=e._primitives,o=e._modelHash;try{const a=await Model.fromGltfAsync({url:n,incrementallyLoadTextures:i,scene:e._scene});if(e.isDestroyed()||!defined(o[t.id]))return;a.id=t,r.add(a),o[t.id].modelPrimitive=a,a.errorEvent.addEventListener(s=>{defined(o[t.id])&&(console.log(s),s.name!=="TextureError"&&a.incrementallyLoadTextures&&(o[t.id].loadFailed=!0))})}catch(a){if(e.isDestroyed()||!defined(o[t.id]))return;console.log(a),o[t.id].loadFailed=!0}}ModelVisualizer.prototype.update=function(e){if(!defined(e))throw new DeveloperError("time is required.");const t=this._entitiesToVisualize.values,n=this._modelHash,i=this._primitives;for(let r=0,o=t.length;r<o;r++){const a=t[r],s=a._model;let l,c=n[a.id],d=a.isShowing&&a.isAvailable(e)&&Property.getValueOrDefault(s._show,e,!0),h;if(d&&(h=a.computeModelMatrix(e,modelMatrixScratch),l=Resource.createIfNeeded(Property.getValueOrUndefined(s._uri,e)),d=defined(h)&&defined(l)),!d){defined(c)&&c.modelPrimitive&&(c.modelPrimitive.show=!1);continue}if(!defined(c)||l.url!==c.url){defined(c==null?void 0:c.modelPrimitive)&&(i.removeAndDestroy(c.modelPrimitive),delete n[a.id]),c={modelPrimitive:void 0,url:l.url,animationsRunning:!1,nodeTransformationsScratch:{},articulationsScratch:{},loadFailed:!1,modelUpdated:!1},n[a.id]=c;const u=Property.getValueOrDefault(s._incrementallyLoadTextures,e,defaultIncrementallyLoadTextures);createModelPrimitive(this,a,l,u)}const f=c.modelPrimitive;if(!defined(f))continue;f.show=!0,f.scale=Property.getValueOrDefault(s._scale,e,defaultScale),f.minimumPixelSize=Property.getValueOrDefault(s._minimumPixelSize,e,defaultMinimumPixelSize),f.maximumScale=Property.getValueOrUndefined(s._maximumScale,e),f.modelMatrix=Matrix4.clone(h,f.modelMatrix),f.shadows=Property.getValueOrDefault(s._shadows,e,defaultShadows$1),f.heightReference=Property.getValueOrDefault(s._heightReference,e,defaultHeightReference),f.distanceDisplayCondition=Property.getValueOrUndefined(s._distanceDisplayCondition,e),f.silhouetteColor=Property.getValueOrDefault(s._silhouetteColor,e,defaultSilhouetteColor,scratchColor$6),f.silhouetteSize=Property.getValueOrDefault(s._silhouetteSize,e,defaultSilhouetteSize),f.color=Property.getValueOrDefault(s._color,e,defaultColor$2,scratchColor$6),f.colorBlendMode=Property.getValueOrDefault(s._colorBlendMode,e,defaultColorBlendMode),f.colorBlendAmount=Property.getValueOrDefault(s._colorBlendAmount,e,defaultColorBlendAmount),f.clippingPlanes=Property.getValueOrUndefined(s._clippingPlanes,e),f.clampAnimations=Property.getValueOrDefault(s._clampAnimations,e,defaultClampAnimations),f.imageBasedLighting.imageBasedLightingFactor=Property.getValueOrDefault(s._imageBasedLightingFactor,e,defaultImageBasedLightingFactor);let p=Property.getValueOrUndefined(s._lightColor,e);if(defined(p)&&(Color.pack(p,scratchArray$2,0),p=Cartesian3.unpack(scratchArray$2,0,scratchCartesian$3)),f.lightColor=p,f.customShader=Property.getValueOrUndefined(s._customShader,e),n[a.id].modelUpdated=!0,f.ready){const u=Property.getValueOrDefault(s._runAnimations,e,!0);c.animationsRunning!==u&&(u?f.activeAnimations.addAll({loop:ModelAnimationLoop.REPEAT}):f.activeAnimations.removeAll(),c.animationsRunning=u);const m=Property.getValueOrUndefined(s._nodeTransformations,e,c.nodeTransformationsScratch);if(defined(m)){const C=Object.keys(m);for(let A=0,S=C.length;A<S;++A){const v=C[A],b=m[v];if(!defined(b))continue;const D=f.getNode(v);if(!defined(D))continue;const I=Matrix4.fromTranslationRotationScale(b,nodeMatrixScratch);D.matrix=Matrix4.multiply(D.originalMatrix,I,I)}}let g=!1;const _=Property.getValueOrUndefined(s._articulations,e,c.articulationsScratch);if(defined(_)){const C=Object.keys(_);for(let A=0,S=C.length;A<S;++A){const v=C[A],b=_[v];defined(b)&&(g=!0,f.setArticulationStage(v,b))}}g&&f.applyArticulations()}}return!0};ModelVisualizer.prototype.isDestroyed=function(){return!1};ModelVisualizer.prototype.destroy=function(){this._entityCollection.collectionChanged.removeEventListener(ModelVisualizer.prototype._onCollectionChanged,this);const e=this._entitiesToVisualize.values,t=this._modelHash,n=this._primitives;for(let i=e.length-1;i>-1;i--)removeModel(this,e[i],t,n);return destroyObject(this)};const scratchPosition$5=new Cartesian3,scratchCartographic$7=new Cartographic;ModelVisualizer.prototype.getBoundingSphere=function(e,t){if(!defined(e))throw new DeveloperError("entity is required.");if(!defined(t))throw new DeveloperError("result is required.");const n=this._modelHash[e.id];if(!defined(n)||n.loadFailed)return BoundingSphereState$1.FAILED;const i=n.modelPrimitive;if(!defined(i)||!i.show||!i.ready||!n.modelUpdated)return BoundingSphereState$1.PENDING;const r=this._scene,o=defaultValue(r.ellipsoid,Ellipsoid.default);if(i.heightReference!==HeightReference.NONE){const s=i.modelMatrix;scratchPosition$5.x=s[12],scratchPosition$5.y=s[13],scratchPosition$5.z=s[14];const l=o.cartesianToCartographic(scratchPosition$5,scratchCartographic$7),c=r.getHeight(l,i.heightReference);return defined(c)&&(isHeightReferenceClamp(i.heightReference)?l.height=c:l.height+=c),BoundingSphere.clone(i.boundingSphere,t),t.center=o.cartographicToCartesian(l),BoundingSphereState$1.DONE}return BoundingSphere.clone(i.boundingSphere,t),BoundingSphereState$1.DONE};ModelVisualizer.prototype._onCollectionChanged=function(e,t,n,i){let r,o;const a=this._entitiesToVisualize,s=this._modelHash,l=this._primitives;for(r=t.length-1;r>-1;r--)o=t[r],defined(o._model)&&defined(o._position)&&a.set(o.id,o);for(r=i.length-1;r>-1;r--)o=i[r],defined(o._model)&&defined(o._position)?(clearNodeTransformationsArticulationsScratch(o,s),a.set(o.id,o)):(removeModel(this,o,s,l),a.remove(o.id));for(r=n.length-1;r>-1;r--)o=n[r],removeModel(this,o,s,l),a.remove(o.id)};function removeModel(e,t,n,i){const r=n[t.id];defined(r)&&(i.removeAndDestroy(r.modelPrimitive),delete n[t.id])}function clearNodeTransformationsArticulationsScratch(e,t){const n=t[e.id];defined(n)&&(n.nodeTransformationsScratch={},n.articulationsScratch={})}const defaultResolution=60,defaultWidth=1,scratchTimeInterval=new TimeInterval,subSampleCompositePropertyScratch=new TimeInterval,subSampleIntervalPropertyScratch=new TimeInterval;function EntityData$1(e){this.entity=e,this.polyline=void 0,this.index=void 0,this.updater=void 0}function subSampleSampledProperty(e,t,n,i,r,o,a,s,l){let c=s,d;d=e.getValueInReferenceFrame(t,o,l[c]),defined(d)&&(l[c++]=d);let h=!defined(r)||JulianDate.lessThanOrEquals(r,t)||JulianDate.greaterThanOrEquals(r,n),f=0;const p=i.length;let u=i[f];const m=n;let g=!1,_,C,A;for(;f<p;){if(!h&&JulianDate.greaterThanOrEquals(u,r)&&(d=e.getValueInReferenceFrame(r,o,l[c]),defined(d)&&(l[c++]=d),h=!0),JulianDate.greaterThan(u,t)&&JulianDate.lessThan(u,m)&&!u.equals(r)&&(d=e.getValueInReferenceFrame(u,o,l[c]),defined(d)&&(l[c++]=d)),f<p-1){if(a>0&&!g){const S=i[f+1],v=JulianDate.secondsDifference(S,u);g=v>a,g&&(_=Math.ceil(v/a),C=0,A=v/Math.max(_,2),_=Math.max(_-1,1))}if(g&&C<_){u=JulianDate.addSeconds(u,A,new JulianDate),C++;continue}}g=!1,f++,u=i[f]}return d=e.getValueInReferenceFrame(n,o,l[c]),defined(d)&&(l[c++]=d),c}function subSampleGenericProperty(e,t,n,i,r,o,a,s){let l,c=0,d=a,h=t;const f=Math.max(o,60);let p=!defined(i)||JulianDate.lessThanOrEquals(i,t)||JulianDate.greaterThanOrEquals(i,n);for(;JulianDate.lessThan(h,n);)!p&&JulianDate.greaterThanOrEquals(h,i)&&(p=!0,l=e.getValueInReferenceFrame(i,r,s[d]),defined(l)&&(s[d]=l,d++)),l=e.getValueInReferenceFrame(h,r,s[d]),defined(l)&&(s[d]=l,d++),c++,h=JulianDate.addSeconds(t,f*c,new JulianDate);return l=e.getValueInReferenceFrame(n,r,s[d]),defined(l)&&(s[d]=l,d++),d}function subSampleIntervalProperty(e,t,n,i,r,o,a,s){subSampleIntervalPropertyScratch.start=t,subSampleIntervalPropertyScratch.stop=n;let l=a;const c=e.intervals;for(let d=0;d<c.length;d++){const h=c.get(d);if(!TimeInterval.intersect(h,subSampleIntervalPropertyScratch,scratchTimeInterval).isEmpty){let f=h.start;h.isStartIncluded||(h.isStopIncluded?f=h.stop:f=JulianDate.addSeconds(h.start,JulianDate.secondsDifference(h.stop,h.start)/2,new JulianDate));const p=e.getValueInReferenceFrame(f,r,s[l]);defined(p)&&(s[l]=p,l++)}}return l}function subSampleConstantProperty(e,t,n,i,r,o,a,s){const l=e.getValueInReferenceFrame(t,r,s[a]);return defined(l)&&(s[a++]=l),a}function subSampleCompositeProperty(e,t,n,i,r,o,a,s){subSampleCompositePropertyScratch.start=t,subSampleCompositePropertyScratch.stop=n;let l=a;const c=e.intervals;for(let d=0;d<c.length;d++){const h=c.get(d);if(!TimeInterval.intersect(h,subSampleCompositePropertyScratch,scratchTimeInterval).isEmpty){const f=h.start,p=h.stop;let u=t;JulianDate.greaterThan(f,u)&&(u=f);let m=n;JulianDate.lessThan(p,m)&&(m=p),l=reallySubSample(h.data,u,m,i,r,o,l,s)}}return l}function reallySubSample(e,t,n,i,r,o,a,s){for(;e instanceof ReferenceProperty;)e=e.resolvedProperty;if(e instanceof SampledPositionProperty){const l=e._property._times;a=subSampleSampledProperty(e,t,n,l,i,r,o,a,s)}else e instanceof CompositePositionProperty?a=subSampleCompositeProperty(e,t,n,i,r,o,a,s):e instanceof TimeIntervalCollectionPositionProperty?a=subSampleIntervalProperty(e,t,n,i,r,o,a,s):e instanceof ConstantPositionProperty||e instanceof ScaledPositionProperty&&Property.isConstant(e)?a=subSampleConstantProperty(e,t,n,i,r,o,a,s):a=subSampleGenericProperty(e,t,n,i,r,o,a,s);return a}function subSample(e,t,n,i,r,o,a){defined(a)||(a=[]);const s=reallySubSample(e,t,n,i,r,o,0,a);return a.length=s,a}const toFixedScratch=new Matrix3;function PolylineUpdater(e,t){this._unusedIndexes=[],this._polylineCollection=new PolylineCollection,this._scene=e,this._referenceFrame=t,e.primitives.add(this._polylineCollection)}PolylineUpdater.prototype.update=function(e){if(this._referenceFrame===ReferenceFrame.INERTIAL){let t=Transforms.computeIcrfToFixedMatrix(e,toFixedScratch);defined(t)||(t=Transforms.computeTemeToPseudoFixedMatrix(e,toFixedScratch)),Matrix4.fromRotationTranslation(t,Cartesian3.ZERO,this._polylineCollection.modelMatrix)}};PolylineUpdater.prototype.updateObject=function(e,t){const n=t.entity,i=n._path,r=n._position;let o,a;const s=i._show;let l=t.polyline,c=n.isShowing&&n.isAvailable(e)&&(!defined(s)||s.getValue(e));if(c){const h=Property.getValueOrUndefined(i._leadTime,e),f=Property.getValueOrUndefined(i._trailTime,e),p=n._availability,u=defined(p),m=defined(h),g=defined(f);if(c=u||m&&g,c){if(g&&(o=JulianDate.addSeconds(e,-f,new JulianDate)),m&&(a=JulianDate.addSeconds(e,h,new JulianDate)),u){const _=p.start,C=p.stop;(!g||JulianDate.greaterThan(_,o))&&(o=_),(!m||JulianDate.lessThan(C,a))&&(a=C)}c=JulianDate.lessThan(o,a)}}if(!c){defined(l)&&(this._unusedIndexes.push(t.index),t.polyline=void 0,l.show=!1,t.index=void 0);return}if(!defined(l)){const h=this._unusedIndexes;if(h.length>0){const p=h.pop();l=this._polylineCollection.get(p),t.index=p}else t.index=this._polylineCollection.length,l=this._polylineCollection.add();l.id=n,t.polyline=l}const d=Property.getValueOrDefault(i._resolution,e,defaultResolution);l.show=!0,l.positions=subSample(r,o,a,e,this._referenceFrame,d,l.positions.slice()),l.material=MaterialProperty.getValue(e,i._material,l.material),l.width=Property.getValueOrDefault(i._width,e,defaultWidth),l.distanceDisplayCondition=Property.getValueOrUndefined(i._distanceDisplayCondition,e,l.distanceDisplayCondition)};PolylineUpdater.prototype.removeObject=function(e){const t=e.polyline;defined(t)&&(this._unusedIndexes.push(e.index),e.polyline=void 0,t.show=!1,t.id=void 0,e.index=void 0)};PolylineUpdater.prototype.destroy=function(){return this._scene.primitives.remove(this._polylineCollection),destroyObject(this)};function PathVisualizer(e,t){if(!defined(e))throw new DeveloperError("scene is required.");if(!defined(t))throw new DeveloperError("entityCollection is required.");t.collectionChanged.addEventListener(PathVisualizer.prototype._onCollectionChanged,this),this._scene=e,this._updaters={},this._entityCollection=t,this._items=new AssociativeArray,this._onCollectionChanged(t,t.values,[],[])}PathVisualizer.prototype.update=function(e){if(!defined(e))throw new DeveloperError("time is required.");const t=this._updaters;for(const i in t)t.hasOwnProperty(i)&&t[i].update(e);const n=this._items.values;if(n.length===0&&defined(this._updaters)&&Object.keys(this._updaters).length>0){for(const i in t)t.hasOwnProperty(i)&&t[i].destroy();this._updaters={}}for(let i=0,r=n.length;i<r;i++){const o=n[i],s=o.entity._position,l=o.updater;let c=ReferenceFrame.FIXED;this._scene.mode===SceneMode.SCENE3D&&(c=s.referenceFrame);let d=this._updaters[c];if(l===d&&defined(d)){d.updateObject(e,o);continue}defined(l)&&l.removeObject(o),defined(d)||(d=new PolylineUpdater(this._scene,c),d.update(e),this._updaters[c]=d),o.updater=d,defined(d)&&d.updateObject(e,o)}return!0};PathVisualizer.prototype.isDestroyed=function(){return!1};PathVisualizer.prototype.destroy=function(){this._entityCollection.collectionChanged.removeEventListener(PathVisualizer.prototype._onCollectionChanged,this);const e=this._updaters;for(const t in e)e.hasOwnProperty(t)&&e[t].destroy();return destroyObject(this)};PathVisualizer.prototype._onCollectionChanged=function(e,t,n,i){let r,o,a;const s=this._items;for(r=t.length-1;r>-1;r--)o=t[r],defined(o._path)&&defined(o._position)&&s.set(o.id,new EntityData$1(o));for(r=i.length-1;r>-1;r--)o=i[r],defined(o._path)&&defined(o._position)?s.contains(o.id)||s.set(o.id,new EntityData$1(o)):(a=s.get(o.id),defined(a)&&(defined(a.updater)&&a.updater.removeObject(a),s.remove(o.id)));for(r=n.length-1;r>-1;r--)o=n[r],a=s.get(o.id),defined(a)&&(defined(a.updater)&&a.updater.removeObject(a),s.remove(o.id))};PathVisualizer._subSample=subSample;const defaultColor$1=Color.WHITE,defaultOutlineColor=Color.BLACK,defaultOutlineWidth=0,defaultPixelSize=1,defaultDisableDepthTestDistance=0,colorScratch$2=new Color,positionScratch=new Cartesian3,outlineColorScratch=new Color,scaleByDistanceScratch=new NearFarScalar,translucencyByDistanceScratch=new NearFarScalar,distanceDisplayConditionScratch$1=new DistanceDisplayCondition;function EntityData(e){this.entity=e,this.pointPrimitive=void 0,this.billboard=void 0,this.color=void 0,this.outlineColor=void 0,this.pixelSize=void 0,this.outlineWidth=void 0}function PointVisualizer(e,t){if(!defined(e))throw new DeveloperError("entityCluster is required.");if(!defined(t))throw new DeveloperError("entityCollection is required.");t.collectionChanged.addEventListener(PointVisualizer.prototype._onCollectionChanged,this),this._cluster=e,this._entityCollection=t,this._items=new AssociativeArray,this._onCollectionChanged(t,t.values,[],[])}PointVisualizer.prototype.update=function(e){if(!defined(e))throw new DeveloperError("time is required.");const t=this._items.values,n=this._cluster;for(let i=0,r=t.length;i<r;i++){const o=t[i],a=o.entity,s=a._point;let l=o.pointPrimitive,c=o.billboard;const d=Property.getValueOrDefault(s._heightReference,e,HeightReference.NONE);let h=a.isShowing&&a.isAvailable(e)&&Property.getValueOrDefault(s._show,e,!0),f;if(h&&(f=Property.getValueOrUndefined(a._position,e,positionScratch),h=defined(f)),!h){returnPrimitive(o,a,n);continue}Property.isConstant(a._position)||(n._clusterDirty=!0);let p=!1,u=!1;if(d!==HeightReference.NONE&&!defined(c)?(defined(l)&&(returnPrimitive(o,a,n),l=void 0),c=n.getBillboard(a),c.id=a,c.image=void 0,o.billboard=c,p=!0,u=Cartesian3.equals(c.position,f)&&c.heightReference===d):d===HeightReference.NONE&&!defined(l)&&(defined(c)&&(returnPrimitive(o,a,n),c=void 0),l=n.getPoint(a),l.id=a,o.pointPrimitive=l),defined(l))l.show=!0,l.position=f,l.scaleByDistance=Property.getValueOrUndefined(s._scaleByDistance,e,scaleByDistanceScratch),l.translucencyByDistance=Property.getValueOrUndefined(s._translucencyByDistance,e,translucencyByDistanceScratch),l.color=Property.getValueOrDefault(s._color,e,defaultColor$1,colorScratch$2),l.outlineColor=Property.getValueOrDefault(s._outlineColor,e,defaultOutlineColor,outlineColorScratch),l.outlineWidth=Property.getValueOrDefault(s._outlineWidth,e,defaultOutlineWidth),l.pixelSize=Property.getValueOrDefault(s._pixelSize,e,defaultPixelSize),l.distanceDisplayCondition=Property.getValueOrUndefined(s._distanceDisplayCondition,e,distanceDisplayConditionScratch$1),l.disableDepthTestDistance=Property.getValueOrDefault(s._disableDepthTestDistance,e,defaultDisableDepthTestDistance);else if(defined(c)){c.show=!0,c.position=f,c.scaleByDistance=Property.getValueOrUndefined(s._scaleByDistance,e,scaleByDistanceScratch),c.translucencyByDistance=Property.getValueOrUndefined(s._translucencyByDistance,e,translucencyByDistanceScratch),c.distanceDisplayCondition=Property.getValueOrUndefined(s._distanceDisplayCondition,e,distanceDisplayConditionScratch$1),c.disableDepthTestDistance=Property.getValueOrDefault(s._disableDepthTestDistance,e,defaultDisableDepthTestDistance),c.heightReference=d;const m=Property.getValueOrDefault(s._color,e,defaultColor$1,colorScratch$2),g=Property.getValueOrDefault(s._outlineColor,e,defaultOutlineColor,outlineColorScratch),_=Math.round(Property.getValueOrDefault(s._outlineWidth,e,defaultOutlineWidth));let C=Math.max(1,Math.round(Property.getValueOrDefault(s._pixelSize,e,defaultPixelSize)));if(_>0?(c.scale=1,p=p||_!==o.outlineWidth||C!==o.pixelSize||!Color.equals(m,o.color)||!Color.equals(g,o.outlineColor)):(c.scale=C/50,C=50,p=p||_!==o.outlineWidth||!Color.equals(m,o.color)||!Color.equals(g,o.outlineColor)),p){o.color=Color.clone(m,o.color),o.outlineColor=Color.clone(g,o.outlineColor),o.pixelSize=C,o.outlineWidth=_;const A=m.alpha,S=m.toCssColorString(),v=g.toCssColorString(),b=JSON.stringify([S,C,v,_]);c.setImage(b,createBillboardPointCallback(A,S,v,_,C))}u&&c._updateClamping()}}return!0};PointVisualizer.prototype.getBoundingSphere=function(e,t){if(!defined(e))throw new DeveloperError("entity is required.");if(!defined(t))throw new DeveloperError("result is required.");const n=this._items.get(e.id);if(!defined(n)||!(defined(n.pointPrimitive)||defined(n.billboard)))return BoundingSphereState$1.FAILED;if(defined(n.pointPrimitive))t.center=Cartesian3.clone(n.pointPrimitive.position,t.center);else{const i=n.billboard;if(!defined(i._clampedPosition))return BoundingSphereState$1.PENDING;t.center=Cartesian3.clone(i._clampedPosition,t.center)}return t.radius=0,BoundingSphereState$1.DONE};PointVisualizer.prototype.isDestroyed=function(){return!1};PointVisualizer.prototype.destroy=function(){this._entityCollection.collectionChanged.removeEventListener(PointVisualizer.prototype._onCollectionChanged,this);const e=this._entityCollection.values;for(let t=0;t<e.length;t++)this._cluster.removePoint(e[t]);return destroyObject(this)};PointVisualizer.prototype._onCollectionChanged=function(e,t,n,i){let r,o;const a=this._items,s=this._cluster;for(r=t.length-1;r>-1;r--)o=t[r],defined(o._point)&&defined(o._position)&&a.set(o.id,new EntityData(o));for(r=i.length-1;r>-1;r--)o=i[r],defined(o._point)&&defined(o._position)?a.contains(o.id)||a.set(o.id,new EntityData(o)):(returnPrimitive(a.get(o.id),o,s),a.remove(o.id));for(r=n.length-1;r>-1;r--)o=n[r],returnPrimitive(a.get(o.id),o,s),a.remove(o.id)};function returnPrimitive(e,t,n){if(defined(e)){const i=e.pointPrimitive;if(defined(i)){e.pointPrimitive=void 0,n.removePoint(t);return}const r=e.billboard;defined(r)&&(e.billboard=void 0,n.removeBillboard(t))}}const scratchInterpolateColorsArray=[];function interpolateColors$1(e,t,n,i,r){const o=scratchInterpolateColorsArray;o.length=r;let a;const s=n.red,l=n.green,c=n.blue,d=n.alpha,h=i.red,f=i.green,p=i.blue,u=i.alpha;if(Color.equals(n,i)){for(a=0;a<r;a++)o[a]=Color.clone(n);return o}const m=(h-s)/r,g=(f-l)/r,_=(p-c)/r,C=(u-d)/r;for(a=0;a<r;a++)o[a]=new Color(s+a*m,l+a*g,c+a*_,d+a*C);return o}function PolylineGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.positions,n=e.colors,i=defaultValue(e.width,1),r=defaultValue(e.colorsPerVertex,!1);if(!defined(t)||t.length<2)throw new DeveloperError("At least two positions are required.");if(typeof i!="number")throw new DeveloperError("width must be a number");if(defined(n)&&(r&&n.length<t.length||!r&&n.length<t.length-1))throw new DeveloperError("colors has an invalid length.");this._positions=t,this._colors=n,this._width=i,this._colorsPerVertex=r,this._vertexFormat=VertexFormat.clone(defaultValue(e.vertexFormat,VertexFormat.DEFAULT)),this._arcType=defaultValue(e.arcType,ArcType.GEODESIC),this._granularity=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=Ellipsoid.clone(defaultValue(e.ellipsoid,Ellipsoid.default)),this._workerName="createPolylineGeometry";let o=1+t.length*Cartesian3.packedLength;o+=defined(n)?1+n.length*Color.packedLength:1,this.packedLength=o+Ellipsoid.packedLength+VertexFormat.packedLength+4}PolylineGeometry.pack=function(e,t,n){if(!defined(e))throw new DeveloperError("value is required");if(!defined(t))throw new DeveloperError("array is required");n=defaultValue(n,0);let i;const r=e._positions;let o=r.length;for(t[n++]=o,i=0;i<o;++i,n+=Cartesian3.packedLength)Cartesian3.pack(r[i],t,n);const a=e._colors;for(o=defined(a)?a.length:0,t[n++]=o,i=0;i<o;++i,n+=Color.packedLength)Color.pack(a[i],t,n);return Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,VertexFormat.pack(e._vertexFormat,t,n),n+=VertexFormat.packedLength,t[n++]=e._width,t[n++]=e._colorsPerVertex?1:0,t[n++]=e._arcType,t[n]=e._granularity,t};const scratchEllipsoid$1=Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),scratchVertexFormat$1=new VertexFormat,scratchOptions$3={positions:void 0,colors:void 0,ellipsoid:scratchEllipsoid$1,vertexFormat:scratchVertexFormat$1,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};PolylineGeometry.unpack=function(e,t,n){if(!defined(e))throw new DeveloperError("array is required");t=defaultValue(t,0);let i,r=e[t++];const o=new Array(r);for(i=0;i<r;++i,t+=Cartesian3.packedLength)o[i]=Cartesian3.unpack(e,t);r=e[t++];const a=r>0?new Array(r):void 0;for(i=0;i<r;++i,t+=Color.packedLength)a[i]=Color.unpack(e,t);const s=Ellipsoid.unpack(e,t,scratchEllipsoid$1);t+=Ellipsoid.packedLength;const l=VertexFormat.unpack(e,t,scratchVertexFormat$1);t+=VertexFormat.packedLength;const c=e[t++],d=e[t++]===1,h=e[t++],f=e[t];return defined(n)?(n._positions=o,n._colors=a,n._ellipsoid=Ellipsoid.clone(s,n._ellipsoid),n._vertexFormat=VertexFormat.clone(l,n._vertexFormat),n._width=c,n._colorsPerVertex=d,n._arcType=h,n._granularity=f,n):(scratchOptions$3.positions=o,scratchOptions$3.colors=a,scratchOptions$3.width=c,scratchOptions$3.colorsPerVertex=d,scratchOptions$3.arcType=h,scratchOptions$3.granularity=f,new PolylineGeometry(scratchOptions$3))};const scratchCartesian3$4=new Cartesian3,scratchPosition$4=new Cartesian3,scratchPrevPosition=new Cartesian3,scratchNextPosition=new Cartesian3;PolylineGeometry.createGeometry=function(e){const t=e._width,n=e._vertexFormat;let i=e._colors;const r=e._colorsPerVertex,o=e._arcType,a=e._granularity,s=e._ellipsoid;let l,c,d;const h=[];let f=arrayRemoveDuplicates(e._positions,Cartesian3.equalsEpsilon,!1,h);if(defined(i)&&h.length>0){let P=0,M=h[0];i=i.filter(function(O,V){let R=!1;return r?R=V===M||V===0&&M===1:R=V+1===M,R?(P++,M=h[P],!1):!0})}let p=f.length;if(p<2||t<=0)return;if(o===ArcType.GEODESIC||o===ArcType.RHUMB){let P,M;o===ArcType.GEODESIC?(P=CesiumMath.chordLength(a,s.maximumRadius),M=PolylinePipeline.numberOfPoints):(P=a,M=PolylinePipeline.numberOfPointsRhumbLine);const O=PolylinePipeline.extractHeights(f,s);if(defined(i)){let V=1;for(l=0;l<p-1;++l)V+=M(f[l],f[l+1],P);const R=new Array(V);let w=0;for(l=0;l<p-1;++l){const U=f[l],k=f[l+1],H=i[l],F=M(U,k,P);if(r&&l<V){const G=i[l+1],B=interpolateColors$1(U,k,H,G,F),W=B.length;for(c=0;c<W;++c)R[w++]=B[c]}else for(c=0;c<F;++c)R[w++]=Color.clone(H)}R[w]=Color.clone(i[i.length-1]),i=R,scratchInterpolateColorsArray.length=0}o===ArcType.GEODESIC?f=PolylinePipeline.generateCartesianArc({positions:f,minDistance:P,ellipsoid:s,height:O}):f=PolylinePipeline.generateCartesianRhumbArc({positions:f,granularity:P,ellipsoid:s,height:O})}p=f.length;const u=p*4-4,m=new Float64Array(u*3),g=new Float64Array(u*3),_=new Float64Array(u*3),C=new Float32Array(u*2),A=n.st?new Float32Array(u*2):void 0,S=defined(i)?new Uint8Array(u*4):void 0;let v=0,b=0,D=0,I=0,L;for(c=0;c<p;++c){c===0?(L=scratchCartesian3$4,Cartesian3.subtract(f[0],f[1],L),Cartesian3.add(f[0],L,L)):L=f[c-1],Cartesian3.clone(L,scratchPrevPosition),Cartesian3.clone(f[c],scratchPosition$4),c===p-1?(L=scratchCartesian3$4,Cartesian3.subtract(f[p-1],f[p-2],L),Cartesian3.add(f[p-1],L,L)):L=f[c+1],Cartesian3.clone(L,scratchNextPosition);let P,M;defined(S)&&(c!==0&&!r?P=i[c-1]:P=i[c],c!==p-1&&(M=i[c]));const O=c===0?2:0,V=c===p-1?2:4;for(d=O;d<V;++d){Cartesian3.pack(scratchPosition$4,m,v),Cartesian3.pack(scratchPrevPosition,g,v),Cartesian3.pack(scratchNextPosition,_,v),v+=3;const R=d-2<0?-1:1;if(C[b++]=2*(d%2)-1,C[b++]=R*t,n.st&&(A[D++]=c/(p-1),A[D++]=Math.max(C[b-2],0)),defined(S)){const w=d<2?P:M;S[I++]=Color.floatToByte(w.red),S[I++]=Color.floatToByte(w.green),S[I++]=Color.floatToByte(w.blue),S[I++]=Color.floatToByte(w.alpha)}}}const N=new GeometryAttributes;N.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:m}),N.prevPosition=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:g}),N.nextPosition=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:_}),N.expandAndWidth=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:C}),n.st&&(N.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:A})),defined(S)&&(N.color=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:S,normalize:!0}));const y=IndexDatatype.createTypedArray(u,p*6-6);let x=0,T=0;const E=p-1;for(c=0;c<E;++c)y[T++]=x,y[T++]=x+2,y[T++]=x+1,y[T++]=x+1,y[T++]=x+2,y[T++]=x+3,x+=4;return new Geometry({attributes:N,indices:y,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:BoundingSphere.fromPoints(f),geometryType:GeometryType.POLYLINES})};const defaultZIndex=new ConstantProperty(0),polylineCollections={},scratchColor$5=new Color,defaultMaterial=new ColorMaterialProperty(Color.WHITE),defaultShow=new ConstantProperty(!0),defaultShadows=new ConstantProperty(ShadowMode.DISABLED),defaultDistanceDisplayCondition$1=new ConstantProperty(new DistanceDisplayCondition),defaultClassificationType=new ConstantProperty(ClassificationType.BOTH);function GeometryOptions(){this.vertexFormat=void 0,this.positions=void 0,this.width=void 0,this.arcType=void 0,this.granularity=void 0}function GroundGeometryOptions(){this.positions=void 0,this.width=void 0,this.arcType=void 0,this.granularity=void 0}function PolylineGeometryUpdater(e,t){if(!defined(e))throw new DeveloperError("entity is required");if(!defined(t))throw new DeveloperError("scene is required");this._entity=e,this._scene=t,this._entitySubscription=e.definitionChanged.addEventListener(PolylineGeometryUpdater.prototype._onEntityPropertyChanged,this),this._fillEnabled=!1,this._dynamic=!1,this._geometryChanged=new Event,this._showProperty=void 0,this._materialProperty=void 0,this._shadowsProperty=void 0,this._distanceDisplayConditionProperty=void 0,this._classificationTypeProperty=void 0,this._depthFailMaterialProperty=void 0,this._geometryOptions=new GeometryOptions,this._groundGeometryOptions=new GroundGeometryOptions,this._id=`polyline-${e.id}`,this._clampToGround=!1,this._supportsPolylinesOnTerrain=Entity.supportsPolylinesOnTerrain(t),this._zIndex=0,this._onEntityPropertyChanged(e,"polyline",e.polyline,void 0)}Object.defineProperties(PolylineGeometryUpdater.prototype,{id:{get:function(){return this._id}},entity:{get:function(){return this._entity}},fillEnabled:{get:function(){return this._fillEnabled}},hasConstantFill:{get:function(){return!this._fillEnabled||!defined(this._entity.availability)&&Property.isConstant(this._showProperty)}},fillMaterialProperty:{get:function(){return this._materialProperty}},depthFailMaterialProperty:{get:function(){return this._depthFailMaterialProperty}},outlineEnabled:{value:!1},hasConstantOutline:{value:!0},outlineColorProperty:{value:void 0},shadowsProperty:{get:function(){return this._shadowsProperty}},distanceDisplayConditionProperty:{get:function(){return this._distanceDisplayConditionProperty}},classificationTypeProperty:{get:function(){return this._classificationTypeProperty}},isDynamic:{get:function(){return this._dynamic}},isClosed:{value:!1},geometryChanged:{get:function(){return this._geometryChanged}},arcType:{get:function(){return this._arcType}},clampToGround:{get:function(){return this._clampToGround&&this._supportsPolylinesOnTerrain}},zIndex:{get:function(){return this._zIndex}}});PolylineGeometryUpdater.prototype.isOutlineVisible=function(e){return!1};PolylineGeometryUpdater.prototype.isFilled=function(e){const t=this._entity,n=this._fillEnabled&&t.isAvailable(e)&&this._showProperty.getValue(e);return defaultValue(n,!1)};PolylineGeometryUpdater.prototype.createFillGeometryInstance=function(e){if(!defined(e))throw new DeveloperError("time is required.");if(!this._fillEnabled)throw new DeveloperError("This instance does not represent a filled geometry.");const t=this._entity,n=t.isAvailable(e),i=new ShowGeometryInstanceAttribute(n&&t.isShowing&&this._showProperty.getValue(e)),r=this._distanceDisplayConditionProperty.getValue(e),o=DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(r),a={show:i,distanceDisplayCondition:o};let s;return this._materialProperty instanceof ColorMaterialProperty&&(defined(this._materialProperty.color)&&(this._materialProperty.color.isConstant||n)&&(s=this._materialProperty.color.getValue(e,scratchColor$5)),defined(s)||(s=Color.WHITE),a.color=ColorGeometryInstanceAttribute.fromColor(s)),this.clampToGround?new GeometryInstance({id:t,geometry:new GroundPolylineGeometry(this._groundGeometryOptions),attributes:a}):(defined(this._depthFailMaterialProperty)&&this._depthFailMaterialProperty instanceof ColorMaterialProperty&&(defined(this._depthFailMaterialProperty.color)&&(this._depthFailMaterialProperty.color.isConstant||n)&&(s=this._depthFailMaterialProperty.color.getValue(e,scratchColor$5)),defined(s)||(s=Color.WHITE),a.depthFailColor=ColorGeometryInstanceAttribute.fromColor(s)),new GeometryInstance({id:t,geometry:new PolylineGeometry(this._geometryOptions),attributes:a}))};PolylineGeometryUpdater.prototype.createOutlineGeometryInstance=function(e){throw new DeveloperError("This instance does not represent an outlined geometry.")};PolylineGeometryUpdater.prototype.isDestroyed=function(){return!1};PolylineGeometryUpdater.prototype.destroy=function(){this._entitySubscription(),destroyObject(this)};PolylineGeometryUpdater.prototype._onEntityPropertyChanged=function(e,t,n,i){if(!(t==="availability"||t==="polyline"))return;const r=this._entity.polyline;if(!defined(r)){this._fillEnabled&&(this._fillEnabled=!1,this._geometryChanged.raiseEvent(this));return}const o=r.positions,a=r.show;if(defined(a)&&a.isConstant&&!a.getValue(Iso8601.MINIMUM_VALUE)||!defined(o)){this._fillEnabled&&(this._fillEnabled=!1,this._geometryChanged.raiseEvent(this));return}const s=r.zIndex,l=defaultValue(r.material,defaultMaterial),c=l instanceof ColorMaterialProperty;this._materialProperty=l,this._depthFailMaterialProperty=r.depthFailMaterial,this._showProperty=defaultValue(a,defaultShow),this._shadowsProperty=defaultValue(r.shadows,defaultShadows),this._distanceDisplayConditionProperty=defaultValue(r.distanceDisplayCondition,defaultDistanceDisplayCondition$1),this._classificationTypeProperty=defaultValue(r.classificationType,defaultClassificationType),this._fillEnabled=!0,this._zIndex=defaultValue(s,defaultZIndex);const d=r.width,h=r.arcType,f=r.clampToGround,p=r.granularity;if(!o.isConstant||!Property.isConstant(d)||!Property.isConstant(h)||!Property.isConstant(p)||!Property.isConstant(f)||!Property.isConstant(s))this._dynamic||(this._dynamic=!0,this._geometryChanged.raiseEvent(this));else{const u=this._geometryOptions,m=o.getValue(Iso8601.MINIMUM_VALUE,u.positions);if(!defined(m)||m.length<2){this._fillEnabled&&(this._fillEnabled=!1,this._geometryChanged.raiseEvent(this));return}let g;c&&(!defined(this._depthFailMaterialProperty)||this._depthFailMaterialProperty instanceof ColorMaterialProperty)?g=PolylineColorAppearance.VERTEX_FORMAT:g=PolylineMaterialAppearance.VERTEX_FORMAT,u.vertexFormat=g,u.positions=m,u.width=defined(d)?d.getValue(Iso8601.MINIMUM_VALUE):void 0,u.arcType=defined(h)?h.getValue(Iso8601.MINIMUM_VALUE):void 0,u.granularity=defined(p)?p.getValue(Iso8601.MINIMUM_VALUE):void 0;const _=this._groundGeometryOptions;_.positions=m,_.width=u.width,_.arcType=u.arcType,_.granularity=u.granularity,this._clampToGround=defined(f)?f.getValue(Iso8601.MINIMUM_VALUE):!1,!this._clampToGround&&defined(s)&&oneTimeWarning("Entity polylines must have clampToGround: true when using zIndex.  zIndex will be ignored."),this._dynamic=!1,this._geometryChanged.raiseEvent(this)}};PolylineGeometryUpdater.prototype.createDynamicUpdater=function(e,t){if(Check.defined("primitives",e),Check.defined("groundPrimitives",t),!this._dynamic)throw new DeveloperError("This instance does not represent dynamic geometry.");return new DynamicGeometryUpdater(e,t,this)};const generateCartesianArcOptions={positions:void 0,granularity:void 0,height:void 0,ellipsoid:void 0};function DynamicGeometryUpdater(e,t,n){this._line=void 0,this._primitives=e,this._groundPrimitives=t,this._groundPolylinePrimitive=void 0,this._material=void 0,this._geometryUpdater=n,this._positions=[]}function getLine(e){if(defined(e._line))return e._line;const t=e._primitives,n=e._geometryUpdater._scene.id+t._guid;let i=polylineCollections[n];!defined(i)||i.isDestroyed()?(i=new PolylineCollection,polylineCollections[n]=i,t.add(i)):t.contains(i)||t.add(i);const r=i.add();return r.id=e._geometryUpdater._entity,e._line=r,r}DynamicGeometryUpdater.prototype.update=function(e){const t=this._geometryUpdater,n=t._entity,i=n.polyline,r=i.positions;let o=Property.getValueOrUndefined(r,e,this._positions);t._clampToGround=Property.getValueOrDefault(i._clampToGround,e,!1),t._groundGeometryOptions.positions=o,t._groundGeometryOptions.width=Property.getValueOrDefault(i._width,e,1),t._groundGeometryOptions.arcType=Property.getValueOrDefault(i._arcType,e,ArcType.GEODESIC),t._groundGeometryOptions.granularity=Property.getValueOrDefault(i._granularity,e,9999);const a=this._groundPrimitives;if(defined(this._groundPolylinePrimitive)&&(a.remove(this._groundPolylinePrimitive),this._groundPolylinePrimitive=void 0),t.clampToGround){if(!n.isShowing||!n.isAvailable(e)||!Property.getValueOrDefault(i._show,e,!0)||!defined(o)||o.length<2)return;const h=t.fillMaterialProperty;let f;if(h instanceof ColorMaterialProperty)f=new PolylineColorAppearance;else{const p=MaterialProperty.getValue(e,h,this._material);f=new PolylineMaterialAppearance({material:p,translucent:p.isTranslucent()}),this._material=p}this._groundPolylinePrimitive=a.add(new GroundPolylinePrimitive({geometryInstances:t.createFillGeometryInstance(e),appearance:f,classificationType:t.classificationTypeProperty.getValue(e),asynchronous:!1}),Property.getValueOrUndefined(t.zIndex,e)),defined(this._line)&&(this._line.show=!1);return}const s=getLine(this);if(!n.isShowing||!n.isAvailable(e)||!Property.getValueOrDefault(i._show,e,!0)){s.show=!1;return}if(!defined(o)||o.length<2){s.show=!1;return}let l=ArcType.GEODESIC;l=Property.getValueOrDefault(i._arcType,e,l);const c=t._scene.globe,d=t._scene.ellipsoid;l!==ArcType.NONE&&defined(c)&&(generateCartesianArcOptions.ellipsoid=d,generateCartesianArcOptions.positions=o,generateCartesianArcOptions.granularity=Property.getValueOrUndefined(i._granularity,e),generateCartesianArcOptions.height=PolylinePipeline.extractHeights(o,d),l===ArcType.GEODESIC?o=PolylinePipeline.generateCartesianArc(generateCartesianArcOptions):o=PolylinePipeline.generateCartesianRhumbArc(generateCartesianArcOptions)),s.show=!0,s.positions=o.slice(),s.material=MaterialProperty.getValue(e,t.fillMaterialProperty,s.material),s.width=Property.getValueOrDefault(i._width,e,1),s.distanceDisplayCondition=Property.getValueOrUndefined(i._distanceDisplayCondition,e,s.distanceDisplayCondition)};DynamicGeometryUpdater.prototype.getBoundingSphere=function(e){if(Check.defined("result",e),this._geometryUpdater.clampToGround){const t=this._groundPolylinePrimitive;if(defined(t)&&t.show&&t.ready){const n=t.getGeometryInstanceAttributes(this._geometryUpdater._entity);if(defined(n)&&defined(n.boundingSphere))return BoundingSphere.clone(n.boundingSphere,e),BoundingSphereState$1.DONE}return defined(t)&&!t.ready?BoundingSphereState$1.PENDING:BoundingSphereState$1.DONE}else{const t=getLine(this);if(t.show&&t.positions.length>0)return BoundingSphere.fromPoints(t.positions,e),BoundingSphereState$1.DONE}return BoundingSphereState$1.FAILED};DynamicGeometryUpdater.prototype.isDestroyed=function(){return!1};DynamicGeometryUpdater.prototype.destroy=function(){const t=this._geometryUpdater._scene.id+this._primitives._guid,n=polylineCollections[t];defined(n)&&(n.remove(this._line),n.length===0&&(this._primitives.removeAndDestroy(n),delete polylineCollections[t])),defined(this._groundPolylinePrimitive)&&this._groundPrimitives.remove(this._groundPolylinePrimitive),destroyObject(this)};const scratchColor$4=new Color,distanceDisplayConditionScratch=new DistanceDisplayCondition,defaultDistanceDisplayCondition=new DistanceDisplayCondition;function Batch(e,t,n,i,r){let o;n instanceof ColorMaterialProperty?o=PolylineColorAppearance:o=PolylineMaterialAppearance,this.orderedGroundPrimitives=e,this.classificationType=t,this.appearanceType=o,this.materialProperty=n,this.updaters=new AssociativeArray,this.createPrimitive=!0,this.primitive=void 0,this.oldPrimitive=void 0,this.geometry=new AssociativeArray,this.material=void 0,this.updatersWithAttributes=new AssociativeArray,this.attributes=new AssociativeArray,this.invalidated=!1,this.removeMaterialSubscription=n.definitionChanged.addEventListener(Batch.prototype.onMaterialChanged,this),this.subscriptions=new AssociativeArray,this.showsUpdated=new AssociativeArray,this.zIndex=i,this._asynchronous=r}Batch.prototype.onMaterialChanged=function(){this.invalidated=!0};Batch.prototype.isMaterial=function(e){const t=this.materialProperty,n=e.fillMaterialProperty;return n===t||n instanceof ColorMaterialProperty&&t instanceof ColorMaterialProperty?!0:defined(t)&&t.equals(n)};Batch.prototype.add=function(e,t,n){const i=t.id;if(this.updaters.set(i,t),this.geometry.set(i,n),!t.hasConstantFill||!t.fillMaterialProperty.isConstant||!Property.isConstant(t.distanceDisplayConditionProperty))this.updatersWithAttributes.set(i,t);else{const r=this;this.subscriptions.set(i,t.entity.definitionChanged.addEventListener(function(o,a,s,l){a==="isShowing"&&r.showsUpdated.set(t.id,t)}))}this.createPrimitive=!0};Batch.prototype.remove=function(e){const t=e.id;if(this.createPrimitive=this.geometry.remove(t)||this.createPrimitive,this.updaters.remove(t)){this.updatersWithAttributes.remove(t);const n=this.subscriptions.get(t);return defined(n)&&(n(),this.subscriptions.remove(t)),!0}return!1};Batch.prototype.update=function(e){let t=!0,n=this.primitive;const i=this.orderedGroundPrimitives,r=this.geometry.values;let o;if(this.createPrimitive){if(r.length>0)defined(n)&&(defined(this.oldPrimitive)?i.remove(n):this.oldPrimitive=n),n=new GroundPolylinePrimitive({show:!1,asynchronous:this._asynchronous,geometryInstances:r.slice(),appearance:new this.appearanceType,classificationType:this.classificationType}),this.appearanceType===PolylineMaterialAppearance&&(this.material=MaterialProperty.getValue(e,this.materialProperty,this.material),n.appearance.material=this.material),i.add(n,this.zIndex),t=!1;else{defined(n)&&(i.remove(n),n=void 0);const s=this.oldPrimitive;defined(s)&&(i.remove(s),this.oldPrimitive=void 0)}this.attributes.removeAll(),this.primitive=n,this.createPrimitive=!1}else if(defined(n)&&n.ready){n.show=!0,defined(this.oldPrimitive)&&(i.remove(this.oldPrimitive),this.oldPrimitive=void 0),this.appearanceType===PolylineMaterialAppearance&&(this.material=MaterialProperty.getValue(e,this.materialProperty,this.material),this.primitive.appearance.material=this.material);const a=this.updatersWithAttributes.values,s=a.length;for(o=0;o<s;o++){const l=a[o],c=l.entity,d=this.geometry.get(l.id);let h=this.attributes.get(d.id.id);if(defined(h)||(h=n.getGeometryInstanceAttributes(d.id),this.attributes.set(d.id.id,h)),!l.fillMaterialProperty.isConstant){const m=l.fillMaterialProperty.color,g=Property.getValueOrDefault(m,e,Color.WHITE,scratchColor$4);Color.equals(h._lastColor,g)||(h._lastColor=Color.clone(g,h._lastColor),h.color=ColorGeometryInstanceAttribute.toValue(g,h.color))}const f=c.isShowing&&(l.hasConstantFill||l.isFilled(e)),p=h.show[0]===1;f!==p&&(h.show=ShowGeometryInstanceAttribute.toValue(f,h.show));const u=l.distanceDisplayConditionProperty;if(!Property.isConstant(u)){const m=Property.getValueOrDefault(u,e,defaultDistanceDisplayCondition,distanceDisplayConditionScratch);DistanceDisplayCondition.equals(m,h._lastDistanceDisplayCondition)||(h._lastDistanceDisplayCondition=DistanceDisplayCondition.clone(m,h._lastDistanceDisplayCondition),h.distanceDisplayCondition=DistanceDisplayConditionGeometryInstanceAttribute.toValue(m,h.distanceDisplayCondition))}}this.updateShows(n)}else defined(n)&&!n.ready&&(t=!1);return t};Batch.prototype.updateShows=function(e){const t=this.showsUpdated.values,n=t.length;for(let i=0;i<n;i++){const r=t[i],o=r.entity,a=this.geometry.get(r.id);let s=this.attributes.get(a.id.id);defined(s)||(s=e.getGeometryInstanceAttributes(a.id),this.attributes.set(a.id.id,s));const l=o.isShowing,c=s.show[0]===1;l!==c&&(s.show=ShowGeometryInstanceAttribute.toValue(l,s.show),a.attributes.show.value[0]=s.show[0])}this.showsUpdated.removeAll()};Batch.prototype.contains=function(e){return this.updaters.contains(e.id)};Batch.prototype.getBoundingSphere=function(e,t){const n=this.primitive;if(!n.ready)return BoundingSphereState$1.PENDING;const i=n.getGeometryInstanceAttributes(e.entity);return!defined(i)||!defined(i.boundingSphere)||defined(i.show)&&i.show[0]===0?BoundingSphereState$1.FAILED:(i.boundingSphere.clone(t),BoundingSphereState$1.DONE)};Batch.prototype.destroy=function(){const e=this.primitive,t=this.orderedGroundPrimitives;defined(e)&&t.remove(e);const n=this.oldPrimitive;defined(n)&&t.remove(n),this.removeMaterialSubscription()};function StaticGroundPolylinePerMaterialBatch(e,t,n){this._items=[],this._orderedGroundPrimitives=e,this._classificationType=t,this._asynchronous=defaultValue(n,!0)}StaticGroundPolylinePerMaterialBatch.prototype.add=function(e,t){const n=this._items,i=n.length,r=t.createFillGeometryInstance(e),o=Property.getValueOrDefault(t.zIndex,0);for(let s=0;s<i;++s){const l=n[s];if(l.isMaterial(t)&&l.zIndex===o){l.add(e,t,r);return}}const a=new Batch(this._orderedGroundPrimitives,this._classificationType,t.fillMaterialProperty,o,this._asynchronous);a.add(e,t,r),n.push(a)};StaticGroundPolylinePerMaterialBatch.prototype.remove=function(e){const t=this._items,n=t.length;for(let i=n-1;i>=0;i--){const r=t[i];if(r.remove(e)){r.updaters.length===0&&(t.splice(i,1),r.destroy());break}}};StaticGroundPolylinePerMaterialBatch.prototype.update=function(e){let t;const n=this._items,i=n.length;for(t=i-1;t>=0;t--){const o=n[t];if(o.invalidated){n.splice(t,1);const a=o.updaters.values,s=a.length;for(let l=0;l<s;l++)this.add(e,a[l]);o.destroy()}}let r=!0;for(t=0;t<n.length;t++)r=n[t].update(e)&&r;return r};StaticGroundPolylinePerMaterialBatch.prototype.getBoundingSphere=function(e,t){const n=this._items,i=n.length;for(let r=0;r<i;r++){const o=n[r];if(o.contains(e))return o.getBoundingSphere(e,t)}return BoundingSphereState$1.FAILED};StaticGroundPolylinePerMaterialBatch.prototype.removeAllPrimitives=function(){const e=this._items,t=e.length;for(let n=0;n<t;n++)e[n].destroy();this._items.length=0};const emptyArray=[];function removeUpdater(e,t){const n=e._batches,i=n.length;for(let r=0;r<i;r++)n[r].remove(t)}function insertUpdaterIntoBatch(e,t,n){if(n.isDynamic){e._dynamicBatch.add(t,n);return}if(n.clampToGround&&n.fillEnabled){const a=n.classificationTypeProperty.getValue(t);e._groundBatches[a].add(t,n);return}let i;n.fillEnabled&&(i=n.shadowsProperty.getValue(t));let r=0;defined(n.depthFailMaterialProperty)&&(r=n.depthFailMaterialProperty instanceof ColorMaterialProperty?1:2);let o;defined(i)&&(o=i+r*ShadowMode.NUMBER_OF_SHADOW_MODES),n.fillEnabled&&(n.fillMaterialProperty instanceof ColorMaterialProperty?e._colorBatches[o].add(t,n):e._materialBatches[o].add(t,n))}function PolylineVisualizer(e,t,n,i){Check.defined("scene",e),Check.defined("entityCollection",t),i=defaultValue(i,e.groundPrimitives),n=defaultValue(n,e.primitives),this._scene=e,this._primitives=n,this._entityCollection=void 0,this._addedObjects=new AssociativeArray,this._removedObjects=new AssociativeArray,this._changedObjects=new AssociativeArray;let r;const o=ShadowMode.NUMBER_OF_SHADOW_MODES;for(this._colorBatches=new Array(o*3),this._materialBatches=new Array(o*3),r=0;r<o;++r)this._colorBatches[r]=new StaticGeometryColorBatch(n,PolylineColorAppearance,void 0,!1,r),this._materialBatches[r]=new StaticGeometryPerMaterialBatch(n,PolylineMaterialAppearance,void 0,!1,r),this._colorBatches[r+o]=new StaticGeometryColorBatch(n,PolylineColorAppearance,PolylineColorAppearance,!1,r),this._materialBatches[r+o]=new StaticGeometryPerMaterialBatch(n,PolylineMaterialAppearance,PolylineColorAppearance,!1,r),this._colorBatches[r+o*2]=new StaticGeometryColorBatch(n,PolylineColorAppearance,PolylineMaterialAppearance,!1,r),this._materialBatches[r+o*2]=new StaticGeometryPerMaterialBatch(n,PolylineMaterialAppearance,PolylineMaterialAppearance,!1,r);this._dynamicBatch=new DynamicGeometryBatch(n,i);const a=ClassificationType.NUMBER_OF_CLASSIFICATION_TYPES;for(this._groundBatches=new Array(a),r=0;r<a;++r)this._groundBatches[r]=new StaticGroundPolylinePerMaterialBatch(i,r);this._batches=this._colorBatches.concat(this._materialBatches,this._dynamicBatch,this._groundBatches),this._subscriptions=new AssociativeArray,this._updaters=new AssociativeArray,this._entityCollection=t,t.collectionChanged.addEventListener(PolylineVisualizer.prototype._onCollectionChanged,this),this._onCollectionChanged(t,t.values,emptyArray)}PolylineVisualizer.prototype.update=function(e){Check.defined("time",e);const t=this._addedObjects,n=t.values,i=this._removedObjects,r=i.values,o=this._changedObjects,a=o.values;let s,l,c,d;for(s=a.length-1;s>-1;s--)l=a[s],c=l.id,d=this._updaters.get(c),d.entity===l?(removeUpdater(this,d),insertUpdaterIntoBatch(this,e,d)):(r.push(l),n.push(l));for(s=r.length-1;s>-1;s--)l=r[s],c=l.id,d=this._updaters.get(c),removeUpdater(this,d),d.destroy(),this._updaters.remove(c),this._subscriptions.get(c)(),this._subscriptions.remove(c);for(s=n.length-1;s>-1;s--)l=n[s],c=l.id,d=new PolylineGeometryUpdater(l,this._scene),this._updaters.set(c,d),insertUpdaterIntoBatch(this,e,d),this._subscriptions.set(c,d.geometryChanged.addEventListener(PolylineVisualizer._onGeometryChanged,this));t.removeAll(),i.removeAll(),o.removeAll();let h=!0;const f=this._batches,p=f.length;for(s=0;s<p;s++)h=f[s].update(e)&&h;return h};const getBoundingSphereArrayScratch$1=[],getBoundingSphereBoundingSphereScratch$1=new BoundingSphere;PolylineVisualizer.prototype.getBoundingSphere=function(e,t){Check.defined("entity",e),Check.defined("result",t);const n=getBoundingSphereArrayScratch$1,i=getBoundingSphereBoundingSphereScratch$1;let r=0,o=BoundingSphereState$1.DONE;const a=this._batches,s=a.length,l=this._updaters.get(e.id);for(let c=0;c<s;c++){if(o=a[c].getBoundingSphere(l,i),o===BoundingSphereState$1.PENDING)return BoundingSphereState$1.PENDING;o===BoundingSphereState$1.DONE&&(n[r]=BoundingSphere.clone(i,n[r]),r++)}return r===0?BoundingSphereState$1.FAILED:(n.length=r,BoundingSphere.fromBoundingSpheres(n,t),BoundingSphereState$1.DONE)};PolylineVisualizer.prototype.isDestroyed=function(){return!1};PolylineVisualizer.prototype.destroy=function(){this._entityCollection.collectionChanged.removeEventListener(PolylineVisualizer.prototype._onCollectionChanged,this),this._addedObjects.removeAll(),this._removedObjects.removeAll();let e;const t=this._batches;let n=t.length;for(e=0;e<n;e++)t[e].removeAllPrimitives();const i=this._subscriptions.values;for(n=i.length,e=0;e<n;e++)i[e]();return this._subscriptions.removeAll(),destroyObject(this)};PolylineVisualizer._onGeometryChanged=function(e){const t=this._removedObjects,n=this._changedObjects,i=e.entity,r=i.id;!defined(t.get(r))&&!defined(n.get(r))&&n.set(r,i)};PolylineVisualizer.prototype._onCollectionChanged=function(e,t,n){const i=this._addedObjects,r=this._removedObjects,o=this._changedObjects;let a,s,l;for(a=n.length-1;a>-1;a--)l=n[a],s=l.id,i.remove(s)||(r.set(s,l),o.remove(s));for(a=t.length-1;a>-1;a--)l=t[a],s=l.id,r.remove(s)?o.set(s,l):i.set(s,l)};function DataSourceDisplay(e){Check.typeOf.object("options",e),Check.typeOf.object("options.scene",e.scene),Check.typeOf.object("options.dataSourceCollection",e.dataSourceCollection),GroundPrimitive.initializeTerrainHeights(),GroundPolylinePrimitive.initializeTerrainHeights();const t=e.scene,n=e.dataSourceCollection;this._eventHelper=new EventHelper,this._eventHelper.add(n.dataSourceAdded,this._onDataSourceAdded,this),this._eventHelper.add(n.dataSourceRemoved,this._onDataSourceRemoved,this),this._eventHelper.add(n.dataSourceMoved,this._onDataSourceMoved,this),this._eventHelper.add(t.postRender,this._postRender,this),this._dataSourceCollection=n,this._scene=t,this._visualizersCallback=defaultValue(e.visualizersCallback,DataSourceDisplay.defaultVisualizersCallback);let i=!1;const r=new PrimitiveCollection,o=new PrimitiveCollection;n.length>0&&(t.primitives.add(r),t.groundPrimitives.add(o),i=!0),this._primitives=r,this._groundPrimitives=o;for(let c=0,d=n.length;c<d;c++)this._onDataSourceAdded(n,n.get(c));const a=new CustomDataSource;this._onDataSourceAdded(void 0,a),this._defaultDataSource=a;let s,l;if(!i){const c=this,d=function(){t.primitives.add(r),t.groundPrimitives.add(o),s(),l(),c._removeDefaultDataSourceListener=void 0,c._removeDataSourceCollectionListener=void 0};s=a.entities.collectionChanged.addEventListener(d),l=n.dataSourceAdded.addEventListener(d)}this._removeDefaultDataSourceListener=s,this._removeDataSourceCollectionListener=l,this._ready=!1}const ExtraVisualizers=[];DataSourceDisplay.registerVisualizer=function(e){ExtraVisualizers.includes(e)||ExtraVisualizers.push(e)};DataSourceDisplay.unregisterVisualizer=function(e){if(ExtraVisualizers.includes(e)){const t=ExtraVisualizers.indexOf(e);ExtraVisualizers.splice(t,1)}};DataSourceDisplay.defaultVisualizersCallback=function(e,t,n){const i=n.entities;return[new BillboardVisualizer(t,i),new GeometryVisualizer(e,i,n._primitives,n._groundPrimitives),new LabelVisualizer(t,i),new ModelVisualizer(e,i),new Cesium3DTilesetVisualizer(e,i),new PointVisualizer(t,i),new PathVisualizer(e,i),new PolylineVisualizer(e,i,n._primitives,n._groundPrimitives),...ExtraVisualizers.map(r=>new r(e,i))]};Object.defineProperties(DataSourceDisplay.prototype,{scene:{get:function(){return this._scene}},dataSources:{get:function(){return this._dataSourceCollection}},defaultDataSource:{get:function(){return this._defaultDataSource}},ready:{get:function(){return this._ready}}});DataSourceDisplay.prototype.isDestroyed=function(){return!1};DataSourceDisplay.prototype.destroy=function(){this._eventHelper.removeAll();const e=this._dataSourceCollection;for(let t=0,n=e.length;t<n;++t)this._onDataSourceRemoved(this._dataSourceCollection,e.get(t));return this._onDataSourceRemoved(void 0,this._defaultDataSource),defined(this._removeDefaultDataSourceListener)?(this._removeDefaultDataSourceListener(),this._removeDataSourceCollectionListener()):(this._scene.primitives.remove(this._primitives),this._scene.groundPrimitives.remove(this._groundPrimitives)),destroyObject(this)};DataSourceDisplay.prototype.update=function(e){if(Check.defined("time",e),!ApproximateTerrainHeights.initialized)return this._ready=!1,!1;let t=!0,n,i,r,o;const a=this._dataSourceCollection,s=a.length;for(n=0;n<s;n++){const l=a.get(n);for(defined(l.update)&&(t=l.update(e)&&t),r=l._visualizers,o=r.length,i=0;i<o;i++)t=r[i].update(e)&&t}for(r=this._defaultDataSource._visualizers,o=r.length,i=0;i<o;i++)t=r[i].update(e)&&t;return!this._ready&&t&&this._scene.requestRender(),this._ready=t,t};DataSourceDisplay.prototype._postRender=function(){const e=this._scene.frameState,t=this._dataSourceCollection,n=t.length;for(let i=0;i<n;i++){const r=t.get(i),o=r.credit;defined(o)&&e.creditDisplay.addCreditToNextFrame(o);const a=r._resourceCredits;if(defined(a)){const s=a.length;for(let l=0;l<s;l++)e.creditDisplay.addCreditToNextFrame(a[l])}}};const getBoundingSphereArrayScratch=[],getBoundingSphereBoundingSphereScratch=new BoundingSphere;DataSourceDisplay.prototype.getBoundingSphere=function(e,t,n){if(Check.defined("entity",e),Check.typeOf.bool("allowPartial",t),Check.defined("result",n),!this._ready)return BoundingSphereState$1.PENDING;let i,r,o=this._defaultDataSource;if(!o.entities.contains(e)){o=void 0;const f=this._dataSourceCollection;for(r=f.length,i=0;i<r;i++){const p=f.get(i);if(p.entities.contains(e)){o=p;break}}}if(!defined(o))return BoundingSphereState$1.FAILED;const a=getBoundingSphereArrayScratch,s=getBoundingSphereBoundingSphereScratch;let l=0,c=BoundingSphereState$1.DONE;const d=o._visualizers,h=d.length;for(i=0;i<h;i++){const f=d[i];if(defined(f.getBoundingSphere)){if(c=d[i].getBoundingSphere(e,s),!t&&c===BoundingSphereState$1.PENDING)return BoundingSphereState$1.PENDING;c===BoundingSphereState$1.DONE&&(a[l]=BoundingSphere.clone(s,a[l]),l++)}}return l===0?BoundingSphereState$1.FAILED:(a.length=l,BoundingSphere.fromBoundingSpheres(a,n),BoundingSphereState$1.DONE)};DataSourceDisplay.prototype._onDataSourceAdded=function(e,t){const n=this._scene,i=this._primitives,r=this._groundPrimitives,o=i.add(new PrimitiveCollection),a=r.add(new OrderedGroundPrimitiveCollection);t._primitives=o,t._groundPrimitives=a;const s=t.clustering;s._initialize(n),o.add(s),t._visualizers=this._visualizersCallback(n,s,t)};DataSourceDisplay.prototype._onDataSourceRemoved=function(e,t){const n=this._primitives,i=this._groundPrimitives,r=t._primitives,o=t._groundPrimitives,a=t.clustering;r.remove(a);const s=t._visualizers,l=s.length;for(let c=0;c<l;c++)s[c].destroy();n.remove(r),i.remove(o),t._visualizers=void 0};DataSourceDisplay.prototype._onDataSourceMoved=function(e,t,n){const i=this._primitives,r=this._groundPrimitives,o=e._primitives,a=e._groundPrimitives;t===n+1?(i.raise(o),r.raise(a)):t===n-1?(i.lower(o),r.lower(a)):t===0?(i.lowerToBottom(o),r.lowerToBottom(a),i.raise(o),r.raise(a)):(i.raiseToTop(o),r.raiseToTop(a))};function HeadingPitchRange(e,t,n){this.heading=defaultValue(e,0),this.pitch=defaultValue(t,0),this.range=defaultValue(n,0)}HeadingPitchRange.clone=function(e,t){if(defined(e))return defined(t)||(t=new HeadingPitchRange),t.heading=e.heading,t.pitch=e.pitch,t.range=e.range,t};const updateTransformMatrix3Scratch1=new Matrix3,updateTransformMatrix3Scratch2=new Matrix3,updateTransformMatrix3Scratch3=new Matrix3,updateTransformMatrix4Scratch=new Matrix4,updateTransformCartesian3Scratch1=new Cartesian3,updateTransformCartesian3Scratch2=new Cartesian3,updateTransformCartesian3Scratch3=new Cartesian3,updateTransformCartesian3Scratch4=new Cartesian3,updateTransformCartesian3Scratch5=new Cartesian3,updateTransformCartesian3Scratch6=new Cartesian3,deltaTime=new JulianDate,northUpAxisFactor=1.25;function updateTransform(e,t,n,i,r,o,a){const s=e.scene.mode;let l=r.getValue(o,e._lastCartesian);if(defined(l)){let c=!1,d=!1,h,f,p;if(s===SceneMode.SCENE3D){JulianDate.addSeconds(o,.001,deltaTime);let C=r.getValue(deltaTime,updateTransformCartesian3Scratch1);if(defined(C)||(JulianDate.addSeconds(o,-.001,deltaTime),C=r.getValue(deltaTime,updateTransformCartesian3Scratch1),d=!0),defined(C)){let A=Transforms.computeFixedToIcrfMatrix(o,updateTransformMatrix3Scratch1),S=Transforms.computeFixedToIcrfMatrix(deltaTime,updateTransformMatrix3Scratch2),v;!defined(A)||!defined(S)?(v=Transforms.computeTemeToPseudoFixedMatrix(o,updateTransformMatrix3Scratch3),A=Matrix3.transpose(v,updateTransformMatrix3Scratch1),S=Transforms.computeTemeToPseudoFixedMatrix(deltaTime,updateTransformMatrix3Scratch2),Matrix3.transpose(S,S)):v=Matrix3.transpose(A,updateTransformMatrix3Scratch3);const b=Matrix3.multiplyByVector(A,l,updateTransformCartesian3Scratch5),D=Matrix3.multiplyByVector(S,C,updateTransformCartesian3Scratch6);Cartesian3.subtract(b,D,updateTransformCartesian3Scratch4);const I=Cartesian3.magnitude(updateTransformCartesian3Scratch4)*1e3,L=CesiumMath.GRAVITATIONALPARAMETER,N=-L/(I*I-2*L/Cartesian3.magnitude(b));N<0||N>northUpAxisFactor*a.maximumRadius?(h=updateTransformCartesian3Scratch2,Cartesian3.normalize(l,h),Cartesian3.negate(h,h),p=Cartesian3.clone(Cartesian3.UNIT_Z,updateTransformCartesian3Scratch3),f=Cartesian3.cross(p,h,updateTransformCartesian3Scratch1),Cartesian3.magnitude(f)>CesiumMath.EPSILON7&&(Cartesian3.normalize(h,h),Cartesian3.normalize(f,f),p=Cartesian3.cross(h,f,updateTransformCartesian3Scratch3),Cartesian3.normalize(p,p),c=!0)):Cartesian3.equalsEpsilon(l,C,CesiumMath.EPSILON7)||(p=updateTransformCartesian3Scratch2,Cartesian3.normalize(b,p),Cartesian3.normalize(D,D),f=Cartesian3.cross(p,D,updateTransformCartesian3Scratch3),d&&(f=Cartesian3.multiplyByScalar(f,-1,f)),Cartesian3.equalsEpsilon(f,Cartesian3.ZERO,CesiumMath.EPSILON7)||(h=Cartesian3.cross(f,p,updateTransformCartesian3Scratch1),Matrix3.multiplyByVector(v,h,h),Matrix3.multiplyByVector(v,f,f),Matrix3.multiplyByVector(v,p,p),Cartesian3.normalize(h,h),Cartesian3.normalize(f,f),Cartesian3.normalize(p,p),c=!0))}}defined(e.boundingSphere)&&(l=e.boundingSphere.center);let u,m,g;i&&(u=Cartesian3.clone(t.position,updateTransformCartesian3Scratch4),m=Cartesian3.clone(t.direction,updateTransformCartesian3Scratch5),g=Cartesian3.clone(t.up,updateTransformCartesian3Scratch6));const _=updateTransformMatrix4Scratch;c?(_[0]=h.x,_[1]=h.y,_[2]=h.z,_[3]=0,_[4]=f.x,_[5]=f.y,_[6]=f.z,_[7]=0,_[8]=p.x,_[9]=p.y,_[10]=p.z,_[11]=0,_[12]=l.x,_[13]=l.y,_[14]=l.z,_[15]=0):Transforms.eastNorthUpToFixedFrame(l,a,_),t._setTransform(_),i&&(Cartesian3.clone(u,t.position),Cartesian3.clone(m,t.direction),Cartesian3.clone(g,t.up),Cartesian3.cross(m,g,t.right))}if(n){const c=s===SceneMode.SCENE2D||Cartesian3.equals(e._offset3D,Cartesian3.ZERO)?void 0:e._offset3D;t.lookAtTransform(t.transform,c)}}function EntityView(e,t,n){Check.defined("entity",e),Check.defined("scene",t),this.entity=e,this.scene=t,this.ellipsoid=defaultValue(n,Ellipsoid.default),this.boundingSphere=void 0,this._lastEntity=void 0,this._mode=void 0,this._lastCartesian=new Cartesian3,this._defaultOffset3D=void 0,this._offset3D=new Cartesian3}Object.defineProperties(EntityView,{defaultOffset3D:{get:function(){return this._defaultOffset3D},set:function(e){this._defaultOffset3D=Cartesian3.clone(e,new Cartesian3)}}});EntityView.defaultOffset3D=new Cartesian3(-14e3,3500,3500);const scratchHeadingPitchRange=new HeadingPitchRange,scratchCartesian$2=new Cartesian3;EntityView.prototype.update=function(e,t){Check.defined("time",e);const n=this.scene,i=this.ellipsoid,r=n.mode;if(r===SceneMode.MORPHING)return;const o=this.entity,a=o.position;if(!defined(a))return;const s=o!==this._lastEntity,l=r!==this._mode,c=n.camera;let d=s||l,h=!0;if(s){const f=o.viewFrom,p=defined(f);if(!p&&defined(t)){scratchHeadingPitchRange.pitch=-CesiumMath.PI_OVER_FOUR,scratchHeadingPitchRange.range=0;const u=a.getValue(e,scratchCartesian$2);if(defined(u)){const m=2-1/Math.max(1,Cartesian3.magnitude(u)/i.maximumRadius);scratchHeadingPitchRange.pitch*=m}c.viewBoundingSphere(t,scratchHeadingPitchRange),this.boundingSphere=t,d=!1,h=!1}else(!p||!defined(f.getValue(e,this._offset3D)))&&Cartesian3.clone(EntityView._defaultOffset3D,this._offset3D)}else!l&&this._mode!==SceneMode.SCENE2D&&Cartesian3.clone(c.position,this._offset3D);this._lastEntity=o,this._mode=r,updateTransform(this,c,d,h,a,e,i)};function PinBuilder(){this._cache={}}PinBuilder.prototype.fromColor=function(e,t){if(!defined(e))throw new DeveloperError("color is required");if(!defined(t))throw new DeveloperError("size is required");return createPin(void 0,void 0,e,t,this._cache)};PinBuilder.prototype.fromUrl=function(e,t,n){if(!defined(e))throw new DeveloperError("url is required");if(!defined(t))throw new DeveloperError("color is required");if(!defined(n))throw new DeveloperError("size is required");return createPin(e,void 0,t,n,this._cache)};PinBuilder.prototype.fromMakiIconId=function(e,t,n){if(!defined(e))throw new DeveloperError("id is required");if(!defined(t))throw new DeveloperError("color is required");if(!defined(n))throw new DeveloperError("size is required");return createPin(buildModuleUrl(`Assets/Textures/maki/${encodeURIComponent(e)}.png`),void 0,t,n,this._cache)};PinBuilder.prototype.fromText=function(e,t,n){if(!defined(e))throw new DeveloperError("text is required");if(!defined(t))throw new DeveloperError("color is required");if(!defined(n))throw new DeveloperError("size is required");return createPin(void 0,e,t,n,this._cache)};const colorScratch$1=new Color;function drawPin(e,t,n){e.save(),e.scale(n/24,n/24),e.fillStyle=t.toCssColorString(),e.strokeStyle=t.brighten(.6,colorScratch$1).toCssColorString(),e.lineWidth=.846,e.beginPath(),e.moveTo(6.72,.422),e.lineTo(17.28,.422),e.bezierCurveTo(18.553,.422,19.577,1.758,19.577,3.415),e.lineTo(19.577,10.973),e.bezierCurveTo(19.577,12.63,18.553,13.966,17.282,13.966),e.lineTo(14.386,14.008),e.lineTo(11.826,23.578),e.lineTo(9.614,14.008),e.lineTo(6.719,13.965),e.bezierCurveTo(5.446,13.983,4.422,12.629,4.422,10.972),e.lineTo(4.422,3.416),e.bezierCurveTo(4.423,1.76,5.447,.423,6.718,.423),e.closePath(),e.fill(),e.stroke(),e.restore()}function drawIcon(e,t,n){const i=n/2.5;let r=i,o=i;t.width>t.height?o=i*(t.height/t.width):t.width<t.height&&(r=i*(t.width/t.height));const a=Math.round((n-r)/2),s=Math.round(7/24*n-o/2);e.globalCompositeOperation="destination-out",e.drawImage(t,a-1,s,r,o),e.drawImage(t,a,s-1,r,o),e.drawImage(t,a+1,s,r,o),e.drawImage(t,a,s+1,r,o),e.globalCompositeOperation="destination-over",e.fillStyle=Color.BLACK.toCssColorString(),e.fillRect(a-1,s-1,r+2,o+2),e.globalCompositeOperation="destination-out",e.drawImage(t,a,s,r,o),e.globalCompositeOperation="destination-over",e.fillStyle=Color.WHITE.toCssColorString(),e.fillRect(a-1,s-2,r+2,o+2)}const stringifyScratch=new Array(4);function createPin(e,t,n,i,r){stringifyScratch[0]=e,stringifyScratch[1]=t,stringifyScratch[2]=n,stringifyScratch[3]=i;const o=JSON.stringify(stringifyScratch),a=r[o];if(defined(a))return a;const s=document.createElement("canvas");s.width=i,s.height=i;const l=s.getContext("2d");if(drawPin(l,n,i),defined(e)){const d=Resource.createIfNeeded(e).fetchImage().then(function(h){return drawIcon(l,h,i),r[o]=s,s});return r[o]=d,d}else if(defined(t)){const c=writeTextToCanvas(t,{font:`bold ${i}px sans-serif`});drawIcon(l,c,i)}return r[o]=s,s}function identity(e){return e}function transform$1(e){if(e==null)return identity;var t,n,i=e.scale[0],r=e.scale[1],o=e.translate[0],a=e.translate[1];return function(s,l){l||(t=n=0);var c=2,d=s.length,h=new Array(d);for(h[0]=(t+=s[0])*i+o,h[1]=(n+=s[1])*r+a;c<d;)h[c]=s[c],++c;return h}}function reverse(e,t){for(var n,i=e.length,r=i-t;r<--i;)n=e[r],e[r++]=e[i],e[i]=n}function feature(e,t){return typeof t=="string"&&(t=e.objects[t]),t.type==="GeometryCollection"?{type:"FeatureCollection",features:t.geometries.map(function(n){return feature$1(e,n)})}:feature$1(e,t)}function feature$1(e,t){var n=t.id,i=t.bbox,r=t.properties==null?{}:t.properties,o=object(e,t);return n==null&&i==null?{type:"Feature",properties:r,geometry:o}:i==null?{type:"Feature",id:n,properties:r,geometry:o}:{type:"Feature",id:n,bbox:i,properties:r,geometry:o}}function object(e,t){var n=transform$1(e.transform),i=e.arcs;function r(d,h){h.length&&h.pop();for(var f=i[d<0?~d:d],p=0,u=f.length;p<u;++p)h.push(n(f[p],p));d<0&&reverse(h,u)}function o(d){return n(d)}function a(d){for(var h=[],f=0,p=d.length;f<p;++f)r(d[f],h);return h.length<2&&h.push(h[0]),h}function s(d){for(var h=a(d);h.length<4;)h.push(h[0]);return h}function l(d){return d.map(s)}function c(d){var h=d.type,f;switch(h){case"GeometryCollection":return{type:h,geometries:d.geometries.map(c)};case"Point":f=o(d.coordinates);break;case"MultiPoint":f=d.coordinates.map(o);break;case"LineString":f=a(d.arcs);break;case"MultiLineString":f=d.arcs.map(a);break;case"Polygon":f=l(d.arcs);break;case"MultiPolygon":f=d.arcs.map(l);break;default:return null}return{type:h,coordinates:f}}return c(t)}function defaultCrsFunction(e){return Cartesian3.fromDegrees(e[0],e[1],e[2])}const crsNames={"urn:ogc:def:crs:OGC:1.3:CRS84":defaultCrsFunction,"EPSG:4326":defaultCrsFunction,"urn:ogc:def:crs:EPSG::4326":defaultCrsFunction},crsLinkHrefs={},crsLinkTypes={};let defaultMarkerSize=48,defaultMarkerSymbol,defaultMarkerColor=Color.ROYALBLUE,defaultStroke=Color.YELLOW,defaultStrokeWidth=2,defaultFill=Color.fromBytes(255,255,0,100),defaultClampToGround=!1;const sizes={small:24,medium:48,large:64},simpleStyleIdentifiers=["title","description","marker-size","marker-symbol","marker-color","stroke","stroke-opacity","stroke-width","fill","fill-opacity"];function defaultDescribe(e,t){let n="";for(const i in e)if(e.hasOwnProperty(i)){if(i===t||simpleStyleIdentifiers.indexOf(i)!==-1)continue;const r=e[i];defined(r)&&(typeof r=="object"?n+=`<tr><th>${i}</th><td>${defaultDescribe(r)}</td></tr>`:n+=`<tr><th>${i}</th><td>${r}</td></tr>`)}return n.length>0&&(n=`<table class="cesium-infoBox-defaultTable"><tbody>${n}</tbody></table>`),n}function createDescriptionCallback(e,t,n){let i;return function(r,o){return defined(i)||(i=e(t,n)),i}}function defaultDescribeProperty(e,t){return new CallbackProperty(createDescriptionCallback(defaultDescribe,e,t),!0)}function createObject(e,t,n){let i=e.id;if(!defined(i)||e.type!=="Feature")i=createGuid();else{let a=2,s=i;for(;defined(t.getById(s));)s=`${i}_${a}`,a++;i=s}const r=t.getOrCreateEntity(i),o=e.properties;if(defined(o)){r.properties=o;let a;const s=o.title;if(defined(s))r.name=s,a="title";else{let c=Number.MAX_VALUE;for(const d in o)if(o.hasOwnProperty(d)&&o[d]){const h=d.toLowerCase();if(c>1&&h==="title"){c=1,a=d;break}else c>2&&h==="name"?(c=2,a=d):c>3&&/title/i.test(d)?(c=3,a=d):c>4&&/name/i.test(d)&&(c=4,a=d)}defined(a)&&(r.name=o[a])}const l=o.description;l!==null&&(r.description=defined(l)?new ConstantProperty(l):n(o,a))}return r}function coordinatesArrayToCartesianArray(e,t){const n=new Array(e.length);for(let i=0;i<e.length;i++)n[i]=t(e[i]);return n}const geoJsonObjectTypes={Feature:processFeature$1,FeatureCollection:processFeatureCollection,GeometryCollection:processGeometryCollection,LineString:processLineString,MultiLineString:processMultiLineString,MultiPoint:processMultiPoint,MultiPolygon:processMultiPolygon,Point:processPoint$1,Polygon:processPolygon$1,Topology:processTopology},geometryTypes$1={GeometryCollection:processGeometryCollection,LineString:processLineString,MultiLineString:processMultiLineString,MultiPoint:processMultiPoint,MultiPolygon:processMultiPolygon,Point:processPoint$1,Polygon:processPolygon$1,Topology:processTopology};function processFeature$1(e,t,n,i,r){if(t.geometry===null){createObject(t,e._entityCollection,r.describe);return}if(!defined(t.geometry))throw new RuntimeError("feature.geometry is required.");const o=t.geometry.type,a=geometryTypes$1[o];if(!defined(a))throw new RuntimeError(`Unknown geometry type: ${o}`);a(e,t,t.geometry,i,r)}function processFeatureCollection(e,t,n,i,r){const o=t.features;for(let a=0,s=o.length;a<s;a++)processFeature$1(e,o[a],void 0,i,r)}function processGeometryCollection(e,t,n,i,r){const o=n.geometries;for(let a=0,s=o.length;a<s;a++){const l=o[a],c=l.type,d=geometryTypes$1[c];if(!defined(d))throw new RuntimeError(`Unknown geometry type: ${c}`);d(e,t,l,i,r)}}function createPoint(e,t,n,i,r){let o=r.markerSymbol,a=r.markerColor,s=r.markerSize;const l=t.properties;if(defined(l)){const p=l["marker-color"];defined(p)&&(a=Color.fromCssColorString(p)),s=defaultValue(sizes[l["marker-size"]],s);const u=l["marker-symbol"];defined(u)&&(o=u)}let c;defined(o)?o.length===1?c=e._pinBuilder.fromText(o.toUpperCase(),a,s):c=e._pinBuilder.fromMakiIconId(o,a,s):c=e._pinBuilder.fromColor(a,s);const d=new BillboardGraphics;d.verticalOrigin=new ConstantProperty(VerticalOrigin.BOTTOM),i.length===2&&r.clampToGround&&(d.heightReference=HeightReference.CLAMP_TO_GROUND);const h=createObject(t,e._entityCollection,r.describe);h.billboard=d,h.position=new ConstantPositionProperty(n(i));const f=Promise.resolve(c).then(function(p){d.image=new ConstantProperty(p)}).catch(function(){d.image=new ConstantProperty(e._pinBuilder.fromColor(a,s))});e._promises.push(f)}function processPoint$1(e,t,n,i,r){createPoint(e,t,i,n.coordinates,r)}function processMultiPoint(e,t,n,i,r){const o=n.coordinates;for(let a=0;a<o.length;a++)createPoint(e,t,i,o[a],r)}function createLineString(e,t,n,i,r){let o=r.strokeMaterialProperty,a=r.strokeWidthProperty;const s=t.properties;if(defined(s)){const d=s["stroke-width"];defined(d)&&(a=new ConstantProperty(d));let h;const f=s.stroke;defined(f)&&(h=Color.fromCssColorString(f));const p=s["stroke-opacity"];defined(p)&&p!==1&&(defined(h)||(h=o.color.getValue().clone()),h.alpha=p),defined(h)&&(o=new ColorMaterialProperty(h))}const l=createObject(t,e._entityCollection,r.describe),c=new PolylineGraphics;l.polyline=c,c.clampToGround=r.clampToGround,c.material=o,c.width=a,c.positions=new ConstantProperty(coordinatesArrayToCartesianArray(i,n)),c.arcType=ArcType.RHUMB}function processLineString(e,t,n,i,r){createLineString(e,t,i,n.coordinates,r)}function processMultiLineString(e,t,n,i,r){const o=n.coordinates;for(let a=0;a<o.length;a++)createLineString(e,t,i,o[a],r)}function createPolygon(e,t,n,i,r){if(i.length===0||i[0].length===0)return;let o=r.strokeMaterialProperty.color,a=r.fillMaterialProperty,s=r.strokeWidthProperty;const l=t.properties;if(defined(l)){const p=l["stroke-width"];defined(p)&&(s=new ConstantProperty(p));let u;const m=l.stroke;defined(m)&&(u=Color.fromCssColorString(m));let g=l["stroke-opacity"];defined(g)&&g!==1&&(defined(u)||(u=o.getValue().clone()),u.alpha=g),defined(u)&&(o=new ConstantProperty(u));let _;const C=l.fill,A=a.color.getValue();defined(C)&&(_=Color.fromCssColorString(C),_.alpha=A.alpha),g=l["fill-opacity"],defined(g)&&g!==A.alpha&&(defined(_)||(_=A.clone()),_.alpha=g),defined(_)&&(a=new ColorMaterialProperty(_))}const c=new PolygonGraphics;c.outline=new ConstantProperty(!0),c.outlineColor=o,c.outlineWidth=s,c.material=a,c.arcType=ArcType.RHUMB;const d=[];for(let p=1,u=i.length;p<u;p++)d.push(new PolygonHierarchy(coordinatesArrayToCartesianArray(i[p],n)));const h=i[0];c.hierarchy=new ConstantProperty(new PolygonHierarchy(coordinatesArrayToCartesianArray(h,n),d)),h[0].length>2?c.perPositionHeight=new ConstantProperty(!0):r.clampToGround||(c.height=0);const f=createObject(t,e._entityCollection,r.describe);f.polygon=c}function processPolygon$1(e,t,n,i,r){createPolygon(e,t,i,n.coordinates,r)}function processMultiPolygon(e,t,n,i,r){const o=n.coordinates;for(let a=0;a<o.length;a++)createPolygon(e,t,i,o[a],r)}function processTopology(e,t,n,i,r){for(const o in n.objects)if(n.objects.hasOwnProperty(o)){const a=feature(n,n.objects[o]),s=geoJsonObjectTypes[a.type];s(e,a,a,i,r)}}function GeoJsonDataSource(e){this._name=e,this._changed=new Event,this._error=new Event,this._isLoading=!1,this._loading=new Event,this._entityCollection=new EntityCollection(this),this._promises=[],this._pinBuilder=new PinBuilder,this._entityCluster=new EntityCluster,this._credit=void 0,this._resourceCredits=[]}GeoJsonDataSource.load=function(e,t){return new GeoJsonDataSource().load(e,t)};Object.defineProperties(GeoJsonDataSource,{markerSize:{get:function(){return defaultMarkerSize},set:function(e){defaultMarkerSize=e}},markerSymbol:{get:function(){return defaultMarkerSymbol},set:function(e){defaultMarkerSymbol=e}},markerColor:{get:function(){return defaultMarkerColor},set:function(e){defaultMarkerColor=e}},stroke:{get:function(){return defaultStroke},set:function(e){defaultStroke=e}},strokeWidth:{get:function(){return defaultStrokeWidth},set:function(e){defaultStrokeWidth=e}},fill:{get:function(){return defaultFill},set:function(e){defaultFill=e}},clampToGround:{get:function(){return defaultClampToGround},set:function(e){defaultClampToGround=e}},crsNames:{get:function(){return crsNames}},crsLinkHrefs:{get:function(){return crsLinkHrefs}},crsLinkTypes:{get:function(){return crsLinkTypes}}});Object.defineProperties(GeoJsonDataSource.prototype,{name:{get:function(){return this._name},set:function(e){this._name!==e&&(this._name=e,this._changed.raiseEvent(this))}},clock:{value:void 0,writable:!1},entities:{get:function(){return this._entityCollection}},isLoading:{get:function(){return this._isLoading}},changedEvent:{get:function(){return this._changed}},errorEvent:{get:function(){return this._error}},loadingEvent:{get:function(){return this._loading}},show:{get:function(){return this._entityCollection.show},set:function(e){this._entityCollection.show=e}},clustering:{get:function(){return this._entityCluster},set:function(e){if(!defined(e))throw new DeveloperError("value must be defined.");this._entityCluster=e}},credit:{get:function(){return this._credit}}});GeoJsonDataSource.prototype.load=function(e,t){return preload(this,e,t,!0)};GeoJsonDataSource.prototype.process=function(e,t){return preload(this,e,t,!1)};function preload(e,t,n,i){if(!defined(t))throw new DeveloperError("data is required.");DataSource.setLoading(e,!0),n=defaultValue(n,defaultValue.EMPTY_OBJECT);let r=n.credit;typeof r=="string"&&(r=new Credit(r)),e._credit=r;let o=t,a=n.sourceUri;if(typeof t=="string"||t instanceof Resource){t=Resource.createIfNeeded(t),o=t.fetchJson(),a=defaultValue(a,t.getUrlComponent());const s=e._resourceCredits,l=t.credits;if(defined(l)){const c=l.length;for(let d=0;d<c;d++)s.push(l[d])}}return n={describe:defaultValue(n.describe,defaultDescribeProperty),markerSize:defaultValue(n.markerSize,defaultMarkerSize),markerSymbol:defaultValue(n.markerSymbol,defaultMarkerSymbol),markerColor:defaultValue(n.markerColor,defaultMarkerColor),strokeWidthProperty:new ConstantProperty(defaultValue(n.strokeWidth,defaultStrokeWidth)),strokeMaterialProperty:new ColorMaterialProperty(defaultValue(n.stroke,defaultStroke)),fillMaterialProperty:new ColorMaterialProperty(defaultValue(n.fill,defaultFill)),clampToGround:defaultValue(n.clampToGround,defaultClampToGround)},Promise.resolve(o).then(function(s){return load$3(e,s,n,a,i)}).catch(function(s){throw DataSource.setLoading(e,!1),e._error.raiseEvent(e,s),s})}GeoJsonDataSource.prototype.update=function(e){return!0};function load$3(e,t,n,i,r){let o;defined(i)&&(o=getFilenameFromUri(i)),defined(o)&&e._name!==o&&(e._name=o,e._changed.raiseEvent(e));const a=geoJsonObjectTypes[t.type];if(!defined(a))throw new RuntimeError(`Unsupported GeoJSON object type: ${t.type}`);const s=t.crs;let l=s!==null?defaultCrsFunction:null;if(defined(s)){if(!defined(s.properties))throw new RuntimeError("crs.properties is undefined.");const c=s.properties;if(s.type==="name"){if(l=crsNames[c.name],!defined(l))throw new RuntimeError(`Unknown crs name: ${c.name}`)}else if(s.type==="link"){let d=crsLinkHrefs[c.href];if(defined(d)||(d=crsLinkTypes[c.type]),!defined(d))throw new RuntimeError(`Unable to resolve crs link: ${JSON.stringify(c)}`);l=d(c)}else if(s.type==="EPSG"){if(l=crsNames[`EPSG:${c.code}`],!defined(l))throw new RuntimeError(`Unknown crs EPSG code: ${c.code}`)}else throw new RuntimeError(`Unknown crs type: ${s.type}`)}return Promise.resolve(l).then(function(c){return r&&e._entityCollection.removeAll(),c!==null&&a(e,t,t,c,n),Promise.all(e._promises).then(function(){return e._promises.length=0,DataSource.setLoading(e,!1),e})})}var version="4.0.0";function isUndefined(e){return e===void 0}function isBoolean(e){return typeof e=="boolean"}function defaults(e,t){for(var n in t)t.hasOwnProperty(n)&&isUndefined(e[n])&&(e[n]=t[n]);return e}function ellipsis(e,t,n){var i;return e.length>t&&(n==null?(n="&hellip;",i=3):i=n.length,e=e.substring(0,t-i)+n),e}function remove$1(e,t){for(var n=e.length-1;n>=0;n--)e[n]===t&&e.splice(n,1)}function removeWithPredicate(e,t){for(var n=e.length-1;n>=0;n--)t(e[n])===!0&&e.splice(n,1)}function assertNever(e){throw new Error("Unhandled case for value: '".concat(e,"'"))}var letterRe=/[A-Za-z]/,digitRe=/[\d]/,whitespaceRe=/\s/,quoteRe=/['"]/,controlCharsRe=/[\x00-\x1F\x7F]/,alphaCharsStr=/A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC/.source,emojiStr=/\u2700-\u27bf\udde6-\uddff\ud800-\udbff\udc00-\udfff\ufe0e\ufe0f\u0300-\u036f\ufe20-\ufe23\u20d0-\u20f0\ud83c\udffb-\udfff\u200d\u3299\u3297\u303d\u3030\u24c2\ud83c\udd70-\udd71\udd7e-\udd7f\udd8e\udd91-\udd9a\udde6-\uddff\ude01-\ude02\ude1a\ude2f\ude32-\ude3a\ude50-\ude51\u203c\u2049\u25aa-\u25ab\u25b6\u25c0\u25fb-\u25fe\u00a9\u00ae\u2122\u2139\udc04\u2600-\u26FF\u2b05\u2b06\u2b07\u2b1b\u2b1c\u2b50\u2b55\u231a\u231b\u2328\u23cf\u23e9-\u23f3\u23f8-\u23fa\udccf\u2935\u2934\u2190-\u21ff/.source,marksStr=/\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F/.source,alphaCharsAndMarksStr=alphaCharsStr+emojiStr+marksStr,decimalNumbersStr=/0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19/.source,alphaNumericAndMarksCharsStr=alphaCharsAndMarksStr+decimalNumbersStr,alphaNumericAndMarksRe=new RegExp("[".concat(alphaNumericAndMarksCharsStr,"]")),HtmlTag=function(){function e(t){t===void 0&&(t={}),this.tagName="",this.attrs={},this.innerHTML="",this.tagName=t.tagName||"",this.attrs=t.attrs||{},this.innerHTML=t.innerHtml||t.innerHTML||""}return e.prototype.setTagName=function(t){return this.tagName=t,this},e.prototype.getTagName=function(){return this.tagName||""},e.prototype.setAttr=function(t,n){var i=this.getAttrs();return i[t]=n,this},e.prototype.getAttr=function(t){return this.getAttrs()[t]},e.prototype.setAttrs=function(t){return Object.assign(this.getAttrs(),t),this},e.prototype.getAttrs=function(){return this.attrs||(this.attrs={})},e.prototype.setClass=function(t){return this.setAttr("class",t)},e.prototype.addClass=function(t){for(var n=this.getClass(),i=n?n.split(whitespaceRe):[],r=t.split(whitespaceRe),o;o=r.shift();)i.indexOf(o)===-1&&i.push(o);return this.getAttrs().class=i.join(" "),this},e.prototype.removeClass=function(t){for(var n=this.getClass(),i=n?n.split(whitespaceRe):[],r=t.split(whitespaceRe),o;i.length&&(o=r.shift());){var a=i.indexOf(o);a!==-1&&i.splice(a,1)}return this.getAttrs().class=i.join(" "),this},e.prototype.getClass=function(){return this.getAttrs().class||""},e.prototype.hasClass=function(t){return(" "+this.getClass()+" ").indexOf(" "+t+" ")!==-1},e.prototype.setInnerHTML=function(t){return this.innerHTML=t,this},e.prototype.setInnerHtml=function(t){return this.setInnerHTML(t)},e.prototype.getInnerHTML=function(){return this.innerHTML||""},e.prototype.getInnerHtml=function(){return this.getInnerHTML()},e.prototype.toAnchorString=function(){var t=this.getTagName(),n=this.buildAttrsStr();return n=n?" "+n:"",["<",t,n,">",this.getInnerHtml(),"</",t,">"].join("")},e.prototype.buildAttrsStr=function(){if(!this.attrs)return"";var t=this.getAttrs(),n=[];for(var i in t)t.hasOwnProperty(i)&&n.push(i+'="'+t[i]+'"');return n.join(" ")},e}();function truncateSmart(e,t,n){var i,r;n==null?(n="&hellip;",r=3,i=8):(r=n.length,i=n.length);var o=function(C){var A={},S=C,v=S.match(/^([a-z]+):\/\//i);return v&&(A.scheme=v[1],S=S.substr(v[0].length)),v=S.match(/^(.*?)(?=(\?|#|\/|$))/i),v&&(A.host=v[1],S=S.substr(v[0].length)),v=S.match(/^\/(.*?)(?=(\?|#|$))/i),v&&(A.path=v[1],S=S.substr(v[0].length)),v=S.match(/^\?(.*?)(?=(#|$))/i),v&&(A.query=v[1],S=S.substr(v[0].length)),v=S.match(/^#(.*?)$/i),v&&(A.fragment=v[1]),A},a=function(C){var A="";return C.scheme&&C.host&&(A+=C.scheme+"://"),C.host&&(A+=C.host),C.path&&(A+="/"+C.path),C.query&&(A+="?"+C.query),C.fragment&&(A+="#"+C.fragment),A},s=function(C,A){var S=A/2,v=Math.ceil(S),b=-1*Math.floor(S),D="";return b<0&&(D=C.substr(b)),C.substr(0,v)+n+D};if(e.length<=t)return e;var l=t-r,c=o(e);if(c.query){var d=c.query.match(/^(.*?)(?=(\?|\#))(.*?)$/i);d&&(c.query=c.query.substr(0,d[1].length),e=a(c))}if(e.length<=t||(c.host&&(c.host=c.host.replace(/^www\./,""),e=a(c)),e.length<=t))return e;var h="";if(c.host&&(h+=c.host),h.length>=l)return c.host.length==t?(c.host.substr(0,t-r)+n).substr(0,l+i):s(h,l).substr(0,l+i);var f="";if(c.path&&(f+="/"+c.path),c.query&&(f+="?"+c.query),f)if((h+f).length>=l){if((h+f).length==t)return(h+f).substr(0,t);var p=l-h.length;return(h+s(f,p)).substr(0,l+i)}else h+=f;if(c.fragment){var u="#"+c.fragment;if((h+u).length>=l){if((h+u).length==t)return(h+u).substr(0,t);var m=l-h.length;return(h+s(u,m)).substr(0,l+i)}else h+=u}if(c.scheme&&c.host){var g=c.scheme+"://";if((h+g).length<l)return(g+h).substr(0,t)}if(h.length<=t)return h;var _="";return l>0&&(_=h.substr(-1*Math.floor(l/2))),(h.substr(0,Math.ceil(l/2))+n+_).substr(0,l+i)}function truncateMiddle(e,t,n){if(e.length<=t)return e;var i,r;n==null?(n="&hellip;",i=8,r=3):(i=n.length,r=n.length);var o=t-r,a="";return o>0&&(a=e.substr(-1*Math.floor(o/2))),(e.substr(0,Math.ceil(o/2))+n+a).substr(0,o+i)}function truncateEnd(e,t,n){return ellipsis(e,t,n)}var AnchorTagBuilder=function(){function e(t){t===void 0&&(t={}),this.newWindow=!1,this.truncate={},this.className="",this.newWindow=t.newWindow||!1,this.truncate=t.truncate||{},this.className=t.className||""}return e.prototype.build=function(t){return new HtmlTag({tagName:"a",attrs:this.createAttrs(t),innerHtml:this.processAnchorText(t.getAnchorText())})},e.prototype.createAttrs=function(t){var n={href:t.getAnchorHref()},i=this.createCssClass(t);return i&&(n.class=i),this.newWindow&&(n.target="_blank",n.rel="noopener noreferrer"),this.truncate&&this.truncate.length&&this.truncate.length<t.getAnchorText().length&&(n.title=t.getAnchorHref()),n},e.prototype.createCssClass=function(t){var n=this.className;if(n){for(var i=[n],r=t.getCssClassSuffixes(),o=0,a=r.length;o<a;o++)i.push(n+"-"+r[o]);return i.join(" ")}else return""},e.prototype.processAnchorText=function(t){return t=this.doTruncate(t),t},e.prototype.doTruncate=function(t){var n=this.truncate;if(!n||!n.length)return t;var i=n.length,r=n.location;return r==="smart"?truncateSmart(t,i):r==="middle"?truncateMiddle(t,i):truncateEnd(t,i)},e}(),extendStatics=function(e,t){return extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,i){n.__proto__=i}||function(n,i){for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(n[r]=i[r])},extendStatics(e,t)};function __extends(e,t){if(typeof t!="function"&&t!==null)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");extendStatics(e,t);function n(){this.constructor=e}e.prototype=t===null?Object.create(t):(n.prototype=t.prototype,new n)}var __assign=function(){return __assign=Object.assign||function(t){for(var n,i=1,r=arguments.length;i<r;i++){n=arguments[i];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t},__assign.apply(this,arguments)};typeof SuppressedError=="function"&&SuppressedError;var AbstractMatch=function(){function e(t){this._=null,this.matchedText="",this.offset=0,this.tagBuilder=t.tagBuilder,this.matchedText=t.matchedText,this.offset=t.offset}return e.prototype.getMatchedText=function(){return this.matchedText},e.prototype.setOffset=function(t){this.offset=t},e.prototype.getOffset=function(){return this.offset},e.prototype.getCssClassSuffixes=function(){return[this.type]},e.prototype.buildTag=function(){return this.tagBuilder.build(this)},e}(),tldRegexStr="(?:xn--vermgensberatung-pwb|xn--vermgensberater-ctb|xn--clchc0ea0b2g2a9gcd|xn--w4r85el8fhu5dnra|northwesternmutual|travelersinsurance|vermgensberatung|xn--5su34j936bgsg|xn--bck1b9a5dre4c|xn--mgbah1a3hjkrd|xn--mgbai9azgqp6j|xn--mgberp4a5d4ar|xn--xkc2dl3a5ee0h|vermgensberater|xn--fzys8d69uvgm|xn--mgba7c0bbn0a|xn--mgbcpq6gpa1a|xn--xkc2al3hye2a|americanexpress|kerryproperties|sandvikcoromant|xn--i1b6b1a6a2e|xn--kcrx77d1x4a|xn--lgbbat1ad8j|xn--mgba3a4f16a|xn--mgbaakc7dvf|xn--mgbc0a9azcg|xn--nqv7fs00ema|americanfamily|bananarepublic|cancerresearch|cookingchannel|kerrylogistics|weatherchannel|xn--54b7fta0cc|xn--6qq986b3xl|xn--80aqecdr1a|xn--b4w605ferd|xn--fiq228c5hs|xn--h2breg3eve|xn--jlq480n2rg|xn--jlq61u9w7b|xn--mgba3a3ejt|xn--mgbaam7a8h|xn--mgbayh7gpa|xn--mgbbh1a71e|xn--mgbca7dzdo|xn--mgbi4ecexp|xn--mgbx4cd0ab|xn--rvc1e0am3e|international|lifeinsurance|travelchannel|wolterskluwer|xn--cckwcxetd|xn--eckvdtc9d|xn--fpcrj9c3d|xn--fzc2c9e2c|xn--h2brj9c8c|xn--tiq49xqyj|xn--yfro4i67o|xn--ygbi2ammx|construction|lplfinancial|scholarships|versicherung|xn--3e0b707e|xn--45br5cyl|xn--4dbrk0ce|xn--80adxhks|xn--80asehdb|xn--8y0a063a|xn--gckr3f0f|xn--mgb9awbf|xn--mgbab2bd|xn--mgbgu82a|xn--mgbpl2fh|xn--mgbt3dhd|xn--mk1bu44c|xn--ngbc5azd|xn--ngbe9e0a|xn--ogbpf8fl|xn--qcka1pmc|accountants|barclaycard|blackfriday|blockbuster|bridgestone|calvinklein|contractors|creditunion|engineering|enterprises|foodnetwork|investments|kerryhotels|lamborghini|motorcycles|olayangroup|photography|playstation|productions|progressive|redumbrella|williamhill|xn--11b4c3d|xn--1ck2e1b|xn--1qqw23a|xn--2scrj9c|xn--3bst00m|xn--3ds443g|xn--3hcrj9c|xn--42c2d9a|xn--45brj9c|xn--55qw42g|xn--6frz82g|xn--80ao21a|xn--9krt00a|xn--cck2b3b|xn--czr694b|xn--d1acj3b|xn--efvy88h|xn--fct429k|xn--fjq720a|xn--flw351e|xn--g2xx48c|xn--gecrj9c|xn--gk3at1e|xn--h2brj9c|xn--hxt814e|xn--imr513n|xn--j6w193g|xn--jvr189m|xn--kprw13d|xn--kpry57d|xn--mgbbh1a|xn--mgbtx2b|xn--mix891f|xn--nyqy26a|xn--otu796d|xn--pgbs0dh|xn--q9jyb4c|xn--rhqv96g|xn--rovu88b|xn--s9brj9c|xn--ses554g|xn--t60b56a|xn--vuq861b|xn--w4rs40l|xn--xhq521b|xn--zfr164b||accountant|apartments|associates|basketball|bnpparibas|boehringer|capitalone|consulting|creditcard|cuisinella|eurovision|extraspace|foundation|healthcare|immobilien|industries|management|mitsubishi|nextdirect|properties|protection|prudential|realestate|republican|restaurant|schaeffler|tatamotors|technology|university|vlaanderen|volkswagen|xn--30rr7y|xn--3pxu8k|xn--45q11c|xn--4gbrim|xn--55qx5d|xn--5tzm5g|xn--80aswg|xn--90a3ac|xn--9dbq2a|xn--9et52u|xn--c2br7g|xn--cg4bki|xn--czrs0t|xn--czru2d|xn--fiq64b|xn--fiqs8s|xn--fiqz9s|xn--io0a7i|xn--kput3i|xn--mxtq1m|xn--o3cw4h|xn--pssy2u|xn--q7ce6a|xn--unup4y|xn--wgbh1c|xn--wgbl6a|xn--y9a3aq|accenture|alfaromeo|allfinanz|amsterdam|analytics|aquarelle|barcelona|bloomberg|christmas|community|directory|education|equipment|fairwinds|financial|firestone|fresenius|frontdoor|furniture|goldpoint|hisamitsu|homedepot|homegoods|homesense|institute|insurance|kuokgroup|lancaster|landrover|lifestyle|marketing|marshalls|melbourne|microsoft|panasonic|passagens|pramerica|richardli|shangrila|solutions|statebank|statefarm|stockholm|travelers|vacations|xn--90ais|xn--c1avg|xn--d1alf|xn--e1a4c|xn--fhbei|xn--j1aef|xn--j1amh|xn--l1acc|xn--ngbrx|xn--nqv7f|xn--p1acf|xn--qxa6a|xn--tckwe|xn--vhquv|yodobashi||abudhabi|airforce|allstate|attorney|barclays|barefoot|bargains|baseball|boutique|bradesco|broadway|brussels|builders|business|capetown|catering|catholic|cipriani|cityeats|cleaning|clinique|clothing|commbank|computer|delivery|deloitte|democrat|diamonds|discount|discover|download|engineer|ericsson|etisalat|exchange|feedback|fidelity|firmdale|football|frontier|goodyear|grainger|graphics|guardian|hdfcbank|helsinki|holdings|hospital|infiniti|ipiranga|istanbul|jpmorgan|lighting|lundbeck|marriott|maserati|mckinsey|memorial|merckmsd|mortgage|observer|partners|pharmacy|pictures|plumbing|property|redstone|reliance|saarland|samsclub|security|services|shopping|showtime|softbank|software|stcgroup|supplies|training|vanguard|ventures|verisign|woodside|xn--90ae|xn--node|xn--p1ai|xn--qxam|yokohama||abogado|academy|agakhan|alibaba|android|athleta|auction|audible|auspost|avianca|banamex|bauhaus|bentley|bestbuy|booking|brother|bugatti|capital|caravan|careers|channel|charity|chintai|citadel|clubmed|college|cologne|comcast|company|compare|contact|cooking|corsica|country|coupons|courses|cricket|cruises|dentist|digital|domains|exposed|express|farmers|fashion|ferrari|ferrero|finance|fishing|fitness|flights|florist|flowers|forsale|frogans|fujitsu|gallery|genting|godaddy|grocery|guitars|hamburg|hangout|hitachi|holiday|hosting|hoteles|hotmail|hyundai|ismaili|jewelry|juniper|kitchen|komatsu|lacaixa|lanxess|lasalle|latrobe|leclerc|limited|lincoln|markets|monster|netbank|netflix|network|neustar|okinawa|oldnavy|organic|origins|philips|pioneer|politie|realtor|recipes|rentals|reviews|rexroth|samsung|sandvik|schmidt|schwarz|science|shiksha|singles|staples|storage|support|surgery|systems|temasek|theater|theatre|tickets|tiffany|toshiba|trading|walmart|wanggou|watches|weather|website|wedding|whoswho|windows|winners|xfinity|yamaxun|youtube|zuerich|||||||||abarth|abbott|abbvie|africa|agency|airbus|airtel|alipay|alsace|alstom|amazon|anquan|aramco|author|bayern|beauty|berlin|bharti|bostik|boston|broker|camera|career|casino|center|chanel|chrome|church|circle|claims|clinic|coffee|comsec|condos|coupon|credit|cruise|dating|datsun|dealer|degree|dental|design|direct|doctor|dunlop|dupont|durban|emerck|energy|estate|events|expert|family|flickr|futbol|gallup|garden|george|giving|global|google|gratis|health|hermes|hiphop|hockey|hotels|hughes|imamat|insure|intuit|jaguar|joburg|juegos|kaufen|kinder|kindle|kosher|lancia|latino|lawyer|lefrak|living|locker|london|luxury|madrid|maison|makeup|market|mattel|mobile|monash|mormon|moscow|museum|mutual|nagoya|natura|nissan|nissay|norton|nowruz|office|olayan|online|oracle|orange|otsuka|pfizer|photos|physio|pictet|quebec|racing|realty|reisen|repair|report|review|rocher|rogers|ryukyu|safety|sakura|sanofi|school|schule|search|secure|select|shouji|soccer|social|stream|studio|supply|suzuki|swatch|sydney|taipei|taobao|target|tattoo|tennis|tienda|tjmaxx|tkmaxx|toyota|travel|unicom|viajes|viking|villas|virgin|vision|voting|voyage|vuelos|walter|webcam|xihuan|yachts|yandex|zappos|||||||||||||actor|adult|aetna|amfam|amica|apple|archi|audio|autos|azure|baidu|beats|bible|bingo|black|boats|bosch|build|canon|cards|chase|cheap|cisco|citic|click|cloud|coach|codes|crown|cymru|dabur|dance|deals|delta|drive|dubai|earth|edeka|email|epson|faith|fedex|final|forex|forum|gallo|games|gifts|gives|glass|globo|gmail|green|gripe|group|gucci|guide|homes|honda|horse|house|hyatt|ikano|irish|jetzt|koeln|kyoto|lamer|lease|legal|lexus|lilly|linde|lipsy|loans|locus|lotte|lotto|macys|mango|media|miami|money|movie|music|nexus|nikon|ninja|nokia|nowtv|omega|osaka|paris|parts|party|phone|photo|pizza|place|poker|praxi|press|prime|promo|quest|radio|rehab|reise|ricoh|rocks|rodeo|rugby|salon|sener|seven|sharp|shell|shoes|skype|sling|smart|smile|solar|space|sport|stada|store|study|style|sucks|swiss|tatar|tires|tirol|tmall|today|tokyo|tools|toray|total|tours|trade|trust|tunes|tushu|ubank|vegas|video|vodka|volvo|wales|watch|weber|weibo|works|world|xerox|yahoo||||||||||||||aarp|able|adac|aero|akdn|ally|amex|arab|army|arpa|arte|asda|asia|audi|auto|baby|band|bank|bbva|beer|best|bike|bing|blog|blue|bofa|bond|book|buzz|cafe|call|camp|care|cars|casa|case|cash|cbre|cern|chat|citi|city|club|cool|coop|cyou|data|date|dclk|deal|dell|desi|diet|dish|docs|dvag|erni|fage|fail|fans|farm|fast|fiat|fido|film|fire|fish|flir|food|ford|free|fund|game|gbiz|gent|ggee|gift|gmbh|gold|golf|goog|guge|guru|hair|haus|hdfc|help|here|hgtv|host|hsbc|icbc|ieee|imdb|immo|info|itau|java|jeep|jobs|jprs|kddi|kids|kiwi|kpmg|kred|land|lego|lgbt|lidl|life|like|limo|link|live|loan|loft|love|ltda|luxe|maif|meet|meme|menu|mini|mint|mobi|moda|moto|name|navy|news|next|nico|nike|ollo|open|page|pars|pccw|pics|ping|pink|play|plus|pohl|porn|post|prod|prof|qpon|read|reit|rent|rest|rich|room|rsvp|ruhr|safe|sale|sarl|save|saxo|scot|seat|seek|sexy|shaw|shia|shop|show|silk|sina|site|skin|sncf|sohu|song|sony|spot|star|surf|talk|taxi|team|tech|teva|tiaa|tips|town|toys|tube|vana|visa|viva|vivo|vote|voto|wang|weir|wien|wiki|wine|work|xbox|yoga|zara|zero|zone||||||||||||||||||||||||||aaa|abb|abc|aco|ads|aeg|afl|aig|anz|aol|app|art|aws|axa|bar|bbc|bbt|bcg|bcn|bet|bid|bio|biz|bms|bmw|bom|boo|bot|box|buy|bzh|cab|cal|cam|car|cat|cba|cbn|cbs|ceo|cfa|cfd|com|cpa|crs|dad|day|dds|dev|dhl|diy|dnp|dog|dot|dtv|dvr|eat|eco|edu|esq|eus|fan|fit|fly|foo|fox|frl|ftr|fun|fyi|gal|gap|gay|gdn|gea|gle|gmo|gmx|goo|gop|got|gov|hbo|hiv|hkt|hot|how|ibm|ice|icu|ifm|inc|ing|ink|int|ist|itv|jcb|jio|jll|jmp|jnj|jot|joy|kfh|kia|kim|kpn|krd|lat|law|lds|llc|llp|lol|lpl|ltd|man|map|mba|med|men|mil|mit|mlb|mls|mma|moe|moi|mom|mov|msd|mtn|mtr|nab|nba|nec|net|new|nfl|ngo|nhk|now|nra|nrw|ntt|nyc|obi|one|ong|onl|ooo|org|ott|ovh|pay|pet|phd|pid|pin|pnc|pro|pru|pub|pwc|red|ren|ril|rio|rip|run|rwe|sap|sas|sbi|sbs|sca|scb|ses|sew|sex|sfr|ski|sky|soy|spa|srl|stc|tab|tax|tci|tdk|tel|thd|tjx|top|trv|tui|tvs|ubs|uno|uol|ups|vet|vig|vin|vip|wed|win|wme|wow|wtc|wtf|xin|xxx|xyz|you|yun|zip||||||||||||||||||||||||||||||||ac|ad|ae|af|ag|ai|al|am|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|er|es|et|eu|fi|fj|fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|tj|tk|tl|tm|tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||)",tldRegex=new RegExp("^"+tldRegexStr+"$"),urlSuffixStartCharsRe=/[\/?#]/,urlSuffixAllowedSpecialCharsRe=/[-+&@#/%=~_()|'$*\[\]{}\u2713]/,urlSuffixNotAllowedAsLastCharRe=/[?!:,.;^]/,httpSchemeRe=/https?:\/\//i,httpSchemePrefixRe=new RegExp("^"+httpSchemeRe.source,"i"),urlSuffixedCharsNotAllowedAtEndRe=new RegExp(urlSuffixNotAllowedAsLastCharRe.source+"$"),invalidSchemeRe=/^(javascript|vbscript):/i,schemeUrlRe=/^[A-Za-z][-.+A-Za-z0-9]*:(\/\/)?([^:/]*)/,tldUrlHostRe=/^(?:\/\/)?([^/#?:]+)/;function isSchemeStartChar(e){return letterRe.test(e)}function isSchemeChar(e){return letterRe.test(e)||digitRe.test(e)||e==="+"||e==="-"||e==="."}function isDomainLabelStartChar(e){return alphaNumericAndMarksRe.test(e)}function isDomainLabelChar(e){return e==="_"||isDomainLabelStartChar(e)}function isPathChar(e){return alphaNumericAndMarksRe.test(e)||urlSuffixAllowedSpecialCharsRe.test(e)||urlSuffixNotAllowedAsLastCharRe.test(e)}function isUrlSuffixStartChar(e){return urlSuffixStartCharsRe.test(e)}function isKnownTld(e){return tldRegex.test(e.toLowerCase())}function isValidSchemeUrl(e){if(invalidSchemeRe.test(e))return!1;var t=e.match(schemeUrlRe);if(!t)return!1;var n=!!t[1],i=t[2];return n?!0:!(i.indexOf(".")===-1||!letterRe.test(i))}function isValidTldMatch(e){var t=e.match(tldUrlHostRe);if(!t)return!1;var n=t[0],i=n.split(".");if(i.length<2)return!1;var r=i[i.length-1];return!!isKnownTld(r)}var ipV4Re=/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,ipV4PartRe=/[:/?#]/;function isValidIpV4Address(e){var t=e.split(ipV4PartRe,1)[0];return ipV4Re.test(t)}var wwwPrefixRegex=/^(https?:\/\/)?(www\.)?/i,protocolRelativeRegex=/^\/\//,UrlMatch=function(e){__extends(t,e);function t(n){var i=e.call(this,n)||this;return i.type="url",i.url="",i.urlMatchType="scheme",i.protocolRelativeMatch=!1,i.stripPrefix={scheme:!0,www:!0},i.stripTrailingSlash=!0,i.decodePercentEncoding=!0,i.protocolPrepended=!1,i.urlMatchType=n.urlMatchType,i.url=n.url,i.protocolRelativeMatch=n.protocolRelativeMatch,i.stripPrefix=n.stripPrefix,i.stripTrailingSlash=n.stripTrailingSlash,i.decodePercentEncoding=n.decodePercentEncoding,i}return t.prototype.getType=function(){return"url"},t.prototype.getUrlMatchType=function(){return this.urlMatchType},t.prototype.getUrl=function(){var n=this.url;return!this.protocolRelativeMatch&&this.urlMatchType!=="scheme"&&!this.protocolPrepended&&(n=this.url="http://"+n,this.protocolPrepended=!0),n},t.prototype.getAnchorHref=function(){var n=this.getUrl();return n.replace(/&amp;/g,"&")},t.prototype.getAnchorText=function(){var n=this.getMatchedText();return this.protocolRelativeMatch&&(n=stripProtocolRelativePrefix(n)),this.stripPrefix.scheme&&(n=stripSchemePrefix(n)),this.stripPrefix.www&&(n=stripWwwPrefix(n)),this.stripTrailingSlash&&(n=removeTrailingSlash(n)),this.decodePercentEncoding&&(n=removePercentEncoding(n)),n},t}(AbstractMatch);function stripSchemePrefix(e){return e.replace(httpSchemePrefixRe,"")}function stripWwwPrefix(e){return e.replace(wwwPrefixRegex,"$1")}function stripProtocolRelativePrefix(e){return e.replace(protocolRelativeRegex,"")}function removeTrailingSlash(e){return e.charAt(e.length-1)==="/"&&(e=e.slice(0,-1)),e}function removePercentEncoding(e){var t=e.replace(/%22/gi,"&quot;").replace(/%26/gi,"&amp;").replace(/%27/gi,"&#39;").replace(/%3C/gi,"&lt;").replace(/%3E/gi,"&gt;");try{return decodeURIComponent(t)}catch{return t}}var mailtoSchemePrefixRe=/^mailto:/i,emailLocalPartCharRegex=new RegExp("[".concat(alphaNumericAndMarksCharsStr,"!#$%&'*+/=?^_`{|}~-]"));function isEmailLocalPartStartChar(e){return alphaNumericAndMarksRe.test(e)}function isEmailLocalPartChar(e){return emailLocalPartCharRegex.test(e)}function isValidEmail(e){var t=e.split(".").pop()||"";return isKnownTld(t)}var EmailMatch=function(e){__extends(t,e);function t(n){var i=e.call(this,n)||this;return i.type="email",i.email="",i.email=n.email,i}return t.prototype.getType=function(){return"email"},t.prototype.getEmail=function(){return this.email},t.prototype.getAnchorHref=function(){return"mailto:"+this.email},t.prototype.getAnchorText=function(){return this.email},t}(AbstractMatch);function isHashtagTextChar(e){return e==="_"||alphaNumericAndMarksRe.test(e)}function isValidHashtag(e){return e.length<=140}var hashtagServices=["twitter","facebook","instagram","tiktok"],HashtagMatch=function(e){__extends(t,e);function t(n){var i=e.call(this,n)||this;return i.type="hashtag",i.serviceName="twitter",i.hashtag="",i.serviceName=n.serviceName,i.hashtag=n.hashtag,i}return t.prototype.getType=function(){return"hashtag"},t.prototype.getServiceName=function(){return this.serviceName},t.prototype.getHashtag=function(){return this.hashtag},t.prototype.getAnchorHref=function(){var n=this.serviceName,i=this.hashtag;switch(n){case"twitter":return"https://twitter.com/hashtag/"+i;case"facebook":return"https://www.facebook.com/hashtag/"+i;case"instagram":return"https://instagram.com/explore/tags/"+i;case"tiktok":return"https://www.tiktok.com/tag/"+i;default:throw assertNever(n),new Error("Invalid hashtag service: ".concat(n))}},t.prototype.getAnchorText=function(){return"#"+this.hashtag},t.prototype.getCssClassSuffixes=function(){var n=e.prototype.getCssClassSuffixes.call(this),i=this.getServiceName();return i&&n.push(i),n},t}(AbstractMatch),mentionRegexes={twitter:/^@\w{1,15}$/,instagram:/^@[_\w]{1,30}$/,soundcloud:/^@[-a-z0-9_]{3,25}$/,tiktok:/^@[.\w]{1,23}[\w]$/},mentionTextCharRe=/[-\w.]/;function isMentionTextChar(e){return mentionTextCharRe.test(e)}function isValidMention(e,t){var n=mentionRegexes[t];return n.test(e)}var mentionServices=["twitter","instagram","soundcloud","tiktok"],MentionMatch=function(e){__extends(t,e);function t(n){var i=e.call(this,n)||this;return i.type="mention",i.serviceName="twitter",i.mention="",i.mention=n.mention,i.serviceName=n.serviceName,i}return t.prototype.getType=function(){return"mention"},t.prototype.getMention=function(){return this.mention},t.prototype.getServiceName=function(){return this.serviceName},t.prototype.getAnchorHref=function(){switch(this.serviceName){case"twitter":return"https://twitter.com/"+this.mention;case"instagram":return"https://instagram.com/"+this.mention;case"soundcloud":return"https://soundcloud.com/"+this.mention;case"tiktok":return"https://www.tiktok.com/@"+this.mention;default:throw new Error("Unknown service name to point mention to: "+this.serviceName)}},t.prototype.getAnchorText=function(){return"@"+this.mention},t.prototype.getCssClassSuffixes=function(){var n=e.prototype.getCssClassSuffixes.call(this),i=this.getServiceName();return i&&n.push(i),n},t}(AbstractMatch),separatorCharRe=/[-. ]/,hasDelimCharsRe=/[-. ()]/,controlCharRe=/[,;]/,mostPhoneNumbers=/(?:(?:(?:(\+)?\d{1,3}[-. ]?)?\(?\d{3}\)?[-. ]?\d{3}[-. ]?\d{4})|(?:(\+)(?:9[976]\d|8[987530]\d|6[987]\d|5[90]\d|42\d|3[875]\d|2[98654321]\d|9[8543210]|8[6421]|6[6543210]|5[87654321]|4[987654310]|3[9643210]|2[70]|7|1)[-. ]?(?:\d[-. ]?){6,12}\d+))([,;]+[0-9]+#?)*/,japanesePhoneRe=/(0([1-9]-?[1-9]\d{3}|[1-9]{2}-?\d{3}|[1-9]{2}\d{1}-?\d{2}|[1-9]{2}\d{2}-?\d{1})-?\d{4}|0[789]0-?\d{4}-?\d{4}|050-?\d{4}-?\d{4})/,validPhoneNumberRe=new RegExp("^".concat(mostPhoneNumbers.source,"|").concat(japanesePhoneRe.source,"$"));function isPhoneNumberSeparatorChar(e){return separatorCharRe.test(e)}function isPhoneNumberControlChar(e){return controlCharRe.test(e)}function isValidPhoneNumber(e){var t=e.charAt(0)==="+"||hasDelimCharsRe.test(e);return t&&validPhoneNumberRe.test(e)}var PhoneMatch=function(e){__extends(t,e);function t(n){var i=e.call(this,n)||this;return i.type="phone",i.number="",i.plusSign=!1,i.number=n.number,i.plusSign=n.plusSign,i}return t.prototype.getType=function(){return"phone"},t.prototype.getPhoneNumber=function(){return this.number},t.prototype.getNumber=function(){return this.getPhoneNumber()},t.prototype.getAnchorHref=function(){return"tel:"+(this.plusSign?"+":"")+this.number},t.prototype.getAnchorText=function(){return this.matchedText},t}(AbstractMatch);function parseMatches(e,t){for(var n=t.tagBuilder,i=t.stripPrefix,r=t.stripTrailingSlash,o=t.decodePercentEncoding,a=t.hashtagServiceName,s=t.mentionServiceName,l=[],c=e.length,d=[],h=0;h<c;h++){var f=e.charAt(h);if(d.length===0)g(f);else for(var p=d.length-1;p>=0;p--){var u=d[p];switch(u.state){case 11:b(u,f);break;case 12:D(u,f);break;case 0:_(u,f);break;case 1:C(u,f);break;case 2:A(u,f);break;case 3:S(u,f);break;case 4:v(u,f);break;case 5:I(u,f);break;case 6:L(u,f);break;case 7:N(u,f);break;case 13:y(u,f);break;case 14:x(u,f);break;case 8:T(u,f);break;case 9:E(u,f);break;case 10:P(u,f);break;case 15:M(u,f);break;case 16:O(u,f);break;case 17:V(u,f);break;case 18:R(u,f);break;case 19:w(u,f);break;case 20:U(u,f);break;case 21:k(u,f);break;case 22:H(u,f);break;case 23:F(u,f);break;case 24:G(u,f);break;case 25:B(u,f);break;case 26:W(u,f);break;case 27:Y(u,f);break;case 28:z(u,f);break;case 29:X(u,f);break;case 30:q(u,f);break;case 31:Q(u,f);break;case 32:K(u,f);break;case 33:J(u,f);break;case 34:se(u,f);break;case 35:ae(u,f);break;case 36:te(u,f);break;case 37:Z(u,f);break;case 38:ee(u,f);break;case 39:ce(u,f);break;case 40:re(u,f);break;case 41:ne(u,f);break;default:assertNever(u.state)}}}for(var m=d.length-1;m>=0;m--)d.forEach(function($){return le($)});return l;function g($){if($==="#")d.push(createHashtagStateMachine(h,28));else if($==="@")d.push(createMentionStateMachine(h,30));else if($==="/")d.push(createTldUrlStateMachine(h,11));else if($==="+")d.push(createPhoneNumberStateMachine(h,37));else if($==="(")d.push(createPhoneNumberStateMachine(h,32));else{if(digitRe.test($)&&(d.push(createPhoneNumberStateMachine(h,38)),d.push(createIpV4UrlStateMachine(h,13))),isEmailLocalPartStartChar($)){var j=$.toLowerCase()==="m"?15:22;d.push(createEmailStateMachine(h,j))}isSchemeStartChar($)&&d.push(createSchemeUrlStateMachine(h,0)),alphaNumericAndMarksRe.test($)&&d.push(createTldUrlStateMachine(h,5))}}function _($,j){j===":"?$.state=2:j==="-"?$.state=1:isSchemeChar(j)||remove$1(d,$)}function C($,j){j==="-"||(j==="/"?(remove$1(d,$),d.push(createTldUrlStateMachine(h,11))):isSchemeChar(j)?$.state=0:remove$1(d,$))}function A($,j){j==="/"?$.state=3:j==="."?remove$1(d,$):isDomainLabelStartChar(j)?($.state=5,isSchemeStartChar(j)&&d.push(createSchemeUrlStateMachine(h,0))):remove$1(d,$)}function S($,j){j==="/"?$.state=4:isPathChar(j)?($.state=10,$.acceptStateReached=!0):le($)}function v($,j){j==="/"?$.state=10:isDomainLabelStartChar(j)?($.state=5,$.acceptStateReached=!0):remove$1(d,$)}function b($,j){j==="/"?$.state=12:remove$1(d,$)}function D($,j){isDomainLabelStartChar(j)?$.state=5:remove$1(d,$)}function I($,j){j==="."?$.state=7:j==="-"?$.state=6:j===":"?$.state=8:isUrlSuffixStartChar(j)?$.state=10:isDomainLabelChar(j)||le($)}function L($,j){j==="-"||(j==="."?le($):isDomainLabelStartChar(j)?$.state=5:le($))}function N($,j){j==="."?le($):isDomainLabelStartChar(j)?($.state=5,$.acceptStateReached=!0):le($)}function y($,j){j==="."?$.state=14:j===":"?$.state=8:digitRe.test(j)||(isUrlSuffixStartChar(j)?$.state=10:alphaNumericAndMarksRe.test(j)?remove$1(d,$):le($))}function x($,j){digitRe.test(j)?($.octetsEncountered++,$.octetsEncountered===4&&($.acceptStateReached=!0),$.state=13):le($)}function T($,j){digitRe.test(j)?$.state=9:le($)}function E($,j){digitRe.test(j)||(isUrlSuffixStartChar(j)?$.state=10:le($))}function P($,j){isPathChar(j)||le($)}function M($,j){j.toLowerCase()==="a"?$.state=16:H($,j)}function O($,j){j.toLowerCase()==="i"?$.state=17:H($,j)}function V($,j){j.toLowerCase()==="l"?$.state=18:H($,j)}function R($,j){j.toLowerCase()==="t"?$.state=19:H($,j)}function w($,j){j.toLowerCase()==="o"?$.state=20:H($,j)}function U($,j){j.toLowerCase()===":"?$.state=21:H($,j)}function k($,j){isEmailLocalPartChar(j)?$.state=22:remove$1(d,$)}function H($,j){j==="."?$.state=23:j==="@"?$.state=24:isEmailLocalPartChar(j)?$.state=22:remove$1(d,$)}function F($,j){j==="."||j==="@"?remove$1(d,$):isEmailLocalPartChar(j)?$.state=22:remove$1(d,$)}function G($,j){isDomainLabelStartChar(j)?$.state=25:remove$1(d,$)}function B($,j){j==="."?$.state=27:j==="-"?$.state=26:isDomainLabelChar(j)||le($)}function W($,j){j==="-"||j==="."?le($):isDomainLabelChar(j)?$.state=25:le($)}function Y($,j){j==="."||j==="-"?le($):isDomainLabelStartChar(j)?($.state=25,$.acceptStateReached=!0):le($)}function z($,j){isHashtagTextChar(j)?($.state=29,$.acceptStateReached=!0):remove$1(d,$)}function X($,j){isHashtagTextChar(j)||le($)}function q($,j){isMentionTextChar(j)?($.state=31,$.acceptStateReached=!0):remove$1(d,$)}function Q($,j){isMentionTextChar(j)||(alphaNumericAndMarksRe.test(j)?remove$1(d,$):le($))}function Z($,j){digitRe.test(j)?$.state=38:(remove$1(d,$),g(j))}function K($,j){digitRe.test(j)?$.state=33:remove$1(d,$),g(j)}function J($,j){digitRe.test(j)?$.state=34:remove$1(d,$)}function se($,j){digitRe.test(j)?$.state=35:remove$1(d,$)}function ae($,j){j===")"?$.state=36:remove$1(d,$)}function te($,j){digitRe.test(j)?$.state=38:isPhoneNumberSeparatorChar(j)?$.state=39:remove$1(d,$)}function ee($,j){$.acceptStateReached=!0,isPhoneNumberControlChar(j)?$.state=40:j==="#"?$.state=41:digitRe.test(j)||(j==="("?$.state=32:isPhoneNumberSeparatorChar(j)?$.state=39:(le($),isSchemeStartChar(j)&&d.push(createSchemeUrlStateMachine(h,0))))}function ce($,j){digitRe.test(j)?$.state=38:j==="("?$.state=32:(le($),g(j))}function re($,j){isPhoneNumberControlChar(j)||(j==="#"?$.state=41:digitRe.test(j)?$.state=38:le($))}function ne($,j){isPhoneNumberControlChar(j)?$.state=40:digitRe.test(j)?remove$1(d,$):le($)}function le($){if(remove$1(d,$),!!$.acceptStateReached){var j=$.startIdx,oe=e.slice($.startIdx,h);if(oe=excludeUnbalancedTrailingBracesAndPunctuation(oe),$.type==="url"){var ie=e.charAt($.startIdx-1);if(ie==="@")return;var de=$.matchType;if(de==="scheme"){var ue=httpSchemeRe.exec(oe);if(ue&&(j=j+ue.index,oe=oe.slice(ue.index)),!isValidSchemeUrl(oe))return}else if(de==="tld"){if(!isValidTldMatch(oe))return}else if(de==="ipV4"){if(!isValidIpV4Address(oe))return}else assertNever(de);l.push(new UrlMatch({tagBuilder:n,matchedText:oe,offset:j,urlMatchType:de,url:oe,protocolRelativeMatch:oe.slice(0,2)==="//",stripPrefix:i,stripTrailingSlash:r,decodePercentEncoding:o}))}else if($.type==="email")isValidEmail(oe)&&l.push(new EmailMatch({tagBuilder:n,matchedText:oe,offset:j,email:oe.replace(mailtoSchemePrefixRe,"")}));else if($.type==="hashtag")isValidHashtag(oe)&&l.push(new HashtagMatch({tagBuilder:n,matchedText:oe,offset:j,serviceName:a,hashtag:oe.slice(1)}));else if($.type==="mention")isValidMention(oe,s)&&l.push(new MentionMatch({tagBuilder:n,matchedText:oe,offset:j,serviceName:s,mention:oe.slice(1)}));else if($.type==="phone"){if(oe=oe.replace(/ +$/g,""),isValidPhoneNumber(oe)){var Ee=oe.replace(/[^0-9,;#]/g,"");l.push(new PhoneMatch({tagBuilder:n,matchedText:oe,offset:j,number:Ee,plusSign:oe.charAt(0)==="+"}))}}else assertNever($)}}}var openBraceRe=/[\(\{\[]/,closeBraceRe=/[\)\}\]]/,oppositeBrace={")":"(","}":"{","]":"["};function excludeUnbalancedTrailingBracesAndPunctuation(e){for(var t={"(":0,"{":0,"[":0},n=0;n<e.length;n++){var i=e.charAt(n);openBraceRe.test(i)?t[i]++:closeBraceRe.test(i)&&t[oppositeBrace[i]]--}for(var r=e.length-1,o;r>=0;)if(o=e.charAt(r),closeBraceRe.test(o)){var a=oppositeBrace[o];if(t[a]<0)t[a]++,r--;else break}else if(urlSuffixedCharsNotAllowedAtEndRe.test(o))r--;else break;return e.slice(0,r+1)}function createSchemeUrlStateMachine(e,t){return{type:"url",startIdx:e,state:t,acceptStateReached:!1,matchType:"scheme"}}function createTldUrlStateMachine(e,t){return{type:"url",startIdx:e,state:t,acceptStateReached:!1,matchType:"tld"}}function createIpV4UrlStateMachine(e,t){return{type:"url",startIdx:e,state:t,acceptStateReached:!1,matchType:"ipV4",octetsEncountered:1}}function createEmailStateMachine(e,t){return{type:"email",startIdx:e,state:t,acceptStateReached:!1}}function createHashtagStateMachine(e,t){return{type:"hashtag",startIdx:e,state:t,acceptStateReached:!1}}function createMentionStateMachine(e,t){return{type:"mention",startIdx:e,state:t,acceptStateReached:!1}}function createPhoneNumberStateMachine(e,t){return{type:"phone",startIdx:e,state:t,acceptStateReached:!1}}function parseHtml(e,t){for(var n=t.onOpenTag,i=t.onCloseTag,r=t.onText,o=t.onComment,a=t.onDoctype,s=new CurrentTag,l=0,c=e.length,d=0,h=0,f=s;l<c;){var p=e.charAt(l);switch(d){case 0:u(p);break;case 1:m(p);break;case 2:_(p);break;case 3:g(p);break;case 4:C(p);break;case 5:A(p);break;case 6:S(p);break;case 7:v(p);break;case 8:b(p);break;case 9:D(p);break;case 10:I(p);break;case 11:L(p);break;case 12:N(p);break;case 13:y();break;case 14:x(p);break;case 15:T(p);break;case 16:E(p);break;case 17:P(p);break;case 18:M(p);break;case 19:O(p);break;case 20:V(p);break;default:assertNever(d)}l++}h<l&&k();function u(G){G==="<"&&w()}function m(G){G==="!"?d=13:G==="/"?(d=2,f=new CurrentTag(__assign(__assign({},f),{isClosing:!0}))):G==="<"?w():letterRe.test(G)?(d=3,f=new CurrentTag(__assign(__assign({},f),{isOpening:!0}))):(d=0,f=s)}function g(G){whitespaceRe.test(G)?(f=new CurrentTag(__assign(__assign({},f),{name:H()})),d=4):G==="<"?w():G==="/"?(f=new CurrentTag(__assign(__assign({},f),{name:H()})),d=12):G===">"?(f=new CurrentTag(__assign(__assign({},f),{name:H()})),U()):!letterRe.test(G)&&!digitRe.test(G)&&G!==":"&&R()}function _(G){G===">"?R():letterRe.test(G)?d=3:R()}function C(G){whitespaceRe.test(G)||(G==="/"?d=12:G===">"?U():G==="<"?w():G==="="||quoteRe.test(G)||controlCharsRe.test(G)?R():d=5)}function A(G){whitespaceRe.test(G)?d=6:G==="/"?d=12:G==="="?d=7:G===">"?U():G==="<"?w():quoteRe.test(G)&&R()}function S(G){whitespaceRe.test(G)||(G==="/"?d=12:G==="="?d=7:G===">"?U():G==="<"?w():quoteRe.test(G)?R():d=5)}function v(G){whitespaceRe.test(G)||(G==='"'?d=8:G==="'"?d=9:/[>=`]/.test(G)?R():G==="<"?w():d=10)}function b(G){G==='"'&&(d=11)}function D(G){G==="'"&&(d=11)}function I(G){whitespaceRe.test(G)?d=4:G===">"?U():G==="<"&&w()}function L(G){whitespaceRe.test(G)?d=4:G==="/"?d=12:G===">"?U():G==="<"?w():(d=4,F())}function N(G){G===">"?(f=new CurrentTag(__assign(__assign({},f),{isClosing:!0})),U()):d=4}function y(G){e.substr(l,2)==="--"?(l+=2,f=new CurrentTag(__assign(__assign({},f),{type:"comment"})),d=14):e.substr(l,7).toUpperCase()==="DOCTYPE"?(l+=7,f=new CurrentTag(__assign(__assign({},f),{type:"doctype"})),d=20):R()}function x(G){G==="-"?d=15:G===">"?R():d=16}function T(G){G==="-"?d=18:G===">"?R():d=16}function E(G){G==="-"&&(d=17)}function P(G){G==="-"?d=18:d=16}function M(G){G===">"?U():G==="!"?d=19:G==="-"||(d=16)}function O(G){G==="-"?d=17:G===">"?U():d=16}function V(G){G===">"?U():G==="<"&&w()}function R(){d=0,f=s}function w(){d=1,f=new CurrentTag({idx:l})}function U(){var G=e.slice(h,f.idx);G&&r(G,h),f.type==="comment"?o(f.idx):f.type==="doctype"?a(f.idx):(f.isOpening&&n(f.name,f.idx),f.isClosing&&i(f.name,f.idx)),R(),h=l+1}function k(){var G=e.slice(h,l);r(G,h),h=l+1}function H(){var G=f.idx+(f.isClosing?2:1);return e.slice(G,l).toLowerCase()}function F(){l--}}var CurrentTag=function(){function e(t){t===void 0&&(t={}),this.idx=t.idx!==void 0?t.idx:-1,this.type=t.type||"tag",this.name=t.name||"",this.isOpening=!!t.isOpening,this.isClosing=!!t.isClosing}return e}(),Autolinker=function(){function e(t){t===void 0&&(t={}),this.version=e.version,this.urls={},this.email=!0,this.phone=!0,this.hashtag=!1,this.mention=!1,this.newWindow=!0,this.stripPrefix={scheme:!0,www:!0},this.stripTrailingSlash=!0,this.decodePercentEncoding=!0,this.truncate={length:0,location:"end"},this.className="",this.replaceFn=null,this.context=void 0,this.sanitizeHtml=!1,this.tagBuilder=null,this.urls=normalizeUrlsCfg(t.urls),this.email=isBoolean(t.email)?t.email:this.email,this.phone=isBoolean(t.phone)?t.phone:this.phone,this.hashtag=t.hashtag||this.hashtag,this.mention=t.mention||this.mention,this.newWindow=isBoolean(t.newWindow)?t.newWindow:this.newWindow,this.stripPrefix=normalizeStripPrefixCfg(t.stripPrefix),this.stripTrailingSlash=isBoolean(t.stripTrailingSlash)?t.stripTrailingSlash:this.stripTrailingSlash,this.decodePercentEncoding=isBoolean(t.decodePercentEncoding)?t.decodePercentEncoding:this.decodePercentEncoding,this.sanitizeHtml=t.sanitizeHtml||!1;var n=this.mention;if(n!==!1&&mentionServices.indexOf(n)===-1)throw new Error("invalid `mention` cfg '".concat(n,"' - see docs"));var i=this.hashtag;if(i!==!1&&hashtagServices.indexOf(i)===-1)throw new Error("invalid `hashtag` cfg '".concat(i,"' - see docs"));this.truncate=normalizeTruncateCfg(t.truncate),this.className=t.className||this.className,this.replaceFn=t.replaceFn||this.replaceFn,this.context=t.context||this}return e.link=function(t,n){var i=new e(n);return i.link(t)},e.parse=function(t,n){var i=new e(n);return i.parse(t)},e.prototype.parse=function(t){var n=this,i=["a","style","script"],r=0,o=[];return parseHtml(t,{onOpenTag:function(a){i.indexOf(a)>=0&&r++},onText:function(a,s){if(r===0){var l=/(&nbsp;|&#160;|&lt;|&#60;|&gt;|&#62;|&quot;|&#34;|&#39;)/gi,c=a.split(l),d=s;c.forEach(function(h,f){if(f%2===0){var p=n.parseText(h,d);o.push.apply(o,p)}d+=h.length})}},onCloseTag:function(a){i.indexOf(a)>=0&&(r=Math.max(r-1,0))},onComment:function(a){},onDoctype:function(a){}}),o=this.compactMatches(o),o=this.removeUnwantedMatches(o),o},e.prototype.compactMatches=function(t){t.sort(function(l,c){return l.getOffset()-c.getOffset()});for(var n=0;n<t.length-1;){var i=t[n],r=i.getOffset(),o=i.getMatchedText().length,a=r+o;if(n+1<t.length){if(t[n+1].getOffset()===r){var s=t[n+1].getMatchedText().length>o?n:n+1;t.splice(s,1);continue}if(t[n+1].getOffset()<a){t.splice(n+1,1);continue}}n++}return t},e.prototype.removeUnwantedMatches=function(t){return this.hashtag||removeWithPredicate(t,function(n){return n.getType()==="hashtag"}),this.email||removeWithPredicate(t,function(n){return n.getType()==="email"}),this.phone||removeWithPredicate(t,function(n){return n.getType()==="phone"}),this.mention||removeWithPredicate(t,function(n){return n.getType()==="mention"}),this.urls.schemeMatches||removeWithPredicate(t,function(n){return n.getType()==="url"&&n.getUrlMatchType()==="scheme"}),this.urls.tldMatches||removeWithPredicate(t,function(n){return n.getType()==="url"&&n.getUrlMatchType()==="tld"}),this.urls.ipV4Matches||removeWithPredicate(t,function(n){return n.getType()==="url"&&n.getUrlMatchType()==="ipV4"}),t},e.prototype.parseText=function(t,n){n===void 0&&(n=0),n=n||0;for(var i=parseMatches(t,{tagBuilder:this.getTagBuilder(),stripPrefix:this.stripPrefix,stripTrailingSlash:this.stripTrailingSlash,decodePercentEncoding:this.decodePercentEncoding,hashtagServiceName:this.hashtag,mentionServiceName:this.mention||"twitter"}),r=0,o=i.length;r<o;r++)i[r].setOffset(n+i[r].getOffset());return i},e.prototype.link=function(t){if(!t)return"";this.sanitizeHtml&&(t=t.replace(/</g,"&lt;").replace(/>/g,"&gt;"));for(var n=this.parse(t),i=[],r=0,o=0,a=n.length;o<a;o++){var s=n[o];i.push(t.substring(r,s.getOffset())),i.push(this.createMatchReturnVal(s)),r=s.getOffset()+s.getMatchedText().length}return i.push(t.substring(r)),i.join("")},e.prototype.createMatchReturnVal=function(t){var n;if(this.replaceFn&&(n=this.replaceFn.call(this.context,t)),typeof n=="string")return n;if(n===!1)return t.getMatchedText();if(n instanceof HtmlTag)return n.toAnchorString();var i=t.buildTag();return i.toAnchorString()},e.prototype.getTagBuilder=function(){var t=this.tagBuilder;return t||(t=this.tagBuilder=new AnchorTagBuilder({newWindow:this.newWindow,truncate:this.truncate,className:this.className})),t},e.version=version,e}();function normalizeUrlsCfg(e){return e==null&&(e=!0),isBoolean(e)?{schemeMatches:e,tldMatches:e,ipV4Matches:e}:{schemeMatches:isBoolean(e.schemeMatches)?e.schemeMatches:!0,tldMatches:isBoolean(e.tldMatches)?e.tldMatches:!0,ipV4Matches:isBoolean(e.ipV4Matches)?e.ipV4Matches:!0}}function normalizeStripPrefixCfg(e){return e==null&&(e=!0),isBoolean(e)?{scheme:e,www:e}:{scheme:isBoolean(e.scheme)?e.scheme:!0,www:isBoolean(e.www)?e.www:!0}}function normalizeTruncateCfg(e){return typeof e=="number"?{length:e,location:"end"}:defaults(e||{},{length:Number.POSITIVE_INFINITY,location:"end"})}let parser$1;typeof DOMParser<"u"&&(parser$1=new DOMParser);const autolinker$1=new Autolinker({stripPrefix:!1,email:!1,replaceFn:function(e,t){return t.urlMatchType==="scheme"||t.urlMatchType==="www"}}),BILLBOARD_SIZE$1=32,BILLBOARD_NEAR_DISTANCE$1=2414016,BILLBOARD_NEAR_RATIO$1=1,BILLBOARD_FAR_DISTANCE$1=16093e3,BILLBOARD_FAR_RATIO$1=.1,gpxNamespaces=[null,void 0,"http://www.topografix.com/GPX/1/1"],namespaces$1={gpx:gpxNamespaces};function readBlobAsText$1(e){return new Promise((t,n)=>{const i=new FileReader;i.addEventListener("load",function(){t(i.result)}),i.addEventListener("error",function(){n(i.error)}),i.readAsText(e)})}function getOrCreateEntity(e,t){let n=queryStringAttribute$1(e,"id");return n=defined(n)?n:createGuid(),t.getOrCreateEntity(n)}function readCoordinateFromNode(e){const t=queryNumericAttribute$1(e,"lon"),n=queryNumericAttribute$1(e,"lat"),i=queryNumericValue$1(e,"ele",namespaces$1.gpx);return Cartesian3.fromDegrees(t,n,i)}function queryNumericAttribute$1(e,t){if(!defined(e))return;const n=e.getAttribute(t);if(n!==null){const i=parseFloat(n);return isNaN(i)?void 0:i}}function queryStringAttribute$1(e,t){if(!defined(e))return;const n=e.getAttribute(t);return n!==null?n:void 0}function queryFirstNode$1(e,t,n){if(!defined(e))return;const i=e.childNodes,r=i.length;for(let o=0;o<r;o++){const a=i[o];if(a.localName===t&&n.indexOf(a.namespaceURI)!==-1)return a}}function queryNodes$1(e,t,n){if(!defined(e))return;const i=[],r=e.getElementsByTagName(t),o=r.length;for(let a=0;a<o;a++){const s=r[a];s.localName===t&&n.indexOf(s.namespaceURI)!==-1&&i.push(s)}return i}function queryNumericValue$1(e,t,n){const i=queryFirstNode$1(e,t,n);if(defined(i)){const r=parseFloat(i.textContent);return isNaN(r)?void 0:r}}function queryStringValue$1(e,t,n){const i=queryFirstNode$1(e,t,n);if(defined(i))return i.textContent.trim()}function createDefaultBillboard$1(e){const t=new BillboardGraphics;return t.width=BILLBOARD_SIZE$1,t.height=BILLBOARD_SIZE$1,t.scaleByDistance=new NearFarScalar(BILLBOARD_NEAR_DISTANCE$1,BILLBOARD_NEAR_RATIO$1,BILLBOARD_FAR_DISTANCE$1,BILLBOARD_FAR_RATIO$1),t.pixelOffsetScaleByDistance=new NearFarScalar(BILLBOARD_NEAR_DISTANCE$1,BILLBOARD_NEAR_RATIO$1,BILLBOARD_FAR_DISTANCE$1,BILLBOARD_FAR_RATIO$1),t.verticalOrigin=new ConstantProperty(VerticalOrigin.BOTTOM),t.image=e,t}function createDefaultLabel$1(){const e=new LabelGraphics;return e.translucencyByDistance=new NearFarScalar(3e6,1,5e6,0),e.pixelOffset=new Cartesian2(17,0),e.horizontalOrigin=HorizontalOrigin.LEFT,e.font="16px sans-serif",e.style=LabelStyle.FILL_AND_OUTLINE,e}function createDefaultPolyline(e){const t=new PolylineGraphics;return t.width=4,t.material=new PolylineOutlineMaterialProperty,t.material.color=defined(e)?e:Color.RED,t.material.outlineWidth=2,t.material.outlineColor=Color.BLACK,t}const descriptiveInfoTypes={time:{text:"Time",tag:"time"},comment:{text:"Comment",tag:"cmt"},description:{text:"Description",tag:"desc"},source:{text:"Source",tag:"src"},number:{text:"GPS track/route number",tag:"number"},type:{text:"Type",tag:"type"}};let scratchDiv$1;typeof document<"u"&&(scratchDiv$1=document.createElement("div"));function processDescription$1(e,t){let n,i="";const r=Object.keys(descriptiveInfoTypes),o=r.length;for(n=0;n<o;n++){const d=r[n],h=descriptiveInfoTypes[d];h.value=defaultValue(queryStringValue$1(e,h.tag,namespaces$1.gpx),""),defined(h.value)&&h.value!==""&&(i=`${i}<p>${h.text}: ${h.value}</p>`)}if(!defined(i)||i==="")return;i=autolinker$1.link(i),scratchDiv$1.innerHTML=i;const a=scratchDiv$1.querySelectorAll("a");for(n=0;n<a.length;n++)a[n].setAttribute("target","_blank");const s=Color.WHITE,l=Color.BLACK;let c='<div class="cesium-infoBox-description-lighter" style="';return c+="overflow:auto;",c+="word-wrap:break-word;",c+=`background-color:${s.toCssColorString()};`,c+=`color:${l.toCssColorString()};`,c+='">',c+=`${scratchDiv$1.innerHTML}</div>`,scratchDiv$1.innerHTML="",c}function processWpt(e,t,n,i){const r=readCoordinateFromNode(t),o=getOrCreateEntity(t,n);o.position=r;const a=defined(i.waypointImage)?i.waypointImage:e._pinBuilder.fromMakiIconId("marker",Color.RED,BILLBOARD_SIZE$1);o.billboard=createDefaultBillboard$1(a);const s=queryStringValue$1(t,"name",namespaces$1.gpx);o.name=s,o.label=createDefaultLabel$1(),o.label.text=s,o.description=processDescription$1(t),i.clampToGround&&(o.billboard.heightReference=HeightReference.CLAMP_TO_GROUND,o.label.heightReference=HeightReference.CLAMP_TO_GROUND)}function processRte(e,t,n,i){const r=getOrCreateEntity(t,n);r.description=processDescription$1(t);const o=queryNodes$1(t,"rtept",namespaces$1.gpx),a=new Array(o.length);for(let s=0;s<o.length;s++)processWpt(e,o[s],n,i),a[s]=readCoordinateFromNode(o[s]);r.polyline=createDefaultPolyline(i.routeColor),i.clampToGround&&(r.polyline.clampToGround=!0),r.polyline.positions=a}function processTrk(e,t,n,i){const r=getOrCreateEntity(t,n);r.description=processDescription$1(t);const o=queryNodes$1(t,"trkseg",namespaces$1.gpx);let a=[],s=[],l,c=!0;const d=new SampledPositionProperty;for(let h=0;h<o.length;h++)l=processTrkSeg(o[h]),a=a.concat(l.positions),l.times.length>0?(s=s.concat(l.times),d.addSamples(s,a),c=c&&!0):c=!1;if(c){const h=defined(i.waypointImage)?i.waypointImage:e._pinBuilder.fromMakiIconId("marker",Color.RED,BILLBOARD_SIZE$1);r.billboard=createDefaultBillboard$1(h),r.position=d,i.clampToGround&&(r.billboard.heightReference=HeightReference.CLAMP_TO_GROUND),r.availability=new TimeIntervalCollection,r.availability.addInterval(new TimeInterval({start:s[0],stop:s[s.length-1]}))}r.polyline=createDefaultPolyline(i.trackColor),r.polyline.positions=a,i.clampToGround&&(r.polyline.clampToGround=!0)}function processTrkSeg(e){const t={positions:[],times:[]},n=queryNodes$1(e,"trkpt",namespaces$1.gpx);let i;for(let r=0;r<n.length;r++){const o=readCoordinateFromNode(n[r]);t.positions.push(o),i=queryStringValue$1(n[r],"time",namespaces$1.gpx),defined(i)&&t.times.push(JulianDate.fromIso8601(i))}return t}function processMetadata(e){const t=queryFirstNode$1(e,"metadata",namespaces$1.gpx);if(defined(t)){const n={name:queryStringValue$1(t,"name",namespaces$1.gpx),desc:queryStringValue$1(t,"desc",namespaces$1.gpx),author:getPerson(t),copyright:getCopyright(t),link:getLink(t),time:queryStringValue$1(t,"time",namespaces$1.gpx),keywords:queryStringValue$1(t,"keywords",namespaces$1.gpx),bounds:getBounds(t)};if(defined(n.name)||defined(n.desc)||defined(n.author)||defined(n.copyright)||defined(n.link)||defined(n.time)||defined(n.keywords)||defined(n.bounds))return n}}function getPerson(e){const t=queryFirstNode$1(e,"author",namespaces$1.gpx);if(defined(t)){const n={name:queryStringValue$1(t,"name",namespaces$1.gpx),email:getEmail(t),link:getLink(t)};if(defined(n.name)||defined(n.email)||defined(n.link))return n}}function getEmail(e){const t=queryFirstNode$1(e,"email",namespaces$1.gpx);if(defined(t)){const n=queryStringValue$1(t,"id",namespaces$1.gpx),i=queryStringValue$1(t,"domain",namespaces$1.gpx);return`${n}@${i}`}}function getLink(e){const t=queryFirstNode$1(e,"link",namespaces$1.gpx);if(defined(t)){const n={href:queryStringAttribute$1(t,"href"),text:queryStringValue$1(t,"text",namespaces$1.gpx),mimeType:queryStringValue$1(t,"type",namespaces$1.gpx)};if(defined(n.href)||defined(n.text)||defined(n.mimeType))return n}}function getCopyright(e){const t=queryFirstNode$1(e,"copyright",namespaces$1.gpx);if(defined(t)){const n={author:queryStringAttribute$1(t,"author"),year:queryStringValue$1(t,"year",namespaces$1.gpx),license:queryStringValue$1(t,"license",namespaces$1.gpx)};if(defined(n.author)||defined(n.year)||defined(n.license))return n}}function getBounds(e){const t=queryFirstNode$1(e,"bounds",namespaces$1.gpx);if(defined(t)){const n={minLat:queryNumericValue$1(t,"minlat",namespaces$1.gpx),maxLat:queryNumericValue$1(t,"maxlat",namespaces$1.gpx),minLon:queryNumericValue$1(t,"minlon",namespaces$1.gpx),maxLon:queryNumericValue$1(t,"maxlon",namespaces$1.gpx)};if(defined(n.minLat)||defined(n.maxLat)||defined(n.minLon)||defined(n.maxLon))return n}}const complexTypes={wpt:processWpt,rte:processRte,trk:processTrk};function processGpx(e,t,n,i){const r=Object.keys(complexTypes),o=r.length;for(let a=0;a<o;a++){const s=r[a],l=complexTypes[s],c=t.childNodes,d=c.length;for(let h=0;h<d;h++){const f=c[h];f.localName===s&&namespaces$1.gpx.indexOf(f.namespaceURI)!==-1&&l(e,f,n,i)}}}function loadGpx(e,t,n){const i=e._entityCollection;i.removeAll();const r=t.documentElement,o=queryStringAttribute$1(r,"version"),a=queryStringAttribute$1(r,"creator");let s;const l=processMetadata(r);defined(l)&&(s=l.name),r.localName==="gpx"?processGpx(e,r,i,n):console.log(`GPX - Unsupported node: ${r.localName}`);let c;const d=i.computeAvailability();let h=d.start,f=d.stop;const p=JulianDate.equals(h,Iso8601.MINIMUM_VALUE),u=JulianDate.equals(f,Iso8601.MAXIMUM_VALUE);if(!p||!u){let g;p&&(g=new Date,g.setHours(0,0,0,0),h=JulianDate.fromDate(g)),u&&(g=new Date,g.setHours(24,0,0,0),f=JulianDate.fromDate(g)),c=new DataSourceClock,c.startTime=h,c.stopTime=f,c.currentTime=JulianDate.clone(h),c.clockRange=ClockRange$1.LOOP_STOP,c.clockStep=ClockStep$1.SYSTEM_CLOCK_MULTIPLIER,c.multiplier=Math.round(Math.min(Math.max(JulianDate.secondsDifference(f,h)/60,1),31556900))}let m=!1;return e._name!==s&&(e._name=s,m=!0),e._creator!==a&&(e._creator=a,m=!0),metadataChanged(e._metadata,l)&&(e._metadata=l,m=!0),e._version!==o&&(e._version=o,m=!0),c!==e._clock&&(m=!0,e._clock=c),m&&e._changed.raiseEvent(e),DataSource.setLoading(e,!1),e}function metadataChanged(e,t){return!defined(e)&&!defined(t)?!1:defined(e)&&defined(t)?e.name!==t.name||e.dec!==t.desc||e.src!==t.src||e.author!==t.author||e.copyright!==t.copyright||e.link!==t.link||e.time!==t.time||e.bounds!==t.bounds:!0}function load$2(e,t,n,i){i=defaultValue(i,defaultValue.EMPTY_OBJECT);let r=n;if(typeof n=="string"||n instanceof Resource){n=Resource.createIfNeeded(n),r=n.fetchBlob();const o=e._resourceCredits,a=n.credits;if(defined(a)){const s=a.length;for(let l=0;l<s;l++)o.push(a[l])}}return Promise.resolve(r).then(function(o){return o instanceof Blob?readBlobAsText$1(o).then(function(a){let s,l;try{s=parser$1.parseFromString(a,"application/xml")}catch(c){l=c.toString()}if(defined(l)||s.body||s.documentElement.tagName==="parsererror"){let c=defined(l)?l:s.documentElement.firstChild.nodeValue;throw c||(c=s.body.innerText),new RuntimeError(c)}return loadGpx(e,s,i)}):loadGpx(e,o,i)}).catch(function(o){return e._error.raiseEvent(e,o),console.log(o),Promise.reject(o)})}function GpxDataSource(){this._changed=new Event,this._error=new Event,this._loading=new Event,this._clock=void 0,this._entityCollection=new EntityCollection(this),this._entityCluster=new EntityCluster,this._name=void 0,this._version=void 0,this._creator=void 0,this._metadata=void 0,this._isLoading=!1,this._pinBuilder=new PinBuilder}GpxDataSource.load=function(e,t){return new GpxDataSource().load(e,t)};Object.defineProperties(GpxDataSource.prototype,{name:{get:function(){return this._name}},version:{get:function(){return this._version}},creator:{get:function(){return this._creator}},metadata:{get:function(){return this._metadata}},clock:{get:function(){return this._clock}},entities:{get:function(){return this._entityCollection}},isLoading:{get:function(){return this._isLoading}},changedEvent:{get:function(){return this._changed}},errorEvent:{get:function(){return this._error}},loadingEvent:{get:function(){return this._loading}},show:{get:function(){return this._entityCollection.show},set:function(e){this._entityCollection.show=e}},clustering:{get:function(){return this._entityCluster},set:function(e){if(!defined(e))throw new DeveloperError("value must be defined.");this._entityCluster=e}}});GpxDataSource.prototype.update=function(e){return!0};GpxDataSource.prototype.load=function(e,t){if(!defined(e))throw new DeveloperError("data is required.");t=defaultValue(t,defaultValue.EMPTY_OBJECT),DataSource.setLoading(this,!0);const n=this._name,i=this;return load$2(this,this._entityCollection,e,t).then(function(){let r;const o=i._entityCollection.computeAvailability();let a=o.start,s=o.stop;const l=JulianDate.equals(a,Iso8601.MINIMUM_VALUE),c=JulianDate.equals(s,Iso8601.MAXIMUM_VALUE);if(!l||!c){let h;l&&(h=new Date,h.setHours(0,0,0,0),a=JulianDate.fromDate(h)),c&&(h=new Date,h.setHours(24,0,0,0),s=JulianDate.fromDate(h)),r=new DataSourceClock,r.startTime=a,r.stopTime=s,r.currentTime=JulianDate.clone(a),r.clockRange=ClockRange$1.LOOP_STOP,r.clockStep=ClockStep$1.SYSTEM_CLOCK_MULTIPLIER,r.multiplier=Math.round(Math.min(Math.max(JulianDate.secondsDifference(s,a)/60,1),31556900))}let d=!1;return r!==i._clock&&(i._clock=r,d=!0),n!==i._name&&(d=!0),d&&i._changed.raiseEvent(i),DataSource.setLoading(i,!1),i}).catch(function(r){return DataSource.setLoading(i,!1),i._error.raiseEvent(i,r),console.log(r),Promise.reject(r)})};function KmlCamera(e,t){this.position=e,this.headingPitchRoll=t}function decodeText(e,t){return t&&t.trim().toLowerCase()=="cp437"?decodeCP437(e):new TextDecoder(t).decode(e)}const ERR_BAD_FORMAT="File format is not recognized",ERR_EOCDR_NOT_FOUND="End of central directory not found",ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND="End of Zip64 central directory locator not found",ERR_CENTRAL_DIRECTORY_NOT_FOUND="Central directory header not found",ERR_LOCAL_FILE_HEADER_NOT_FOUND="Local file header not found",ERR_EXTRAFIELD_ZIP64_NOT_FOUND="Zip64 extra field not found",ERR_ENCRYPTED="File contains encrypted entry",ERR_UNSUPPORTED_ENCRYPTION="Encryption method not supported",ERR_UNSUPPORTED_COMPRESSION="Compression method not supported",ERR_SPLIT_ZIP_FILE="Split zip file",CHARSET_UTF8="utf-8",CHARSET_CP437="cp437",ZIP64_PROPERTIES=[[PROPERTY_NAME_UNCOMPPRESSED_SIZE,MAX_32_BITS],[PROPERTY_NAME_COMPPRESSED_SIZE,MAX_32_BITS],[PROPERTY_NAME_OFFSET,MAX_32_BITS],[PROPERTY_NAME_DISK_NUMBER_START,MAX_16_BITS]],ZIP64_EXTRACTION={[MAX_16_BITS]:{getValue:getUint32,bytes:4},[MAX_32_BITS]:{getValue:getBigUint64,bytes:8}};class ZipReader{constructor(t,n={}){Object.assign(this,{reader:initReader(t),options:n,config:getConfiguration()})}async*getEntriesGenerator(t={}){const n=this;let{reader:i}=n;const{config:r}=n;if(await initStream(i),(i.size===UNDEFINED_VALUE||!i.readUint8Array)&&(i=new BlobReader(await new Response(i.readable).blob()),await initStream(i)),i.size<END_OF_CENTRAL_DIR_LENGTH)throw new Error(ERR_BAD_FORMAT);i.chunkSize=getChunkSize(r);const o=await seekSignature(i,END_OF_CENTRAL_DIR_SIGNATURE,i.size,END_OF_CENTRAL_DIR_LENGTH,MAX_16_BITS*16);if(!o){const N=await readUint8Array(i,0,4),y=getDataView(N);throw getUint32(y)==SPLIT_ZIP_FILE_SIGNATURE?new Error(ERR_SPLIT_ZIP_FILE):new Error(ERR_EOCDR_NOT_FOUND)}const a=getDataView(o);let s=getUint32(a,12),l=getUint32(a,16);const c=o.offset,d=getUint16(a,20),h=c+END_OF_CENTRAL_DIR_LENGTH+d;let f=getUint16(a,4);const p=i.lastDiskNumber||0;let u=getUint16(a,6),m=getUint16(a,8),g=0,_=0;if(l==MAX_32_BITS||s==MAX_32_BITS||m==MAX_16_BITS||u==MAX_16_BITS){const N=await readUint8Array(i,o.offset-ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH,ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH),y=getDataView(N);if(getUint32(y,0)==ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE){l=getBigUint64(y,8);let x=await readUint8Array(i,l,ZIP64_END_OF_CENTRAL_DIR_LENGTH,-1),T=getDataView(x);const E=o.offset-ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH-ZIP64_END_OF_CENTRAL_DIR_LENGTH;if(getUint32(T,0)!=ZIP64_END_OF_CENTRAL_DIR_SIGNATURE&&l!=E){const P=l;l=E,g=l-P,x=await readUint8Array(i,l,ZIP64_END_OF_CENTRAL_DIR_LENGTH,-1),T=getDataView(x)}if(getUint32(T,0)!=ZIP64_END_OF_CENTRAL_DIR_SIGNATURE)throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);f==MAX_16_BITS&&(f=getUint32(T,16)),u==MAX_16_BITS&&(u=getUint32(T,20)),m==MAX_16_BITS&&(m=getBigUint64(T,32)),s==MAX_32_BITS&&(s=getBigUint64(T,40)),l-=s}}if(l>=i.size&&(g=i.size-l-s-END_OF_CENTRAL_DIR_LENGTH,l=i.size-s-END_OF_CENTRAL_DIR_LENGTH),p!=f)throw new Error(ERR_SPLIT_ZIP_FILE);if(l<0)throw new Error(ERR_BAD_FORMAT);let C=0,A=await readUint8Array(i,l,s,u),S=getDataView(A);if(s){const N=o.offset-s;if(getUint32(S,C)!=CENTRAL_FILE_HEADER_SIGNATURE&&l!=N){const y=l;l=N,g+=l-y,A=await readUint8Array(i,l,s,u),S=getDataView(A)}}const v=o.offset-l-(i.lastDiskOffset||0);if(s!=v&&v>=0&&(s=v,A=await readUint8Array(i,l,s,u),S=getDataView(A)),l<0||l>=i.size)throw new Error(ERR_BAD_FORMAT);const b=getOptionValue(n,t,"filenameEncoding"),D=getOptionValue(n,t,"commentEncoding");for(let N=0;N<m;N++){const y=new ZipEntry(i,r,n.options);if(getUint32(S,C)!=CENTRAL_FILE_HEADER_SIGNATURE)throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);readCommonHeader(y,S,C+6);const x=!!y.bitFlag.languageEncodingFlag,T=C+46,E=T+y.filenameLength,P=E+y.extraFieldLength,M=getUint16(S,C+4),O=(M&0)==0,V=A.subarray(T,E),R=getUint16(S,C+32),w=P+R,U=A.subarray(P,w),k=x,H=x,F=O&&(getUint8(S,C+38)&FILE_ATTR_MSDOS_DIR_MASK)==FILE_ATTR_MSDOS_DIR_MASK,G=getUint32(S,C+42)+g;Object.assign(y,{versionMadeBy:M,msDosCompatible:O,compressedSize:0,uncompressedSize:0,commentLength:R,directory:F,offset:G,diskNumberStart:getUint16(S,C+34),internalFileAttribute:getUint16(S,C+36),externalFileAttribute:getUint32(S,C+38),rawFilename:V,filenameUTF8:k,commentUTF8:H,rawExtraField:A.subarray(E,P)});const B=getOptionValue(n,t,"decodeText")||decodeText,W=k?CHARSET_UTF8:b||CHARSET_CP437,Y=H?CHARSET_UTF8:D||CHARSET_CP437;let z=B(V,W);z===UNDEFINED_VALUE&&(z=decodeText(V,W));let X=B(U,Y);X===UNDEFINED_VALUE&&(X=decodeText(U,Y)),Object.assign(y,{rawComment:U,filename:z,comment:X,directory:F||z.endsWith(DIRECTORY_SIGNATURE)}),_=Math.max(G,_),await readCommonFooter(y,y,S,C+6);const q=new Entry(y);q.getData=(Z,K)=>y.getData(Z,q,K),C=w;const{onprogress:Q}=t;if(Q)try{await Q(N+1,m,new Entry(y))}catch{}yield q}const I=getOptionValue(n,t,"extractPrependedData"),L=getOptionValue(n,t,"extractAppendedData");return I&&(n.prependedData=_>0?await readUint8Array(i,0,_):new Uint8Array),n.comment=d?await readUint8Array(i,c+END_OF_CENTRAL_DIR_LENGTH,d):new Uint8Array,L&&(n.appendedData=h<i.size?await readUint8Array(i,h,i.size-h):new Uint8Array),!0}async getEntries(t={}){const n=[];for await(const i of this.getEntriesGenerator(t))n.push(i);return n}async close(){}}class ZipEntry{constructor(t,n,i){Object.assign(this,{reader:t,config:n,options:i})}async getData(t,n,i={}){const r=this,{reader:o,offset:a,diskNumberStart:s,extraFieldAES:l,compressionMethod:c,config:d,bitFlag:h,signature:f,rawLastModDate:p,uncompressedSize:u,compressedSize:m}=r,g=n.localDirectory={},_=await readUint8Array(o,a,30,s),C=getDataView(_);let A=getOptionValue(r,i,"password"),S=getOptionValue(r,i,"rawPassword");if(A=A&&A.length&&A,S=S&&S.length&&S,l&&l.originalCompressionMethod!=COMPRESSION_METHOD_AES)throw new Error(ERR_UNSUPPORTED_COMPRESSION);if(c!=COMPRESSION_METHOD_STORE&&c!=COMPRESSION_METHOD_DEFLATE)throw new Error(ERR_UNSUPPORTED_COMPRESSION);if(getUint32(C,0)!=LOCAL_FILE_HEADER_SIGNATURE)throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);readCommonHeader(g,C,4),g.rawExtraField=g.extraFieldLength?await readUint8Array(o,a+30+g.filenameLength,g.extraFieldLength,s):new Uint8Array,await readCommonFooter(r,g,C,4,!0),Object.assign(n,{lastAccessDate:g.lastAccessDate,creationDate:g.creationDate});const v=r.encrypted&&g.encrypted,b=v&&!l;if(v){if(!b&&l.strength===UNDEFINED_VALUE)throw new Error(ERR_UNSUPPORTED_ENCRYPTION);if(!A&&!S)throw new Error(ERR_ENCRYPTED)}const D=a+30+g.filenameLength+g.extraFieldLength,I=m,L=o.readable;Object.assign(L,{diskNumberStart:s,offset:D,size:I});const N=getOptionValue(r,i,"signal"),y=getOptionValue(r,i,"checkPasswordOnly");y&&(t=new WritableStream),t=initWriter(t),await initStream(t,u);const{writable:x}=t,{onstart:T,onprogress:E,onend:P}=i,M={options:{codecType:CODEC_INFLATE,password:A,rawPassword:S,zipCrypto:b,encryptionStrength:l&&l.strength,signed:getOptionValue(r,i,"checkSignature"),passwordVerification:b&&(h.dataDescriptor?p>>>8&255:f>>>24&255),signature:f,compressed:c!=0,encrypted:v,useWebWorkers:getOptionValue(r,i,"useWebWorkers"),useCompressionStream:getOptionValue(r,i,"useCompressionStream"),transferStreams:getOptionValue(r,i,"transferStreams"),checkPasswordOnly:y},config:d,streamOptions:{signal:N,size:I,onstart:T,onprogress:E,onend:P}};let O=0;try{({outputSize:O}=await runWorker({readable:L,writable:x},M))}catch(V){if(!y||V.message!=ERR_ABORT_CHECK_PASSWORD)throw V}finally{const V=getOptionValue(r,i,"preventClose");x.size+=O,!V&&!x.locked&&await x.getWriter().close()}return y?UNDEFINED_VALUE:t.getData?t.getData():x}}function readCommonHeader(e,t,n){const i=e.rawBitFlag=getUint16(t,n+2),r=(i&BITFLAG_ENCRYPTED)==BITFLAG_ENCRYPTED,o=getUint32(t,n+6);Object.assign(e,{encrypted:r,version:getUint16(t,n),bitFlag:{level:(i&BITFLAG_LEVEL)>>1,dataDescriptor:(i&BITFLAG_DATA_DESCRIPTOR)==BITFLAG_DATA_DESCRIPTOR,languageEncodingFlag:(i&BITFLAG_LANG_ENCODING_FLAG)==BITFLAG_LANG_ENCODING_FLAG},rawLastModDate:o,lastModDate:getDate(o),filenameLength:getUint16(t,n+22),extraFieldLength:getUint16(t,n+24)})}async function readCommonFooter(e,t,n,i,r){const{rawExtraField:o}=t,a=t.extraField=new Map,s=getDataView(new Uint8Array(o));let l=0;try{for(;l<o.length;){const _=getUint16(s,l),C=getUint16(s,l+2);a.set(_,{type:_,data:o.slice(l+4,l+4+C)}),l+=4+C}}catch{}const c=getUint16(n,i+4);Object.assign(t,{signature:getUint32(n,i+10),uncompressedSize:getUint32(n,i+18),compressedSize:getUint32(n,i+14)});const d=a.get(EXTRAFIELD_TYPE_ZIP64);d&&(readExtraFieldZip64(d,t),t.extraFieldZip64=d);const h=a.get(EXTRAFIELD_TYPE_UNICODE_PATH);h&&(await readExtraFieldUnicode(h,PROPERTY_NAME_FILENAME,PROPERTY_NAME_RAW_FILENAME,t,e),t.extraFieldUnicodePath=h);const f=a.get(EXTRAFIELD_TYPE_UNICODE_COMMENT);f&&(await readExtraFieldUnicode(f,PROPERTY_NAME_COMMENT,PROPERTY_NAME_RAW_COMMENT,t,e),t.extraFieldUnicodeComment=f);const p=a.get(EXTRAFIELD_TYPE_AES);p?(readExtraFieldAES(p,t,c),t.extraFieldAES=p):t.compressionMethod=c;const u=a.get(EXTRAFIELD_TYPE_NTFS);u&&(readExtraFieldNTFS(u,t),t.extraFieldNTFS=u);const m=a.get(EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);m&&(readExtraFieldExtendedTimestamp(m,t,r),t.extraFieldExtendedTimestamp=m);const g=a.get(EXTRAFIELD_TYPE_USDZ);g&&(t.extraFieldUSDZ=g)}function readExtraFieldZip64(e,t){t.zip64=!0;const n=getDataView(e.data),i=ZIP64_PROPERTIES.filter(([r,o])=>t[r]==o);for(let r=0,o=0;r<i.length;r++){const[a,s]=i[r];if(t[a]==s){const l=ZIP64_EXTRACTION[s];t[a]=e[a]=l.getValue(n,o),o+=l.bytes}else if(e[a])throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND)}}async function readExtraFieldUnicode(e,t,n,i,r){const o=getDataView(e.data),a=new Crc32;a.append(r[n]);const s=getDataView(new Uint8Array(4));s.setUint32(0,a.get(),!0);const l=getUint32(o,1);Object.assign(e,{version:getUint8(o,0),[t]:decodeText(e.data.subarray(5)),valid:!r.bitFlag.languageEncodingFlag&&l==getUint32(s,0)}),e.valid&&(i[t]=e[t],i[t+"UTF8"]=!0)}function readExtraFieldAES(e,t,n){const i=getDataView(e.data),r=getUint8(i,4);Object.assign(e,{vendorVersion:getUint8(i,0),vendorId:getUint8(i,2),strength:r,originalCompressionMethod:n,compressionMethod:getUint16(i,5)}),t.compressionMethod=e.compressionMethod}function readExtraFieldNTFS(e,t){const n=getDataView(e.data);let i=4,r;try{for(;i<e.data.length&&!r;){const o=getUint16(n,i),a=getUint16(n,i+2);o==EXTRAFIELD_TYPE_NTFS_TAG1&&(r=e.data.slice(i+4,i+4+a)),i+=4+a}}catch{}try{if(r&&r.length==24){const o=getDataView(r),a=o.getBigUint64(0,!0),s=o.getBigUint64(8,!0),l=o.getBigUint64(16,!0);Object.assign(e,{rawLastModDate:a,rawLastAccessDate:s,rawCreationDate:l});const c=getDateNTFS(a),d=getDateNTFS(s),h=getDateNTFS(l),f={lastModDate:c,lastAccessDate:d,creationDate:h};Object.assign(e,f),Object.assign(t,f)}}catch{}}function readExtraFieldExtendedTimestamp(e,t,n){const i=getDataView(e.data),r=getUint8(i,0),o=[],a=[];n?((r&1)==1&&(o.push(PROPERTY_NAME_LAST_MODIFICATION_DATE),a.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE)),(r&2)==2&&(o.push(PROPERTY_NAME_LAST_ACCESS_DATE),a.push(PROPERTY_NAME_RAW_LAST_ACCESS_DATE)),(r&4)==4&&(o.push(PROPERTY_NAME_CREATION_DATE),a.push(PROPERTY_NAME_RAW_CREATION_DATE))):e.data.length>=5&&(o.push(PROPERTY_NAME_LAST_MODIFICATION_DATE),a.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE));let s=1;o.forEach((l,c)=>{if(e.data.length>=s+4){const d=getUint32(i,s);t[l]=e[l]=new Date(d*1e3);const h=a[c];e[h]=d}s+=4})}async function seekSignature(e,t,n,i,r){const o=new Uint8Array(4),a=getDataView(o);setUint32(a,0,t);const s=i+r;return await l(i)||await l(Math.min(s,n));async function l(c){const d=n-c,h=await readUint8Array(e,d,c);for(let f=h.length-i;f>=0;f--)if(h[f]==o[0]&&h[f+1]==o[1]&&h[f+2]==o[2]&&h[f+3]==o[3])return{offset:d+f,buffer:h.slice(f,f+i).buffer}}}function getOptionValue(e,t,n){return t[n]===UNDEFINED_VALUE?e.options[n]:t[n]}function getDate(e){const t=(e&4294901760)>>16,n=e&65535;try{return new Date(1980+((t&65024)>>9),((t&480)>>5)-1,t&31,(n&63488)>>11,(n&2016)>>5,(n&31)*2,0)}catch{}}function getDateNTFS(e){return new Date(Number(e/BigInt(1e4)-BigInt(116444736e5)))}function getUint8(e,t){return e.getUint8(t)}function getUint16(e,t){return e.getUint16(t,!0)}function getUint32(e,t){return e.getUint32(t,!0)}function getBigUint64(e,t){return Number(e.getBigUint64(t,!0))}function setUint32(e,t,n){e.setUint32(t,n,!0)}function getDataView(e){return new DataView(e.buffer)}function getElement(e){if(typeof e=="string"){const t=document.getElementById(e);if(t===null)throw new DeveloperError(`Element with id "${e}" does not exist in the document.`);e=t}return e}function KmlLookAt(e,t){this.position=e,this.headingPitchRange=t}function KmlTour(e,t){this.id=t,this.name=e,this.playlistIndex=0,this.playlist=[],this.tourStart=new Event,this.tourEnd=new Event,this.entryStart=new Event,this.entryEnd=new Event,this._activeEntries=[]}KmlTour.prototype.addPlaylistEntry=function(e){this.playlist.push(e)};KmlTour.prototype.play=function(e,t){this.tourStart.raiseEvent();const n=this;playEntry.call(this,e,t,function(i){n.playlistIndex=0,i||cancelAllEntries(n._activeEntries),n.tourEnd.raiseEvent(i)})};KmlTour.prototype.stop=function(){cancelAllEntries(this._activeEntries)};function cancelAllEntries(e){for(let t=e.pop();t!==void 0;t=e.pop())t.stop()}function playEntry(e,t,n){const i=this.playlist[this.playlistIndex];if(i){const r=playNext.bind(this,e,t,n);if(this._activeEntries.push(i),this.entryStart.raiseEvent(i),i.blocking)i.play(r,e.scene.camera,t);else{const o=this;i.play(function(){o.entryEnd.raiseEvent(i);const a=o._activeEntries.indexOf(i);a>=0&&o._activeEntries.splice(a,1)}),r(e,t,n)}}else defined(n)&&n(!1)}function playNext(e,t,n,i){const r=this.playlist[this.playlistIndex];if(this.entryEnd.raiseEvent(r,i),i)n(i);else{const o=this._activeEntries.indexOf(r);o>=0&&this._activeEntries.splice(o,1),this.playlistIndex++,playEntry.call(this,e,t,n)}}var Easing=Object.freeze({Linear:Object.freeze({None:function(e){return e},In:function(e){return e},Out:function(e){return e},InOut:function(e){return e}}),Quadratic:Object.freeze({In:function(e){return e*e},Out:function(e){return e*(2-e)},InOut:function(e){return(e*=2)<1?.5*e*e:-.5*(--e*(e-2)-1)}}),Cubic:Object.freeze({In:function(e){return e*e*e},Out:function(e){return--e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e:.5*((e-=2)*e*e+2)}}),Quartic:Object.freeze({In:function(e){return e*e*e*e},Out:function(e){return 1- --e*e*e*e},InOut:function(e){return(e*=2)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)}}),Quintic:Object.freeze({In:function(e){return e*e*e*e*e},Out:function(e){return--e*e*e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)}}),Sinusoidal:Object.freeze({In:function(e){return 1-Math.sin((1-e)*Math.PI/2)},Out:function(e){return Math.sin(e*Math.PI/2)},InOut:function(e){return .5*(1-Math.sin(Math.PI*(.5-e)))}}),Exponential:Object.freeze({In:function(e){return e===0?0:Math.pow(1024,e-1)},Out:function(e){return e===1?1:1-Math.pow(2,-10*e)},InOut:function(e){return e===0?0:e===1?1:(e*=2)<1?.5*Math.pow(1024,e-1):.5*(-Math.pow(2,-10*(e-1))+2)}}),Circular:Object.freeze({In:function(e){return 1-Math.sqrt(1-e*e)},Out:function(e){return Math.sqrt(1- --e*e)},InOut:function(e){return(e*=2)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1)}}),Elastic:Object.freeze({In:function(e){return e===0?0:e===1?1:-Math.pow(2,10*(e-1))*Math.sin((e-1.1)*5*Math.PI)},Out:function(e){return e===0?0:e===1?1:Math.pow(2,-10*e)*Math.sin((e-.1)*5*Math.PI)+1},InOut:function(e){return e===0?0:e===1?1:(e*=2,e<1?-.5*Math.pow(2,10*(e-1))*Math.sin((e-1.1)*5*Math.PI):.5*Math.pow(2,-10*(e-1))*Math.sin((e-1.1)*5*Math.PI)+1)}}),Back:Object.freeze({In:function(e){var t=1.70158;return e===1?1:e*e*((t+1)*e-t)},Out:function(e){var t=1.70158;return e===0?0:--e*e*((t+1)*e+t)+1},InOut:function(e){var t=2.5949095;return(e*=2)<1?.5*(e*e*((t+1)*e-t)):.5*((e-=2)*e*((t+1)*e+t)+2)}}),Bounce:Object.freeze({In:function(e){return 1-Easing.Bounce.Out(1-e)},Out:function(e){return e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},InOut:function(e){return e<.5?Easing.Bounce.In(e*2)*.5:Easing.Bounce.Out(e*2-1)*.5+.5}}),generatePow:function(e){return e===void 0&&(e=4),e=e<Number.EPSILON?Number.EPSILON:e,e=e>1e4?1e4:e,{In:function(t){return Math.pow(t,e)},Out:function(t){return 1-Math.pow(1-t,e)},InOut:function(t){return t<.5?Math.pow(t*2,e)/2:(1-Math.pow(2-t*2,e))/2+.5}}}}),now=function(){return performance.now()},Group=function(){function e(){this._tweens={},this._tweensAddedDuringUpdate={}}return e.prototype.getAll=function(){var t=this;return Object.keys(this._tweens).map(function(n){return t._tweens[n]})},e.prototype.removeAll=function(){this._tweens={}},e.prototype.add=function(t){this._tweens[t.getId()]=t,this._tweensAddedDuringUpdate[t.getId()]=t},e.prototype.remove=function(t){delete this._tweens[t.getId()],delete this._tweensAddedDuringUpdate[t.getId()]},e.prototype.update=function(t,n){t===void 0&&(t=now()),n===void 0&&(n=!1);var i=Object.keys(this._tweens);if(i.length===0)return!1;for(;i.length>0;){this._tweensAddedDuringUpdate={};for(var r=0;r<i.length;r++){var o=this._tweens[i[r]],a=!n;o&&o.update(t,a)===!1&&!n&&delete this._tweens[i[r]]}i=Object.keys(this._tweensAddedDuringUpdate)}return!0},e}(),Interpolation={Linear:function(e,t){var n=e.length-1,i=n*t,r=Math.floor(i),o=Interpolation.Utils.Linear;return t<0?o(e[0],e[1],i):t>1?o(e[n],e[n-1],n-i):o(e[r],e[r+1>n?n:r+1],i-r)},Bezier:function(e,t){for(var n=0,i=e.length-1,r=Math.pow,o=Interpolation.Utils.Bernstein,a=0;a<=i;a++)n+=r(1-t,i-a)*r(t,a)*e[a]*o(i,a);return n},CatmullRom:function(e,t){var n=e.length-1,i=n*t,r=Math.floor(i),o=Interpolation.Utils.CatmullRom;return e[0]===e[n]?(t<0&&(r=Math.floor(i=n*(1+t))),o(e[(r-1+n)%n],e[r],e[(r+1)%n],e[(r+2)%n],i-r)):t<0?e[0]-(o(e[0],e[0],e[1],e[1],-i)-e[0]):t>1?e[n]-(o(e[n],e[n],e[n-1],e[n-1],i-n)-e[n]):o(e[r?r-1:0],e[r],e[n<r+1?n:r+1],e[n<r+2?n:r+2],i-r)},Utils:{Linear:function(e,t,n){return(t-e)*n+e},Bernstein:function(e,t){var n=Interpolation.Utils.Factorial;return n(e)/n(t)/n(e-t)},Factorial:function(){var e=[1];return function(t){var n=1;if(e[t])return e[t];for(var i=t;i>1;i--)n*=i;return e[t]=n,n}}(),CatmullRom:function(e,t,n,i,r){var o=(n-e)*.5,a=(i-t)*.5,s=r*r,l=r*s;return(2*t-2*n+o+a)*l+(-3*t+3*n-2*o-a)*s+o*r+t}}},Sequence=function(){function e(){}return e.nextId=function(){return e._nextId++},e._nextId=0,e}(),mainGroup=new Group,Tween$1=function(){function e(t,n){n===void 0&&(n=mainGroup),this._object=t,this._group=n,this._isPaused=!1,this._pauseStart=0,this._valuesStart={},this._valuesEnd={},this._valuesStartRepeat={},this._duration=1e3,this._isDynamic=!1,this._initialRepeat=0,this._repeat=0,this._yoyo=!1,this._isPlaying=!1,this._reversed=!1,this._delayTime=0,this._startTime=0,this._easingFunction=Easing.Linear.None,this._interpolationFunction=Interpolation.Linear,this._chainedTweens=[],this._onStartCallbackFired=!1,this._onEveryStartCallbackFired=!1,this._id=Sequence.nextId(),this._isChainStopped=!1,this._propertiesAreSetUp=!1,this._goToEnd=!1}return e.prototype.getId=function(){return this._id},e.prototype.isPlaying=function(){return this._isPlaying},e.prototype.isPaused=function(){return this._isPaused},e.prototype.getDuration=function(){return this._duration},e.prototype.to=function(t,n){if(n===void 0&&(n=1e3),this._isPlaying)throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");return this._valuesEnd=t,this._propertiesAreSetUp=!1,this._duration=n<0?0:n,this},e.prototype.duration=function(t){return t===void 0&&(t=1e3),this._duration=t<0?0:t,this},e.prototype.dynamic=function(t){return t===void 0&&(t=!1),this._isDynamic=t,this},e.prototype.start=function(t,n){if(t===void 0&&(t=now()),n===void 0&&(n=!1),this._isPlaying)return this;if(this._group&&this._group.add(this),this._repeat=this._initialRepeat,this._reversed){this._reversed=!1;for(var i in this._valuesStartRepeat)this._swapEndStartRepeatValues(i),this._valuesStart[i]=this._valuesStartRepeat[i]}if(this._isPlaying=!0,this._isPaused=!1,this._onStartCallbackFired=!1,this._onEveryStartCallbackFired=!1,this._isChainStopped=!1,this._startTime=t,this._startTime+=this._delayTime,!this._propertiesAreSetUp||n){if(this._propertiesAreSetUp=!0,!this._isDynamic){var r={};for(var o in this._valuesEnd)r[o]=this._valuesEnd[o];this._valuesEnd=r}this._setupProperties(this._object,this._valuesStart,this._valuesEnd,this._valuesStartRepeat,n)}return this},e.prototype.startFromCurrentValues=function(t){return this.start(t,!0)},e.prototype._setupProperties=function(t,n,i,r,o){for(var a in i){var s=t[a],l=Array.isArray(s),c=l?"array":typeof s,d=!l&&Array.isArray(i[a]);if(!(c==="undefined"||c==="function")){if(d){var h=i[a];if(h.length===0)continue;for(var f=[s],p=0,u=h.length;p<u;p+=1){var m=this._handleRelativeValue(s,h[p]);if(isNaN(m)){d=!1,console.warn("Found invalid interpolation list. Skipping.");break}f.push(m)}d&&(i[a]=f)}if((c==="object"||l)&&s&&!d){n[a]=l?[]:{};var g=s;for(var _ in g)n[a][_]=g[_];r[a]=l?[]:{};var h=i[a];if(!this._isDynamic){var C={};for(var _ in h)C[_]=h[_];i[a]=h=C}this._setupProperties(g,n[a],h,r[a],o)}else(typeof n[a]>"u"||o)&&(n[a]=s),l||(n[a]*=1),d?r[a]=i[a].slice().reverse():r[a]=n[a]||0}}},e.prototype.stop=function(){return this._isChainStopped||(this._isChainStopped=!0,this.stopChainedTweens()),this._isPlaying?(this._group&&this._group.remove(this),this._isPlaying=!1,this._isPaused=!1,this._onStopCallback&&this._onStopCallback(this._object),this):this},e.prototype.end=function(){return this._goToEnd=!0,this.update(1/0),this},e.prototype.pause=function(t){return t===void 0&&(t=now()),this._isPaused||!this._isPlaying?this:(this._isPaused=!0,this._pauseStart=t,this._group&&this._group.remove(this),this)},e.prototype.resume=function(t){return t===void 0&&(t=now()),!this._isPaused||!this._isPlaying?this:(this._isPaused=!1,this._startTime+=t-this._pauseStart,this._pauseStart=0,this._group&&this._group.add(this),this)},e.prototype.stopChainedTweens=function(){for(var t=0,n=this._chainedTweens.length;t<n;t++)this._chainedTweens[t].stop();return this},e.prototype.group=function(t){return t===void 0&&(t=mainGroup),this._group=t,this},e.prototype.delay=function(t){return t===void 0&&(t=0),this._delayTime=t,this},e.prototype.repeat=function(t){return t===void 0&&(t=0),this._initialRepeat=t,this._repeat=t,this},e.prototype.repeatDelay=function(t){return this._repeatDelayTime=t,this},e.prototype.yoyo=function(t){return t===void 0&&(t=!1),this._yoyo=t,this},e.prototype.easing=function(t){return t===void 0&&(t=Easing.Linear.None),this._easingFunction=t,this},e.prototype.interpolation=function(t){return t===void 0&&(t=Interpolation.Linear),this._interpolationFunction=t,this},e.prototype.chain=function(){for(var t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];return this._chainedTweens=t,this},e.prototype.onStart=function(t){return this._onStartCallback=t,this},e.prototype.onEveryStart=function(t){return this._onEveryStartCallback=t,this},e.prototype.onUpdate=function(t){return this._onUpdateCallback=t,this},e.prototype.onRepeat=function(t){return this._onRepeatCallback=t,this},e.prototype.onComplete=function(t){return this._onCompleteCallback=t,this},e.prototype.onStop=function(t){return this._onStopCallback=t,this},e.prototype.update=function(t,n){var i;if(t===void 0&&(t=now()),n===void 0&&(n=!0),this._isPaused)return!0;var r=this._startTime+this._duration;if(!this._goToEnd&&!this._isPlaying){if(t>r)return!1;n&&this.start(t,!0)}if(this._goToEnd=!1,t<this._startTime)return!0;this._onStartCallbackFired===!1&&(this._onStartCallback&&this._onStartCallback(this._object),this._onStartCallbackFired=!0),this._onEveryStartCallbackFired===!1&&(this._onEveryStartCallback&&this._onEveryStartCallback(this._object),this._onEveryStartCallbackFired=!0);var o=t-this._startTime,a=this._duration+((i=this._repeatDelayTime)!==null&&i!==void 0?i:this._delayTime),s=this._duration+this._repeat*a,l=this._calculateElapsedPortion(o,a,s),c=this._easingFunction(l),d=this._calculateCompletionStatus(o,a);if(d==="repeat"&&this._processRepetition(o,a),this._updateProperties(this._object,this._valuesStart,this._valuesEnd,c),d==="about-to-repeat"&&this._processRepetition(o,a),this._onUpdateCallback&&this._onUpdateCallback(this._object,l),d==="repeat"||d==="about-to-repeat")this._onRepeatCallback&&this._onRepeatCallback(this._object),this._onEveryStartCallbackFired=!1;else if(d==="completed"){this._isPlaying=!1,this._onCompleteCallback&&this._onCompleteCallback(this._object);for(var h=0,f=this._chainedTweens.length;h<f;h++)this._chainedTweens[h].start(this._startTime+this._duration,!1)}return d!=="completed"},e.prototype._calculateElapsedPortion=function(t,n,i){if(this._duration===0||t>i)return 1;var r=t%n,o=Math.min(r/this._duration,1);return o===0&&t!==0&&t%this._duration===0?1:o},e.prototype._calculateCompletionStatus=function(t,n){return this._duration!==0&&t<this._duration?"playing":this._repeat<=0?"completed":t===this._duration?"about-to-repeat":"repeat"},e.prototype._processRepetition=function(t,n){var i=Math.min(Math.trunc((t-this._duration)/n)+1,this._repeat);isFinite(this._repeat)&&(this._repeat-=i);for(var r in this._valuesStartRepeat){var o=this._valuesEnd[r];!this._yoyo&&typeof o=="string"&&(this._valuesStartRepeat[r]=this._valuesStartRepeat[r]+parseFloat(o)),this._yoyo&&this._swapEndStartRepeatValues(r),this._valuesStart[r]=this._valuesStartRepeat[r]}this._yoyo&&(this._reversed=!this._reversed),this._startTime+=n*i},e.prototype._updateProperties=function(t,n,i,r){for(var o in i)if(n[o]!==void 0){var a=n[o]||0,s=i[o],l=Array.isArray(t[o]),c=Array.isArray(s),d=!l&&c;d?t[o]=this._interpolationFunction(s,r):typeof s=="object"&&s?this._updateProperties(t[o],a,s,r):(s=this._handleRelativeValue(a,s),typeof s=="number"&&(t[o]=a+(s-a)*r))}},e.prototype._handleRelativeValue=function(t,n){return typeof n!="string"?n:n.charAt(0)==="+"||n.charAt(0)==="-"?t+parseFloat(n):parseFloat(n)},e.prototype._swapEndStartRepeatValues=function(t){var n=this._valuesStartRepeat[t],i=this._valuesEnd[t];typeof i=="string"?this._valuesStartRepeat[t]=this._valuesStartRepeat[t]+parseFloat(i):this._valuesStartRepeat[t]=this._valuesEnd[t],this._valuesEnd[t]=n},e}(),TWEEN=mainGroup;TWEEN.getAll.bind(TWEEN);TWEEN.removeAll.bind(TWEEN);TWEEN.add.bind(TWEEN);TWEEN.remove.bind(TWEEN);TWEEN.update.bind(TWEEN);const EasingFunction={LINEAR_NONE:Easing.Linear.None,QUADRATIC_IN:Easing.Quadratic.In,QUADRATIC_OUT:Easing.Quadratic.Out,QUADRATIC_IN_OUT:Easing.Quadratic.InOut,CUBIC_IN:Easing.Cubic.In,CUBIC_OUT:Easing.Cubic.Out,CUBIC_IN_OUT:Easing.Cubic.InOut,QUARTIC_IN:Easing.Quartic.In,QUARTIC_OUT:Easing.Quartic.Out,QUARTIC_IN_OUT:Easing.Quartic.InOut,QUINTIC_IN:Easing.Quintic.In,QUINTIC_OUT:Easing.Quintic.Out,QUINTIC_IN_OUT:Easing.Quintic.InOut,SINUSOIDAL_IN:Easing.Sinusoidal.In,SINUSOIDAL_OUT:Easing.Sinusoidal.Out,SINUSOIDAL_IN_OUT:Easing.Sinusoidal.InOut,EXPONENTIAL_IN:Easing.Exponential.In,EXPONENTIAL_OUT:Easing.Exponential.Out,EXPONENTIAL_IN_OUT:Easing.Exponential.InOut,CIRCULAR_IN:Easing.Circular.In,CIRCULAR_OUT:Easing.Circular.Out,CIRCULAR_IN_OUT:Easing.Circular.InOut,ELASTIC_IN:Easing.Elastic.In,ELASTIC_OUT:Easing.Elastic.Out,ELASTIC_IN_OUT:Easing.Elastic.InOut,BACK_IN:Easing.Back.In,BACK_OUT:Easing.Back.Out,BACK_IN_OUT:Easing.Back.InOut,BOUNCE_IN:Easing.Bounce.In,BOUNCE_OUT:Easing.Bounce.Out,BOUNCE_IN_OUT:Easing.Bounce.InOut},EasingFunction$1=Object.freeze(EasingFunction);function KmlTourFlyTo(e,t,n){this.type="KmlTourFlyTo",this.blocking=!0,this.activeCamera=null,this.activeCallback=null,this.duration=e,this.view=n,this.flyToMode=t}KmlTourFlyTo.prototype.play=function(e,t,n){if(this.activeCamera=t,defined(e)&&e!==null){const r=this;this.activeCallback=function(o){delete r.activeCallback,delete r.activeCamera,e(defined(o)?!1:o)}}const i=this.getCameraOptions(n);if(this.view.headingPitchRoll)t.flyTo(i);else if(this.view.headingPitchRange){const r=new BoundingSphere(this.view.position);t.flyToBoundingSphere(r,i)}};KmlTourFlyTo.prototype.stop=function(){defined(this.activeCamera)&&this.activeCamera.cancelFlight(),defined(this.activeCallback)&&this.activeCallback(!0)};KmlTourFlyTo.prototype.getCameraOptions=function(e){let t={duration:this.duration};return defined(this.activeCallback)&&(t.complete=this.activeCallback),this.flyToMode==="smooth"&&(t.easingFunction=EasingFunction$1.LINEAR_NONE),this.view.headingPitchRoll?(t.destination=this.view.position,t.orientation=this.view.headingPitchRoll):this.view.headingPitchRange&&(t.offset=this.view.headingPitchRange),defined(e)&&(t=combine$2(t,e)),t};function KmlTourWait(e){this.type="KmlTourWait",this.blocking=!0,this.duration=e,this.timeout=null}KmlTourWait.prototype.play=function(e){const t=this;this.activeCallback=e,this.timeout=setTimeout(function(){delete t.activeCallback,e(!1)},this.duration*1e3)};KmlTourWait.prototype.stop=function(){clearTimeout(this.timeout),defined(this.activeCallback)&&this.activeCallback(!0)};const MimeTypes={avi:"video/x-msvideo",bmp:"image/bmp",bz2:"application/x-bzip2",chm:"application/vnd.ms-htmlhelp",css:"text/css",csv:"text/csv",doc:"application/msword",dvi:"application/x-dvi",eps:"application/postscript",flv:"video/x-flv",gif:"image/gif",gz:"application/x-gzip",htm:"text/html",html:"text/html",ico:"image/vnd.microsoft.icon",jnlp:"application/x-java-jnlp-file",jpeg:"image/jpeg",jpg:"image/jpeg",m3u:"audio/x-mpegurl",m4v:"video/mp4",mathml:"application/mathml+xml",mid:"audio/midi",midi:"audio/midi",mov:"video/quicktime",mp3:"audio/mpeg",mp4:"video/mp4",mp4v:"video/mp4",mpeg:"video/mpeg",mpg:"video/mpeg",odp:"application/vnd.oasis.opendocument.presentation",ods:"application/vnd.oasis.opendocument.spreadsheet",odt:"application/vnd.oasis.opendocument.text",ogg:"application/ogg",pdf:"application/pdf",png:"image/png",pps:"application/vnd.ms-powerpoint",ppt:"application/vnd.ms-powerpoint",ps:"application/postscript",qt:"video/quicktime",rdf:"application/rdf+xml",rss:"application/rss+xml",rtf:"application/rtf",svg:"image/svg+xml",swf:"application/x-shockwave-flash",text:"text/plain",tif:"image/tiff",tiff:"image/tiff",txt:"text/plain",wav:"audio/x-wav",wma:"audio/x-ms-wma",wmv:"video/x-ms-wmv",xml:"application/xml",zip:"application/zip",detectFromFilename:function(e){let t=e.toLowerCase();return t=getExtensionFromUri(t),MimeTypes[t]}};let parser;typeof DOMParser<"u"&&(parser=new DOMParser);const autolinker=new Autolinker({stripPrefix:!1,email:!1,replaceFn:function(e){return e.urlMatchType==="scheme"||e.urlMatchType==="www"}}),BILLBOARD_SIZE=32,BILLBOARD_NEAR_DISTANCE=2414016,BILLBOARD_NEAR_RATIO=1,BILLBOARD_FAR_DISTANCE=16093e3,BILLBOARD_FAR_RATIO=.1,kmlNamespaces=[null,void 0,"http://www.opengis.net/kml/2.2","http://earth.google.com/kml/2.2","http://earth.google.com/kml/2.1","http://earth.google.com/kml/2.0"],gxNamespaces=["http://www.google.com/kml/ext/2.2"],atomNamespaces=["http://www.w3.org/2005/Atom"],namespaces={kml:kmlNamespaces,gx:gxNamespaces,atom:atomNamespaces,kmlgx:kmlNamespaces.concat(gxNamespaces)},featureTypes={Document:processDocument,Folder:processFolder,Placemark:processPlacemark,NetworkLink:processNetworkLink,GroundOverlay:processGroundOverlay,PhotoOverlay:processUnsupportedFeature,ScreenOverlay:processScreenOverlay,Tour:processTour};function DeferredLoading(e){this._dataSource=e,this._deferred=defer(),this._stack=[],this._promises=[],this._timeoutSet=!1,this._used=!1,this._started=0,this._timeThreshold=1e3}Object.defineProperties(DeferredLoading.prototype,{dataSource:{get:function(){return this._dataSource}}});DeferredLoading.prototype.addNodes=function(e,t){this._stack.push({nodes:e,index:0,processingData:t}),this._used=!0};DeferredLoading.prototype.addPromise=function(e){this._promises.push(e)};DeferredLoading.prototype.wait=function(){const e=this._deferred;return this._used||e.resolve(),Promise.all([e.promise,Promise.all(this._promises)])};DeferredLoading.prototype.process=function(){const e=this._stack.length===1;return e&&(this._started=KmlDataSource._getTimestamp()),this._process(e)};DeferredLoading.prototype._giveUpTime=function(){if(this._timeoutSet)return;this._timeoutSet=!0,this._timeThreshold=50;const e=this;setTimeout(function(){e._timeoutSet=!1,e._started=KmlDataSource._getTimestamp(),e._process(!0)},0)};DeferredLoading.prototype._nextNode=function(){const e=this._stack,t=e[e.length-1],n=t.index,i=t.nodes;if(n!==i.length)return++t.index,i[n]};DeferredLoading.prototype._pop=function(){const e=this._stack;return e.pop(),e.length===0?(this._deferred.resolve(),!1):!0};DeferredLoading.prototype._process=function(e){const t=this.dataSource,n=this._stack[this._stack.length-1].processingData;let i=this._nextNode();for(;defined(i);){const r=featureTypes[i.localName];if(defined(r)&&(namespaces.kml.indexOf(i.namespaceURI)!==-1||namespaces.gx.indexOf(i.namespaceURI)!==-1)&&(r(t,i,n,this),this._timeoutSet||KmlDataSource._getTimestamp()>this._started+this._timeThreshold)){this._giveUpTime();return}i=this._nextNode()}this._pop()&&e&&this._process(!0)};function isZipFile(e){const t=e.slice(0,Math.min(4,e.size)),n=defer(),i=new FileReader;return i.addEventListener("load",function(){n.resolve(new DataView(i.result).getUint32(0,!1)===1347093252)}),i.addEventListener("error",function(){n.reject(i.error)}),i.readAsArrayBuffer(t),n.promise}function readBlobAsText(e){const t=defer(),n=new FileReader;return n.addEventListener("load",function(){t.resolve(n.result)}),n.addEventListener("error",function(){t.reject(n.error)}),n.readAsText(e),t.promise}function insertNamespaces(e){const t={xsi:"http://www.w3.org/2001/XMLSchema-instance"};let n,i,r,o;for(const a in t)t.hasOwnProperty(a)&&(r=RegExp(`[< ]${a}:`),o=`xmlns:${a}=`,r.test(e)&&e.indexOf(o)===-1&&(defined(n)||(n=e.substr(0,e.indexOf("<kml")+4),i=e.substr(n.length)),n+=` ${o}"${t[a]}"`));return defined(n)&&(e=n+i),e}function removeDuplicateNamespaces(e){let t=e.indexOf("xmlns:");const n=e.indexOf(">",t);let i,r,o;for(;t!==-1&&t<n;)i=e.slice(t,e.indexOf('"',t)),r=t,t=e.indexOf(i,t+1),t!==-1?(o=e.indexOf('"',e.indexOf('"',t)+1),e=e.slice(0,t-1)+e.slice(o+1,e.length),t=e.indexOf("xmlns:",r-1)):t=e.indexOf("xmlns:",r+1);return e}function loadXmlFromZip(e,t){return Promise.resolve(e.getData(new TextWriter)).then(function(n){n=insertNamespaces(n),n=removeDuplicateNamespaces(n),t.kml=parser.parseFromString(n,"application/xml")})}function loadDataUriFromZip(e,t){const n=defaultValue(MimeTypes.detectFromFilename(e.filename),"application/octet-stream");return Promise.resolve(e.getData(new Data64URIWriter(n))).then(function(i){t[e.filename]=i})}function embedDataUris(e,t,n,i){const r=i.keys,o=new Uri("."),a=e.querySelectorAll(t);for(let s=0;s<a.length;s++){const l=a[s],c=l.getAttribute(n);if(defined(c)){const h=new Uri(c).absoluteTo(o).toString(),f=r.indexOf(h);if(f!==-1){const p=r[f];l.setAttribute(n,i[p]),t==="a"&&l.getAttribute("download")===null&&l.setAttribute("download",p)}}}}function applyBasePath(e,t,n,i){const r=e.querySelectorAll(t);for(let o=0;o<r.length;o++){const a=r[o],s=a.getAttribute(n),l=resolveHref(s,i);defined(l)&&a.setAttribute(n,l.url)}}function createEntity(e,t,n){let i=queryStringAttribute(e,"id");i=defined(i)&&i.length!==0?i:createGuid(),defined(n)&&(i=n+i);let r=t.getById(i);return defined(r)&&(i=createGuid(),defined(n)&&(i=n+i)),r=t.add(new Entity({id:i})),defined(r.kml)||(r.addProperty("kml"),r.kml=new KmlFeatureData),r}function isExtrudable(e,t){return e==="absolute"||e==="relativeToGround"||t==="relativeToSeaFloor"}function readCoordinate(e,t){if(!defined(e))return Cartesian3.fromDegrees(0,0,0,t);const n=e.match(/[^\s,\n]+/g);if(!defined(n))return Cartesian3.fromDegrees(0,0,0,t);let i=parseFloat(n[0]),r=parseFloat(n[1]),o=parseFloat(n[2]);return i=isNaN(i)?0:i,r=isNaN(r)?0:r,o=isNaN(o)?0:o,Cartesian3.fromDegrees(i,r,o,t)}function readCoordinates(e,t){if(!defined(e))return;const n=e.textContent.match(/[^\s\n]+/g);if(!defined(n))return;const i=n.length,r=new Array(i);let o=0;for(let a=0;a<i;a++)r[o++]=readCoordinate(n[a],t);return r}function queryNumericAttribute(e,t){if(!defined(e))return;const n=e.getAttribute(t);if(n!==null){const i=parseFloat(n);return isNaN(i)?void 0:i}}function queryStringAttribute(e,t){if(!defined(e))return;const n=e.getAttribute(t);return n!==null?n:void 0}function queryFirstNode(e,t,n){if(!defined(e))return;const i=e.childNodes,r=i.length;for(let o=0;o<r;o++){const a=i[o];if(a.localName===t&&n.indexOf(a.namespaceURI)!==-1)return a}}function queryNodes(e,t,n){if(!defined(e))return;const i=[],r=e.getElementsByTagNameNS("*",t),o=r.length;for(let a=0;a<o;a++){const s=r[a];s.localName===t&&n.indexOf(s.namespaceURI)!==-1&&i.push(s)}return i}function queryChildNodes(e,t,n){if(!defined(e))return[];const i=[],r=e.childNodes,o=r.length;for(let a=0;a<o;a++){const s=r[a];s.localName===t&&n.indexOf(s.namespaceURI)!==-1&&i.push(s)}return i}function queryNumericValue(e,t,n){const i=queryFirstNode(e,t,n);if(defined(i)){const r=parseFloat(i.textContent);return isNaN(r)?void 0:r}}function queryStringValue(e,t,n){const i=queryFirstNode(e,t,n);if(defined(i))return i.textContent.trim()}function queryBooleanValue(e,t,n){const i=queryFirstNode(e,t,n);if(defined(i)){const r=i.textContent.trim();return r==="1"||/^true$/i.test(r)}}function resolveHref(e,t,n){if(!defined(e))return;let i;if(defined(n)){e=e.replace(/\\/g,"/");let r=n[e];if(defined(r))i=new Resource({url:r});else{const o=new Uri(t.getUrlComponent()),a=new Uri(e);r=n[a.absoluteTo(o)],defined(r)&&(i=new Resource({url:r}))}}return defined(i)||(i=t.getDerivedResource({url:e})),i}const colorOptions={maximumRed:void 0,red:void 0,maximumGreen:void 0,green:void 0,maximumBlue:void 0,blue:void 0};function parseColorString(e,t){if(!defined(e)||/^\s*$/gm.test(e))return;e[0]==="#"&&(e=e.substring(1));const n=parseInt(e.substring(0,2),16)/255,i=parseInt(e.substring(2,4),16)/255,r=parseInt(e.substring(4,6),16)/255,o=parseInt(e.substring(6,8),16)/255;return t?(o>0?(colorOptions.maximumRed=o,colorOptions.red=void 0):(colorOptions.maximumRed=void 0,colorOptions.red=0),r>0?(colorOptions.maximumGreen=r,colorOptions.green=void 0):(colorOptions.maximumGreen=void 0,colorOptions.green=0),i>0?(colorOptions.maximumBlue=i,colorOptions.blue=void 0):(colorOptions.maximumBlue=void 0,colorOptions.blue=0),colorOptions.alpha=n,Color.fromRandom(colorOptions)):new Color(o,r,i,n)}function queryColorValue(e,t,n){const i=queryStringValue(e,t,n);if(defined(i))return parseColorString(i,queryStringValue(e,"colorMode",n)==="random")}function processTimeStamp(e){const t=queryFirstNode(e,"TimeStamp",namespaces.kmlgx),n=queryStringValue(t,"when",namespaces.kmlgx);if(!defined(t)||!defined(n)||n.length===0)return;const i=JulianDate.fromIso8601(n),r=new TimeIntervalCollection;return r.addInterval(new TimeInterval({start:i,stop:Iso8601.MAXIMUM_VALUE})),r}function processTimeSpan(e){const t=queryFirstNode(e,"TimeSpan",namespaces.kmlgx);if(!defined(t))return;let n;const i=queryFirstNode(t,"begin",namespaces.kmlgx);let r=defined(i)?JulianDate.fromIso8601(i.textContent):void 0;const o=queryFirstNode(t,"end",namespaces.kmlgx);let a=defined(o)?JulianDate.fromIso8601(o.textContent):void 0;if(defined(r)&&defined(a)){if(JulianDate.lessThan(a,r)){const s=r;r=a,a=s}n=new TimeIntervalCollection,n.addInterval(new TimeInterval({start:r,stop:a}))}else defined(r)?(n=new TimeIntervalCollection,n.addInterval(new TimeInterval({start:r,stop:Iso8601.MAXIMUM_VALUE}))):defined(a)&&(n=new TimeIntervalCollection,n.addInterval(new TimeInterval({start:Iso8601.MINIMUM_VALUE,stop:a})));return n}function createDefaultBillboard(){const e=new BillboardGraphics;return e.width=BILLBOARD_SIZE,e.height=BILLBOARD_SIZE,e.scaleByDistance=new NearFarScalar(BILLBOARD_NEAR_DISTANCE,BILLBOARD_NEAR_RATIO,BILLBOARD_FAR_DISTANCE,BILLBOARD_FAR_RATIO),e.pixelOffsetScaleByDistance=new NearFarScalar(BILLBOARD_NEAR_DISTANCE,BILLBOARD_NEAR_RATIO,BILLBOARD_FAR_DISTANCE,BILLBOARD_FAR_RATIO),e}function createDefaultPolygon(){const e=new PolygonGraphics;return e.outline=!0,e.outlineColor=Color.WHITE,e}function createDefaultLabel(){const e=new LabelGraphics;return e.translucencyByDistance=new NearFarScalar(3e6,1,5e6,0),e.pixelOffset=new Cartesian2(17,0),e.horizontalOrigin=HorizontalOrigin.LEFT,e.font="16px sans-serif",e.style=LabelStyle.FILL_AND_OUTLINE,e}function getIconHref(e,t,n,i,r){let o=queryStringValue(e,"href",namespaces.kml);if(!defined(o)||o.length===0)return;if(o.indexOf("root://icons/palette-")===0){const s=o.charAt(21);let l=defaultValue(queryNumericValue(e,"x",namespaces.gx),0),c=defaultValue(queryNumericValue(e,"y",namespaces.gx),0);l=Math.min(l/32,7),c=7-Math.min(c/32,7);const d=8*c+l;o=`https://maps.google.com/mapfiles/kml/pal${s}/icon${d}.png`}const a=resolveHref(o,n,i);if(r){const s=queryStringValue(e,"refreshMode",namespaces.kml),l=queryStringValue(e,"viewRefreshMode",namespaces.kml);s==="onInterval"||s==="onExpire"?oneTimeWarning(`kml-refreshMode-${s}`,`KML - Unsupported Icon refreshMode: ${s}`):(l==="onStop"||l==="onRegion")&&oneTimeWarning(`kml-refreshMode-${l}`,`KML - Unsupported Icon viewRefreshMode: ${l}`);const c=defaultValue(queryStringValue(e,"viewBoundScale",namespaces.kml),1),d=l==="onStop"?"BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]":"",h=defaultValue(queryStringValue(e,"viewFormat",namespaces.kml),d),f=queryStringValue(e,"httpQuery",namespaces.kml);defined(h)&&a.setQueryParameters(queryToObject(cleanupString(h))),defined(f)&&a.setQueryParameters(queryToObject(cleanupString(f)));const p=t._ellipsoid;return processNetworkLinkQueryString(a,t.camera,t.canvas,c,t._lastCameraView.bbox,p),a}return a}function processBillboardIcon(e,t,n,i,r){let o=queryNumericValue(t,"scale",namespaces.kml);const a=queryNumericValue(t,"heading",namespaces.kml),s=queryColorValue(t,"color",namespaces.kml),l=queryFirstNode(t,"Icon",namespaces.kml);let c=getIconHref(l,e,i,r,!1);defined(l)&&!defined(c)&&(c=!1);const d=queryNumericValue(l,"x",namespaces.gx),h=queryNumericValue(l,"y",namespaces.gx),f=queryNumericValue(l,"w",namespaces.gx),p=queryNumericValue(l,"h",namespaces.gx),u=queryFirstNode(t,"hotSpot",namespaces.kml),m=queryNumericAttribute(u,"x"),g=queryNumericAttribute(u,"y"),_=queryStringAttribute(u,"xunits"),C=queryStringAttribute(u,"yunits");let A=n.billboard;defined(A)||(A=createDefaultBillboard(),n.billboard=A),A.image=c,A.scale=o,A.color=s,(defined(d)||defined(h)||defined(f)||defined(p))&&(A.imageSubRegion=new BoundingRectangle(d,h,f,p)),defined(a)&&a!==0&&(A.rotation=CesiumMath.toRadians(-a),A.alignedAxis=Cartesian3.UNIT_Z),o=defaultValue(o,1);let S,v;defined(m)&&(_==="pixels"?S=-m*o:_==="insetPixels"?S=(m-BILLBOARD_SIZE)*o:_==="fraction"&&(S=-m*BILLBOARD_SIZE*o),S+=BILLBOARD_SIZE*.5*o),defined(g)&&(C==="pixels"?v=g*o:C==="insetPixels"?v=(-g+BILLBOARD_SIZE)*o:C==="fraction"&&(v=g*BILLBOARD_SIZE*o),v-=BILLBOARD_SIZE*.5*o),(defined(S)||defined(v))&&(A.pixelOffset=new Cartesian2(S,v))}function applyStyle(e,t,n,i,r){for(let o=0,a=t.childNodes.length;o<a;o++){const s=t.childNodes.item(o);if(s.localName==="IconStyle")processBillboardIcon(e,s,n,i,r);else if(s.localName==="LabelStyle"){let l=n.label;defined(l)||(l=createDefaultLabel(),n.label=l),l.scale=defaultValue(queryNumericValue(s,"scale",namespaces.kml),l.scale),l.fillColor=defaultValue(queryColorValue(s,"color",namespaces.kml),l.fillColor),l.text=n.name}else if(s.localName==="LineStyle"){let l=n.polyline;defined(l)||(l=new PolylineGraphics,n.polyline=l),l.width=queryNumericValue(s,"width",namespaces.kml),l.material=queryColorValue(s,"color",namespaces.kml),defined(queryColorValue(s,"outerColor",namespaces.gx))&&oneTimeWarning("kml-gx:outerColor","KML - gx:outerColor is not supported in a LineStyle"),defined(queryNumericValue(s,"outerWidth",namespaces.gx))&&oneTimeWarning("kml-gx:outerWidth","KML - gx:outerWidth is not supported in a LineStyle"),defined(queryNumericValue(s,"physicalWidth",namespaces.gx))&&oneTimeWarning("kml-gx:physicalWidth","KML - gx:physicalWidth is not supported in a LineStyle"),defined(queryBooleanValue(s,"labelVisibility",namespaces.gx))&&oneTimeWarning("kml-gx:labelVisibility","KML - gx:labelVisibility is not supported in a LineStyle")}else if(s.localName==="PolyStyle"){let l=n.polygon;defined(l)||(l=createDefaultPolygon(),n.polygon=l),l.material=defaultValue(queryColorValue(s,"color",namespaces.kml),l.material),l.fill=defaultValue(queryBooleanValue(s,"fill",namespaces.kml),l.fill),l.outline=defaultValue(queryBooleanValue(s,"outline",namespaces.kml),l.outline)}else if(s.localName==="BalloonStyle"){const l=defaultValue(parseColorString(queryStringValue(s,"bgColor",namespaces.kml)),Color.WHITE),c=defaultValue(parseColorString(queryStringValue(s,"textColor",namespaces.kml)),Color.BLACK),d=queryStringValue(s,"text",namespaces.kml);n.addProperty("balloonStyle"),n.balloonStyle={bgColor:l,textColor:c,text:d}}else if(s.localName==="ListStyle"){const l=queryStringValue(s,"listItemType",namespaces.kml);(l==="radioFolder"||l==="checkOffOnly")&&oneTimeWarning(`kml-listStyle-${l}`,`KML - Unsupported ListStyle with listItemType: ${l}`)}}}function computeFinalStyle(e,t,n,i,r){const o=new Entity;let a,s=-1;const l=t.childNodes,c=l.length;for(let h=0;h<c;h++){const f=l[h];(f.localName==="Style"||f.localName==="StyleMap")&&(s=h)}if(s!==-1){const h=l[s];if(h.localName==="Style")applyStyle(e,h,o,i,r);else{const f=queryChildNodes(h,"Pair",namespaces.kml);for(let p=0;p<f.length;p++){const u=f[p],m=queryStringValue(u,"key",namespaces.kml);if(m==="normal"){const g=queryStringValue(u,"styleUrl",namespaces.kml);if(defined(g))a=n.getById(g),defined(a)||(a=n.getById(`#${g}`)),defined(a)&&o.merge(a);else{const _=queryFirstNode(u,"Style",namespaces.kml);applyStyle(e,_,o,i,r)}}else oneTimeWarning(`kml-styleMap-${m}`,`KML - Unsupported StyleMap key: ${m}`)}}}const d=queryStringValue(t,"styleUrl",namespaces.kml);if(defined(d)){let h=d;if(d[0]!=="#"&&d.indexOf("#")!==-1){const f=d.split("#"),p=f[0];h=`${i.getDerivedResource({url:p}).getUrlComponent()}#${f[1]}`}a=n.getById(h),defined(a)||(a=n.getById(`#${h}`)),defined(a)&&o.merge(a)}return o}function processExternalStyles(e,t,n){return t.fetchXML().then(function(i){return processStyles(e,i,n,t,!0)})}function processStyles(e,t,n,i,r,o){let a,s,l,c;const d=queryNodes(t,"Style",namespaces.kml);if(defined(d)){const m=d.length;for(a=0;a<m;a++)c=d[a],s=queryStringAttribute(c,"id"),defined(s)&&(s=`#${s}`,r&&defined(i)&&(s=i.getUrlComponent()+s),defined(n.getById(s))||(l=new Entity({id:s}),n.add(l),applyStyle(e,c,l,i,o)))}const h=queryNodes(t,"StyleMap",namespaces.kml);if(defined(h)){const m=h.length;for(a=0;a<m;a++){const g=h[a];if(s=queryStringAttribute(g,"id"),defined(s)){const _=queryChildNodes(g,"Pair",namespaces.kml);for(let C=0;C<_.length;C++){const A=_[C],S=queryStringValue(A,"key",namespaces.kml);if(S==="normal"){if(s=`#${s}`,r&&defined(i)&&(s=i.getUrlComponent()+s),!defined(n.getById(s))){l=n.getOrCreateEntity(s);let v=queryStringValue(A,"styleUrl",namespaces.kml);if(defined(v)){v[0]!=="#"&&(v=`#${v}`),r&&defined(i)&&(v=i.getUrlComponent()+v);const b=n.getById(v);defined(b)&&l.merge(b)}else c=queryFirstNode(A,"Style",namespaces.kml),applyStyle(e,c,l,i,o)}}else oneTimeWarning(`kml-styleMap-${S}`,`KML - Unsupported StyleMap key: ${S}`)}}}}const f=[],p=t.getElementsByTagName("styleUrl"),u=p.length;for(a=0;a<u;a++){const m=p[a].textContent;if(m[0]!=="#"){const g=m.split("#");if(g.length===2){const _=g[0],C=i.getDerivedResource({url:_});f.push(processExternalStyles(e,C,n))}}}return f}function createDropLine(e,t,n){const i=new ReferenceProperty(e,t.id,["position"]),r=new ScaledPositionProperty(t.position);t.polyline=defined(n.polyline)?n.polyline.clone():new PolylineGraphics,t.polyline.positions=new PositionPropertyArray([i,r])}function heightReferenceFromAltitudeMode(e,t){return!defined(e)&&!defined(t)||e==="clampToGround"?HeightReference.CLAMP_TO_GROUND:e==="relativeToGround"?HeightReference.RELATIVE_TO_GROUND:e==="absolute"?HeightReference.NONE:t==="clampToSeaFloor"?(oneTimeWarning("kml-gx:altitudeMode-clampToSeaFloor","KML - <gx:altitudeMode>:clampToSeaFloor is currently not supported, using <kml:altitudeMode>:clampToGround."),HeightReference.CLAMP_TO_GROUND):t==="relativeToSeaFloor"?(oneTimeWarning("kml-gx:altitudeMode-relativeToSeaFloor","KML - <gx:altitudeMode>:relativeToSeaFloor is currently not supported, using <kml:altitudeMode>:relativeToGround."),HeightReference.RELATIVE_TO_GROUND):(defined(e)?oneTimeWarning("kml-altitudeMode-unknown",`KML - Unknown <kml:altitudeMode>:${e}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`):oneTimeWarning("kml-gx:altitudeMode-unknown",`KML - Unknown <gx:altitudeMode>:${t}, using <kml:altitudeMode>:CLAMP_TO_GROUND.`),HeightReference.CLAMP_TO_GROUND)}function createPositionPropertyFromAltitudeMode(e,t,n){return n==="relativeToSeaFloor"||t==="absolute"||t==="relativeToGround"?e:((defined(t)&&t!=="clampToGround"||defined(n)&&n!=="clampToSeaFloor")&&oneTimeWarning("kml-altitudeMode-unknown",`KML - Unknown altitudeMode: ${defaultValue(t,n)}`),new ScaledPositionProperty(e))}function createPositionPropertyArrayFromAltitudeMode(e,t,n,i){if(!defined(e))return;if(n==="relativeToSeaFloor"||t==="absolute"||t==="relativeToGround")return e;(defined(t)&&t!=="clampToGround"||defined(n)&&n!=="clampToSeaFloor")&&oneTimeWarning("kml-altitudeMode-unknown",`KML - Unknown altitudeMode: ${defaultValue(t,n)}`);const r=e.length;for(let o=0;o<r;o++){const a=e[o];i.scaleToGeodeticSurface(a,a)}return e}function processPositionGraphics(e,t,n,i){let r=t.label;defined(r)||(r=defined(n.label)?n.label.clone():createDefaultLabel(),t.label=r),r.text=t.name;let o=t.billboard;defined(o)||(o=defined(n.billboard)?n.billboard.clone():createDefaultBillboard(),t.billboard=o),defined(o.image)?o.image.getValue()||(o.image=void 0):o.image=e._pinBuilder.fromColor(Color.YELLOW,64);let a=1;defined(o.scale)&&(a=o.scale.getValue(),a!==0?r.pixelOffset=new Cartesian2(a*16+1,0):(r.pixelOffset=void 0,r.horizontalOrigin=void 0)),defined(i)&&e._clampToGround&&(o.heightReference=i,r.heightReference=i)}function processPathGraphics(e,t){let n=e.path;defined(n)||(n=new PathGraphics,n.leadTime=0,e.path=n);const i=t.polyline;defined(i)&&(n.material=i.material,n.width=i.width)}function processPoint(e,t,n,i,r){const o=queryStringValue(n,"coordinates",namespaces.kml),a=queryStringValue(n,"altitudeMode",namespaces.kml),s=queryStringValue(n,"altitudeMode",namespaces.gx),l=queryBooleanValue(n,"extrude",namespaces.kml),c=e._ellipsoid,d=readCoordinate(o,c);return i.position=d,processPositionGraphics(e,i,r,heightReferenceFromAltitudeMode(a,s)),l&&isExtrudable(a,s)&&createDropLine(t,i,r),!0}function processLineStringOrLinearRing(e,t,n,i,r){const o=queryFirstNode(n,"coordinates",namespaces.kml),a=queryStringValue(n,"altitudeMode",namespaces.kml),s=queryStringValue(n,"altitudeMode",namespaces.gx),l=queryBooleanValue(n,"extrude",namespaces.kml),c=queryBooleanValue(n,"tessellate",namespaces.kml),d=isExtrudable(a,s),h=queryNumericValue(n,"drawOrder",namespaces.gx),f=e._ellipsoid,p=readCoordinates(o,f);let u=r.polyline;if(d&&l){const m=new WallGraphics;i.wall=m,m.positions=p;const g=r.polygon;defined(g)&&(m.fill=g.fill,m.material=g.material),m.outline=!0,defined(u)?(m.outlineColor=defined(u.material)?u.material.color:Color.WHITE,m.outlineWidth=u.width):defined(g)&&(m.outlineColor=defined(g.material)?g.material.color:Color.WHITE)}else if(e._clampToGround&&!d&&c){const m=new PolylineGraphics;m.clampToGround=!0,i.polyline=m,m.positions=p,defined(u)?(m.material=defined(u.material)?u.material.color.getValue(Iso8601.MINIMUM_VALUE):Color.WHITE,m.width=defaultValue(u.width,1)):(m.material=Color.WHITE,m.width=1),m.zIndex=h}else defined(h)&&oneTimeWarning("kml-gx:drawOrder","KML - gx:drawOrder is not supported in LineStrings when clampToGround is false"),e._clampToGround&&!c&&oneTimeWarning("kml-line-tesselate","Ignoring clampToGround for KML lines without the tessellate flag."),u=defined(u)?u.clone():new PolylineGraphics,i.polyline=u,u.positions=createPositionPropertyArrayFromAltitudeMode(p,a,s,f),(!c||d)&&(u.arcType=ArcType.NONE);return!0}function processPolygon(e,t,n,i,r){const o=queryFirstNode(n,"outerBoundaryIs",namespaces.kml);let a=queryFirstNode(o,"LinearRing",namespaces.kml),s=queryFirstNode(a,"coordinates",namespaces.kml);const l=e._ellipsoid;let c=readCoordinates(s,l);const d=queryBooleanValue(n,"extrude",namespaces.kml),h=queryStringValue(n,"altitudeMode",namespaces.kml),f=queryStringValue(n,"altitudeMode",namespaces.gx),p=isExtrudable(h,f),u=defined(r.polygon)?r.polygon.clone():createDefaultPolygon(),m=r.polyline;if(defined(m)&&(u.outlineColor=defined(m.material)?m.material.color:Color.WHITE,u.outlineWidth=m.width),i.polygon=u,p?(u.perPositionHeight=!0,u.extrudedHeight=d?0:void 0):e._clampToGround||(u.height=0),defined(c)){const g=new PolygonHierarchy(c),_=queryChildNodes(n,"innerBoundaryIs",namespaces.kml);for(let C=0;C<_.length;C++){a=queryChildNodes(_[C],"LinearRing",namespaces.kml);for(let A=0;A<a.length;A++)s=queryFirstNode(a[A],"coordinates",namespaces.kml),c=readCoordinates(s,l),defined(c)&&g.holes.push(new PolygonHierarchy(c))}u.hierarchy=g}return!0}function processTrack(e,t,n,i,r){const o=queryStringValue(n,"altitudeMode",namespaces.kml),a=queryStringValue(n,"altitudeMode",namespaces.gx),s=queryChildNodes(n,"coord",namespaces.gx),l=queryChildNodes(n,"angles",namespaces.gx),c=queryChildNodes(n,"when",namespaces.kml),d=queryBooleanValue(n,"extrude",namespaces.kml),h=isExtrudable(o,a),f=e._ellipsoid;l.length>0&&oneTimeWarning("kml-gx:angles","KML - gx:angles are not supported in gx:Tracks");const p=Math.min(s.length,c.length),u=[],m=[];for(let _=0;_<p;_++){const C=readCoordinate(s[_].textContent,f);u.push(C),m.push(JulianDate.fromIso8601(c[_].textContent))}const g=new SampledPositionProperty;return g.addSamples(m,u),i.position=g,processPositionGraphics(e,i,r,heightReferenceFromAltitudeMode(o,a)),processPathGraphics(i,r),i.availability=new TimeIntervalCollection,c.length>0&&i.availability.addInterval(new TimeInterval({start:m[0],stop:m[m.length-1]})),h&&d&&createDropLine(t,i,r),!0}function addToMultiTrack(e,t,n,i,r,o,a,s,l){const c=e[0],d=e[e.length-1],h=new SampledPositionProperty;h.addSamples(e,t),n.intervals.addInterval(new TimeInterval({start:c,stop:d,isStartIncluded:l,isStopIncluded:l,data:createPositionPropertyFromAltitudeMode(h,a,s)})),i.addInterval(new TimeInterval({start:c,stop:d,isStartIncluded:l,isStopIncluded:l})),r.intervals.addInterval(new TimeInterval({start:c,stop:d,isStartIncluded:l,isStopIncluded:l,data:o}))}function processMultiTrack(e,t,n,i,r){const o=queryBooleanValue(n,"interpolate",namespaces.gx),a=queryChildNodes(n,"Track",namespaces.gx);let s,l,c,d=!1;const h=new TimeIntervalCollectionProperty,f=new TimeIntervalCollection,p=new CompositePositionProperty,u=e._ellipsoid;for(let m=0,g=a.length;m<g;m++){const _=a[m],C=queryChildNodes(_,"when",namespaces.kml),A=queryChildNodes(_,"coord",namespaces.gx),S=queryStringValue(_,"altitudeMode",namespaces.kml),v=queryStringValue(_,"altitudeMode",namespaces.gx),b=isExtrudable(S,v),D=queryBooleanValue(_,"extrude",namespaces.kml),I=Math.min(A.length,C.length),L=[];s=[];for(let N=0;N<I;N++){const y=readCoordinate(A[N].textContent,u);L.push(y),s.push(JulianDate.fromIso8601(C[N].textContent))}o&&(defined(l)&&addToMultiTrack([l,s[0]],[c,L[0]],p,f,h,!1,"absolute",void 0,!1),l=s[I-1],c=L[L.length-1]),addToMultiTrack(s,L,p,f,h,b&&D,S,v,!0),d=d||b&&D}return i.availability=f,i.position=p,processPositionGraphics(e,i,r),processPathGraphics(i,r),d&&(createDropLine(t,i,r),i.polyline.show=h),!0}const geometryTypes={Point:processPoint,LineString:processLineStringOrLinearRing,LinearRing:processLineStringOrLinearRing,Polygon:processPolygon,Track:processTrack,MultiTrack:processMultiTrack,MultiGeometry:processMultiGeometry,Model:processUnsupportedGeometry};function processMultiGeometry(e,t,n,i,r,o){const a=n.childNodes;let s=!1;for(let l=0,c=a.length;l<c;l++){const d=a.item(l),h=geometryTypes[d.localName];if(defined(h)){const f=createEntity(d,t,o);f.parent=i,f.name=i.name,f.availability=i.availability,f.description=i.description,f.kml=i.kml,h(e,t,d,f,r)&&(s=!0)}}return s}function processUnsupportedGeometry(e,t,n,i,r){return oneTimeWarning("kml-unsupportedGeometry",`KML - Unsupported geometry: ${n.localName}`),!1}function processExtendedData(e,t){const n=queryFirstNode(e,"ExtendedData",namespaces.kml);if(!defined(n))return;defined(queryFirstNode(n,"SchemaData",namespaces.kml))&&oneTimeWarning("kml-schemaData","KML - SchemaData is unsupported"),defined(queryStringAttribute(n,"xmlns:prefix"))&&oneTimeWarning("kml-extendedData","KML - ExtendedData with xmlns:prefix is unsupported");const i={},r=queryChildNodes(n,"Data",namespaces.kml);if(defined(r)){const o=r.length;for(let a=0;a<o;a++){const s=r[a],l=queryStringAttribute(s,"name");defined(l)&&(i[l]={displayName:queryStringValue(s,"displayName",namespaces.kml),value:queryStringValue(s,"value",namespaces.kml)})}}t.kml.extendedData=i}let scratchDiv;typeof document<"u"&&(scratchDiv=document.createElement("div"));function processDescription(e,t,n,i,r){let o,a,s;const l=t.kml,c=l.extendedData,d=queryStringValue(e,"description",namespaces.kml),h=defaultValue(t.balloonStyle,n.balloonStyle);let f=Color.WHITE,p=Color.BLACK,u=d;defined(h)&&(f=defaultValue(h.bgColor,Color.WHITE),p=defaultValue(h.textColor,Color.BLACK),u=defaultValue(h.text,d));let m;if(defined(u)){if(u=u.replace("$[name]",defaultValue(t.name,"")),u=u.replace("$[description]",defaultValue(d,"")),u=u.replace("$[address]",defaultValue(l.address,"")),u=u.replace("$[Snippet]",defaultValue(l.snippet,"")),u=u.replace("$[id]",t.id),u=u.replace("$[geDirections]",""),defined(c)){const C=u.match(/\$\[.+?\]/g);if(C!==null)for(o=0;o<C.length;o++){const A=C[o];let S=A.substr(2,A.length-3);const v=/\/displayName$/.test(S);S=S.replace(/\/displayName$/,""),m=c[S],defined(m)&&(m=v?m.displayName:m.value),defined(m)&&(u=u.replace(A,defaultValue(m,"")))}}}else if(defined(c)&&(s=Object.keys(c),s.length>0)){for(u='<table class="cesium-infoBox-defaultTable cesium-infoBox-defaultTable-lighter"><tbody>',o=0;o<s.length;o++)a=s[o],m=c[a],u+=`<tr><th>${defaultValue(m.displayName,a)}</th><td>${defaultValue(m.value,"")}</td></tr>`;u+="</tbody></table>"}if(!defined(u))return;u=autolinker.link(u),scratchDiv.innerHTML=u;const g=scratchDiv.querySelectorAll("a");for(o=0;o<g.length;o++)g[o].setAttribute("target","_blank");defined(i)&&i.keys.length>1&&(embedDataUris(scratchDiv,"a","href",i),embedDataUris(scratchDiv,"link","href",i),embedDataUris(scratchDiv,"area","href",i),embedDataUris(scratchDiv,"img","src",i),embedDataUris(scratchDiv,"iframe","src",i),embedDataUris(scratchDiv,"video","src",i),embedDataUris(scratchDiv,"audio","src",i),embedDataUris(scratchDiv,"source","src",i),embedDataUris(scratchDiv,"track","src",i),embedDataUris(scratchDiv,"input","src",i),embedDataUris(scratchDiv,"embed","src",i),embedDataUris(scratchDiv,"script","src",i),embedDataUris(scratchDiv,"video","poster",i)),applyBasePath(scratchDiv,"a","href",r),applyBasePath(scratchDiv,"link","href",r),applyBasePath(scratchDiv,"area","href",r),applyBasePath(scratchDiv,"img","src",r),applyBasePath(scratchDiv,"iframe","src",r),applyBasePath(scratchDiv,"video","src",r),applyBasePath(scratchDiv,"audio","src",r),applyBasePath(scratchDiv,"source","src",r),applyBasePath(scratchDiv,"track","src",r),applyBasePath(scratchDiv,"input","src",r),applyBasePath(scratchDiv,"embed","src",r),applyBasePath(scratchDiv,"script","src",r),applyBasePath(scratchDiv,"video","poster",r);let _='<div class="cesium-infoBox-description-lighter" style="';_+="overflow:auto;",_+="word-wrap:break-word;",_+=`background-color:${f.toCssColorString()};`,_+=`color:${p.toCssColorString()};`,_+='">',_+=`${scratchDiv.innerHTML}</div>`,scratchDiv.innerHTML="",t.description=_}function processFeature(e,t,n){const i=n.entityCollection,r=n.parentEntity,o=n.sourceResource,a=n.uriResolver,s=createEntity(t,i,n.context),l=s.kml,c=computeFinalStyle(e,t,n.styleCollection,o,a),d=queryStringValue(t,"name",namespaces.kml);s.name=d,s.parent=r;let h=processTimeSpan(t);defined(h)||(h=processTimeStamp(t)),s.availability=h,mergeAvailabilityWithParent(s);function f(A){return A?A.show&&f(A.parent):!0}const p=queryBooleanValue(t,"visibility",namespaces.kml);s.show=f(r)&&defaultValue(p,!0);const u=queryFirstNode(t,"author",namespaces.atom),m=l.author;m.name=queryStringValue(u,"name",namespaces.atom),m.uri=queryStringValue(u,"uri",namespaces.atom),m.email=queryStringValue(u,"email",namespaces.atom);const g=queryFirstNode(t,"link",namespaces.atom),_=l.link;_.href=queryStringAttribute(g,"href"),_.hreflang=queryStringAttribute(g,"hreflang"),_.rel=queryStringAttribute(g,"rel"),_.type=queryStringAttribute(g,"type"),_.title=queryStringAttribute(g,"title"),_.length=queryStringAttribute(g,"length"),l.address=queryStringValue(t,"address",namespaces.kml),l.phoneNumber=queryStringValue(t,"phoneNumber",namespaces.kml),l.snippet=queryStringValue(t,"Snippet",namespaces.kml),processExtendedData(t,s),processDescription(t,s,c,a,o);const C=e._ellipsoid;return processLookAt(t,s,C),processCamera(t,s,C),defined(queryFirstNode(t,"Region",namespaces.kml))&&oneTimeWarning("kml-region","KML - Placemark Regions are unsupported"),{entity:s,styleEntity:c}}function processDocument(e,t,n,i){i.addNodes(t.childNodes,n),i.process()}function processFolder(e,t,n,i){const r=processFeature(e,t,n),o=clone(n);o.parentEntity=r.entity,processDocument(e,t,o,i)}function processPlacemark(e,t,n,i){const r=processFeature(e,t,n),o=r.entity,a=r.styleEntity;let s=!1;const l=t.childNodes;for(let c=0,d=l.length;c<d&&!s;c++){const h=l.item(c),f=geometryTypes[h.localName];defined(f)&&(f(e,n.entityCollection,h,o,a,o.id),s=!0)}s||(o.merge(a),processPositionGraphics(e,o,a))}const playlistNodeProcessors={FlyTo:processTourFlyTo,Wait:processTourWait,SoundCue:processTourUnsupportedNode,AnimatedUpdate:processTourUnsupportedNode,TourControl:processTourUnsupportedNode};function processTour(e,t,n,i){const r=queryStringValue(t,"name",namespaces.kml),o=queryStringAttribute(t,"id"),a=new KmlTour(r,o),s=queryFirstNode(t,"Playlist",namespaces.gx);if(s){const l=e._ellipsoid,c=s.childNodes;for(let d=0;d<c.length;d++){const h=c[d];if(h.localName){const f=playlistNodeProcessors[h.localName];f?f(a,h,l):console.log(`Unknown KML Tour playlist entry type ${h.localName}`)}}}e._kmlTours.push(a)}function processTourUnsupportedNode(e,t){oneTimeWarning(`KML Tour unsupported node ${t.localName}`)}function processTourWait(e,t){const n=queryNumericValue(t,"duration",namespaces.gx);e.addPlaylistEntry(new KmlTourWait(n))}function processTourFlyTo(e,t,n){const i=queryNumericValue(t,"duration",namespaces.gx),r=queryStringValue(t,"flyToMode",namespaces.gx),o={kml:{}};processLookAt(t,o,n),processCamera(t,o,n);const a=o.kml.lookAt||o.kml.camera,s=new KmlTourFlyTo(i,r,a);e.addPlaylistEntry(s)}function processCamera(e,t,n){const i=queryFirstNode(e,"Camera",namespaces.kml);if(defined(i)){const r=defaultValue(queryNumericValue(i,"longitude",namespaces.kml),0),o=defaultValue(queryNumericValue(i,"latitude",namespaces.kml),0),a=defaultValue(queryNumericValue(i,"altitude",namespaces.kml),0),s=defaultValue(queryNumericValue(i,"heading",namespaces.kml),0),l=defaultValue(queryNumericValue(i,"tilt",namespaces.kml),0),c=defaultValue(queryNumericValue(i,"roll",namespaces.kml),0),d=Cartesian3.fromDegrees(r,o,a,n),h=HeadingPitchRoll.fromDegrees(s,l-90,c);t.kml.camera=new KmlCamera(d,h)}}function processLookAt(e,t,n){const i=queryFirstNode(e,"LookAt",namespaces.kml);if(defined(i)){const r=defaultValue(queryNumericValue(i,"longitude",namespaces.kml),0),o=defaultValue(queryNumericValue(i,"latitude",namespaces.kml),0),a=defaultValue(queryNumericValue(i,"altitude",namespaces.kml),0);let s=queryNumericValue(i,"heading",namespaces.kml),l=queryNumericValue(i,"tilt",namespaces.kml);const c=defaultValue(queryNumericValue(i,"range",namespaces.kml),0);l=CesiumMath.toRadians(defaultValue(l,0)),s=CesiumMath.toRadians(defaultValue(s,0));const d=new HeadingPitchRange(s,l-CesiumMath.PI_OVER_TWO,c),h=Cartesian3.fromDegrees(r,o,a,n);t.kml.lookAt=new KmlLookAt(h,d)}}function processScreenOverlay(e,t,n,i){const r=n.screenOverlayContainer;if(!defined(r))return;const o=n.sourceResource,a=n.uriResolver,s=queryFirstNode(t,"Icon",namespaces.kml),l=getIconHref(s,e,o,a,!1);if(!defined(l))return;const c=document.createElement("img");e._screenOverlays.push(c),c.src=l.url,c.onload=function(){const d=["position: absolute"],h=queryFirstNode(t,"screenXY",namespaces.kml),f=queryFirstNode(t,"overlayXY",namespaces.kml),p=queryFirstNode(t,"size",namespaces.kml);let u,m,g,_,C,A;defined(p)&&(u=queryNumericAttribute(p,"x"),m=queryNumericAttribute(p,"y"),g=queryStringAttribute(p,"xunits"),_=queryStringAttribute(p,"yunits"),defined(u)&&u!==-1&&u!==0&&(g==="fraction"?C=`width: ${Math.floor(u*100)}%`:g==="pixels"&&(C=`width: ${u}px`),d.push(C)),defined(m)&&m!==-1&&m!==0&&(_==="fraction"?A=`height: ${Math.floor(m*100)}%`:_==="pixels"&&(A=`height: ${m}px`),d.push(A))),c.style=d.join(";");let S=0,v=c.height;defined(f)&&(u=queryNumericAttribute(f,"x"),m=queryNumericAttribute(f,"y"),g=queryStringAttribute(f,"xunits"),_=queryStringAttribute(f,"yunits"),defined(u)&&(g==="fraction"?S=u*c.width:(g==="pixels"||g==="insetPixels")&&(S=u)),defined(m)&&(_==="fraction"?v=m*c.height:(_==="pixels"||_==="insetPixels")&&(v=m))),defined(h)&&(u=queryNumericAttribute(h,"x"),m=queryNumericAttribute(h,"y"),g=queryStringAttribute(h,"xunits"),_=queryStringAttribute(h,"yunits"),defined(u)&&(g==="fraction"?C=`left: calc(${Math.floor(u*100)}% - ${S}px)`:g==="pixels"?C=`left: ${u-S}px`:g==="insetPixels"&&(C=`right: ${u-S}px`),d.push(C)),defined(m)&&(_==="fraction"?A=`bottom: calc(${Math.floor(m*100)}% - ${v}px)`:_==="pixels"?A=`bottom: ${m-v}px`:_==="insetPixels"&&(A=`top: ${m-v}px`),d.push(A))),c.style=d.join(";")},r.appendChild(c)}function processGroundOverlay(e,t,n,i){const o=processFeature(e,t,n).entity;let a,s=!1;const l=e._ellipsoid,c=readCoordinates(queryFirstNode(t,"LatLonQuad",namespaces.gx),l),d=queryNumericValue(t,"drawOrder",namespaces.kml);if(defined(c))a=createDefaultPolygon(),a.hierarchy=new PolygonHierarchy(c),a.zIndex=d,o.polygon=a,s=!0;else{a=new RectangleGraphics,a.zIndex=d,o.rectangle=a;const u=queryFirstNode(t,"LatLonBox",namespaces.kml);if(defined(u)){let m=queryNumericValue(u,"west",namespaces.kml),g=queryNumericValue(u,"south",namespaces.kml),_=queryNumericValue(u,"east",namespaces.kml),C=queryNumericValue(u,"north",namespaces.kml);defined(m)&&(m=CesiumMath.negativePiToPi(CesiumMath.toRadians(m))),defined(g)&&(g=CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(g))),defined(_)&&(_=CesiumMath.negativePiToPi(CesiumMath.toRadians(_))),defined(C)&&(C=CesiumMath.clampToLatitudeRange(CesiumMath.toRadians(C))),a.coordinates=new Rectangle(m,g,_,C);const A=queryNumericValue(u,"rotation",namespaces.kml);if(defined(A)){const S=CesiumMath.toRadians(A);a.rotation=S,a.stRotation=S}}}const h=queryFirstNode(t,"Icon",namespaces.kml),f=getIconHref(h,e,n.sourceResource,n.uriResolver,!0);if(defined(f)){s&&oneTimeWarning("kml-gx:LatLonQuad","KML - gx:LatLonQuad Icon does not support texture projection.");const u=queryNumericValue(h,"x",namespaces.gx),m=queryNumericValue(h,"y",namespaces.gx),g=queryNumericValue(h,"w",namespaces.gx),_=queryNumericValue(h,"h",namespaces.gx);(defined(u)||defined(m)||defined(g)||defined(_))&&oneTimeWarning("kml-groundOverlay-xywh","KML - gx:x, gx:y, gx:w, gx:h aren't supported for GroundOverlays"),a.material=f,a.material.color=queryColorValue(t,"color",namespaces.kml),a.material.transparent=!0}else a.material=queryColorValue(t,"color",namespaces.kml);let p=queryStringValue(t,"altitudeMode",namespaces.kml);defined(p)?p==="absolute"?(a.height=queryNumericValue(t,"altitude",namespaces.kml),a.zIndex=void 0):p!=="clampToGround"&&oneTimeWarning("kml-altitudeMode-unknown",`KML - Unknown altitudeMode: ${p}`):(p=queryStringValue(t,"altitudeMode",namespaces.gx),p==="relativeToSeaFloor"?(oneTimeWarning("kml-altitudeMode-relativeToSeaFloor","KML - altitudeMode relativeToSeaFloor is currently not supported, treating as absolute."),a.height=queryNumericValue(t,"altitude",namespaces.kml),a.zIndex=void 0):p==="clampToSeaFloor"?oneTimeWarning("kml-altitudeMode-clampToSeaFloor","KML - altitudeMode clampToSeaFloor is currently not supported, treating as clampToGround."):defined(p)&&oneTimeWarning("kml-altitudeMode-unknown",`KML - Unknown altitudeMode: ${p}`))}function processUnsupportedFeature(e,t,n,i){e._unsupportedNode.raiseEvent(e,n.parentEntity,t,n.entityCollection,n.styleCollection,n.sourceResource,n.uriResolver),oneTimeWarning(`kml-unsupportedFeature-${t.nodeName}`,`KML - Unsupported feature: ${t.nodeName}`)}const RefreshMode={INTERVAL:0,EXPIRE:1,STOP:2};function cleanupString(e){if(!defined(e)||e.length===0)return"";const t=e[0];return(t==="&"||t==="?")&&(e=e.substring(1)),e}const zeroRectangle=new Rectangle,scratchCartographic$6=new Cartographic,scratchCartesian2$4=new Cartesian2,scratchCartesian3$3=new Cartesian3;function processNetworkLinkQueryString(e,t,n,i,r,o){function a(c){return c<-CesiumMath.PI_OVER_TWO?-CesiumMath.PI_OVER_TWO:c>CesiumMath.PI_OVER_TWO?CesiumMath.PI_OVER_TWO:c}function s(c){return c>CesiumMath.PI?c-CesiumMath.TWO_PI:c<-CesiumMath.PI?c+CesiumMath.TWO_PI:c}let l=objectToQuery(e.queryParameters);if(l=l.replace(/%5B/g,"[").replace(/%5D/g,"]"),defined(t)&&t._mode!==SceneMode.MORPHING){let c,d;if(r=defaultValue(r,zeroRectangle),defined(n)&&(scratchCartesian2$4.x=n.clientWidth*.5,scratchCartesian2$4.y=n.clientHeight*.5,c=t.pickEllipsoid(scratchCartesian2$4,o,scratchCartesian3$3)),defined(c)?d=o.cartesianToCartographic(c,scratchCartographic$6):(d=Rectangle.center(r,scratchCartographic$6),c=o.cartographicToCartesian(d)),defined(i)&&!CesiumMath.equalsEpsilon(i,1,CesiumMath.EPSILON9)){const _=r.width*i*.5,C=r.height*i*.5;r=new Rectangle(s(d.longitude-_),a(d.latitude-C),s(d.longitude+_),a(d.latitude+C))}l=l.replace("[bboxWest]",CesiumMath.toDegrees(r.west).toString()),l=l.replace("[bboxSouth]",CesiumMath.toDegrees(r.south).toString()),l=l.replace("[bboxEast]",CesiumMath.toDegrees(r.east).toString()),l=l.replace("[bboxNorth]",CesiumMath.toDegrees(r.north).toString());const h=CesiumMath.toDegrees(d.longitude).toString(),f=CesiumMath.toDegrees(d.latitude).toString();l=l.replace("[lookatLon]",h),l=l.replace("[lookatLat]",f),l=l.replace("[lookatTilt]",CesiumMath.toDegrees(t.pitch).toString()),l=l.replace("[lookatHeading]",CesiumMath.toDegrees(t.heading).toString()),l=l.replace("[lookatRange]",Cartesian3.distance(t.positionWC,c)),l=l.replace("[lookatTerrainLon]",h),l=l.replace("[lookatTerrainLat]",f),l=l.replace("[lookatTerrainAlt]",d.height.toString()),o.cartesianToCartographic(t.positionWC,scratchCartographic$6),l=l.replace("[cameraLon]",CesiumMath.toDegrees(scratchCartographic$6.longitude).toString()),l=l.replace("[cameraLat]",CesiumMath.toDegrees(scratchCartographic$6.latitude).toString()),l=l.replace("[cameraAlt]",CesiumMath.toDegrees(scratchCartographic$6.height).toString());const p=t.frustum,u=p.aspectRatio;let m="",g="";if(defined(u)){const _=CesiumMath.toDegrees(p.fov);u>1?(m=_,g=_/u):(g=_,m=_*u)}l=l.replace("[horizFov]",m.toString()),l=l.replace("[vertFov]",g.toString())}else l=l.replace("[bboxWest]","-180"),l=l.replace("[bboxSouth]","-90"),l=l.replace("[bboxEast]","180"),l=l.replace("[bboxNorth]","90"),l=l.replace("[lookatLon]",""),l=l.replace("[lookatLat]",""),l=l.replace("[lookatRange]",""),l=l.replace("[lookatTilt]",""),l=l.replace("[lookatHeading]",""),l=l.replace("[lookatTerrainLon]",""),l=l.replace("[lookatTerrainLat]",""),l=l.replace("[lookatTerrainAlt]",""),l=l.replace("[cameraLon]",""),l=l.replace("[cameraLat]",""),l=l.replace("[cameraAlt]",""),l=l.replace("[horizFov]",""),l=l.replace("[vertFov]","");defined(n)?(l=l.replace("[horizPixels]",n.clientWidth),l=l.replace("[vertPixels]",n.clientHeight)):(l=l.replace("[horizPixels]",""),l=l.replace("[vertPixels]","")),l=l.replace("[terrainEnabled]","1"),l=l.replace("[clientVersion]","1"),l=l.replace("[kmlVersion]","2.2"),l=l.replace("[clientName]","Cesium"),l=l.replace("[language]","English"),e.setQueryParameters(queryToObject(l))}function processNetworkLink(e,t,n,i){const o=processFeature(e,t,n).entity,a=n.sourceResource,s=n.uriResolver;let l=queryFirstNode(t,"Link",namespaces.kml);if(defined(l)||(l=queryFirstNode(t,"Url",namespaces.kml)),defined(l)){let c=queryStringValue(l,"href",namespaces.kml),d,h;if(defined(c)){let f=c;if(c=resolveHref(c,a,n.uriResolver),/^data:/.test(c.getUrlComponent()))/\.kmz/i.test(a.getUrlComponent())||(f=a.getDerivedResource({url:f}));else{if(f=c.clone(),d=queryStringValue(l,"viewRefreshMode",namespaces.kml),d==="onRegion"){oneTimeWarning("kml-refrehMode-onRegion","KML - Unsupported viewRefreshMode: onRegion");return}h=defaultValue(queryStringValue(l,"viewBoundScale",namespaces.kml),1);const g=d==="onStop"?"BBOX=[bboxWest],[bboxSouth],[bboxEast],[bboxNorth]":"",_=defaultValue(queryStringValue(l,"viewFormat",namespaces.kml),g),C=queryStringValue(l,"httpQuery",namespaces.kml);defined(_)&&c.setQueryParameters(queryToObject(cleanupString(_))),defined(C)&&c.setQueryParameters(queryToObject(cleanupString(C)));const A=e._ellipsoid;processNetworkLinkQueryString(c,e.camera,e.canvas,h,e._lastCameraView.bbox,A)}const p={sourceUri:f,uriResolver:s,context:o.id,screenOverlayContainer:n.screenOverlayContainer},u=new EntityCollection,m=load$1(e,u,c,p).then(function(g){const _=e._entityCollection,C=u.values;_.suspendEvents();for(let v=0;v<C.length;v++){const b=C[v];defined(b.parent)||(b.parent=o,mergeAvailabilityWithParent(b)),_.add(b)}_.resumeEvents();const A=queryStringValue(l,"refreshMode",namespaces.kml);let S=defaultValue(queryNumericValue(l,"refreshInterval",namespaces.kml),0);if(A==="onInterval"&&S>0||A==="onExpire"||d==="onStop"){const v=queryFirstNode(g,"NetworkLinkControl",namespaces.kml),b=defined(v),D=JulianDate.now(),I={id:createGuid(),href:c,cookie:{},lastUpdated:D,updating:!1,entity:o,viewBoundScale:h,needsUpdate:!1,cameraUpdateTime:D};let L=0;if(b&&(I.cookie=queryToObject(defaultValue(queryStringValue(v,"cookie",namespaces.kml),"")),L=defaultValue(queryNumericValue(v,"minRefreshPeriod",namespaces.kml),0)),A==="onInterval")b&&(S=Math.max(L,S)),I.refreshMode=RefreshMode.INTERVAL,I.time=S;else if(A==="onExpire"){let N;if(b&&(N=queryStringValue(v,"expires",namespaces.kml)),defined(N))try{const y=JulianDate.fromIso8601(N),x=JulianDate.secondsDifference(y,D);x>0&&x<L&&JulianDate.addSeconds(D,L,y),I.refreshMode=RefreshMode.EXPIRE,I.time=y}catch{oneTimeWarning("kml-refreshMode-onInterval-onExpire","KML - NetworkLinkControl expires is not a valid date")}else oneTimeWarning("kml-refreshMode-onExpire","KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element")}else defined(e.camera)?(I.refreshMode=RefreshMode.STOP,I.time=defaultValue(queryNumericValue(l,"viewRefreshTime",namespaces.kml),0)):oneTimeWarning("kml-refrehMode-onStop-noCamera","A NetworkLink with viewRefreshMode=onStop requires the `camera` property to be defined.");defined(I.refreshMode)&&e._networkLinks.set(I.id,I)}}).catch(function(g){oneTimeWarning(`An error occured during loading ${c.url}`),e._error.raiseEvent(e,g)});i.addPromise(m)}}}function processFeatureNode(e,t,n,i){const r=featureTypes[t.localName];return defined(r)?r(e,t,n,i):processUnsupportedFeature(e,t,n)}function loadKml(e,t,n,i,r,o,a){t.removeAll();const s=n.documentElement,l=s.localName==="Document"?s:queryFirstNode(s,"Document",namespaces.kml);let c=queryStringValue(l,"name",namespaces.kml);defined(c)||(c=getFilenameFromUri(i.getUrlComponent())),defined(e._name)||(e._name=c);const d=new KmlDataSource._DeferredLoading(e),h=new EntityCollection(e);return Promise.all(processStyles(e,n,h,i,!1,r)).then(function(){let f=n.documentElement;if(f.localName==="kml"){const u=f.childNodes;for(let m=0;m<u.length;m++){const g=u[m];if(defined(featureTypes[g.localName])){f=g;break}}}const p={parentEntity:void 0,entityCollection:t,styleCollection:h,sourceResource:i,uriResolver:r,context:a,screenOverlayContainer:o};return t.suspendEvents(),processFeatureNode(e,f,p,d),t.resumeEvents(),d.wait().then(function(){return n.documentElement})})}function loadKmz(e,t,n,i,r){const o=buildModuleUrl("ThirdParty/Workers/z-worker-pako.js");configure({workerScripts:{deflate:[o,"./pako_deflate.min.js"],inflate:[o,"./pako_inflate.min.js"]}});const a=new ZipReader(new BlobReader(n));return Promise.resolve(a.getEntries()).then(function(s){const l=[],c={};let d;for(let h=0;h<s.length;h++){const f=s[h];f.directory||(/\.kml$/i.test(f.filename)&&(!defined(d)||!/\//i.test(f.filename))?(defined(d)&&l.push(loadDataUriFromZip(d,c)),d=f):l.push(loadDataUriFromZip(f,c)))}return defined(d)&&l.push(loadXmlFromZip(d,c)),Promise.all(l).then(function(){if(a.close(),!defined(c.kml))throw new RuntimeError("KMZ file does not contain a KML document.");return c.keys=Object.keys(c),loadKml(e,t,c.kml,i,c,r)})})}function load$1(e,t,n,i){i=defaultValue(i,defaultValue.EMPTY_OBJECT);let r=i.sourceUri;const o=i.uriResolver,a=i.context;let s=i.screenOverlayContainer,l=n;if(typeof n=="string"||n instanceof Resource){n=Resource.createIfNeeded(n),l=n.fetchBlob(),r=defaultValue(r,n.clone());const c=e._resourceCredits,d=n.credits;if(defined(d)){const h=d.length;for(let f=0;f<h;f++)c.push(d[f])}}else r=defaultValue(r,Resource.DEFAULT.clone());return r=Resource.createIfNeeded(r),defined(s)&&(s=getElement(s)),Promise.resolve(l).then(function(c){return c instanceof Blob?isZipFile(c).then(function(d){return d?loadKmz(e,t,c,r,s):readBlobAsText(c).then(function(h){h=insertNamespaces(h),h=removeDuplicateNamespaces(h);let f,p;try{f=parser.parseFromString(h,"application/xml")}catch(u){p=u.toString()}if(defined(p)||f.body||f.documentElement.tagName==="parsererror"){let u=defined(p)?p:f.documentElement.firstChild.nodeValue;throw u||(u=f.body.innerText),new RuntimeError(u)}return loadKml(e,t,f,r,o,s,a)})}):loadKml(e,t,c,r,o,s,a)}).catch(function(c){return e._error.raiseEvent(e,c),console.log(c),Promise.reject(c)})}function KmlDataSource(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.camera,n=e.canvas;this._changed=new Event,this._error=new Event,this._loading=new Event,this._refresh=new Event,this._unsupportedNode=new Event,this._clock=void 0,this._entityCollection=new EntityCollection(this),this._name=void 0,this._isLoading=!1,this._pinBuilder=new PinBuilder,this._networkLinks=new AssociativeArray,this._entityCluster=new EntityCluster,this.canvas=n,this.camera=t,this._lastCameraView={position:defined(t)?Cartesian3.clone(t.positionWC):void 0,direction:defined(t)?Cartesian3.clone(t.directionWC):void 0,up:defined(t)?Cartesian3.clone(t.upWC):void 0,bbox:defined(t)?t.computeViewRectangle():Rectangle.clone(Rectangle.MAX_VALUE)},this._ellipsoid=defaultValue(e.ellipsoid,Ellipsoid.default);let i=e.credit;typeof i=="string"&&(i=new Credit(i)),this._credit=i,this._resourceCredits=[],this._kmlTours=[],this._screenOverlays=[]}KmlDataSource.load=function(e,t){return t=defaultValue(t,defaultValue.EMPTY_OBJECT),new KmlDataSource(t).load(e,t)};Object.defineProperties(KmlDataSource.prototype,{name:{get:function(){return this._name},set:function(e){this._name!==e&&(this._name=e,this._changed.raiseEvent(this))}},clock:{get:function(){return this._clock}},entities:{get:function(){return this._entityCollection}},isLoading:{get:function(){return this._isLoading}},changedEvent:{get:function(){return this._changed}},errorEvent:{get:function(){return this._error}},loadingEvent:{get:function(){return this._loading}},refreshEvent:{get:function(){return this._refresh}},unsupportedNodeEvent:{get:function(){return this._unsupportedNode}},show:{get:function(){return this._entityCollection.show},set:function(e){this._entityCollection.show=e}},clustering:{get:function(){return this._entityCluster},set:function(e){if(!defined(e))throw new DeveloperError("value must be defined.");this._entityCluster=e}},credit:{get:function(){return this._credit}},kmlTours:{get:function(){return this._kmlTours}}});KmlDataSource.prototype.load=function(e,t){if(!defined(e))throw new DeveloperError("data is required.");t=defaultValue(t,defaultValue.EMPTY_OBJECT),DataSource.setLoading(this,!0);const n=this._name;this._name=void 0,this._clampToGround=defaultValue(t.clampToGround,!1);const i=this;return load$1(this,this._entityCollection,e,t).then(function(){let r;const o=i._entityCollection.computeAvailability();let a=o.start,s=o.stop;const l=JulianDate.equals(a,Iso8601.MINIMUM_VALUE),c=JulianDate.equals(s,Iso8601.MAXIMUM_VALUE);if(!l||!c){let h;l&&(h=new Date,h.setHours(0,0,0,0),a=JulianDate.fromDate(h)),c&&(h=new Date,h.setHours(24,0,0,0),s=JulianDate.fromDate(h)),r=new DataSourceClock,r.startTime=a,r.stopTime=s,r.currentTime=JulianDate.clone(a),r.clockRange=ClockRange$1.LOOP_STOP,r.clockStep=ClockStep$1.SYSTEM_CLOCK_MULTIPLIER,r.multiplier=Math.round(Math.min(Math.max(JulianDate.secondsDifference(s,a)/60,1),31556900))}let d=!1;return r!==i._clock&&(i._clock=r,d=!0),n!==i._name&&(d=!0),d&&i._changed.raiseEvent(i),DataSource.setLoading(i,!1),i}).catch(function(r){return DataSource.setLoading(i,!1),i._error.raiseEvent(i,r),console.log(r),Promise.reject(r)})};KmlDataSource.prototype.destroy=function(){for(;this._screenOverlays.length>0;)this._screenOverlays.pop().remove()};function mergeAvailabilityWithParent(e){const t=e.parent;if(defined(t)){const n=t.availability;if(defined(n)){const i=e.availability;defined(i)?i.intersect(n):e.availability=n}}}function getNetworkLinkUpdateCallback(e,t,n,i,r){return function(o){if(!i.contains(t.id))return;let a=!1;const s=queryFirstNode(o,"NetworkLinkControl",namespaces.kml),l=defined(s);let c=0;if(l){if(defined(queryFirstNode(s,"Update",namespaces.kml))){oneTimeWarning("kml-networkLinkControl-update","KML - NetworkLinkControl updates aren't supported."),t.updating=!1,i.remove(t.id);return}t.cookie=queryToObject(defaultValue(queryStringValue(s,"cookie",namespaces.kml),"")),c=defaultValue(queryNumericValue(s,"minRefreshPeriod",namespaces.kml),0)}const d=JulianDate.now(),h=t.refreshMode;if(h===RefreshMode.INTERVAL)defined(s)&&(t.time=Math.max(c,t.time));else if(h===RefreshMode.EXPIRE){let D;if(defined(s)&&(D=queryStringValue(s,"expires",namespaces.kml)),defined(D))try{const I=JulianDate.fromIso8601(D),L=JulianDate.secondsDifference(I,d);L>0&&L<c&&JulianDate.addSeconds(d,c,I),t.time=I}catch{oneTimeWarning("kml-networkLinkControl-expires","KML - NetworkLinkControl expires is not a valid date"),a=!0}else oneTimeWarning("kml-refreshMode-onExpire","KML - refreshMode of onExpire requires the NetworkLinkControl to have an expires element"),a=!0}const f=t.entity,p=e._entityCollection,u=n.values;function m(D){p.remove(D);const I=D._children,L=I.length;for(let N=0;N<L;++N)m(I[N])}p.suspendEvents();const g=p.values.slice();let _;for(_=0;_<g.length;++_){const D=g[_];D.parent===f&&(D.parent=void 0,m(D))}for(p.resumeEvents(),p.suspendEvents(),_=0;_<u.length;_++){const D=u[_];defined(D.parent)||(D.parent=f,mergeAvailabilityWithParent(D)),p.add(D)}p.resumeEvents(),a?i.remove(t.id):t.lastUpdated=d;const C=p.computeAvailability(),A=C.start,S=C.stop,v=JulianDate.equals(A,Iso8601.MINIMUM_VALUE),b=JulianDate.equals(S,Iso8601.MAXIMUM_VALUE);if(!v||!b){const D=e._clock;(D.startTime!==A||D.stopTime!==S)&&(D.startTime=A,D.stopTime=S,e._changed.raiseEvent(e))}t.updating=!1,t.needsUpdate=!1,e._refresh.raiseEvent(e,r.getUrlComponent(!0))}}const entitiesToIgnore=new AssociativeArray;KmlDataSource.prototype.update=function(e){const t=this._networkLinks;if(t.length===0)return!0;const n=JulianDate.now(),i=this;entitiesToIgnore.removeAll();function r(d){const h=d._children,f=h.length;for(let p=0;p<f;++p){const u=h[p];entitiesToIgnore.set(u.id,u),r(u)}}let o=!1;const a=this._lastCameraView,s=this.camera;defined(s)&&!(s.positionWC.equalsEpsilon(a.position,CesiumMath.EPSILON7)&&s.directionWC.equalsEpsilon(a.direction,CesiumMath.EPSILON7)&&s.upWC.equalsEpsilon(a.up,CesiumMath.EPSILON7))&&(a.position=Cartesian3.clone(s.positionWC),a.direction=Cartesian3.clone(s.directionWC),a.up=Cartesian3.clone(s.upWC),a.bbox=s.computeViewRectangle(),o=!0);const l=new AssociativeArray;let c=!1;return t.values.forEach(function(d){const h=d.entity;if(!entitiesToIgnore.contains(h.id)){if(!d.updating){let f=!1;if(d.refreshMode===RefreshMode.INTERVAL?JulianDate.secondsDifference(n,d.lastUpdated)>d.time&&(f=!0):d.refreshMode===RefreshMode.EXPIRE?JulianDate.greaterThan(n,d.time)&&(f=!0):d.refreshMode===RefreshMode.STOP&&(o&&(d.needsUpdate=!0,d.cameraUpdateTime=n),d.needsUpdate&&JulianDate.secondsDifference(n,d.cameraUpdateTime)>=d.time&&(f=!0)),f){r(h),d.updating=!0;const p=new EntityCollection,u=d.href.clone();u.setQueryParameters(d.cookie);const m=defaultValue(i._ellipsoid,Ellipsoid.default);processNetworkLinkQueryString(u,i.camera,i.canvas,d.viewBoundScale,a.bbox,m),load$1(i,p,u,{context:h.id}).then(getNetworkLinkUpdateCallback(i,d,p,l,u)).catch(function(g){const _=`NetworkLink ${d.href} refresh failed: ${g}`;console.log(_),i._error.raiseEvent(i,_)}),c=!0}}l.set(d.id,d)}}),c&&(this._networkLinks=l,this._changed.raiseEvent(this)),!0};function KmlFeatureData(){this.author={name:void 0,uri:void 0,email:void 0},this.link={href:void 0,hreflang:void 0,rel:void 0,type:void 0,title:void 0,length:void 0},this.address=void 0,this.phoneNumber=void 0,this.snippet=void 0,this.extendedData=void 0}KmlDataSource._DeferredLoading=DeferredLoading;KmlDataSource._getTimestamp=getTimestamp;function Visualizer(){DeveloperError.throwInstantiationError()}Visualizer.prototype.update=DeveloperError.throwInstantiationError;Visualizer.prototype.getBoundingSphere=DeveloperError.throwInstantiationError;Visualizer.prototype.isDestroyed=DeveloperError.throwInstantiationError;Visualizer.prototype.destroy=DeveloperError.throwInstantiationError;const AdjustTranslucentFS=`#ifdef MRT
layout (location = 0) out vec4 out_FragData_0;
layout (location = 1) out vec4 out_FragData_1;
#else
layout (location = 0) out vec4 out_FragColor;
#endif

uniform vec4 u_bgColor;
uniform sampler2D u_depthTexture;

in vec2 v_textureCoordinates;

void main()
{
    if (texture(u_depthTexture, v_textureCoordinates).r < 1.0)
    {
#ifdef MRT
        out_FragData_0 = u_bgColor;
        out_FragData_1 = vec4(u_bgColor.a);
#else
        out_FragColor = u_bgColor;
#endif
        return;
    }
    
    discard;
}
`,AtmosphereCommon=`uniform vec3 u_radiiAndDynamicAtmosphereColor;

uniform float u_atmosphereLightIntensity;
uniform float u_atmosphereRayleighScaleHeight;
uniform float u_atmosphereMieScaleHeight;
uniform float u_atmosphereMieAnisotropy;
uniform vec3 u_atmosphereRayleighCoefficient;
uniform vec3 u_atmosphereMieCoefficient;

const float ATMOSPHERE_THICKNESS = 111e3; // The thickness of the atmosphere in meters.
const int PRIMARY_STEPS_MAX = 16; // Maximum number of times the ray from the camera to the world position (primary ray) is sampled.
const int LIGHT_STEPS_MAX = 4; // Maximum number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray.

/**
 * This function computes the colors contributed by Rayliegh and Mie scattering on a given ray, as well as
 * the transmittance value for the ray.
 *
 * @param {czm_ray} primaryRay The ray from the camera to the position.
 * @param {float} primaryRayLength The length of the primary ray.
 * @param {vec3} lightDirection The direction of the light to calculate the scattering from.
 * @param {vec3} rayleighColor The variable the Rayleigh scattering will be written to.
 * @param {vec3} mieColor The variable the Mie scattering will be written to.
 * @param {float} opacity The variable the transmittance will be written to.
 * @glslFunction
 */
void computeScattering(
    czm_ray primaryRay,
    float primaryRayLength,
    vec3 lightDirection,
    float atmosphereInnerRadius,
    out vec3 rayleighColor,
    out vec3 mieColor,
    out float opacity
) {

    // Initialize the default scattering amounts to 0.
    rayleighColor = vec3(0.0);
    mieColor = vec3(0.0);
    opacity = 0.0;

    float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS;

    vec3 origin = vec3(0.0);

    // Calculate intersection from the camera to the outer ring of the atmosphere.
    czm_raySegment primaryRayAtmosphereIntersect = czm_raySphereIntersectionInterval(primaryRay, origin, atmosphereOuterRadius);

    // Return empty colors if no intersection with the atmosphere geometry.
    if (primaryRayAtmosphereIntersect == czm_emptyRaySegment) {
        return;
    }

    // To deal with smaller values of PRIMARY_STEPS (e.g. 4)
    // we implement a split strategy: sky or horizon.
    // For performance reasons, instead of a if/else branch
    // a soft choice is implemented through a weight 0.0 <= w_stop_gt_lprl <= 1.0
    float x = 1e-7 * primaryRayAtmosphereIntersect.stop / length(primaryRayLength);
    // Value close to 0.0: close to the horizon
    // Value close to 1.0: above in the sky
    float w_stop_gt_lprl = 0.5 * (1.0 + czm_approximateTanh(x));

    // The ray should start from the first intersection with the outer atmopshere, or from the camera position, if it is inside the atmosphere.
    float start_0 = primaryRayAtmosphereIntersect.start;
    primaryRayAtmosphereIntersect.start = max(primaryRayAtmosphereIntersect.start, 0.0);
    // The ray should end at the exit from the atmosphere or at the distance to the vertex, whichever is smaller.
    primaryRayAtmosphereIntersect.stop = min(primaryRayAtmosphereIntersect.stop, length(primaryRayLength));

    // For the number of ray steps, distinguish inside or outside atmosphere (outer space)
    // (1) from outer space we have to use more ray steps to get a realistic rendering
    // (2) within atmosphere we need fewer steps for faster rendering
    float x_o_a = start_0 - ATMOSPHERE_THICKNESS; // ATMOSPHERE_THICKNESS used as an ad-hoc constant, no precise meaning here, only the order of magnitude matters
    float w_inside_atmosphere = 1.0 - 0.5 * (1.0 + czm_approximateTanh(x_o_a));
    int PRIMARY_STEPS = PRIMARY_STEPS_MAX - int(w_inside_atmosphere * 12.0); // Number of times the ray from the camera to the world position (primary ray) is sampled.
    int LIGHT_STEPS = LIGHT_STEPS_MAX - int(w_inside_atmosphere * 2.0); // Number of times the light is sampled from the light source's intersection with the atmosphere to a sample position on the primary ray.

    // Setup for sampling positions along the ray - starting from the intersection with the outer ring of the atmosphere.
    float rayPositionLength = primaryRayAtmosphereIntersect.start;
    // (1) Outside the atmosphere: constant rayStepLength
    // (2) Inside atmosphere: variable rayStepLength to compensate the rough rendering of the smaller number of ray steps
    float totalRayLength = primaryRayAtmosphereIntersect.stop - rayPositionLength;
    float rayStepLengthIncrease = w_inside_atmosphere * ((1.0 - w_stop_gt_lprl) * totalRayLength / (float(PRIMARY_STEPS * (PRIMARY_STEPS + 1)) / 2.0));
    float rayStepLength = max(1.0 - w_inside_atmosphere, w_stop_gt_lprl) * totalRayLength / max(7.0 * w_inside_atmosphere, float(PRIMARY_STEPS));

    vec3 rayleighAccumulation = vec3(0.0);
    vec3 mieAccumulation = vec3(0.0);
    vec2 opticalDepth = vec2(0.0);
    vec2 heightScale = vec2(u_atmosphereRayleighScaleHeight, u_atmosphereMieScaleHeight);

    // Sample positions on the primary ray.
    for (int i = 0; i < PRIMARY_STEPS_MAX; ++i) {

        // The loop should be: for (int i = 0; i < PRIMARY_STEPS; ++i) {...} but WebGL1 cannot
        // loop with non-constant condition, so it has to break early instead
        if (i >= PRIMARY_STEPS) {
            break;
        }

        // Calculate sample position along viewpoint ray.
        vec3 samplePosition = primaryRay.origin + primaryRay.direction * (rayPositionLength + rayStepLength);

        // Calculate height of sample position above ellipsoid.
        float sampleHeight = length(samplePosition) - atmosphereInnerRadius;

        // Calculate and accumulate density of particles at the sample position.
        vec2 sampleDensity = exp(-sampleHeight / heightScale) * rayStepLength;
        opticalDepth += sampleDensity;

        // Generate ray from the sample position segment to the light source, up to the outer ring of the atmosphere.
        czm_ray lightRay = czm_ray(samplePosition, lightDirection);
        czm_raySegment lightRayAtmosphereIntersect = czm_raySphereIntersectionInterval(lightRay, origin, atmosphereOuterRadius);

        float lightStepLength = lightRayAtmosphereIntersect.stop / float(LIGHT_STEPS);
        float lightPositionLength = 0.0;

        vec2 lightOpticalDepth = vec2(0.0);

        // Sample positions along the light ray, to accumulate incidence of light on the latest sample segment.
        for (int j = 0; j < LIGHT_STEPS_MAX; ++j) {

            // The loop should be: for (int j = 0; i < LIGHT_STEPS; ++j) {...} but WebGL1 cannot
            // loop with non-constant condition, so it has to break early instead
            if (j >= LIGHT_STEPS) {
                break;
            }

            // Calculate sample position along light ray.
            vec3 lightPosition = samplePosition + lightDirection * (lightPositionLength + lightStepLength * 0.5);

            // Calculate height of the light sample position above ellipsoid.
            float lightHeight = length(lightPosition) - atmosphereInnerRadius;

            // Calculate density of photons at the light sample position.
            lightOpticalDepth += exp(-lightHeight / heightScale) * lightStepLength;

            // Increment distance on light ray.
            lightPositionLength += lightStepLength;
        }

        // Compute attenuation via the primary ray and the light ray.
        vec3 attenuation = exp(-((u_atmosphereMieCoefficient * (opticalDepth.y + lightOpticalDepth.y)) + (u_atmosphereRayleighCoefficient * (opticalDepth.x + lightOpticalDepth.x))));

        // Accumulate the scattering.
        rayleighAccumulation += sampleDensity.x * attenuation;
        mieAccumulation += sampleDensity.y * attenuation;

        // Increment distance on primary ray.
        rayPositionLength += (rayStepLength += rayStepLengthIncrease);
    }

    // Compute the scattering amount.
    rayleighColor = u_atmosphereRayleighCoefficient * rayleighAccumulation;
    mieColor = u_atmosphereMieCoefficient * mieAccumulation;

    // Compute the transmittance i.e. how much light is passing through the atmosphere.
    opacity = length(exp(-((u_atmosphereMieCoefficient * opticalDepth.y) + (u_atmosphereRayleighCoefficient * opticalDepth.x))));
}

vec4 computeAtmosphereColor(
    vec3 positionWC,
    vec3 lightDirection,
    vec3 rayleighColor,
    vec3 mieColor,
    float opacity
) {
    // Setup the primary ray: from the camera position to the vertex position.
    vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC;
    vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC);

    float cosAngle = dot(cameraToPositionWCDirection, lightDirection);
    float cosAngleSq = cosAngle * cosAngle;

    float G = u_atmosphereMieAnisotropy;
    float GSq = G * G;

    // The Rayleigh phase function.
    float rayleighPhase = 3.0 / (50.2654824574) * (1.0 + cosAngleSq);
    // The Mie phase function.
    float miePhase = 3.0 / (25.1327412287) * ((1.0 - GSq) * (cosAngleSq + 1.0)) / (pow(1.0 + GSq - 2.0 * cosAngle * G, 1.5) * (2.0 + GSq));

    // The final color is generated by combining the effects of the Rayleigh and Mie scattering.
    vec3 rayleigh = rayleighPhase * rayleighColor;
    vec3 mie = miePhase * mieColor;

    vec3 color = (rayleigh + mie) * u_atmosphereLightIntensity;

    return vec4(color, opacity);
}
`,BrdfLutGeneratorFS=`in vec2 v_textureCoordinates;
const float M_PI = 3.141592653589793;

float vdcRadicalInverse(int i)
{
    float r;
    float base = 2.0;
    float value = 0.0;
    float invBase = 1.0 / base;
    float invBi = invBase;
    for (int x = 0; x < 100; x++)
    {
        if (i <= 0)
        {
            break;
        }
        r = mod(float(i), base);
        value += r * invBi;
        invBi *= invBase;
        i = int(float(i) * invBase);
    }
    return value;
}

vec2 hammersley2D(int i, int N)
{
    return vec2(float(i) / float(N), vdcRadicalInverse(i));
}

vec3 importanceSampleGGX(vec2 xi, float roughness, vec3 N)
{
    float a = roughness * roughness;
    float phi = 2.0 * M_PI * xi.x;
    float cosTheta = sqrt((1.0 - xi.y) / (1.0 + (a * a - 1.0) * xi.y));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);
    vec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);
    vec3 upVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 tangentX = normalize(cross(upVector, N));
    vec3 tangentY = cross(N, tangentX);
    return tangentX * H.x + tangentY * H.y + N * H.z;
}

float G1_Smith(float NdotV, float k)
{
    return NdotV / (NdotV * (1.0 - k) + k);
}

float G_Smith(float roughness, float NdotV, float NdotL)
{
    float k = roughness * roughness / 2.0;
    return G1_Smith(NdotV, k) * G1_Smith(NdotL, k);
}

vec2 integrateBrdf(float roughness, float NdotV)
{
    vec3 V = vec3(sqrt(1.0 - NdotV * NdotV), 0.0, NdotV);
    float A = 0.0;
    float B = 0.0;
    const int NumSamples = 1024;
    for (int i = 0; i < NumSamples; i++)
    {
        vec2 xi = hammersley2D(i, NumSamples);
        vec3 H = importanceSampleGGX(xi, roughness, vec3(0.0, 0.0, 1.0));
        vec3 L = 2.0 * dot(V, H) * H - V;
        float NdotL = clamp(L.z, 0.0, 1.0);
        float NdotH = clamp(H.z, 0.0, 1.0);
        float VdotH = clamp(dot(V, H), 0.0, 1.0);
        if (NdotL > 0.0)
        {
            float G = G_Smith(roughness, NdotV, NdotL);
            float G_Vis = G * VdotH / (NdotH * NdotV);
            float Fc = pow(1.0 - VdotH, 5.0);
            A += (1.0 - Fc) * G_Vis;
            B += Fc * G_Vis;
        }
    }
    return vec2(A, B) / float(NumSamples);
}

void main()
{
    out_FragColor = vec4(integrateBrdf(v_textureCoordinates.y, v_textureCoordinates.x), 0.0, 1.0);
}
`,CloudCollectionFS=`uniform sampler2D u_noiseTexture;
uniform vec3 u_noiseTextureDimensions;
uniform float u_noiseDetail;
in vec2 v_offset;
in vec3 v_maximumSize;
in vec4 v_color;
in float v_slice;
in float v_brightness;

float wrap(float value, float rangeLength) {
    if(value < 0.0) {
        float absValue = abs(value);
        float modValue = mod(absValue, rangeLength);
        return mod(rangeLength - modValue, rangeLength);
    }
    return mod(value, rangeLength);
}

vec3 wrapVec(vec3 value, float rangeLength) {
    return vec3(wrap(value.x, rangeLength),
                wrap(value.y, rangeLength),
                wrap(value.z, rangeLength));
}

vec2 voxelToUV(vec3 voxelIndex) {
    float textureSliceWidth = u_noiseTextureDimensions.x;
    float noiseTextureRows = u_noiseTextureDimensions.y;
    float inverseNoiseTextureRows = u_noiseTextureDimensions.z;

    float textureSliceWidthSquared = textureSliceWidth * textureSliceWidth;
    vec2 inverseNoiseTextureDimensions = vec2(noiseTextureRows / textureSliceWidthSquared,
                                            inverseNoiseTextureRows / textureSliceWidth);
    vec3 wrappedIndex = wrapVec(voxelIndex, textureSliceWidth);
    float column = mod(wrappedIndex.z, textureSliceWidth * inverseNoiseTextureRows);
    float row = floor(wrappedIndex.z / textureSliceWidth * noiseTextureRows);

    float xPixelCoord = wrappedIndex.x + column * textureSliceWidth;
    float yPixelCoord = wrappedIndex.y + row * textureSliceWidth;
    return vec2(xPixelCoord, yPixelCoord) * inverseNoiseTextureDimensions;
}

// Interpolate a voxel with its neighbor (along the positive X-axis)
vec4 lerpSamplesX(vec3 voxelIndex, float x) {
    vec2 uv0 = voxelToUV(voxelIndex);
    vec2 uv1 = voxelToUV(voxelIndex + vec3(1.0, 0.0, 0.0));
    vec4 sample0 = texture(u_noiseTexture, uv0);
    vec4 sample1 = texture(u_noiseTexture, uv1);
    return mix(sample0, sample1, x);
}

vec4 sampleNoiseTexture(vec3 position) {
    float textureSliceWidth = u_noiseTextureDimensions.x;
    vec3 recenteredPos = position + vec3(textureSliceWidth / 2.0);
    vec3 lerpValue = fract(recenteredPos);
    vec3 voxelIndex = floor(recenteredPos);

    vec4 xLerp00 = lerpSamplesX(voxelIndex, lerpValue.x);
    vec4 xLerp01 = lerpSamplesX(voxelIndex + vec3(0.0, 0.0, 1.0), lerpValue.x);
    vec4 xLerp10 = lerpSamplesX(voxelIndex + vec3(0.0, 1.0, 0.0), lerpValue.x);
    vec4 xLerp11 = lerpSamplesX(voxelIndex + vec3(0.0, 1.0, 1.0), lerpValue.x);

    vec4 yLerp0 = mix(xLerp00, xLerp10, lerpValue.y);
    vec4 yLerp1 = mix(xLerp01, xLerp11, lerpValue.y);
    return mix(yLerp0, yLerp1, lerpValue.z);
}

// Intersection with a unit sphere with radius 0.5 at center (0, 0, 0).
bool intersectSphere(vec3 origin, vec3 dir, float slice,
                     out vec3 point, out vec3 normal) {
    float A = dot(dir, dir);
    float B = dot(origin, dir);
    float C = dot(origin, origin) - 0.25;
    float discriminant = (B * B) - (A * C);
    if(discriminant < 0.0) {
        return false;
    }
    float root = sqrt(discriminant);
    float t = (-B - root) / A;
    if(t < 0.0) {
        t = (-B + root) / A;
    }
    point = origin + t * dir;

    if(slice >= 0.0) {
        point.z = (slice / 2.0) - 0.5;
        if(length(point) > 0.5) {
            return false;
        }
    }

    normal = normalize(point);
    point -= czm_epsilon2 * normal;
    return true;
}

// Transforms the ray origin and direction into unit sphere space,
// then transforms the result back into the ellipsoid's space.
bool intersectEllipsoid(vec3 origin, vec3 dir, vec3 center, vec3 scale, float slice,
                        out vec3 point, out vec3 normal) {
    if(scale.x <= 0.01 || scale.y < 0.01 || scale.z < 0.01) {
        return false;
    }

    vec3 o = (origin - center) / scale;
    vec3 d = dir / scale;
    vec3 p, n;
    bool intersected = intersectSphere(o, d, slice, p, n);
    if(intersected) {
        point = (p * scale) + center;
        normal = n;
    }
    return intersected;
}

// Assume that if phase shift is being called for octave i,
// the frequency is of i - 1. This saves us from doing extra
// division / multiplication operations.
vec2 phaseShift2D(vec2 p, vec2 freq) {
    return (czm_pi / 2.0) * sin(freq.yx * p.yx);
}

vec2 phaseShift3D(vec3 p, vec2 freq) {
    return phaseShift2D(p.xy, freq) + czm_pi * vec2(sin(freq.x * p.z));
}

// The cloud texture function derived from Gardner's 1985 paper,
// "Visual Simulation of Clouds."
// https://www.cs.drexel.edu/~david/Classes/Papers/p297-gardner.pdf
const float T0    = 0.6;  // contrast of the texture pattern
const float k     = 0.1;  // computed to produce a maximum value of 1
const float C0    = 0.8;  // coefficient
const float FX0   = 0.6;  // frequency X
const float FY0   = 0.6;  // frequency Y
const int octaves = 5;

float T(vec3 point) {
    vec2 sum = vec2(0.0);
    float Ci = C0;
    vec2 FXY = vec2(FX0, FY0);
    vec2 PXY = vec2(0.0);
    for(int i = 1; i <= octaves; i++) {
        PXY = phaseShift3D(point, FXY);
        Ci *= 0.707;
        FXY *= 2.0;
        vec2 sinTerm = sin(FXY * point.xy + PXY);
        sum += Ci * sinTerm + vec2(T0);
    }
    return k * sum.x * sum.y;
}

const float a = 0.5;  // fraction of surface reflection due to ambient or scattered light,
const float t = 0.4;  // fraction of texture shading
const float s = 0.25; // fraction of specular reflection

float I(float Id, float Is, float It) {
    return (1.0 - a) * ((1.0 - t) * ((1.0 - s) * Id + s * Is) + t * It) + a;
}

const vec3 lightDir = normalize(vec3(0.2, -1.0, 0.7));

vec4 drawCloud(vec3 rayOrigin, vec3 rayDir, vec3 cloudCenter, vec3 cloudScale, float cloudSlice,
               float brightness) {
    vec3 cloudPoint, cloudNormal;
    if(!intersectEllipsoid(rayOrigin, rayDir, cloudCenter, cloudScale, cloudSlice,
                            cloudPoint, cloudNormal)) {
        return vec4(0.0);
    }

    float Id = clamp(dot(cloudNormal, -lightDir), 0.0, 1.0);  // diffuse reflection
    float Is = max(pow(dot(-lightDir, -rayDir), 2.0), 0.0);   // specular reflection
    float It = T(cloudPoint);                                 // texture function
    float intensity = I(Id, Is, It);
    vec3 color = vec3(intensity * clamp(brightness, 0.1, 1.0));

    vec4 noise = sampleNoiseTexture(u_noiseDetail * cloudPoint);
    float W = noise.x;
    float W2 = noise.y;
    float W3 = noise.z;

    // The dot product between the cloud's normal and the ray's direction is greatest
    // in the center of the ellipsoid's surface. It decreases towards the edge.
    // Thus, it is used to blur the areas leading to the edges of the ellipsoid,
    // so that no harsh lines appear.

    // The first (and biggest) layer of worley noise is then subtracted from this.
    // The final result is scaled up so that the base cloud is not too translucent.
    float ndDot = clamp(dot(cloudNormal, -rayDir), 0.0, 1.0);
    float TR = pow(ndDot, 3.0) - W; // translucency
    TR *= 1.3;

    // Subtracting the second and third layers of worley noise is more complicated.
    // If these layers of noise were simply subtracted from the current translucency,
    // the shape derived from the first layer of noise would be completely deleted.
    // The erosion of this noise should thus be constricted to the edges of the cloud.
    // However, because the edges of the ellipsoid were already blurred away, mapping
    // the noise to (1.0 - ndDot) will have no impact on most of the cloud's appearance.
    // The value of (0.5 - ndDot) provides the best compromise.
    float minusDot = 0.5 - ndDot;

    // Even with the previous calculation, subtracting the second layer of wnoise
    // erode too much of the cloud. The addition of it, however, will detailed
    // volume to the cloud. As long as the noise is only added and not subtracted,
    // the results are aesthetically pleasing.

    // The minusDot product is mapped in a way that it is larger at the edges of
    // the ellipsoid, so a subtraction and min operation are used instead of
    // an addition and max one.
    TR -= min(minusDot * W2, 0.0);

    // The third level of worley noise is subtracted from the result, with some
    // modifications. First, a scalar is added to minusDot so that the noise
    // starts affecting the shape farther away from the center of the ellipsoid's
    // surface. Then, it is scaled down so its impact is not too intense.
    TR -= 0.8 * (minusDot + 0.25) * W3;

    // The texture function's shading does not correlate with the shape of the cloud
    // produced by the layers of noise, so an extra shading scalar is calculated.
    // The darkest areas of the cloud are assigned to be where the noise erodes
    // the cloud the most. This is then interpolated based on the translucency
    // and the diffuse shading term of that point in the cloud.
    float shading = mix(1.0 - 0.8 * W * W, 1.0, Id * TR);

    // To avoid values that are too dark, this scalar is increased by a small amount
    // and clamped so it never goes to zero.
    shading = clamp(shading + 0.2, 0.3, 1.0);

    // Finally, the contrast of the cloud's color is increased.
    vec3 finalColor = mix(vec3(0.5), shading * color, 1.15);
    return vec4(finalColor, clamp(TR, 0.0, 1.0)) * v_color;
}

void main() {
#ifdef DEBUG_BILLBOARDS
    out_FragColor = vec4(0.0, 0.5, 0.5, 1.0);
#endif
    // To avoid calculations with high values,
    // we raycast from an arbitrarily smaller space.
    vec2 coordinate = v_maximumSize.xy * v_offset;

    vec3 ellipsoidScale = 0.82 * v_maximumSize;
    vec3 ellipsoidCenter = vec3(0.0);

    float zOffset = max(ellipsoidScale.z - 10.0, 0.0);
    vec3 eye = vec3(0, 0, -10.0 - zOffset);
    vec3 rayDir = normalize(vec3(coordinate, 1.0) - eye);
    vec3 rayOrigin = eye;
#ifdef DEBUG_ELLIPSOIDS
    vec3 point, normal;
    if(intersectEllipsoid(rayOrigin, rayDir, ellipsoidCenter, ellipsoidScale, v_slice,
                          point, normal)) {
        out_FragColor = v_brightness * v_color;
    }
#else
#ifndef DEBUG_BILLBOARDS
    vec4 cloud = drawCloud(rayOrigin, rayDir,
                           ellipsoidCenter, ellipsoidScale, v_slice, v_brightness);
    if(cloud.w < 0.01) {
        discard;
    }
    out_FragColor = cloud;
#endif
#endif
}
`,CloudCollectionVS=`#ifdef INSTANCED
in vec2 direction;
#endif
in vec4 positionHighAndScaleX;
in vec4 positionLowAndScaleY;
in vec4 packedAttribute0;
in vec4 packedAttribute1;
in vec4 color;

out vec2 v_offset;
out vec3 v_maximumSize;
out vec4 v_color;
out float v_slice;
out float v_brightness;

void main() {
    // Unpack attributes.
    vec3 positionHigh = positionHighAndScaleX.xyz;
    vec3 positionLow = positionLowAndScaleY.xyz;
    vec2 scale = vec2(positionHighAndScaleX.w, positionLowAndScaleY.w);

    float show = packedAttribute0.x;
    float brightness = packedAttribute0.y;
    vec2 coordinates = packedAttribute0.wz;
    vec3 maximumSize = packedAttribute1.xyz;
    float slice = packedAttribute1.w;

#ifdef INSTANCED
    vec2 dir = direction;
#else
    vec2 dir = coordinates;
#endif

    vec2 offset = dir - vec2(0.5, 0.5);
    vec2 scaledOffset = scale * offset;
    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);
    vec4 positionEC = czm_modelViewRelativeToEye * p;
    positionEC.xy += scaledOffset;
    
    positionEC.xyz *= show;
    gl_Position = czm_projection * positionEC;

    v_offset = offset;
    v_maximumSize = maximumSize;
    v_color = color;
    v_slice = slice;
    v_brightness = brightness;
}
`,CloudNoiseFS=`uniform vec3 u_noiseTextureDimensions;
uniform float u_noiseDetail;
uniform vec3 u_noiseOffset;
in vec2 v_position;

float wrap(float value, float rangeLength) {
    if(value < 0.0) {
        float absValue = abs(value);
        float modValue = mod(absValue, rangeLength);
        return mod(rangeLength - modValue, rangeLength);
    }
    return mod(value, rangeLength);
}

vec3 wrapVec(vec3 value, float rangeLength) {
    return vec3(wrap(value.x, rangeLength),
                wrap(value.y, rangeLength),
                wrap(value.z, rangeLength));
}

vec3 random3(vec3 p) {
    float dot1 = dot(p, vec3(127.1, 311.7, 932.8));
    float dot2 = dot(p, vec3(269.5, 183.3, 421.4));
    return fract(vec3(sin(dot1 - dot2), cos(dot1 * dot2), dot1 * dot2));
}

// Frequency corresponds to cell size.
// The higher the frequency, the smaller the cell size.
vec3 getWorleyCellPoint(vec3 centerCell, vec3 offset, float freq) {
    float textureSliceWidth = u_noiseTextureDimensions.x;
    vec3 cell = centerCell + offset;
    cell = wrapVec(cell, textureSliceWidth / u_noiseDetail);
    cell += floor(u_noiseOffset / u_noiseDetail);
    vec3 p = offset + random3(cell);
    return p;
}

float worleyNoise(vec3 p, float freq) {
    vec3 centerCell = floor(p * freq);
    vec3 pointInCell = fract(p * freq);
    float shortestDistance = 1000.0;

    for(float z = -1.0; z <= 1.0; z++) {
        for(float y = -1.0; y <= 1.0; y++) {
            for(float x = -1.0; x <= 1.0; x++) {
                vec3 offset = vec3(x, y, z);
                vec3 point = getWorleyCellPoint(centerCell, offset, freq);

                float distance = length(pointInCell - point);
                if(distance < shortestDistance) {
                    shortestDistance = distance;
                }
            }
        }
    }

    return shortestDistance;
}

const float MAX_FBM_ITERATIONS = 10.0;

float worleyFBMNoise(vec3 p, float octaves, float scale) {
    float noise = 0.0;
    float freq = 1.0;
    float persistence = 0.625;
    for(float i = 0.0; i < MAX_FBM_ITERATIONS; i++) {
        if(i >= octaves) {
            break;
        }

        noise += worleyNoise(p * scale, freq * scale) * persistence;
        persistence *= 0.5;
        freq *= 2.0;
    }
    return noise;
}

void main() {
    float textureSliceWidth = u_noiseTextureDimensions.x;
    float inverseNoiseTextureRows = u_noiseTextureDimensions.z;
    float x = mod(v_position.x, textureSliceWidth);
    float y = mod(v_position.y, textureSliceWidth);
    float sliceRow = floor(v_position.y / textureSliceWidth);
    float z = floor(v_position.x / textureSliceWidth) + sliceRow * inverseNoiseTextureRows * textureSliceWidth;

    vec3 position = vec3(x, y, z);
    position /= u_noiseDetail;
    float worley0 = clamp(worleyFBMNoise(position, 3.0, 1.0), 0.0, 1.0);
    float worley1 = clamp(worleyFBMNoise(position, 3.0, 2.0), 0.0, 1.0);
    float worley2 = clamp(worleyFBMNoise(position, 3.0, 3.0), 0.0, 1.0);
    out_FragColor = vec4(worley0, worley1, worley2, 1.0);
}
`,CloudNoiseVS=`uniform vec3 u_noiseTextureDimensions;
in vec2 position;

out vec2 v_position;

void main()
{
    gl_Position = vec4(position, 0.1, 1.0);

    float textureSliceWidth = u_noiseTextureDimensions.x;
    float noiseTextureRows = u_noiseTextureDimensions.y;
    float inverseNoiseTextureRows = u_noiseTextureDimensions.z;
    vec2 transformedPos = (position * 0.5) + vec2(0.5);
    transformedPos *= textureSliceWidth;
    transformedPos.x *= textureSliceWidth * inverseNoiseTextureRows;
    transformedPos.y *= noiseTextureRows;
    v_position = transformedPos;
}
`,CompareAndPackTranslucentDepth=`uniform sampler2D u_opaqueDepthTexture;
uniform sampler2D u_translucentDepthTexture;

in vec2 v_textureCoordinates;

void main()
{
    float opaqueDepth = texture(u_opaqueDepthTexture, v_textureCoordinates).r;
    float translucentDepth = texture(u_translucentDepthTexture, v_textureCoordinates).r;
    translucentDepth = czm_branchFreeTernary(translucentDepth > opaqueDepth, 1.0, translucentDepth);
    out_FragColor = czm_packDepth(translucentDepth);
}
`,CompositeOITFS=`/**
 * Compositing for Weighted Blended Order-Independent Transparency. See:
 * - http://jcgt.org/published/0002/02/09/
 * - http://casual-effects.blogspot.com/2014/03/weighted-blended-order-independent.html
 */

uniform sampler2D u_opaque;
uniform sampler2D u_accumulation;
uniform sampler2D u_revealage;

in vec2 v_textureCoordinates;

void main()
{
    vec4 opaque = texture(u_opaque, v_textureCoordinates);
    vec4 accum = texture(u_accumulation, v_textureCoordinates);
    float r = texture(u_revealage, v_textureCoordinates).r;

#ifdef MRT
    vec4 transparent = vec4(accum.rgb / clamp(r, 1e-4, 5e4), accum.a);
#else
    vec4 transparent = vec4(accum.rgb / clamp(accum.a, 1e-4, 5e4), r);
#endif

    out_FragColor = (1.0 - transparent.a) * transparent + transparent.a * opaque;

    if (opaque != czm_backgroundColor)
    {
        out_FragColor.a = 1.0;
    }
}
`,DepthPlaneFS=`in vec4 positionEC;

void main()
{
    vec3 position;
    vec3 direction;
    if (czm_orthographicIn3D == 1.0)
    {
        vec2 uv = (gl_FragCoord.xy -  czm_viewport.xy) / czm_viewport.zw;
        vec2 minPlane = vec2(czm_frustumPlanes.z, czm_frustumPlanes.y); // left, bottom
        vec2 maxPlane = vec2(czm_frustumPlanes.w, czm_frustumPlanes.x); // right, top
        position = vec3(mix(minPlane, maxPlane, uv), 0.0);
        direction = vec3(0.0, 0.0, -1.0);
    } 
    else 
    {
        position = vec3(0.0);
        direction = normalize(positionEC.xyz);
    }

    czm_ray ray = czm_ray(position, direction);

    vec3 ellipsoid_center = czm_view[3].xyz;

    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);
    if (!czm_isEmpty(intersection))
    {
        out_FragColor = vec4(1.0, 1.0, 0.0, 1.0);
    }
    else
    {
        discard;
    }

    czm_writeLogDepth();
}
`,DepthPlaneVS=`in vec4 position;

out vec4 positionEC;

void main()
{
    positionEC = czm_modelView * position;
    gl_Position = czm_projection * positionEC;

    czm_vertexLogDepth();
}
`,EllipsoidFS=`uniform vec3 u_radii;
uniform vec3 u_oneOverEllipsoidRadiiSquared;

in vec3 v_positionEC;

vec4 computeEllipsoidColor(czm_ray ray, float intersection, float side)
{
    vec3 positionEC = czm_pointAlongRay(ray, intersection);
    vec3 positionMC = (czm_inverseModelView * vec4(positionEC, 1.0)).xyz;
    vec3 geodeticNormal = normalize(czm_geodeticSurfaceNormal(positionMC, vec3(0.0), u_oneOverEllipsoidRadiiSquared));
    vec3 sphericalNormal = normalize(positionMC / u_radii);
    vec3 normalMC = geodeticNormal * side;              // normalized surface normal (always facing the viewer) in model coordinates
    vec3 normalEC = normalize(czm_normal * normalMC);   // normalized surface normal in eye coordinates

    vec2 st = czm_ellipsoidTextureCoordinates(sphericalNormal);
    vec3 positionToEyeEC = -positionEC;

    czm_materialInput materialInput;
    materialInput.s = st.s;
    materialInput.st = st;
    materialInput.str = (positionMC + u_radii) / u_radii;
    materialInput.normalEC = normalEC;
    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(positionMC, normalEC);
    materialInput.positionToEyeEC = positionToEyeEC;
    czm_material material = czm_getMaterial(materialInput);

#ifdef ONLY_SUN_LIGHTING
    return czm_private_phong(normalize(positionToEyeEC), material, czm_sunDirectionEC);
#else
    return czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
#endif
}

void main()
{
    // PERFORMANCE_TODO: When dynamic branching is available, compute ratio of maximum and minimum radii
    // in the vertex shader. Only when it is larger than some constant, march along the ray.
    // Otherwise perform one intersection test which will be the common case.

    // Test if the ray intersects a sphere with the ellipsoid's maximum radius.
    // For very oblate ellipsoids, using the ellipsoid's radii for an intersection test
    // may cause false negatives. This will discard fragments before marching the ray forward.
    float maxRadius = max(u_radii.x, max(u_radii.y, u_radii.z)) * 1.5;
    vec3 direction = normalize(v_positionEC);
    vec3 ellipsoidCenter = czm_modelView[3].xyz;

    float t1 = -1.0;
    float t2 = -1.0;

    float b = -2.0 * dot(direction, ellipsoidCenter);
    float c = dot(ellipsoidCenter, ellipsoidCenter) - maxRadius * maxRadius;

    float discriminant = b * b - 4.0 * c;
    if (discriminant >= 0.0) {
        t1 = (-b - sqrt(discriminant)) * 0.5;
        t2 = (-b + sqrt(discriminant)) * 0.5;
    }

    if (t1 < 0.0 && t2 < 0.0) {
        discard;
    }

    float t = min(t1, t2);
    if (t < 0.0) {
        t = 0.0;
    }

    // March ray forward to intersection with larger sphere and find
    czm_ray ray = czm_ray(t * direction, direction);

    vec3 ellipsoid_inverseRadii = vec3(1.0 / u_radii.x, 1.0 / u_radii.y, 1.0 / u_radii.z);

    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoidCenter, ellipsoid_inverseRadii);

    if (czm_isEmpty(intersection))
    {
        discard;
    }

    // If the viewer is outside, compute outsideFaceColor, with normals facing outward.
    vec4 outsideFaceColor = (intersection.start != 0.0) ? computeEllipsoidColor(ray, intersection.start, 1.0) : vec4(0.0);

    // If the viewer either is inside or can see inside, compute insideFaceColor, with normals facing inward.
    vec4 insideFaceColor = (outsideFaceColor.a < 1.0) ? computeEllipsoidColor(ray, intersection.stop, -1.0) : vec4(0.0);

    out_FragColor = mix(insideFaceColor, outsideFaceColor, outsideFaceColor.a);
    out_FragColor.a = 1.0 - (1.0 - insideFaceColor.a) * (1.0 - outsideFaceColor.a);

#if (defined(WRITE_DEPTH) && (__VERSION__ == 300 || defined(GL_EXT_frag_depth)))
    t = (intersection.start != 0.0) ? intersection.start : intersection.stop;
    vec3 positionEC = czm_pointAlongRay(ray, t);
    vec4 positionCC = czm_projection * vec4(positionEC, 1.0);
#ifdef LOG_DEPTH
    czm_writeLogDepth(1.0 + positionCC.w);
#else
    float z = positionCC.z / positionCC.w;

    float n = czm_depthRange.near;
    float f = czm_depthRange.far;

    gl_FragDepth = (z * (f - n) + f + n) * 0.5;
#endif
#endif
}
`,EllipsoidVS=`in vec3 position;

uniform vec3 u_radii;

out vec3 v_positionEC;

void main()
{
    // In the vertex data, the cube goes from (-1.0, -1.0, -1.0) to (1.0, 1.0, 1.0) in model coordinates.
    // Scale to consider the radii.  We could also do this once on the CPU when using the BoxGeometry,
    // but doing it here allows us to change the radii without rewriting the vertex data, and
    // allows all ellipsoids to reuse the same vertex data.
    vec4 p = vec4(u_radii * position, 1.0);

    v_positionEC = (czm_modelView * p).xyz;     // position in eye coordinates
    gl_Position = czm_modelViewProjection * p;  // position in clip coordinates

    // With multi-frustum, when the ellipsoid primitive is positioned on the intersection of two frustums
    // and close to terrain, the terrain (writes depth) in the closest frustum can overwrite part of the
    // ellipsoid (does not write depth) that was rendered in the farther frustum.
    //
    // Here, we clamp the depth in the vertex shader to avoid being overwritten; however, this creates
    // artifacts since some fragments can be alpha blended twice.  This is solved by only rendering
    // the ellipsoid in the closest frustum to the viewer.
    gl_Position.z = clamp(gl_Position.z, czm_depthRange.near, czm_depthRange.far);

    czm_vertexLogDepth();
}
`;/**
 * @license
 * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */const FXAA3_11=`/**
 * @license
 * Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *  * Neither the name of NVIDIA CORPORATION nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS \`\`AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

// NVIDIA GameWorks Graphics Samples GitHub link: https://github.com/NVIDIAGameWorks/GraphicsSamples
// Original FXAA 3.11 shader link: https://github.com/NVIDIAGameWorks/GraphicsSamples/blob/master/samples/es3-kepler/FXAA/FXAA3_11.h

// Steps used to integrate into Cesium:
// * The following defines are set:
//       #define FXAA_PC 1
//       #define FXAA_WEBGL_1 1
//       #define FXAA_GREEN_AS_LUMA 1
//       #define FXAA_EARLY_EXIT 1
//       #define FXAA_GLSL_120 1
// * All other preprocessor directives besides the FXAA_QUALITY__P* directives were removed.
// * Double underscores are invalid for preprocessor directives so replace them with a single underscore. Replace
//   /FXAA_QUALITY__P(.*)/g with /FXAA_QUALITY__P$1/.
// * There are no implicit conversions from ivec* to vec* so replace:
//       #define FxaaInt2 ivec2
//           with
//       #define FxaaInt2 vec2
// * The texture2DLod function is only available in vertex shaders so replace:
//       #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)
//       #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)
//           with
//       #define FxaaTexTop(t, p) texture(t, p)
//       #define FxaaTexOff(t, p, o, r) texture(t, p + (o * r))
// * FXAA_QUALITY_PRESET is prepended in the javascript code. We may want to expose that setting in the future.
// * The following parameters to FxaaPixelShader are unused and can be removed:
//       fxaaConsolePosPos
//       fxaaConsoleRcpFrameOpt
//       fxaaConsoleRcpFrameOpt2
//       fxaaConsole360RcpFrameOpt2
//       fxaaConsoleEdgeSharpness
//       fxaaConsoleEdgeThreshold
//       fxaaConsoleEdgeThresholdMi
//       fxaaConsole360ConstDir

//
// Choose the quality preset.
// This needs to be compiled into the shader as it effects code.
// Best option to include multiple presets is to
// in each shader define the preset, then include this file.
//
// OPTIONS
// -----------------------------------------------------------------------
// 10 to 15 - default medium dither (10=fastest, 15=highest quality)
// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)
// 39       - no dither, very expensive
//
// NOTES
// -----------------------------------------------------------------------
// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)
// 13 = about same speed as FXAA 3.9 and better than 12
// 23 = closest to FXAA 3.9 visually and performance wise
//  _ = the lowest digit is directly related to performance
// _  = the highest digit is directly related to style
//
//#define FXAA_QUALITY_PRESET 12


#if (FXAA_QUALITY_PRESET == 10)
    #define FXAA_QUALITY_PS 3
    #define FXAA_QUALITY_P0 1.5
    #define FXAA_QUALITY_P1 3.0
    #define FXAA_QUALITY_P2 12.0
#endif
#if (FXAA_QUALITY_PRESET == 11)
    #define FXAA_QUALITY_PS 4
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 3.0
    #define FXAA_QUALITY_P3 12.0
#endif
#if (FXAA_QUALITY_PRESET == 12)
    #define FXAA_QUALITY_PS 5
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 4.0
    #define FXAA_QUALITY_P4 12.0
#endif
#if (FXAA_QUALITY_PRESET == 13)
    #define FXAA_QUALITY_PS 6
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 4.0
    #define FXAA_QUALITY_P5 12.0
#endif
#if (FXAA_QUALITY_PRESET == 14)
    #define FXAA_QUALITY_PS 7
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 4.0
    #define FXAA_QUALITY_P6 12.0
#endif
#if (FXAA_QUALITY_PRESET == 15)
    #define FXAA_QUALITY_PS 8
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 4.0
    #define FXAA_QUALITY_P7 12.0
#endif
#if (FXAA_QUALITY_PRESET == 20)
    #define FXAA_QUALITY_PS 3
    #define FXAA_QUALITY_P0 1.5
    #define FXAA_QUALITY_P1 2.0
    #define FXAA_QUALITY_P2 8.0
#endif
#if (FXAA_QUALITY_PRESET == 21)
    #define FXAA_QUALITY_PS 4
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 8.0
#endif
#if (FXAA_QUALITY_PRESET == 22)
    #define FXAA_QUALITY_PS 5
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 8.0
#endif
#if (FXAA_QUALITY_PRESET == 23)
    #define FXAA_QUALITY_PS 6
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 8.0
#endif
#if (FXAA_QUALITY_PRESET == 24)
    #define FXAA_QUALITY_PS 7
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 3.0
    #define FXAA_QUALITY_P6 8.0
#endif
#if (FXAA_QUALITY_PRESET == 25)
    #define FXAA_QUALITY_PS 8
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 4.0
    #define FXAA_QUALITY_P7 8.0
#endif
#if (FXAA_QUALITY_PRESET == 26)
    #define FXAA_QUALITY_PS 9
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 4.0
    #define FXAA_QUALITY_P8 8.0
#endif
#if (FXAA_QUALITY_PRESET == 27)
    #define FXAA_QUALITY_PS 10
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 4.0
    #define FXAA_QUALITY_P9 8.0
#endif
#if (FXAA_QUALITY_PRESET == 28)
    #define FXAA_QUALITY_PS 11
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 4.0
    #define FXAA_QUALITY_P10 8.0
#endif
#if (FXAA_QUALITY_PRESET == 29)
    #define FXAA_QUALITY_PS 12
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.5
    #define FXAA_QUALITY_P2 2.0
    #define FXAA_QUALITY_P3 2.0
    #define FXAA_QUALITY_P4 2.0
    #define FXAA_QUALITY_P5 2.0
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 2.0
    #define FXAA_QUALITY_P10 4.0
    #define FXAA_QUALITY_P11 8.0
#endif
#if (FXAA_QUALITY_PRESET == 39)
    #define FXAA_QUALITY_PS 12
    #define FXAA_QUALITY_P0 1.0
    #define FXAA_QUALITY_P1 1.0
    #define FXAA_QUALITY_P2 1.0
    #define FXAA_QUALITY_P3 1.0
    #define FXAA_QUALITY_P4 1.0
    #define FXAA_QUALITY_P5 1.5
    #define FXAA_QUALITY_P6 2.0
    #define FXAA_QUALITY_P7 2.0
    #define FXAA_QUALITY_P8 2.0
    #define FXAA_QUALITY_P9 2.0
    #define FXAA_QUALITY_P10 4.0
    #define FXAA_QUALITY_P11 8.0
#endif

#define FxaaBool bool
#define FxaaFloat float
#define FxaaFloat2 vec2
#define FxaaFloat3 vec3
#define FxaaFloat4 vec4
#define FxaaHalf float
#define FxaaHalf2 vec2
#define FxaaHalf3 vec3
#define FxaaHalf4 vec4
#define FxaaInt2 vec2
#define FxaaTex sampler2D

#define FxaaSat(x) clamp(x, 0.0, 1.0)
#define FxaaTexTop(t, p) texture(t, p)
#define FxaaTexOff(t, p, o, r) texture(t, p + (o * r))

FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }

FxaaFloat4 FxaaPixelShader(
    //
    // Use noperspective interpolation here (turn off perspective interpolation).
    // {xy} = center of pixel
    FxaaFloat2 pos,
    //
    // Input color texture.
    // {rgb_} = color in linear or perceptual color space
    // if (FXAA_GREEN_AS_LUMA == 0)
    //     {___a} = luma in perceptual color space (not linear)
    FxaaTex tex,
    //
    // Only used on FXAA Quality.
    // This must be from a constant/uniform.
    // {x_} = 1.0/screenWidthInPixels
    // {_y} = 1.0/screenHeightInPixels
    FxaaFloat2 fxaaQualityRcpFrame,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY_SUBPIX define.
    // It is here now to allow easier tuning.
    // Choose the amount of sub-pixel aliasing removal.
    // This can effect sharpness.
    //   1.00 - upper limit (softer)
    //   0.75 - default amount of filtering
    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)
    //   0.25 - almost off
    //   0.00 - completely off
    FxaaFloat fxaaQualitySubpix,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.
    // It is here now to allow easier tuning.
    // The minimum amount of local contrast required to apply algorithm.
    //   0.333 - too little (faster)
    //   0.250 - low quality
    //   0.166 - default
    //   0.125 - high quality
    //   0.063 - overkill (slower)
    FxaaFloat fxaaQualityEdgeThreshold,
    //
    // Only used on FXAA Quality.
    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.
    // It is here now to allow easier tuning.
    // Trims the algorithm from processing darks.
    //   0.0833 - upper limit (default, the start of visible unfiltered edges)
    //   0.0625 - high quality (faster)
    //   0.0312 - visible limit (slower)
    // Special notes when using FXAA_GREEN_AS_LUMA,
    //   Likely want to set this to zero.
    //   As colors that are mostly not-green
    //   will appear very dark in the green channel!
    //   Tune by looking at mostly non-green content,
    //   then start at zero and increase until aliasing is a problem.
    FxaaFloat fxaaQualityEdgeThresholdMin
) {
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posM;
    posM.x = pos.x;
    posM.y = pos.y;
    FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
    #define lumaM rgbyM.y
    FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
/*--------------------------------------------------------------------------*/
    FxaaFloat maxSM = max(lumaS, lumaM);
    FxaaFloat minSM = min(lumaS, lumaM);
    FxaaFloat maxESM = max(lumaE, maxSM);
    FxaaFloat minESM = min(lumaE, minSM);
    FxaaFloat maxWN = max(lumaN, lumaW);
    FxaaFloat minWN = min(lumaN, lumaW);
    FxaaFloat rangeMax = max(maxWN, maxESM);
    FxaaFloat rangeMin = min(minWN, minESM);
    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
    FxaaFloat range = rangeMax - rangeMin;
    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
    FxaaBool earlyExit = range < rangeMaxClamped;
/*--------------------------------------------------------------------------*/
    if(earlyExit)
        return rgbyM;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));
    FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNS = lumaN + lumaS;
    FxaaFloat lumaWE = lumaW + lumaE;
    FxaaFloat subpixRcpRange = 1.0/range;
    FxaaFloat subpixNSWE = lumaNS + lumaWE;
    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNESE = lumaNE + lumaSE;
    FxaaFloat lumaNWNE = lumaNW + lumaNE;
    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
/*--------------------------------------------------------------------------*/
    FxaaFloat lumaNWSW = lumaNW + lumaSW;
    FxaaFloat lumaSWSE = lumaSW + lumaSE;
    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
/*--------------------------------------------------------------------------*/
    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
    FxaaBool horzSpan = edgeHorz >= edgeVert;
    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
/*--------------------------------------------------------------------------*/
    if(!horzSpan) lumaN = lumaW;
    if(!horzSpan) lumaS = lumaE;
    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
/*--------------------------------------------------------------------------*/
    FxaaFloat gradientN = lumaN - lumaM;
    FxaaFloat gradientS = lumaS - lumaM;
    FxaaFloat lumaNN = lumaN + lumaM;
    FxaaFloat lumaSS = lumaS + lumaM;
    FxaaBool pairN = abs(gradientN) >= abs(gradientS);
    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
    if(pairN) lengthSign = -lengthSign;
    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posB;
    posB.x = posM.x;
    posB.y = posM.y;
    FxaaFloat2 offNP;
    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
    if(!horzSpan) posB.x += lengthSign * 0.5;
    if( horzSpan) posB.y += lengthSign * 0.5;
/*--------------------------------------------------------------------------*/
    FxaaFloat2 posN;
    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
    FxaaFloat2 posP;
    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));
    FxaaFloat subpixE = subpixC * subpixC;
    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));
/*--------------------------------------------------------------------------*/
    if(!pairN) lumaNN = lumaSS;
    FxaaFloat gradientScaled = gradient * 1.0/4.0;
    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
    FxaaFloat subpixF = subpixD * subpixE;
    FxaaBool lumaMLTZero = lumaMM < 0.0;
/*--------------------------------------------------------------------------*/
    lumaEndN -= lumaNN * 0.5;
    lumaEndP -= lumaNN * 0.5;
    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
    FxaaBool doneNP = (!doneN) || (!doneP);
    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;
/*--------------------------------------------------------------------------*/
    if(doneNP) {
        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
        doneNP = (!doneN) || (!doneP);
        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;
/*--------------------------------------------------------------------------*/
        #if (FXAA_QUALITY_PS > 3)
        if(doneNP) {
            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
            doneNP = (!doneN) || (!doneP);
            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;
/*--------------------------------------------------------------------------*/
            #if (FXAA_QUALITY_PS > 4)
            if(doneNP) {
                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
                doneNP = (!doneN) || (!doneP);
                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
/*--------------------------------------------------------------------------*/
                #if (FXAA_QUALITY_PS > 5)
                if(doneNP) {
                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
                    doneNP = (!doneN) || (!doneP);
                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
/*--------------------------------------------------------------------------*/
                    #if (FXAA_QUALITY_PS > 6)
                    if(doneNP) {
                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
                        doneNP = (!doneN) || (!doneP);
                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
/*--------------------------------------------------------------------------*/
                        #if (FXAA_QUALITY_PS > 7)
                        if(doneNP) {
                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                            doneN = abs(lumaEndN) >= gradientScaled;
                            doneP = abs(lumaEndP) >= gradientScaled;
                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
                            doneNP = (!doneN) || (!doneP);
                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;
/*--------------------------------------------------------------------------*/
    #if (FXAA_QUALITY_PS > 8)
    if(doneNP) {
        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
        doneN = abs(lumaEndN) >= gradientScaled;
        doneP = abs(lumaEndP) >= gradientScaled;
        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
        doneNP = (!doneN) || (!doneP);
        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
/*--------------------------------------------------------------------------*/
        #if (FXAA_QUALITY_PS > 9)
        if(doneNP) {
            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
            doneN = abs(lumaEndN) >= gradientScaled;
            doneP = abs(lumaEndP) >= gradientScaled;
            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
            doneNP = (!doneN) || (!doneP);
            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
/*--------------------------------------------------------------------------*/
            #if (FXAA_QUALITY_PS > 10)
            if(doneNP) {
                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                doneN = abs(lumaEndN) >= gradientScaled;
                doneP = abs(lumaEndP) >= gradientScaled;
                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
                doneNP = (!doneN) || (!doneP);
                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
/*--------------------------------------------------------------------------*/
                #if (FXAA_QUALITY_PS > 11)
                if(doneNP) {
                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                    doneN = abs(lumaEndN) >= gradientScaled;
                    doneP = abs(lumaEndP) >= gradientScaled;
                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
                    doneNP = (!doneN) || (!doneP);
                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
/*--------------------------------------------------------------------------*/
                    #if (FXAA_QUALITY_PS > 12)
                    if(doneNP) {
                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
                        doneN = abs(lumaEndN) >= gradientScaled;
                        doneP = abs(lumaEndP) >= gradientScaled;
                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
                        doneNP = (!doneN) || (!doneP);
                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
/*--------------------------------------------------------------------------*/
                    }
                    #endif
/*--------------------------------------------------------------------------*/
                }
                #endif
/*--------------------------------------------------------------------------*/
            }
            #endif
/*--------------------------------------------------------------------------*/
        }
        #endif
/*--------------------------------------------------------------------------*/
    }
    #endif
/*--------------------------------------------------------------------------*/
                        }
                        #endif
/*--------------------------------------------------------------------------*/
                    }
                    #endif
/*--------------------------------------------------------------------------*/
                }
                #endif
/*--------------------------------------------------------------------------*/
            }
            #endif
/*--------------------------------------------------------------------------*/
        }
        #endif
/*--------------------------------------------------------------------------*/
    }
/*--------------------------------------------------------------------------*/
    FxaaFloat dstN = posM.x - posN.x;
    FxaaFloat dstP = posP.x - posM.x;
    if(!horzSpan) dstN = posM.y - posN.y;
    if(!horzSpan) dstP = posP.y - posM.y;
/*--------------------------------------------------------------------------*/
    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
    FxaaFloat spanLength = (dstP + dstN);
    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
    FxaaFloat spanLengthRcp = 1.0/spanLength;
/*--------------------------------------------------------------------------*/
    FxaaBool directionN = dstN < dstP;
    FxaaFloat dst = min(dstN, dstP);
    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
    FxaaFloat subpixG = subpixF * subpixF;
    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
/*--------------------------------------------------------------------------*/
    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
    return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);
}
`,GlobeFS=`uniform vec4 u_initialColor;

#if TEXTURE_UNITS > 0
uniform sampler2D u_dayTextures[TEXTURE_UNITS];
uniform vec4 u_dayTextureTranslationAndScale[TEXTURE_UNITS];
uniform bool u_dayTextureUseWebMercatorT[TEXTURE_UNITS];

#ifdef APPLY_ALPHA
uniform float u_dayTextureAlpha[TEXTURE_UNITS];
#endif

#ifdef APPLY_DAY_NIGHT_ALPHA
uniform float u_dayTextureNightAlpha[TEXTURE_UNITS];
uniform float u_dayTextureDayAlpha[TEXTURE_UNITS];
#endif

#ifdef APPLY_SPLIT
uniform float u_dayTextureSplit[TEXTURE_UNITS];
#endif

#ifdef APPLY_BRIGHTNESS
uniform float u_dayTextureBrightness[TEXTURE_UNITS];
#endif

#ifdef APPLY_CONTRAST
uniform float u_dayTextureContrast[TEXTURE_UNITS];
#endif

#ifdef APPLY_HUE
uniform float u_dayTextureHue[TEXTURE_UNITS];
#endif

#ifdef APPLY_SATURATION
uniform float u_dayTextureSaturation[TEXTURE_UNITS];
#endif

#ifdef APPLY_GAMMA
uniform float u_dayTextureOneOverGamma[TEXTURE_UNITS];
#endif

#ifdef APPLY_IMAGERY_CUTOUT
uniform vec4 u_dayTextureCutoutRectangles[TEXTURE_UNITS];
#endif

#ifdef APPLY_COLOR_TO_ALPHA
uniform vec4 u_colorsToAlpha[TEXTURE_UNITS];
#endif

uniform vec4 u_dayTextureTexCoordsRectangle[TEXTURE_UNITS];
#endif

#ifdef SHOW_REFLECTIVE_OCEAN
uniform sampler2D u_waterMask;
uniform vec4 u_waterMaskTranslationAndScale;
uniform float u_zoomedOutOceanSpecularIntensity;
#endif

#ifdef SHOW_OCEAN_WAVES
uniform sampler2D u_oceanNormalMap;
#endif

#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)
uniform vec2 u_lightingFadeDistance;
#endif

#ifdef TILE_LIMIT_RECTANGLE
uniform vec4 u_cartographicLimitRectangle;
#endif

#ifdef GROUND_ATMOSPHERE
uniform vec2 u_nightFadeDistance;
#endif

#ifdef ENABLE_CLIPPING_PLANES
uniform highp sampler2D u_clippingPlanes;
uniform mat4 u_clippingPlanesMatrix;
uniform vec4 u_clippingPlanesEdgeStyle;
#endif

#ifdef ENABLE_CLIPPING_POLYGONS
uniform highp sampler2D u_clippingDistance;
in vec2 v_clippingPosition;
flat in int v_regionIndex;
#endif

#if defined(GROUND_ATMOSPHERE) || defined(FOG) && defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))
uniform float u_minimumBrightness;
#endif

#ifdef COLOR_CORRECT
uniform vec3 u_hsbShift; // Hue, saturation, brightness
#endif

#ifdef HIGHLIGHT_FILL_TILE
uniform vec4 u_fillHighlightColor;
#endif

#ifdef TRANSLUCENT
uniform vec4 u_frontFaceAlphaByDistance;
uniform vec4 u_backFaceAlphaByDistance;
uniform vec4 u_translucencyRectangle;
#endif

#ifdef UNDERGROUND_COLOR
uniform vec4 u_undergroundColor;
uniform vec4 u_undergroundColorAlphaByDistance;
#endif

#ifdef ENABLE_VERTEX_LIGHTING
uniform float u_lambertDiffuseMultiplier;
uniform float u_vertexShadowDarkness;
#endif

in vec3 v_positionMC;
in vec3 v_positionEC;
in vec3 v_textureCoordinates;
in vec3 v_normalMC;
in vec3 v_normalEC;

#ifdef APPLY_MATERIAL
in float v_height;
in float v_slope;
in float v_aspect;
#endif

#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
in float v_distance;
#endif

#if defined(GROUND_ATMOSPHERE) || defined(FOG)
in vec3 v_atmosphereRayleighColor;
in vec3 v_atmosphereMieColor;
in float v_atmosphereOpacity;
#endif

#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
float interpolateByDistance(vec4 nearFarScalar, float distance)
{
    float startDistance = nearFarScalar.x;
    float startValue = nearFarScalar.y;
    float endDistance = nearFarScalar.z;
    float endValue = nearFarScalar.w;
    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);
    return mix(startValue, endValue, t);
}
#endif

#if defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT) || defined(APPLY_MATERIAL)
vec4 alphaBlend(vec4 sourceColor, vec4 destinationColor)
{
    return sourceColor * vec4(sourceColor.aaa, 1.0) + destinationColor * (1.0 - sourceColor.a);
}
#endif

#ifdef TRANSLUCENT
bool inTranslucencyRectangle()
{
    return
        v_textureCoordinates.x > u_translucencyRectangle.x &&
        v_textureCoordinates.x < u_translucencyRectangle.z &&
        v_textureCoordinates.y > u_translucencyRectangle.y &&
        v_textureCoordinates.y < u_translucencyRectangle.w;
}
#endif

vec4 sampleAndBlend(
    vec4 previousColor,
    sampler2D textureToSample,
    vec2 tileTextureCoordinates,
    vec4 textureCoordinateRectangle,
    vec4 textureCoordinateTranslationAndScale,
    float textureAlpha,
    float textureNightAlpha,
    float textureDayAlpha,
    float textureBrightness,
    float textureContrast,
    float textureHue,
    float textureSaturation,
    float textureOneOverGamma,
    float split,
    vec4 colorToAlpha,
    float nightBlend)
{
    // This crazy step stuff sets the alpha to 0.0 if this following condition is true:
    //    tileTextureCoordinates.s < textureCoordinateRectangle.s ||
    //    tileTextureCoordinates.s > textureCoordinateRectangle.p ||
    //    tileTextureCoordinates.t < textureCoordinateRectangle.t ||
    //    tileTextureCoordinates.t > textureCoordinateRectangle.q
    // In other words, the alpha is zero if the fragment is outside the rectangle
    // covered by this texture.  Would an actual 'if' yield better performance?
    vec2 alphaMultiplier = step(textureCoordinateRectangle.st, tileTextureCoordinates);
    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

    alphaMultiplier = step(vec2(0.0), textureCoordinateRectangle.pq - tileTextureCoordinates);
    textureAlpha = textureAlpha * alphaMultiplier.x * alphaMultiplier.y;

#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)
    textureAlpha *= mix(textureDayAlpha, textureNightAlpha, nightBlend);
#endif

    vec2 translation = textureCoordinateTranslationAndScale.xy;
    vec2 scale = textureCoordinateTranslationAndScale.zw;
    vec2 textureCoordinates = tileTextureCoordinates * scale + translation;
    vec4 value = texture(textureToSample, textureCoordinates);
    vec3 color = value.rgb;
    float alpha = value.a;

#ifdef APPLY_COLOR_TO_ALPHA
    vec3 colorDiff = abs(color.rgb - colorToAlpha.rgb);
    colorDiff.r = czm_maximumComponent(colorDiff);
    alpha = czm_branchFreeTernary(colorDiff.r < colorToAlpha.a, 0.0, alpha);
#endif

#if !defined(APPLY_GAMMA)
    vec4 tempColor = czm_gammaCorrect(vec4(color, alpha));
    color = tempColor.rgb;
    alpha = tempColor.a;
#else
    color = pow(color, vec3(textureOneOverGamma));
#endif

#ifdef APPLY_SPLIT
    float splitPosition = czm_splitPosition;
    // Split to the left
    if (split < 0.0 && gl_FragCoord.x > splitPosition) {
       alpha = 0.0;
    }
    // Split to the right
    else if (split > 0.0 && gl_FragCoord.x < splitPosition) {
       alpha = 0.0;
    }
#endif

#ifdef APPLY_BRIGHTNESS
    color = mix(vec3(0.0), color, textureBrightness);
#endif

#ifdef APPLY_CONTRAST
    color = mix(vec3(0.5), color, textureContrast);
#endif

#ifdef APPLY_HUE
    color = czm_hue(color, textureHue);
#endif

#ifdef APPLY_SATURATION
    color = czm_saturation(color, textureSaturation);
#endif

    float sourceAlpha = alpha * textureAlpha;
    float outAlpha = mix(previousColor.a, 1.0, sourceAlpha);
    outAlpha += sign(outAlpha) - 1.0;

    vec3 outColor = mix(previousColor.rgb * previousColor.a, color, sourceAlpha) / outAlpha;

    // When rendering imagery for a tile in multiple passes,
    // some GPU/WebGL implementation combinations will not blend fragments in
    // additional passes correctly if their computation includes an unmasked
    // divide-by-zero operation,
    // even if it's not in the output or if the output has alpha zero.
    //
    // For example, without sanitization for outAlpha,
    // this renders without artifacts:
    //   if (outAlpha == 0.0) { outColor = vec3(0.0); }
    //
    // but using czm_branchFreeTernary will cause portions of the tile that are
    // alpha-zero in the additional pass to render as black instead of blending
    // with the previous pass:
    //   outColor = czm_branchFreeTernary(outAlpha == 0.0, vec3(0.0), outColor);
    //
    // So instead, sanitize against divide-by-zero,
    // store this state on the sign of outAlpha, and correct on return.

    return vec4(outColor, max(outAlpha, 0.0));
}

vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend);
vec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float specularMapValue, float fade);

const float fExposure = 2.0;

vec3 computeEllipsoidPosition()
{
    float mpp = czm_metersPerPixel(vec4(0.0, 0.0, -czm_currentFrustum.x, 1.0), 1.0);
    vec2 xy = gl_FragCoord.xy / czm_viewport.zw * 2.0 - vec2(1.0);
    xy *= czm_viewport.zw * mpp * 0.5;

    vec3 direction = normalize(vec3(xy, -czm_currentFrustum.x));
    czm_ray ray = czm_ray(vec3(0.0), direction);

    vec3 ellipsoid_center = czm_view[3].xyz;

    czm_raySegment intersection = czm_rayEllipsoidIntersectionInterval(ray, ellipsoid_center, czm_ellipsoidInverseRadii);

    vec3 ellipsoidPosition = czm_pointAlongRay(ray, intersection.start);
    return (czm_inverseView * vec4(ellipsoidPosition, 1.0)).xyz;
}

void main()
{
#ifdef TILE_LIMIT_RECTANGLE
    if (v_textureCoordinates.x < u_cartographicLimitRectangle.x || u_cartographicLimitRectangle.z < v_textureCoordinates.x ||
        v_textureCoordinates.y < u_cartographicLimitRectangle.y || u_cartographicLimitRectangle.w < v_textureCoordinates.y)
        {
            discard;
        }
#endif

#ifdef ENABLE_CLIPPING_PLANES
    float clipDistance = clip(gl_FragCoord, u_clippingPlanes, u_clippingPlanesMatrix);
#endif

#if defined(SHOW_REFLECTIVE_OCEAN) || defined(ENABLE_DAYNIGHT_SHADING) || defined(HDR)
    vec3 normalMC = czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0));   // normalized surface normal in model coordinates
    vec3 normalEC = czm_normal3D * normalMC;                                         // normalized surface normal in eye coordinates
#endif

#if defined(APPLY_DAY_NIGHT_ALPHA) && defined(ENABLE_DAYNIGHT_SHADING)
    float nightBlend = 1.0 - clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0, 0.0, 1.0);
#else
    float nightBlend = 0.0;
#endif

    // The clamp below works around an apparent bug in Chrome Canary v23.0.1241.0
    // where the fragment shader sees textures coordinates < 0.0 and > 1.0 for the
    // fragments on the edges of tiles even though the vertex shader is outputting
    // coordinates strictly in the 0-1 range.
    vec4 color = computeDayColor(u_initialColor, clamp(v_textureCoordinates, 0.0, 1.0), nightBlend);

#ifdef SHOW_TILE_BOUNDARIES
    if (v_textureCoordinates.x < (1.0/256.0) || v_textureCoordinates.x > (255.0/256.0) ||
        v_textureCoordinates.y < (1.0/256.0) || v_textureCoordinates.y > (255.0/256.0))
    {
        color = vec4(1.0, 0.0, 0.0, 1.0);
    }
#endif

#if defined(ENABLE_DAYNIGHT_SHADING) || defined(GROUND_ATMOSPHERE)
    float cameraDist;
    if (czm_sceneMode == czm_sceneMode2D)
    {
        cameraDist = max(czm_frustumPlanes.x - czm_frustumPlanes.y, czm_frustumPlanes.w - czm_frustumPlanes.z) * 0.5;
    }
    else if (czm_sceneMode == czm_sceneModeColumbusView)
    {
        cameraDist = -czm_view[3].z;
    }
    else
    {
        cameraDist = length(czm_view[3]);
    }
    float fadeOutDist = u_lightingFadeDistance.x;
    float fadeInDist = u_lightingFadeDistance.y;
    if (czm_sceneMode != czm_sceneMode3D) {
        vec3 radii = czm_ellipsoidRadii;
        float maxRadii = max(radii.x, max(radii.y, radii.z));
        fadeOutDist -= maxRadii;
        fadeInDist -= maxRadii;
    }
    float fade = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.0, 1.0);
#else
    float fade = 0.0;
#endif

#ifdef SHOW_REFLECTIVE_OCEAN
    vec2 waterMaskTranslation = u_waterMaskTranslationAndScale.xy;
    vec2 waterMaskScale = u_waterMaskTranslationAndScale.zw;
    vec2 waterMaskTextureCoordinates = v_textureCoordinates.xy * waterMaskScale + waterMaskTranslation;
    waterMaskTextureCoordinates.y = 1.0 - waterMaskTextureCoordinates.y;

    float mask = texture(u_waterMask, waterMaskTextureCoordinates).r;

    if (mask > 0.0)
    {
        mat3 enuToEye = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalEC);

        vec2 ellipsoidTextureCoordinates = czm_ellipsoidTextureCoordinates(normalMC);
        vec2 ellipsoidFlippedTextureCoordinates = czm_ellipsoidTextureCoordinates(normalMC.zyx);

        vec2 textureCoordinates = mix(ellipsoidTextureCoordinates, ellipsoidFlippedTextureCoordinates, czm_morphTime * smoothstep(0.9, 0.95, normalMC.z));

        color = computeWaterColor(v_positionEC, textureCoordinates, enuToEye, color, mask, fade);
    }
#endif

#ifdef APPLY_MATERIAL
    czm_materialInput materialInput;
    materialInput.st = v_textureCoordinates.st;
    materialInput.normalEC = normalize(v_normalEC);
    materialInput.positionToEyeEC = -v_positionEC;
    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, normalize(v_normalEC));
    materialInput.slope = v_slope;
    materialInput.height = v_height;
    materialInput.aspect = v_aspect;
    czm_material material = czm_getMaterial(materialInput);
    vec4 materialColor = vec4(material.diffuse, material.alpha);
    color = alphaBlend(materialColor, color);
#endif

#ifdef ENABLE_VERTEX_LIGHTING
    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalize(v_normalEC)) * u_lambertDiffuseMultiplier + u_vertexShadowDarkness, 0.0, 1.0);
    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);
#elif defined(ENABLE_DAYNIGHT_SHADING)
    float diffuseIntensity = clamp(czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * 5.0 + 0.3, 0.0, 1.0);
    diffuseIntensity = mix(1.0, diffuseIntensity, fade);
    vec4 finalColor = vec4(color.rgb * czm_lightColor * diffuseIntensity, color.a);
#else
    vec4 finalColor = color;
#endif

#ifdef ENABLE_CLIPPING_PLANES
    vec4 clippingPlanesEdgeColor = vec4(1.0);
    clippingPlanesEdgeColor.rgb = u_clippingPlanesEdgeStyle.rgb;
    float clippingPlanesEdgeWidth = u_clippingPlanesEdgeStyle.a;

    if (clipDistance < clippingPlanesEdgeWidth)
    {
        finalColor = clippingPlanesEdgeColor;
    }
#endif

#ifdef ENABLE_CLIPPING_POLYGONS
    vec2 clippingPosition = v_clippingPosition;
    int regionIndex = v_regionIndex;
    clipPolygons(u_clippingDistance, CLIPPING_POLYGON_REGIONS_LENGTH, clippingPosition, regionIndex);    
#endif

#ifdef HIGHLIGHT_FILL_TILE
    finalColor = vec4(mix(finalColor.rgb, u_fillHighlightColor.rgb, u_fillHighlightColor.a), finalColor.a);
#endif

#if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN)
    vec3 atmosphereLightDirection = czm_sunDirectionWC;
#else
    vec3 atmosphereLightDirection = czm_lightDirectionWC;
#endif

#if defined(GROUND_ATMOSPHERE) || defined(FOG)
    if (!czm_backFacing())
    {
        bool dynamicLighting = false;
        #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING))
            dynamicLighting = true;
        #endif

        vec3 rayleighColor;
        vec3 mieColor;
        float opacity;

        vec3 positionWC;
        vec3 lightDirection;

        // When the camera is far away (camera distance > nightFadeOutDistance), the scattering is computed in the fragment shader.
        // Otherwise, the scattering is computed in the vertex shader.
        #ifdef PER_FRAGMENT_GROUND_ATMOSPHERE
            positionWC = computeEllipsoidPosition();
            lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(positionWC));
            computeAtmosphereScattering(
                positionWC,
                lightDirection,
                rayleighColor,
                mieColor,
                opacity
            );
        #else
            positionWC = v_positionMC;
            lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(positionWC));
            rayleighColor = v_atmosphereRayleighColor;
            mieColor = v_atmosphereMieColor;
            opacity = v_atmosphereOpacity;
        #endif

        #ifdef COLOR_CORRECT
            const bool ignoreBlackPixels = true;
            rayleighColor = czm_applyHSBShift(rayleighColor, u_hsbShift, ignoreBlackPixels);
            mieColor = czm_applyHSBShift(mieColor, u_hsbShift, ignoreBlackPixels);
        #endif

        vec4 groundAtmosphereColor = computeAtmosphereColor(positionWC, lightDirection, rayleighColor, mieColor, opacity);

        // Fog is applied to tiles selected for fog, close to the Earth.
        #ifdef FOG
            vec3 fogColor = groundAtmosphereColor.rgb;

            // If there is lighting, apply that to the fog.
            #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))
                float darken = clamp(dot(normalize(czm_viewerPositionWC), atmosphereLightDirection), u_minimumBrightness, 1.0);
                fogColor *= darken;
            #endif

            #ifndef HDR
                fogColor.rgb = czm_acesTonemapping(fogColor.rgb);
                fogColor.rgb = czm_inverseGamma(fogColor.rgb);
            #endif

            const float modifier = 0.15;
            finalColor = vec4(czm_fog(v_distance, finalColor.rgb, fogColor.rgb, modifier), finalColor.a);

        #else
            // Apply ground atmosphere. This happens when the camera is far away from the earth.

            // The transmittance is based on optical depth i.e. the length of segment of the ray inside the atmosphere.
            // This value is larger near the "circumference", as it is further away from the camera. We use it to
            // brighten up that area of the ground atmosphere.
            const float transmittanceModifier = 0.5;
            float transmittance = transmittanceModifier + clamp(1.0 - groundAtmosphereColor.a, 0.0, 1.0);

            vec3 finalAtmosphereColor = finalColor.rgb + groundAtmosphereColor.rgb * transmittance;

            #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_VERTEX_LIGHTING) || defined(ENABLE_DAYNIGHT_SHADING))
                float fadeInDist = u_nightFadeDistance.x;
                float fadeOutDist = u_nightFadeDistance.y;

                float sunlitAtmosphereIntensity = clamp((cameraDist - fadeOutDist) / (fadeInDist - fadeOutDist), 0.05, 1.0);
                float darken = clamp(dot(normalize(positionWC), atmosphereLightDirection), 0.0, 1.0);
                vec3 darkenendGroundAtmosphereColor = mix(groundAtmosphereColor.rgb, finalAtmosphereColor.rgb, darken);

                finalAtmosphereColor = mix(darkenendGroundAtmosphereColor, finalAtmosphereColor, sunlitAtmosphereIntensity);
            #endif

            #ifndef HDR
                finalAtmosphereColor.rgb = vec3(1.0) - exp(-fExposure * finalAtmosphereColor.rgb);
            #else
                finalAtmosphereColor.rgb = czm_saturation(finalAtmosphereColor.rgb, 1.6);
            #endif

            finalColor.rgb = mix(finalColor.rgb, finalAtmosphereColor.rgb, fade);
        #endif
    }
#endif

#ifdef UNDERGROUND_COLOR
    if (czm_backFacing())
    {
        float distanceFromEllipsoid = max(czm_eyeHeight, 0.0);
        float distance = max(v_distance - distanceFromEllipsoid, 0.0);
        float blendAmount = interpolateByDistance(u_undergroundColorAlphaByDistance, distance);
        vec4 undergroundColor = vec4(u_undergroundColor.rgb, u_undergroundColor.a * blendAmount);
        finalColor = alphaBlend(undergroundColor, finalColor);
    }
#endif

#ifdef TRANSLUCENT
    if (inTranslucencyRectangle())
    {
      vec4 alphaByDistance = gl_FrontFacing ? u_frontFaceAlphaByDistance : u_backFaceAlphaByDistance;
      finalColor.a *= interpolateByDistance(alphaByDistance, v_distance);
    }
#endif

    out_FragColor =  finalColor;
}


#ifdef SHOW_REFLECTIVE_OCEAN

float waveFade(float edge0, float edge1, float x)
{
    float y = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return pow(1.0 - y, 5.0);
}

float linearFade(float edge0, float edge1, float x)
{
    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
}

// Based on water rendering by Jonas Wagner:
// http://29a.ch/2012/7/19/webgl-terrain-rendering-water-fog

// low altitude wave settings
const float oceanFrequencyLowAltitude = 825000.0;
const float oceanAnimationSpeedLowAltitude = 0.004;
const float oceanOneOverAmplitudeLowAltitude = 1.0 / 2.0;
const float oceanSpecularIntensity = 0.5;

// high altitude wave settings
const float oceanFrequencyHighAltitude = 125000.0;
const float oceanAnimationSpeedHighAltitude = 0.008;
const float oceanOneOverAmplitudeHighAltitude = 1.0 / 2.0;

vec4 computeWaterColor(vec3 positionEyeCoordinates, vec2 textureCoordinates, mat3 enuToEye, vec4 imageryColor, float maskValue, float fade)
{
    vec3 positionToEyeEC = -positionEyeCoordinates;
    float positionToEyeECLength = length(positionToEyeEC);

    // The double normalize below works around a bug in Firefox on Android devices.
    vec3 normalizedPositionToEyeEC = normalize(normalize(positionToEyeEC));

    // Fade out the waves as the camera moves far from the surface.
    float waveIntensity = waveFade(70000.0, 1000000.0, positionToEyeECLength);

#ifdef SHOW_OCEAN_WAVES
    // high altitude waves
    float time = czm_frameNumber * oceanAnimationSpeedHighAltitude;
    vec4 noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyHighAltitude, time, 0.0);
    vec3 normalTangentSpaceHighAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeHighAltitude);

    // low altitude waves
    time = czm_frameNumber * oceanAnimationSpeedLowAltitude;
    noise = czm_getWaterNoise(u_oceanNormalMap, textureCoordinates * oceanFrequencyLowAltitude, time, 0.0);
    vec3 normalTangentSpaceLowAltitude = vec3(noise.xy, noise.z * oceanOneOverAmplitudeLowAltitude);

    // blend the 2 wave layers based on distance to surface
    float highAltitudeFade = linearFade(0.0, 60000.0, positionToEyeECLength);
    float lowAltitudeFade = 1.0 - linearFade(20000.0, 60000.0, positionToEyeECLength);
    vec3 normalTangentSpace =
        (highAltitudeFade * normalTangentSpaceHighAltitude) +
        (lowAltitudeFade * normalTangentSpaceLowAltitude);
    normalTangentSpace = normalize(normalTangentSpace);

    // fade out the normal perturbation as we move farther from the water surface
    normalTangentSpace.xy *= waveIntensity;
    normalTangentSpace = normalize(normalTangentSpace);
#else
    vec3 normalTangentSpace = vec3(0.0, 0.0, 1.0);
#endif

    vec3 normalEC = enuToEye * normalTangentSpace;

    const vec3 waveHighlightColor = vec3(0.3, 0.45, 0.6);

    // Use diffuse light to highlight the waves
    float diffuseIntensity = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC) * maskValue;
    vec3 diffuseHighlight = waveHighlightColor * diffuseIntensity * (1.0 - fade);

#ifdef SHOW_OCEAN_WAVES
    // Where diffuse light is low or non-existent, use wave highlights based solely on
    // the wave bumpiness and no particular light direction.
    float tsPerturbationRatio = normalTangentSpace.z;
    vec3 nonDiffuseHighlight = mix(waveHighlightColor * 5.0 * (1.0 - tsPerturbationRatio), vec3(0.0), diffuseIntensity);
#else
    vec3 nonDiffuseHighlight = vec3(0.0);
#endif

    // Add specular highlights in 3D, and in all modes when zoomed in.
    float specularIntensity = czm_getSpecular(czm_lightDirectionEC, normalizedPositionToEyeEC, normalEC, 10.0);
    float surfaceReflectance = mix(0.0, mix(u_zoomedOutOceanSpecularIntensity, oceanSpecularIntensity, waveIntensity), maskValue);
    float specular = specularIntensity * surfaceReflectance;

#ifdef HDR
    specular *= 1.4;

    float e = 0.2;
    float d = 3.3;
    float c = 1.7;

    vec3 color = imageryColor.rgb + (c * (vec3(e) + imageryColor.rgb * d) * (diffuseHighlight + nonDiffuseHighlight + specular));
#else
    vec3 color = imageryColor.rgb + diffuseHighlight + nonDiffuseHighlight + specular;
#endif

    return vec4(color, imageryColor.a);
}

#endif // #ifdef SHOW_REFLECTIVE_OCEAN
`,GlobeVS=`#ifdef QUANTIZATION_BITS12
in vec4 compressed0;
in float compressed1;
#else
in vec4 position3DAndHeight;
in vec4 textureCoordAndEncodedNormals;
#endif

#ifdef GEODETIC_SURFACE_NORMALS
in vec3 geodeticSurfaceNormal;
#endif

#ifdef EXAGGERATION
uniform vec2 u_verticalExaggerationAndRelativeHeight;
#endif

uniform vec3 u_center3D;
uniform mat4 u_modifiedModelView;
uniform mat4 u_modifiedModelViewProjection;
uniform vec4 u_tileRectangle;

// Uniforms for 2D Mercator projection
uniform vec2 u_southAndNorthLatitude;
uniform vec2 u_southMercatorYAndOneOverHeight;

out vec3 v_positionMC;
out vec3 v_positionEC;

out vec3 v_textureCoordinates;
out vec3 v_normalMC;
out vec3 v_normalEC;

#ifdef APPLY_MATERIAL
out float v_slope;
out float v_aspect;
out float v_height;
#endif

#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
out float v_distance;
#endif

#if defined(FOG) || defined(GROUND_ATMOSPHERE)
out vec3 v_atmosphereRayleighColor;
out vec3 v_atmosphereMieColor;
out float v_atmosphereOpacity;
#endif

#ifdef ENABLE_CLIPPING_POLYGONS
uniform highp sampler2D u_clippingExtents;
out vec2 v_clippingPosition;
flat out int v_regionIndex;
#endif

// These functions are generated at runtime.
vec4 getPosition(vec3 position, float height, vec2 textureCoordinates);
float get2DYPositionFraction(vec2 textureCoordinates);

vec4 getPosition3DMode(vec3 position, float height, vec2 textureCoordinates)
{
    return u_modifiedModelViewProjection * vec4(position, 1.0);
}

float get2DMercatorYPositionFraction(vec2 textureCoordinates)
{
    // The width of a tile at level 11, in radians and assuming a single root tile, is
    //   2.0 * czm_pi / pow(2.0, 11.0)
    // We want to just linearly interpolate the 2D position from the texture coordinates
    // when we're at this level or higher.  The constant below is the expression
    // above evaluated and then rounded up at the 4th significant digit.
    const float maxTileWidth = 0.003068;
    float positionFraction = textureCoordinates.y;
    float southLatitude = u_southAndNorthLatitude.x;
    float northLatitude = u_southAndNorthLatitude.y;
    if (northLatitude - southLatitude > maxTileWidth)
    {
        float southMercatorY = u_southMercatorYAndOneOverHeight.x;
        float oneOverMercatorHeight = u_southMercatorYAndOneOverHeight.y;

        float currentLatitude = mix(southLatitude, northLatitude, textureCoordinates.y);
        currentLatitude = clamp(currentLatitude, -czm_webMercatorMaxLatitude, czm_webMercatorMaxLatitude);
        positionFraction = czm_latitudeToWebMercatorFraction(currentLatitude, southMercatorY, oneOverMercatorHeight);
    }
    return positionFraction;
}

float get2DGeographicYPositionFraction(vec2 textureCoordinates)
{
    return textureCoordinates.y;
}

vec4 getPositionPlanarEarth(vec3 position, float height, vec2 textureCoordinates)
{
    float yPositionFraction = get2DYPositionFraction(textureCoordinates);
    vec4 rtcPosition2D = vec4(height, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordinates.x, yPositionFraction)), 1.0);
    return u_modifiedModelViewProjection * rtcPosition2D;
}

vec4 getPosition2DMode(vec3 position, float height, vec2 textureCoordinates)
{
    return getPositionPlanarEarth(position, 0.0, textureCoordinates);
}

vec4 getPositionColumbusViewMode(vec3 position, float height, vec2 textureCoordinates)
{
    return getPositionPlanarEarth(position, height, textureCoordinates);
}

vec4 getPositionMorphingMode(vec3 position, float height, vec2 textureCoordinates)
{
    // We do not do RTC while morphing, so there is potential for jitter.
    // This is unlikely to be noticeable, though.
    vec3 position3DWC = position + u_center3D;
    float yPositionFraction = get2DYPositionFraction(textureCoordinates);
    vec4 position2DWC = vec4(height, mix(u_tileRectangle.st, u_tileRectangle.pq, vec2(textureCoordinates.x, yPositionFraction)), 1.0);
    vec4 morphPosition = czm_columbusViewMorph(position2DWC, vec4(position3DWC, 1.0), czm_morphTime);
    return czm_modelViewProjection * morphPosition;
}

#ifdef QUANTIZATION_BITS12
uniform vec2 u_minMaxHeight;
uniform mat4 u_scaleAndBias;
#endif

void main()
{
#ifdef QUANTIZATION_BITS12
    vec2 xy = czm_decompressTextureCoordinates(compressed0.x);
    vec2 zh = czm_decompressTextureCoordinates(compressed0.y);
    vec3 position = vec3(xy, zh.x);
    float height = zh.y;
    vec2 textureCoordinates = czm_decompressTextureCoordinates(compressed0.z);

    height = height * (u_minMaxHeight.y - u_minMaxHeight.x) + u_minMaxHeight.x;
    position = (u_scaleAndBias * vec4(position, 1.0)).xyz;

#if (defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL)) && defined(INCLUDE_WEB_MERCATOR_Y) || defined(APPLY_MATERIAL)
    float webMercatorT = czm_decompressTextureCoordinates(compressed0.w).x;
    float encodedNormal = compressed1;
#elif defined(INCLUDE_WEB_MERCATOR_Y)
    float webMercatorT = czm_decompressTextureCoordinates(compressed0.w).x;
    float encodedNormal = 0.0;
#elif defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL)
    float webMercatorT = textureCoordinates.y;
    float encodedNormal = compressed0.w;
#else
    float webMercatorT = textureCoordinates.y;
    float encodedNormal = 0.0;
#endif

#else
    // A single float per element
    vec3 position = position3DAndHeight.xyz;
    float height = position3DAndHeight.w;
    vec2 textureCoordinates = textureCoordAndEncodedNormals.xy;

#if (defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)) && defined(INCLUDE_WEB_MERCATOR_Y)
    float webMercatorT = textureCoordAndEncodedNormals.z;
    float encodedNormal = textureCoordAndEncodedNormals.w;
#elif defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)
    float webMercatorT = textureCoordinates.y;
    float encodedNormal = textureCoordAndEncodedNormals.z;
#elif defined(INCLUDE_WEB_MERCATOR_Y)
    float webMercatorT = textureCoordAndEncodedNormals.z;
    float encodedNormal = 0.0;
#else
    float webMercatorT = textureCoordinates.y;
    float encodedNormal = 0.0;
#endif

#endif

    vec3 position3DWC = position + u_center3D;

#ifdef GEODETIC_SURFACE_NORMALS
    vec3 ellipsoidNormal = geodeticSurfaceNormal;
#else
    vec3 ellipsoidNormal = normalize(position3DWC);
#endif

#if defined(EXAGGERATION) && defined(GEODETIC_SURFACE_NORMALS)
    float exaggeration = u_verticalExaggerationAndRelativeHeight.x;
    float relativeHeight = u_verticalExaggerationAndRelativeHeight.y;
    float newHeight = (height - relativeHeight) * exaggeration + relativeHeight;

    // stop from going through center of earth
    float minRadius = min(min(czm_ellipsoidRadii.x, czm_ellipsoidRadii.y), czm_ellipsoidRadii.z);
    newHeight = max(newHeight, -minRadius);

    vec3 offset = ellipsoidNormal * (newHeight - height);
    position += offset;
    position3DWC += offset;
    height = newHeight;
#endif

    gl_Position = getPosition(position, height, textureCoordinates);

    v_positionEC = (u_modifiedModelView * vec4(position, 1.0)).xyz;
    v_positionMC = position3DWC;  // position in model coordinates

    v_textureCoordinates = vec3(textureCoordinates, webMercatorT);

#if defined(ENABLE_VERTEX_LIGHTING) || defined(GENERATE_POSITION_AND_NORMAL) || defined(APPLY_MATERIAL)
    vec3 normalMC = czm_octDecode(encodedNormal);

#if defined(EXAGGERATION) && defined(GEODETIC_SURFACE_NORMALS)
    vec3 projection = dot(normalMC, ellipsoidNormal) * ellipsoidNormal;
    vec3 rejection = normalMC - projection;
    normalMC = normalize(projection + rejection * exaggeration);
#endif

    v_normalMC = normalMC;
    v_normalEC = czm_normal3D * v_normalMC;
#endif

#ifdef ENABLE_CLIPPING_POLYGONS
    vec2 sphericalLatLong = czm_approximateSphericalCoordinates(position3DWC);
    sphericalLatLong.y = czm_branchFreeTernary(sphericalLatLong.y < czm_pi, sphericalLatLong.y, sphericalLatLong.y - czm_twoPi);
    
    vec2 minDistance = vec2(czm_infinity);
    v_clippingPosition = vec2(czm_infinity);
    v_regionIndex = -1;

    for (int regionIndex = 0; regionIndex < CLIPPING_POLYGON_REGIONS_LENGTH; regionIndex++) {
        vec4 extents = unpackClippingExtents(u_clippingExtents, regionIndex);
        vec2 rectUv = (sphericalLatLong.yx - extents.yx) * extents.wz;

        vec2 clamped = clamp(rectUv, vec2(0.0), vec2(1.0));
        vec2 distance = abs(rectUv - clamped) * extents.wz;

        float threshold = 0.01;
        if (minDistance.x > distance.x || minDistance.y > distance.y) {
            minDistance = distance;
            v_clippingPosition = rectUv;
            if (rectUv.x > threshold && rectUv.y > threshold && rectUv.x < 1.0 - threshold && rectUv.y < 1.0 - threshold) {
                v_regionIndex = regionIndex;
            }
        }
    }
#endif

#if defined(FOG) || (defined(GROUND_ATMOSPHERE) && !defined(PER_FRAGMENT_GROUND_ATMOSPHERE))

    bool dynamicLighting = false;

    #if defined(DYNAMIC_ATMOSPHERE_LIGHTING) && (defined(ENABLE_DAYNIGHT_SHADING) || defined(ENABLE_VERTEX_LIGHTING))
        dynamicLighting = true;
    #endif

#if defined(DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN)
    vec3 atmosphereLightDirection = czm_sunDirectionWC;
#else
    vec3 atmosphereLightDirection = czm_lightDirectionWC;
#endif

    vec3 lightDirection = czm_branchFreeTernary(dynamicLighting, atmosphereLightDirection, normalize(position3DWC));

    computeAtmosphereScattering(
        position3DWC,
        lightDirection,
        v_atmosphereRayleighColor,
        v_atmosphereMieColor,
        v_atmosphereOpacity
    );
#endif

#if defined(FOG) || defined(GROUND_ATMOSPHERE) || defined(UNDERGROUND_COLOR) || defined(TRANSLUCENT)
    v_distance = length((czm_modelView3D * vec4(position3DWC, 1.0)).xyz);
#endif

#ifdef APPLY_MATERIAL
    float northPoleZ = czm_ellipsoidRadii.z;
    vec3 northPolePositionMC = vec3(0.0, 0.0, northPoleZ);
    vec3 vectorEastMC = normalize(cross(northPolePositionMC - v_positionMC, ellipsoidNormal));
    float dotProd = abs(dot(ellipsoidNormal, v_normalMC));
    v_slope = acos(dotProd);
    vec3 normalRejected = ellipsoidNormal * dotProd;
    vec3 normalProjected = v_normalMC - normalRejected;
    vec3 aspectVector = normalize(normalProjected);
    v_aspect = acos(dot(aspectVector, vectorEastMC));
    float determ = dot(cross(vectorEastMC, aspectVector), ellipsoidNormal);
    v_aspect = czm_branchFreeTernary(determ < 0.0, 2.0 * czm_pi - v_aspect, v_aspect);
    v_height = height;
#endif
}
`,GroundAtmosphere=`void computeAtmosphereScattering(vec3 positionWC, vec3 lightDirection, out vec3 rayleighColor, out vec3 mieColor, out float opacity) {

    vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC;
    vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC);
    czm_ray primaryRay = czm_ray(czm_viewerPositionWC, cameraToPositionWCDirection);
    
    float atmosphereInnerRadius = length(positionWC);

    computeScattering(
        primaryRay,
        length(cameraToPositionWC),
        lightDirection,
        atmosphereInnerRadius,
        rayleighColor,
        mieColor,
        opacity
    );
}
`,SkyAtmosphereCommon=`float interpolateByDistance(vec4 nearFarScalar, float distance)
{
    float startDistance = nearFarScalar.x;
    float startValue = nearFarScalar.y;
    float endDistance = nearFarScalar.z;
    float endValue = nearFarScalar.w;
    float t = clamp((distance - startDistance) / (endDistance - startDistance), 0.0, 1.0);
    return mix(startValue, endValue, t);
}

void computeAtmosphereScattering(vec3 positionWC, vec3 lightDirection, out vec3 rayleighColor, out vec3 mieColor, out float opacity, out float underTranslucentGlobe)
{
    float ellipsoidRadiiDifference = czm_ellipsoidRadii.x - czm_ellipsoidRadii.z;

    // Adjustment to the atmosphere radius applied based on the camera height.
    float distanceAdjustMin = czm_ellipsoidRadii.x / 4.0;
    float distanceAdjustMax = czm_ellipsoidRadii.x;
    float distanceAdjustModifier = ellipsoidRadiiDifference / 2.0;
    float distanceAdjust = distanceAdjustModifier * clamp((czm_eyeHeight - distanceAdjustMin) / (distanceAdjustMax - distanceAdjustMin), 0.0, 1.0);

    // Since atmosphere scattering assumes the atmosphere is a spherical shell, we compute an inner radius of the atmosphere best fit
    // for the position on the ellipsoid.
    float radiusAdjust = (ellipsoidRadiiDifference / 4.0) + distanceAdjust;
    float atmosphereInnerRadius = (length(czm_viewerPositionWC) - czm_eyeHeight) - radiusAdjust;

    // Setup the primary ray: from the camera position to the vertex position.
    vec3 cameraToPositionWC = positionWC - czm_viewerPositionWC;
    vec3 cameraToPositionWCDirection = normalize(cameraToPositionWC);
    czm_ray primaryRay = czm_ray(czm_viewerPositionWC, cameraToPositionWCDirection);

    underTranslucentGlobe = 0.0;

    // Brighten the sky atmosphere under the Earth's atmosphere when translucency is enabled.
    #if defined(GLOBE_TRANSLUCENT)

        // Check for intersection with the inner radius of the atmopshere.
        czm_raySegment primaryRayEarthIntersect = czm_raySphereIntersectionInterval(primaryRay, vec3(0.0), atmosphereInnerRadius + radiusAdjust);
        if (primaryRayEarthIntersect.start > 0.0 && primaryRayEarthIntersect.stop > 0.0) {

            // Compute position on globe.
            vec3 direction = normalize(positionWC);
            czm_ray ellipsoidRay = czm_ray(positionWC, -direction);
            czm_raySegment ellipsoidIntersection = czm_rayEllipsoidIntersectionInterval(ellipsoidRay, vec3(0.0), czm_ellipsoidInverseRadii);
            vec3 onEarth = positionWC - (direction * ellipsoidIntersection.start);

            // Control the color using the camera angle.
            float angle = dot(normalize(czm_viewerPositionWC), normalize(onEarth));

            // Control the opacity using the distance from Earth.
            opacity = interpolateByDistance(vec4(0.0, 1.0, czm_ellipsoidRadii.x, 0.0), length(czm_viewerPositionWC - onEarth));
            vec3 horizonColor = vec3(0.1, 0.2, 0.3);
            vec3 nearColor = vec3(0.0);

            rayleighColor = mix(nearColor, horizonColor, exp(-angle) * opacity);

            // Set the traslucent flag to avoid alpha adjustment in computeFinalColor funciton.
            underTranslucentGlobe = 1.0;
            return;
        }
    #endif

    computeScattering(
        primaryRay,
        length(cameraToPositionWC),
        lightDirection,
        atmosphereInnerRadius,
        rayleighColor,
        mieColor,
        opacity
    );

    // Alter the opacity based on how close the viewer is to the ground.
    // (0.0 = At edge of atmosphere, 1.0 = On ground)
    float cameraHeight = czm_eyeHeight + atmosphereInnerRadius;
    float atmosphereOuterRadius = atmosphereInnerRadius + ATMOSPHERE_THICKNESS;
    opacity = clamp((atmosphereOuterRadius - cameraHeight) / (atmosphereOuterRadius - atmosphereInnerRadius), 0.0, 1.0);

    // Alter alpha based on time of day (0.0 = night , 1.0 = day)
    float nightAlpha = (u_radiiAndDynamicAtmosphereColor.z != 0.0) ? clamp(dot(normalize(positionWC), lightDirection), 0.0, 1.0) : 1.0;
    opacity *= pow(nightAlpha, 0.5);
}
`,SkyAtmosphereFS=`in vec3 v_outerPositionWC;

uniform vec3 u_hsbShift;

#ifndef PER_FRAGMENT_ATMOSPHERE
in vec3 v_mieColor;
in vec3 v_rayleighColor;
in float v_opacity;
in float v_translucent;
#endif

void main (void)
{
    float lightEnum = u_radiiAndDynamicAtmosphereColor.z;
    vec3 lightDirection = czm_getDynamicAtmosphereLightDirection(v_outerPositionWC, lightEnum);

    vec3 mieColor;
    vec3 rayleighColor;
    float opacity;
    float translucent;

    #ifdef PER_FRAGMENT_ATMOSPHERE
        computeAtmosphereScattering(
            v_outerPositionWC,
            lightDirection,
            rayleighColor,
            mieColor,
            opacity,
            translucent
        );
    #else
        mieColor = v_mieColor;
        rayleighColor = v_rayleighColor;
        opacity = v_opacity;
        translucent = v_translucent;
    #endif

    vec4 color = computeAtmosphereColor(v_outerPositionWC, lightDirection, rayleighColor, mieColor, opacity);

    #ifndef HDR
        color.rgb = czm_acesTonemapping(color.rgb);
        color.rgb = czm_inverseGamma(color.rgb);
    #endif

    #ifdef COLOR_CORRECT
        const bool ignoreBlackPixels = true;
        color.rgb = czm_applyHSBShift(color.rgb, u_hsbShift, ignoreBlackPixels);
    #endif

    // For the parts of the sky atmosphere that are not behind a translucent globe,
    // we mix in the default opacity so that the sky atmosphere still appears at distance.
    // This is needed because the opacity in the sky atmosphere is initially adjusted based
    // on the camera height.
    if (translucent == 0.0) {
        color.a = mix(color.b, 1.0, color.a) * smoothstep(0.0, 1.0, czm_morphTime);
    }

    out_FragColor = color;
}
`,SkyAtmosphereVS=`in vec4 position;

out vec3 v_outerPositionWC;

#ifndef PER_FRAGMENT_ATMOSPHERE
out vec3 v_mieColor;
out vec3 v_rayleighColor;
out float v_opacity;
out float v_translucent;
#endif

void main(void)
{
    vec4 positionWC = czm_model * position;
    float lightEnum = u_radiiAndDynamicAtmosphereColor.z;
    vec3 lightDirection = czm_getDynamicAtmosphereLightDirection(positionWC.xyz, lightEnum);

    #ifndef PER_FRAGMENT_ATMOSPHERE
        computeAtmosphereScattering(
            positionWC.xyz,
            lightDirection,
            v_rayleighColor,
            v_mieColor,
            v_opacity,
            v_translucent
        );
    #endif

    v_outerPositionWC = positionWC.xyz;
    gl_Position = czm_modelViewProjection * position;
}
`,SkyBoxFS=`uniform samplerCube u_cubeMap;

in vec3 v_texCoord;

void main()
{
    vec4 color = czm_textureCube(u_cubeMap, normalize(v_texCoord));
    out_FragColor = vec4(czm_gammaCorrect(color).rgb, czm_morphTime);
}
`,SkyBoxVS=`in vec3 position;

out vec3 v_texCoord;

void main()
{
    vec3 p = czm_viewRotation * (czm_temeToPseudoFixed * (czm_entireFrustum.y * position));
    gl_Position = czm_projection * vec4(p, 1.0);
    v_texCoord = position.xyz;
}
`,SunFS=`uniform sampler2D u_texture;

in vec2 v_textureCoordinates;

void main()
{
    vec4 color = texture(u_texture, v_textureCoordinates);
    out_FragColor = czm_gammaCorrect(color);
}
`,SunTextureFS=`uniform float u_radiusTS;

in vec2 v_textureCoordinates;

vec2 rotate(vec2 p, vec2 direction)
{
    return vec2(p.x * direction.x - p.y * direction.y, p.x * direction.y + p.y * direction.x);
}

vec4 addBurst(vec2 position, vec2 direction, float lengthScalar)
{
    vec2 rotatedPosition = rotate(position, direction) * vec2(25.0, 0.75);
    float radius = length(rotatedPosition) * lengthScalar;
    float burst = 1.0 - smoothstep(0.0, 0.55, radius);
    return vec4(burst);
}

void main()
{
    float lengthScalar = 2.0 / sqrt(2.0);
    vec2 position = v_textureCoordinates - vec2(0.5);
    float radius = length(position) * lengthScalar;
    float surface = step(radius, u_radiusTS);
    vec4 color = vec4(vec2(1.0), surface + 0.2, surface);

    float glow = 1.0 - smoothstep(0.0, 0.55, radius);
    color.ba += mix(vec2(0.0), vec2(1.0), glow) * 0.75;

    vec4 burst = vec4(0.0);

    // The following loop has been manually unrolled for speed, to
    // avoid sin() and cos().
    //
    //for (float i = 0.4; i < 3.2; i += 1.047) {
    //    vec2 direction = vec2(sin(i), cos(i));
    //    burst += 0.4 * addBurst(position, direction, lengthScalar);
    //
    //    direction = vec2(sin(i - 0.08), cos(i - 0.08));
    //    burst += 0.3 * addBurst(position, direction, lengthScalar);
    //}

    burst += 0.4 * addBurst(position, vec2(0.38942,  0.92106), lengthScalar);  // angle == 0.4
    burst += 0.4 * addBurst(position, vec2(0.99235,  0.12348), lengthScalar);  // angle == 0.4 + 1.047
    burst += 0.4 * addBurst(position, vec2(0.60327, -0.79754), lengthScalar);  // angle == 0.4 + 1.047 * 2.0

    burst += 0.3 * addBurst(position, vec2(0.31457,  0.94924), lengthScalar);  // angle == 0.4 - 0.08
    burst += 0.3 * addBurst(position, vec2(0.97931,  0.20239), lengthScalar);  // angle == 0.4 + 1.047 - 0.08
    burst += 0.3 * addBurst(position, vec2(0.66507, -0.74678), lengthScalar);  // angle == 0.4 + 1.047 * 2.0 - 0.08

    // End of manual loop unrolling.

    color += clamp(burst, vec4(0.0), vec4(1.0)) * 0.15;

    out_FragColor = clamp(color, vec4(0.0), vec4(1.0));
}
`,SunVS=`in vec2 direction;

uniform float u_size;

out vec2 v_textureCoordinates;

void main() 
{
    vec4 position;
    if (czm_morphTime == 1.0)
    {
        position = vec4(czm_sunPositionWC, 1.0);
    }
    else
    {
        position = vec4(czm_sunPositionColumbusView.zxy, 1.0);
    }
    
    vec4 positionEC = czm_view * position;
    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);
    
    vec2 halfSize = vec2(u_size * 0.5);
    halfSize *= ((direction * 2.0) - 1.0);
    
    gl_Position = czm_viewportOrthographic * vec4(positionWC.xy + halfSize, -positionWC.z, 1.0);
    
    v_textureCoordinates = direction;
}
`,ViewportQuadFS=`
in vec2 v_textureCoordinates;

void main()
{
    czm_materialInput materialInput;
    
    materialInput.s = v_textureCoordinates.s;
    materialInput.st = v_textureCoordinates;
    materialInput.str = vec3(v_textureCoordinates, 0.0);
    materialInput.normalEC = vec3(0.0, 0.0, -1.0);
    
    czm_material material = czm_getMaterial(materialInput);

    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);
}
`,ViewportQuadVS=`in vec4 position;
in vec2 textureCoordinates;

out vec2 v_textureCoordinates;

void main() 
{
    gl_Position = position;
    v_textureCoordinates = textureCoordinates;
}
`,HeightmapEncoding={NONE:0,LERC:1},HeightmapEncoding$1=Object.freeze(HeightmapEncoding),TerrainQuantization={NONE:0,BITS12:1},TerrainQuantization$1=Object.freeze(TerrainQuantization),cartesian3Scratch$2=new Cartesian3,cartesian3DimScratch=new Cartesian3,cartesian2Scratch=new Cartesian2,matrix4Scratch$1=new Matrix4,matrix4Scratch2=new Matrix4,SHIFT_LEFT_12=Math.pow(2,12);function TerrainEncoding(e,t,n,i,r,o,a,s,l,c){let d=TerrainQuantization$1.NONE,h,f;if(defined(t)&&defined(n)&&defined(i)&&defined(r)){const p=t.minimum,u=t.maximum,m=Cartesian3.subtract(u,p,cartesian3DimScratch),g=i-n;Math.max(Cartesian3.maximumComponent(m),g)<SHIFT_LEFT_12-1?d=TerrainQuantization$1.BITS12:d=TerrainQuantization$1.NONE,h=Matrix4.inverseTransformation(r,new Matrix4);const C=Cartesian3.negate(p,cartesian3Scratch$2);Matrix4.multiply(Matrix4.fromTranslation(C,matrix4Scratch$1),h,h);const A=cartesian3Scratch$2;A.x=1/m.x,A.y=1/m.y,A.z=1/m.z,Matrix4.multiply(Matrix4.fromScale(A,matrix4Scratch$1),h,h),f=Matrix4.clone(r),Matrix4.setTranslation(f,Cartesian3.ZERO,f),r=Matrix4.clone(r,new Matrix4);const S=Matrix4.fromTranslation(p,matrix4Scratch$1),v=Matrix4.fromScale(m,matrix4Scratch2),b=Matrix4.multiply(S,v,matrix4Scratch$1);Matrix4.multiply(r,b,r),Matrix4.multiply(f,b,f)}this.quantization=d,this.minimumHeight=n,this.maximumHeight=i,this.center=Cartesian3.clone(e),this.toScaledENU=h,this.fromScaledENU=r,this.matrix=f,this.hasVertexNormals=o,this.hasWebMercatorT=defaultValue(a,!1),this.hasGeodeticSurfaceNormals=defaultValue(s,!1),this.exaggeration=defaultValue(l,1),this.exaggerationRelativeHeight=defaultValue(c,0),this.stride=0,this._offsetGeodeticSurfaceNormal=0,this._offsetVertexNormal=0,this._calculateStrideAndOffsets()}TerrainEncoding.prototype.encode=function(e,t,n,i,r,o,a,s){const l=i.x,c=i.y;if(this.quantization===TerrainQuantization$1.BITS12){n=Matrix4.multiplyByPoint(this.toScaledENU,n,cartesian3Scratch$2),n.x=CesiumMath.clamp(n.x,0,1),n.y=CesiumMath.clamp(n.y,0,1),n.z=CesiumMath.clamp(n.z,0,1);const d=this.maximumHeight-this.minimumHeight,h=CesiumMath.clamp((r-this.minimumHeight)/d,0,1);Cartesian2.fromElements(n.x,n.y,cartesian2Scratch);const f=AttributeCompression.compressTextureCoordinates(cartesian2Scratch);Cartesian2.fromElements(n.z,h,cartesian2Scratch);const p=AttributeCompression.compressTextureCoordinates(cartesian2Scratch);Cartesian2.fromElements(l,c,cartesian2Scratch);const u=AttributeCompression.compressTextureCoordinates(cartesian2Scratch);if(e[t++]=f,e[t++]=p,e[t++]=u,this.hasWebMercatorT){Cartesian2.fromElements(a,0,cartesian2Scratch);const m=AttributeCompression.compressTextureCoordinates(cartesian2Scratch);e[t++]=m}}else Cartesian3.subtract(n,this.center,cartesian3Scratch$2),e[t++]=cartesian3Scratch$2.x,e[t++]=cartesian3Scratch$2.y,e[t++]=cartesian3Scratch$2.z,e[t++]=r,e[t++]=l,e[t++]=c,this.hasWebMercatorT&&(e[t++]=a);return this.hasVertexNormals&&(e[t++]=AttributeCompression.octPackFloat(o)),this.hasGeodeticSurfaceNormals&&(e[t++]=s.x,e[t++]=s.y,e[t++]=s.z),t};const scratchPosition$3=new Cartesian3,scratchGeodeticSurfaceNormal=new Cartesian3;TerrainEncoding.prototype.addGeodeticSurfaceNormals=function(e,t,n){if(this.hasGeodeticSurfaceNormals)return;const i=this.stride,r=e.length/i;this.hasGeodeticSurfaceNormals=!0,this._calculateStrideAndOffsets();const o=this.stride;for(let a=0;a<r;a++){for(let d=0;d<i;d++){const h=a*i+d,f=a*o+d;t[f]=e[h]}const s=this.decodePosition(t,a,scratchPosition$3),l=n.geodeticSurfaceNormal(s,scratchGeodeticSurfaceNormal),c=a*o+this._offsetGeodeticSurfaceNormal;t[c]=l.x,t[c+1]=l.y,t[c+2]=l.z}};TerrainEncoding.prototype.removeGeodeticSurfaceNormals=function(e,t){if(!this.hasGeodeticSurfaceNormals)return;const n=this.stride,i=e.length/n;this.hasGeodeticSurfaceNormals=!1,this._calculateStrideAndOffsets();const r=this.stride;for(let o=0;o<i;o++)for(let a=0;a<r;a++){const s=o*n+a,l=o*r+a;t[l]=e[s]}};TerrainEncoding.prototype.decodePosition=function(e,t,n){if(defined(n)||(n=new Cartesian3),t*=this.stride,this.quantization===TerrainQuantization$1.BITS12){const i=AttributeCompression.decompressTextureCoordinates(e[t],cartesian2Scratch);n.x=i.x,n.y=i.y;const r=AttributeCompression.decompressTextureCoordinates(e[t+1],cartesian2Scratch);return n.z=r.x,Matrix4.multiplyByPoint(this.fromScaledENU,n,n)}return n.x=e[t],n.y=e[t+1],n.z=e[t+2],Cartesian3.add(n,this.center,n)};TerrainEncoding.prototype.getExaggeratedPosition=function(e,t,n){n=this.decodePosition(e,t,n);const i=this.exaggeration,r=this.exaggerationRelativeHeight;if(i!==1&&this.hasGeodeticSurfaceNormals){const a=this.decodeGeodeticSurfaceNormal(e,t,scratchGeodeticSurfaceNormal),s=this.decodeHeight(e,t),l=VerticalExaggeration.getHeight(s,i,r)-s;n.x+=a.x*l,n.y+=a.y*l,n.z+=a.z*l}return n};TerrainEncoding.prototype.decodeTextureCoordinates=function(e,t,n){return defined(n)||(n=new Cartesian2),t*=this.stride,this.quantization===TerrainQuantization$1.BITS12?AttributeCompression.decompressTextureCoordinates(e[t+2],n):Cartesian2.fromElements(e[t+4],e[t+5],n)};TerrainEncoding.prototype.decodeHeight=function(e,t){return t*=this.stride,this.quantization===TerrainQuantization$1.BITS12?AttributeCompression.decompressTextureCoordinates(e[t+1],cartesian2Scratch).y*(this.maximumHeight-this.minimumHeight)+this.minimumHeight:e[t+3]};TerrainEncoding.prototype.decodeWebMercatorT=function(e,t){return t*=this.stride,this.quantization===TerrainQuantization$1.BITS12?AttributeCompression.decompressTextureCoordinates(e[t+3],cartesian2Scratch).x:e[t+6]};TerrainEncoding.prototype.getOctEncodedNormal=function(e,t,n){t=t*this.stride+this._offsetVertexNormal;const i=e[t]/256,r=Math.floor(i),o=(i-r)*256;return Cartesian2.fromElements(r,o,n)};TerrainEncoding.prototype.decodeGeodeticSurfaceNormal=function(e,t,n){return t=t*this.stride+this._offsetGeodeticSurfaceNormal,n.x=e[t],n.y=e[t+1],n.z=e[t+2],n};TerrainEncoding.prototype._calculateStrideAndOffsets=function(){let e=0;switch(this.quantization){case TerrainQuantization$1.BITS12:e+=3;break;default:e+=6}this.hasWebMercatorT&&(e+=1),this.hasVertexNormals&&(this._offsetVertexNormal=e,e+=1),this.hasGeodeticSurfaceNormals&&(this._offsetGeodeticSurfaceNormal=e,e+=3),this.stride=e};const attributesIndicesNone={position3DAndHeight:0,textureCoordAndEncodedNormals:1,geodeticSurfaceNormal:2},attributesIndicesBits12={compressed0:0,compressed1:1,geodeticSurfaceNormal:2};TerrainEncoding.prototype.getAttributes=function(e){const t=ComponentDatatype.FLOAT,n=ComponentDatatype.getSizeInBytes(t),i=this.stride*n;let r=0;const o=[];function a(s,l){o.push({index:s,vertexBuffer:e,componentDatatype:t,componentsPerAttribute:l,offsetInBytes:r,strideInBytes:i}),r+=l*n}if(this.quantization===TerrainQuantization$1.NONE){a(attributesIndicesNone.position3DAndHeight,4);let s=2;s+=this.hasWebMercatorT?1:0,s+=this.hasVertexNormals?1:0,a(attributesIndicesNone.textureCoordAndEncodedNormals,s),this.hasGeodeticSurfaceNormals&&a(attributesIndicesNone.geodeticSurfaceNormal,3)}else{const s=this.hasWebMercatorT||this.hasVertexNormals,l=this.hasWebMercatorT&&this.hasVertexNormals;a(attributesIndicesBits12.compressed0,s?4:3),l&&a(attributesIndicesBits12.compressed1,1),this.hasGeodeticSurfaceNormals&&a(attributesIndicesBits12.geodeticSurfaceNormal,3)}return o};TerrainEncoding.prototype.getAttributeLocations=function(){return this.quantization===TerrainQuantization$1.NONE?attributesIndicesNone:attributesIndicesBits12};TerrainEncoding.clone=function(e,t){if(defined(e))return defined(t)||(t=new TerrainEncoding),t.quantization=e.quantization,t.minimumHeight=e.minimumHeight,t.maximumHeight=e.maximumHeight,t.center=Cartesian3.clone(e.center),t.toScaledENU=Matrix4.clone(e.toScaledENU),t.fromScaledENU=Matrix4.clone(e.fromScaledENU),t.matrix=Matrix4.clone(e.matrix),t.hasVertexNormals=e.hasVertexNormals,t.hasWebMercatorT=e.hasWebMercatorT,t.hasGeodeticSurfaceNormals=e.hasGeodeticSurfaceNormals,t.exaggeration=e.exaggeration,t.exaggerationRelativeHeight=e.exaggerationRelativeHeight,t._calculateStrideAndOffsets(),t};const HeightmapTessellator={};HeightmapTessellator.DEFAULT_STRUCTURE=Object.freeze({heightScale:1,heightOffset:0,elementsPerHeight:1,stride:1,elementMultiplier:256,isBigEndian:!1});const cartesian3Scratch$1=new Cartesian3,matrix4Scratch=new Matrix4,minimumScratch=new Cartesian3,maximumScratch=new Cartesian3;HeightmapTessellator.computeVertices=function(e){if(!defined(e)||!defined(e.heightmap))throw new DeveloperError("options.heightmap is required.");if(!defined(e.width)||!defined(e.height))throw new DeveloperError("options.width and options.height are required.");if(!defined(e.nativeRectangle))throw new DeveloperError("options.nativeRectangle is required.");if(!defined(e.skirtHeight))throw new DeveloperError("options.skirtHeight is required.");const t=Math.cos,n=Math.sin,i=Math.sqrt,r=Math.atan,o=Math.exp,a=CesiumMath.PI_OVER_TWO,s=CesiumMath.toRadians,l=e.heightmap,c=e.width,d=e.height,h=e.skirtHeight,f=h>0,p=defaultValue(e.isGeographic,!0),u=defaultValue(e.ellipsoid,Ellipsoid.default),m=1/u.maximumRadius,g=Rectangle.clone(e.nativeRectangle),_=Rectangle.clone(e.rectangle);let C,A,S,v;defined(_)?(C=_.west,A=_.south,S=_.east,v=_.north):p?(C=s(g.west),A=s(g.south),S=s(g.east),v=s(g.north)):(C=g.west*m,A=a-2*r(o(-g.south*m)),S=g.east*m,v=a-2*r(o(-g.north*m)));let b=e.relativeToCenter;const D=defined(b);b=D?b:Cartesian3.ZERO;const I=defaultValue(e.includeWebMercatorT,!1),L=defaultValue(e.exaggeration,1),N=defaultValue(e.exaggerationRelativeHeight,0),x=L!==1,T=defaultValue(e.structure,HeightmapTessellator.DEFAULT_STRUCTURE),E=defaultValue(T.heightScale,HeightmapTessellator.DEFAULT_STRUCTURE.heightScale),P=defaultValue(T.heightOffset,HeightmapTessellator.DEFAULT_STRUCTURE.heightOffset),M=defaultValue(T.elementsPerHeight,HeightmapTessellator.DEFAULT_STRUCTURE.elementsPerHeight),O=defaultValue(T.stride,HeightmapTessellator.DEFAULT_STRUCTURE.stride),V=defaultValue(T.elementMultiplier,HeightmapTessellator.DEFAULT_STRUCTURE.elementMultiplier),R=defaultValue(T.isBigEndian,HeightmapTessellator.DEFAULT_STRUCTURE.isBigEndian);let w=Rectangle.computeWidth(g),U=Rectangle.computeHeight(g);const k=w/(c-1),H=U/(d-1);p||(w*=m,U*=m);const F=u.radiiSquared,G=F.x,B=F.y,W=F.z;let Y=65536,z=-65536;const X=Transforms.eastNorthUpToFixedFrame(b,u),q=Matrix4.inverseTransformation(X,matrix4Scratch);let Q,Z;I&&(Q=WebMercatorProjection.geodeticLatitudeToMercatorAngle(A),Z=1/(WebMercatorProjection.geodeticLatitudeToMercatorAngle(v)-Q));const K=minimumScratch;K.x=Number.POSITIVE_INFINITY,K.y=Number.POSITIVE_INFINITY,K.z=Number.POSITIVE_INFINITY;const J=maximumScratch;J.x=Number.NEGATIVE_INFINITY,J.y=Number.NEGATIVE_INFINITY,J.z=Number.NEGATIVE_INFINITY;let se=Number.POSITIVE_INFINITY;const ae=c*d,te=h>0?c*2+d*2:0,ee=ae+te,ce=new Array(ee),re=new Array(ee),ne=new Array(ee),le=I?new Array(ee):[],$=x?new Array(ee):[];let j=0,oe=d,ie=0,de=c;f&&(--j,++oe,--ie,++de);const ue=1e-5;for(let he=j;he<oe;++he){let be=he;be<0&&(be=0),be>=d&&(be=d-1);let ye=g.north-H*be;p?ye=s(ye):ye=a-2*r(o(-ye*m));let Be=(ye-A)/(v-A);Be=CesiumMath.clamp(Be,0,1);const Fe=he===j,Ve=he===oe-1;h>0&&(Fe?ye+=ue*U:Ve&&(ye-=ue*U));const Ge=t(ye),Ue=n(ye),ke=W*Ue;let He;I&&(He=(WebMercatorProjection.geodeticLatitudeToMercatorAngle(ye)-Q)*Z);for(let Re=ie;Re<de;++Re){let Ae=Re;Ae<0&&(Ae=0),Ae>=c&&(Ae=c-1);const Oe=be*(c*O)+Ae*O;let me;if(M===1)me=l[Oe];else{me=0;let _e;if(R)for(_e=0;_e<M;++_e)me=me*V+l[Oe+_e];else for(_e=M-1;_e>=0;--_e)me=me*V+l[Oe+_e]}me=me*E+P,z=Math.max(z,me),Y=Math.min(Y,me);let Se=g.west+k*Ae;p?Se=s(Se):Se=Se*m;let ze=(Se-C)/(S-C);ze=CesiumMath.clamp(ze,0,1);let xe=be*c+Ae;if(h>0){const _e=Re===ie,We=Re===de-1,Xe=Fe||Ve||_e||We;if((Fe||Ve)&&(_e||We))continue;Xe&&(me-=h,_e?(xe=ae+(d-be-1),Se-=ue*w):Ve?xe=ae+d+(c-Ae-1):We?(xe=ae+d+c+be,Se+=ue*w):Fe&&(xe=ae+d+c+d+Ae))}const Te=Ge*t(Se),$e=Ge*n(Se),Ce=G*Te,ve=B*$e,fe=1/i(Ce*Te+ve*$e+ke*Ue),Le=Ce*fe,Ne=ve*fe,qe=ke*fe,ge=new Cartesian3;ge.x=Le+Te*me,ge.y=Ne+$e*me,ge.z=qe+Ue*me,Matrix4.multiplyByPoint(q,ge,cartesian3Scratch$1),Cartesian3.minimumByComponent(cartesian3Scratch$1,K,K),Cartesian3.maximumByComponent(cartesian3Scratch$1,J,J),se=Math.min(se,me),ce[xe]=ge,ne[xe]=new Cartesian2(ze,Be),re[xe]=me,I&&(le[xe]=He),x&&($[xe]=u.geodeticSurfaceNormal(ge))}}const Ee=BoundingSphere.fromPoints(ce);let Pe;defined(_)&&(Pe=OrientedBoundingBox.fromRectangle(_,Y,z,u));let De;D&&(De=new EllipsoidalOccluder(u).computeHorizonCullingPointPossiblyUnderEllipsoid(b,ce,Y));const Me=new AxisAlignedBoundingBox(K,J,b),we=new TerrainEncoding(b,Me,se,z,X,!1,I,x,L,N),pe=new Float32Array(ee*we.stride);let Ie=0;for(let he=0;he<ee;++he)Ie=we.encode(pe,Ie,ce[he],ne[he],re[he],void 0,le[he],$[he]);return{vertices:pe,maximumHeight:z,minimumHeight:Y,encoding:we,boundingSphere3D:Ee,orientedBoundingBox:Pe,occludeePointInScaledSpace:De}};const HeightmapTessellator$1=HeightmapTessellator;function TerrainData(){DeveloperError.throwInstantiationError()}Object.defineProperties(TerrainData.prototype,{credits:{get:DeveloperError.throwInstantiationError},waterMask:{get:DeveloperError.throwInstantiationError}});TerrainData.prototype.interpolateHeight=DeveloperError.throwInstantiationError;TerrainData.prototype.isChildAvailable=DeveloperError.throwInstantiationError;TerrainData.prototype.createMesh=DeveloperError.throwInstantiationError;TerrainData.prototype.upsample=DeveloperError.throwInstantiationError;TerrainData.prototype.wasCreatedByUpsampling=DeveloperError.throwInstantiationError;TerrainData.maximumAsynchronousTasks=5;function TerrainMesh(e,t,n,i,r,o,a,s,l,c,d,h,f,p,u,m){this.center=e,this.vertices=t,this.stride=defaultValue(c,6),this.indices=n,this.indexCountWithoutSkirts=i,this.vertexCountWithoutSkirts=r,this.minimumHeight=o,this.maximumHeight=a,this.boundingSphere3D=s,this.occludeePointInScaledSpace=l,this.orientedBoundingBox=d,this.encoding=h,this.westIndicesSouthToNorth=f,this.southIndicesEastToWest=p,this.eastIndicesNorthToSouth=u,this.northIndicesWestToEast=m}function HeightmapTerrainData(e){if(!defined(e)||!defined(e.buffer))throw new DeveloperError("options.buffer is required.");if(!defined(e.width))throw new DeveloperError("options.width is required.");if(!defined(e.height))throw new DeveloperError("options.height is required.");this._buffer=e.buffer,this._width=e.width,this._height=e.height,this._childTileMask=defaultValue(e.childTileMask,15),this._encoding=defaultValue(e.encoding,HeightmapEncoding$1.NONE);const t=HeightmapTessellator$1.DEFAULT_STRUCTURE;let n=e.structure;defined(n)?n!==t&&(n.heightScale=defaultValue(n.heightScale,t.heightScale),n.heightOffset=defaultValue(n.heightOffset,t.heightOffset),n.elementsPerHeight=defaultValue(n.elementsPerHeight,t.elementsPerHeight),n.stride=defaultValue(n.stride,t.stride),n.elementMultiplier=defaultValue(n.elementMultiplier,t.elementMultiplier),n.isBigEndian=defaultValue(n.isBigEndian,t.isBigEndian)):n=t,this._structure=n,this._createdByUpsampling=defaultValue(e.createdByUpsampling,!1),this._waterMask=e.waterMask,this._skirtHeight=void 0,this._bufferType=this._encoding===HeightmapEncoding$1.LERC?Float32Array:this._buffer.constructor,this._mesh=void 0}Object.defineProperties(HeightmapTerrainData.prototype,{credits:{get:function(){}},waterMask:{get:function(){return this._waterMask}},childTileMask:{get:function(){return this._childTileMask}}});const createMeshTaskName$2="createVerticesFromHeightmap",createMeshTaskProcessorNoThrottle$2=new TaskProcessor(createMeshTaskName$2),createMeshTaskProcessorThrottle$2=new TaskProcessor(createMeshTaskName$2,TerrainData.maximumAsynchronousTasks);HeightmapTerrainData.prototype.createMesh=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),Check.typeOf.object("options.tilingScheme",e.tilingScheme),Check.typeOf.number("options.x",e.x),Check.typeOf.number("options.y",e.y),Check.typeOf.number("options.level",e.level);const t=e.tilingScheme,n=e.x,i=e.y,r=e.level,o=defaultValue(e.exaggeration,1),a=defaultValue(e.exaggerationRelativeHeight,0),s=defaultValue(e.throttle,!0),l=t.ellipsoid,c=t.tileXYToNativeRectangle(n,i,r),d=t.tileXYToRectangle(n,i,r),h=l.cartographicToCartesian(Rectangle.center(d)),f=this._structure,u=TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(l,this._width,t.getNumberOfXTilesAtLevel(0))/(1<<r);this._skirtHeight=Math.min(u*4,1e3);const g=(s?createMeshTaskProcessorThrottle$2:createMeshTaskProcessorNoThrottle$2).scheduleTask({heightmap:this._buffer,structure:f,includeWebMercatorT:!0,width:this._width,height:this._height,nativeRectangle:c,rectangle:d,relativeToCenter:h,ellipsoid:l,skirtHeight:this._skirtHeight,isGeographic:t.projection instanceof GeographicProjection,exaggeration:o,exaggerationRelativeHeight:a,encoding:this._encoding});if(!defined(g))return;const _=this;return Promise.resolve(g).then(function(C){let A;_._skirtHeight>0?A=TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(C.gridWidth,C.gridHeight):A=TerrainProvider.getRegularGridIndicesAndEdgeIndices(C.gridWidth,C.gridHeight);const S=C.gridWidth*C.gridHeight;return _._mesh=new TerrainMesh(h,new Float32Array(C.vertices),A.indices,A.indexCountWithoutSkirts,S,C.minimumHeight,C.maximumHeight,BoundingSphere.clone(C.boundingSphere3D),Cartesian3.clone(C.occludeePointInScaledSpace),C.numberOfAttributes,OrientedBoundingBox.clone(C.orientedBoundingBox),TerrainEncoding.clone(C.encoding),A.westIndicesSouthToNorth,A.southIndicesEastToWest,A.eastIndicesNorthToSouth,A.northIndicesWestToEast),_._buffer=void 0,_._mesh})};HeightmapTerrainData.prototype._createMeshSync=function(e){Check.typeOf.object("options.tilingScheme",e.tilingScheme),Check.typeOf.number("options.x",e.x),Check.typeOf.number("options.y",e.y),Check.typeOf.number("options.level",e.level);const t=e.tilingScheme,n=e.x,i=e.y,r=e.level,o=defaultValue(e.exaggeration,1),a=defaultValue(e.exaggerationRelativeHeight,0),s=t.ellipsoid,l=t.tileXYToNativeRectangle(n,i,r),c=t.tileXYToRectangle(n,i,r),d=s.cartographicToCartesian(Rectangle.center(c)),h=this._structure,p=TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(s,this._width,t.getNumberOfXTilesAtLevel(0))/(1<<r);this._skirtHeight=Math.min(p*4,1e3);const u=HeightmapTessellator$1.computeVertices({heightmap:this._buffer,structure:h,includeWebMercatorT:!0,width:this._width,height:this._height,nativeRectangle:l,rectangle:c,relativeToCenter:d,ellipsoid:s,skirtHeight:this._skirtHeight,isGeographic:t.projection instanceof GeographicProjection,exaggeration:o,exaggerationRelativeHeight:a});this._buffer=void 0;let m;this._skirtHeight>0?m=TerrainProvider.getRegularGridAndSkirtIndicesAndEdgeIndices(this._width,this._height):m=TerrainProvider.getRegularGridIndicesAndEdgeIndices(this._width,this._height);const g=u.gridWidth*u.gridHeight;return this._mesh=new TerrainMesh(d,u.vertices,m.indices,m.indexCountWithoutSkirts,g,u.minimumHeight,u.maximumHeight,u.boundingSphere3D,u.occludeePointInScaledSpace,u.encoding.stride,u.orientedBoundingBox,u.encoding,m.westIndicesSouthToNorth,m.southIndicesEastToWest,m.eastIndicesNorthToSouth,m.northIndicesWestToEast),this._mesh};HeightmapTerrainData.prototype.interpolateHeight=function(e,t,n){const i=this._width,r=this._height,o=this._structure,a=o.stride,s=o.elementsPerHeight,l=o.elementMultiplier,c=o.isBigEndian,d=o.heightOffset,h=o.heightScale,f=defined(this._mesh),p=this._encoding===HeightmapEncoding$1.LERC;if(!f&&p)return;let m;if(f){const g=this._mesh.vertices,_=this._mesh.encoding;m=interpolateMeshHeight$2(g,_,d,h,e,i,r,t,n)}else m=interpolateHeight$2(this._buffer,s,l,a,c,e,i,r,t,n),m=m*h+d;return m};HeightmapTerrainData.prototype.upsample=function(e,t,n,i,r,o,a){if(!defined(e))throw new DeveloperError("tilingScheme is required.");if(!defined(t))throw new DeveloperError("thisX is required.");if(!defined(n))throw new DeveloperError("thisY is required.");if(!defined(i))throw new DeveloperError("thisLevel is required.");if(!defined(r))throw new DeveloperError("descendantX is required.");if(!defined(o))throw new DeveloperError("descendantY is required.");if(!defined(a))throw new DeveloperError("descendantLevel is required.");if(a-i>1)throw new DeveloperError("Upsampling through more than one level at a time is not currently supported.");const l=this._mesh;if(!defined(l))return;const c=this._width,d=this._height,h=this._structure,f=h.stride,p=new this._bufferType(c*d*f),u=l.vertices,m=l.encoding,g=e.tileXYToRectangle(t,n,i),_=e.tileXYToRectangle(r,o,a),C=h.heightOffset,A=h.heightScale,S=h.elementsPerHeight,v=h.elementMultiplier,b=h.isBigEndian,D=Math.pow(v,S-1);for(let I=0;I<d;++I){const L=CesiumMath.lerp(_.north,_.south,I/(d-1));for(let N=0;N<c;++N){const y=CesiumMath.lerp(_.west,_.east,N/(c-1));let x=interpolateMeshHeight$2(u,m,C,A,g,c,d,y,L);x=x<h.lowestEncodedHeight?h.lowestEncodedHeight:x,x=x>h.highestEncodedHeight?h.highestEncodedHeight:x,setHeight(p,S,v,D,f,b,I*c+N,x)}}return Promise.resolve(new HeightmapTerrainData({buffer:p,width:c,height:d,childTileMask:0,structure:this._structure,createdByUpsampling:!0}))};HeightmapTerrainData.prototype.isChildAvailable=function(e,t,n,i){if(!defined(e))throw new DeveloperError("thisX is required.");if(!defined(t))throw new DeveloperError("thisY is required.");if(!defined(n))throw new DeveloperError("childX is required.");if(!defined(i))throw new DeveloperError("childY is required.");let r=2;return n!==e*2&&++r,i!==t*2&&(r-=2),(this._childTileMask&1<<r)!==0};HeightmapTerrainData.prototype.wasCreatedByUpsampling=function(){return this._createdByUpsampling};function interpolateHeight$2(e,t,n,i,r,o,a,s,l,c){const d=(l-o.west)*(a-1)/(o.east-o.west),h=(c-o.south)*(s-1)/(o.north-o.south);let f=d|0,p=f+1;p>=a&&(p=a-1,f=a-2);let u=h|0,m=u+1;m>=s&&(m=s-1,u=s-2);const g=d-f,_=h-u;u=s-1-u,m=s-1-m;const C=getHeight(e,t,n,i,r,u*a+f),A=getHeight(e,t,n,i,r,u*a+p),S=getHeight(e,t,n,i,r,m*a+f),v=getHeight(e,t,n,i,r,m*a+p);return triangleInterpolateHeight(g,_,C,A,S,v)}function interpolateMeshHeight$2(e,t,n,i,r,o,a,s,l){const c=(s-r.west)*(o-1)/(r.east-r.west),d=(l-r.south)*(a-1)/(r.north-r.south);let h=c|0,f=h+1;f>=o&&(f=o-1,h=o-2);let p=d|0,u=p+1;u>=a&&(u=a-1,p=a-2);const m=c-h,g=d-p;p=a-1-p,u=a-1-u;const _=(t.decodeHeight(e,p*o+h)-n)/i,C=(t.decodeHeight(e,p*o+f)-n)/i,A=(t.decodeHeight(e,u*o+h)-n)/i,S=(t.decodeHeight(e,u*o+f)-n)/i;return triangleInterpolateHeight(m,g,_,C,A,S)}function triangleInterpolateHeight(e,t,n,i,r,o){return t<e?n+e*(i-n)+t*(o-i):n+e*(o-r)+t*(r-n)}function getHeight(e,t,n,i,r,o){o*=i;let a=0,s;if(r)for(s=0;s<t;++s)a=a*n+e[o+s];else for(s=t-1;s>=0;--s)a=a*n+e[o+s];return a}function setHeight(e,t,n,i,r,o,a,s){a*=r;let l;if(o)for(l=0;l<t-1;++l)e[a+l]=s/i|0,s-=e[a+l]*i,i/=n;else for(l=t-1;l>0;--l)e[a+l]=s/i|0,s-=e[a+l]*i,i/=n;e[a+l]=s}function EllipsoidTerrainProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._tilingScheme=e.tilingScheme,defined(this._tilingScheme)||(this._tilingScheme=new GeographicTilingScheme({ellipsoid:defaultValue(e.ellipsoid,Ellipsoid.default)})),this._levelZeroMaximumGeometricError=TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid,64,this._tilingScheme.getNumberOfXTilesAtLevel(0)),this._errorEvent=new Event}Object.defineProperties(EllipsoidTerrainProvider.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){}},tilingScheme:{get:function(){return this._tilingScheme}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},availability:{get:function(){}}});EllipsoidTerrainProvider.prototype.requestTileGeometry=function(e,t,n,i){return Promise.resolve(new HeightmapTerrainData({buffer:new Uint8Array(16*16),width:16,height:16}))};EllipsoidTerrainProvider.prototype.getLevelMaximumGeometricError=function(e){return this._levelZeroMaximumGeometricError/(1<<e)};EllipsoidTerrainProvider.prototype.getTileDataAvailable=function(e,t,n){};EllipsoidTerrainProvider.prototype.loadTileDataAvailability=function(e,t,n){};const textureResolutionScratch=new Cartesian2;function getClippingFunction(e,t){Check.typeOf.object("clippingPlaneCollection",e),Check.typeOf.object("context",t);const n=e.unionClippingRegions,i=e.length,r=ClippingPlaneCollection.useFloatTexture(t),o=ClippingPlaneCollection.getTextureResolution(e,t,textureResolutionScratch),a=o.x,s=o.y;let l=r?getClippingPlaneFloat(a,s):getClippingPlaneUint8(a,s);return l+=`
`,l+=n?clippingFunctionUnion(i):clippingFunctionIntersect(i),l}function clippingFunctionUnion(e){return`float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)
{
    vec4 position = czm_windowToEyeCoordinates(fragCoord);
    vec3 clipNormal = vec3(0.0);
    vec3 clipPosition = vec3(0.0);
    float clipAmount;
    float pixelWidth = czm_metersPerPixel(position);
    bool breakAndDiscard = false;
    for (int i = 0; i < ${e}; ++i)
    {
        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);
        clipNormal = clippingPlane.xyz;
        clipPosition = -clippingPlane.w * clipNormal;
        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;
        clipAmount = czm_branchFreeTernary(i == 0, amount, min(amount, clipAmount));
        if (amount <= 0.0)
        {
           breakAndDiscard = true;
           break;
        }
    }
    if (breakAndDiscard) {
        discard;
    }
    return clipAmount;
}
`}function clippingFunctionIntersect(e){return`float clip(vec4 fragCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix)
{
    bool clipped = true;
    vec4 position = czm_windowToEyeCoordinates(fragCoord);
    vec3 clipNormal = vec3(0.0);
    vec3 clipPosition = vec3(0.0);
    float clipAmount = 0.0;
    float pixelWidth = czm_metersPerPixel(position);
    for (int i = 0; i < ${e}; ++i)
    {
        vec4 clippingPlane = getClippingPlane(clippingPlanes, i, clippingPlanesMatrix);
        clipNormal = clippingPlane.xyz;
        clipPosition = -clippingPlane.w * clipNormal;
        float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelWidth;
        clipAmount = max(amount, clipAmount);
        clipped = clipped && (amount <= 0.0);
    }
    if (clipped)
    {
        discard;
    }
    return clipAmount;
}
`}function getClippingPlaneFloat(e,t){const n=1/e,i=1/t;let r=`${n}`;r.indexOf(".")===-1&&(r+=".0");let o=`${i}`;return o.indexOf(".")===-1&&(o+=".0"),`vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)
{
    int pixY = clippingPlaneNumber / ${e};
    int pixX = clippingPlaneNumber - (pixY * ${e});
    float u = (float(pixX) + 0.5) * ${r};
    float v = (float(pixY) + 0.5) * ${o};
    vec4 plane = texture(packedClippingPlanes, vec2(u, v));
    return czm_transformPlane(plane, transform);
}
`}function getClippingPlaneUint8(e,t){const n=1/e,i=1/t;let r=`${n}`;r.indexOf(".")===-1&&(r+=".0");let o=`${i}`;return o.indexOf(".")===-1&&(o+=".0"),`vec4 getClippingPlane(highp sampler2D packedClippingPlanes, int clippingPlaneNumber, mat4 transform)
{
    int clippingPlaneStartIndex = clippingPlaneNumber * 2;
    int pixY = clippingPlaneStartIndex / ${e};
    int pixX = clippingPlaneStartIndex - (pixY * ${e});
    float u = (float(pixX) + 0.5) * ${r};
    float v = (float(pixY) + 0.5) * ${o};
    vec4 oct32 = texture(packedClippingPlanes, vec2(u, v)) * 255.0;
    vec2 oct = vec2(oct32.x * 256.0 + oct32.y, oct32.z * 256.0 + oct32.w);
    vec4 plane;
    plane.xyz = czm_octDecode(oct, 65535.0);
    plane.w = czm_unpackFloat(texture(packedClippingPlanes, vec2(u + ${r}, v)));
    return czm_transformPlane(plane, transform);
}
`}function GlobeSurfaceShader(e,t,n,i,r,o){this.numberOfDayTextures=e,this.flags=t,this.material=n,this.shaderProgram=i,this.clippingShaderState=r,this.clippingPolygonShaderState=o}function GlobeSurfaceShaderSet(){this.baseVertexShaderSource=void 0,this.baseFragmentShaderSource=void 0,this._shadersByTexturesFlags=[],this.material=void 0}function getPositionMode(e){const t="vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPosition3DMode(position, height, textureCoordinates); }",n="vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionColumbusViewMode(position, height, textureCoordinates); }",i="vec4 getPosition(vec3 position, float height, vec2 textureCoordinates) { return getPositionMorphingMode(position, height, textureCoordinates); }";let r;switch(e){case SceneMode.SCENE3D:r=t;break;case SceneMode.SCENE2D:case SceneMode.COLUMBUS_VIEW:r=n;break;case SceneMode.MORPHING:r=i;break}return r}function getPolygonClippingFunction(e){return e.webgl2?`void clipPolygons(highp sampler2D clippingDistance, int regionsLength, vec2 clippingPosition, int regionIndex) {
    czm_clipPolygons(clippingDistance, regionsLength, clippingPosition, regionIndex);
  }`:`void clipPolygons(highp sampler2D clippingDistance, int regionsLength, vec2 clippingPosition, int regionIndex) {
    }`}function getUnpackClippingFunction(e){return e.webgl2?`vec4 unpackClippingExtents(highp sampler2D extentsTexture, int index) {
    return czm_unpackClippingExtents(extentsTexture, index);
  }`:`vec4 unpackClippingExtents(highp sampler2D extentsTexture, int index) {
      return vec4();
    }`}function get2DYPositionFraction(e){return e?"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DMercatorYPositionFraction(textureCoordinates); }":"float get2DYPositionFraction(vec2 textureCoordinates) { return get2DGeographicYPositionFraction(textureCoordinates); }"}GlobeSurfaceShaderSet.prototype.getShaderProgram=function(e){const t=e.frameState,n=e.surfaceTile,i=e.numberOfDayTextures,r=e.applyBrightness,o=e.applyContrast,a=e.applyHue,s=e.applySaturation,l=e.applyGamma,c=e.applyAlpha,d=e.applyDayNightAlpha,h=e.applySplit,f=e.showReflectiveOcean,p=e.showOceanWaves,u=e.enableLighting,m=e.dynamicAtmosphereLighting,g=e.dynamicAtmosphereLightingFromSun,_=e.showGroundAtmosphere,C=e.perFragmentGroundAtmosphere,A=e.hasVertexNormals,S=e.useWebMercatorProjection,v=e.enableFog,b=e.enableClippingPlanes,D=e.clippingPlanes,I=e.enableClippingPolygons,L=e.clippingPolygons,N=e.clippedByBoundaries,y=e.hasImageryLayerCutout,x=e.colorCorrect,T=e.highlightFillTile,E=e.colorToAlpha,P=e.hasGeodeticSurfaceNormals,M=e.hasExaggeration,O=e.showUndergroundColor,V=e.translucent;let R=0,w="";const k=n.renderedMesh.encoding;k.quantization===TerrainQuantization$1.BITS12&&(R=1,w="QUANTIZATION_BITS12");let F=0,G="";N&&(F=1,G="TILE_LIMIT_RECTANGLE");let B=0,W="";y&&(B=1,W="APPLY_IMAGERY_CUTOUT");const Y=t.mode,z=Y|r<<2|o<<3|a<<4|s<<5|l<<6|c<<7|f<<8|p<<9|u<<10|m<<11|g<<12|_<<13|C<<14|A<<15|S<<16|v<<17|R<<18|h<<19|b<<20|I<<21|F<<22|B<<23|x<<24|T<<25|E<<26|P<<27|M<<28|O<<29|V<<30|d<<31;let X=0;defined(D)&&D.length>0&&(X=b?D.clippingPlanesState:0);let q=0;defined(L)&&L.length>0&&(q=I?L.clippingPolygonsState:0);let Q=n.surfaceShader;if(defined(Q)&&Q.numberOfDayTextures===i&&Q.flags===z&&Q.material===this.material&&Q.clippingShaderState===X&&Q.clippingPolygonShaderState===q)return Q.shaderProgram;let Z=this._shadersByTexturesFlags[i];if(defined(Z)||(Z=this._shadersByTexturesFlags[i]=[]),Q=Z[z],!defined(Q)||Q.material!==this.material||Q.clippingShaderState!==X||Q.clippingPolygonShaderState!==q){const K=this.baseVertexShaderSource.clone(),J=this.baseFragmentShaderSource.clone();X!==0&&J.sources.unshift(getClippingFunction(D,t.context)),q!==0&&(J.sources.unshift(getPolygonClippingFunction(t.context)),K.sources.unshift(getUnpackClippingFunction(t.context))),K.defines.push(w),J.defines.push(`TEXTURE_UNITS ${i}`,G,W),r&&J.defines.push("APPLY_BRIGHTNESS"),o&&J.defines.push("APPLY_CONTRAST"),a&&J.defines.push("APPLY_HUE"),s&&J.defines.push("APPLY_SATURATION"),l&&J.defines.push("APPLY_GAMMA"),c&&J.defines.push("APPLY_ALPHA"),d&&J.defines.push("APPLY_DAY_NIGHT_ALPHA"),f&&(J.defines.push("SHOW_REFLECTIVE_OCEAN"),K.defines.push("SHOW_REFLECTIVE_OCEAN")),p&&J.defines.push("SHOW_OCEAN_WAVES"),E&&J.defines.push("APPLY_COLOR_TO_ALPHA"),O&&(K.defines.push("UNDERGROUND_COLOR"),J.defines.push("UNDERGROUND_COLOR")),V&&(K.defines.push("TRANSLUCENT"),J.defines.push("TRANSLUCENT")),u&&(A?(K.defines.push("ENABLE_VERTEX_LIGHTING"),J.defines.push("ENABLE_VERTEX_LIGHTING")):(K.defines.push("ENABLE_DAYNIGHT_SHADING"),J.defines.push("ENABLE_DAYNIGHT_SHADING"))),m&&(K.defines.push("DYNAMIC_ATMOSPHERE_LIGHTING"),J.defines.push("DYNAMIC_ATMOSPHERE_LIGHTING"),g&&(K.defines.push("DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN"),J.defines.push("DYNAMIC_ATMOSPHERE_LIGHTING_FROM_SUN"))),_&&(K.defines.push("GROUND_ATMOSPHERE"),J.defines.push("GROUND_ATMOSPHERE"),C&&(K.defines.push("PER_FRAGMENT_GROUND_ATMOSPHERE"),J.defines.push("PER_FRAGMENT_GROUND_ATMOSPHERE"))),K.defines.push("INCLUDE_WEB_MERCATOR_Y"),J.defines.push("INCLUDE_WEB_MERCATOR_Y"),v&&(K.defines.push("FOG"),J.defines.push("FOG")),h&&J.defines.push("APPLY_SPLIT"),b&&J.defines.push("ENABLE_CLIPPING_PLANES"),I&&(J.defines.push("ENABLE_CLIPPING_POLYGONS"),K.defines.push("ENABLE_CLIPPING_POLYGONS"),L.inverse&&J.defines.push("CLIPPING_INVERSE"),J.defines.push(`CLIPPING_POLYGON_REGIONS_LENGTH ${L.extentsCount}`),K.defines.push(`CLIPPING_POLYGON_REGIONS_LENGTH ${L.extentsCount}`)),x&&J.defines.push("COLOR_CORRECT"),T&&J.defines.push("HIGHLIGHT_FILL_TILE"),P&&K.defines.push("GEODETIC_SURFACE_NORMALS"),M&&K.defines.push("EXAGGERATION");let se=`    vec4 computeDayColor(vec4 initialColor, vec3 textureCoordinates, float nightBlend)
    {
        vec4 color = initialColor;
`;y&&(se+=`        vec4 cutoutAndColorResult;
        bool texelUnclipped;
`);for(let te=0;te<i;++te)y?se+=`        cutoutAndColorResult = u_dayTextureCutoutRectangles[${te}];
        texelUnclipped = v_textureCoordinates.x < cutoutAndColorResult.x || cutoutAndColorResult.z < v_textureCoordinates.x || v_textureCoordinates.y < cutoutAndColorResult.y || cutoutAndColorResult.w < v_textureCoordinates.y;
        cutoutAndColorResult = sampleAndBlend(
`:se+=`        color = sampleAndBlend(
`,se+=`            color,
            u_dayTextures[${te}],
            u_dayTextureUseWebMercatorT[${te}] ? textureCoordinates.xz : textureCoordinates.xy,
            u_dayTextureTexCoordsRectangle[${te}],
            u_dayTextureTranslationAndScale[${te}],
            ${c?`u_dayTextureAlpha[${te}]`:"1.0"},
            ${d?`u_dayTextureNightAlpha[${te}]`:"1.0"},
${d?`u_dayTextureDayAlpha[${te}]`:"1.0"},
${r?`u_dayTextureBrightness[${te}]`:"0.0"},
            ${o?`u_dayTextureContrast[${te}]`:"0.0"},
            ${a?`u_dayTextureHue[${te}]`:"0.0"},
            ${s?`u_dayTextureSaturation[${te}]`:"0.0"},
            ${l?`u_dayTextureOneOverGamma[${te}]`:"0.0"},
            ${h?`u_dayTextureSplit[${te}]`:"0.0"},
            ${E?`u_colorsToAlpha[${te}]`:"vec4(0.0)"},
        nightBlend        );
`,y&&(se+=`        color = czm_branchFreeTernary(texelUnclipped, cutoutAndColorResult, color);
`);se+=`        return color;
    }`,J.sources.push(se),K.sources.push(getPositionMode(Y)),K.sources.push(get2DYPositionFraction(S));const ae=ShaderProgram.fromCache({context:t.context,vertexShaderSource:K,fragmentShaderSource:J,attributeLocations:k.getAttributeLocations()});Q=Z[z]=new GlobeSurfaceShader(i,z,this.material,ae,X,q)}return n.surfaceShader=Q,Q.shaderProgram};GlobeSurfaceShaderSet.prototype.destroy=function(){let e,t;const n=this._shadersByTexturesFlags;for(const i in n)if(n.hasOwnProperty(i)){const r=n[i];if(!defined(r))continue;for(e in r)r.hasOwnProperty(e)&&(t=r[e],defined(t)&&t.shaderProgram.destroy())}return destroyObject(this)};const Visibility={NONE:-1,PARTIAL:0,FULL:1},Visibility$1=Object.freeze(Visibility),QuadtreeTileLoadState={START:0,LOADING:1,DONE:2,FAILED:3},QuadtreeTileLoadState$1=Object.freeze(QuadtreeTileLoadState),TerrainState$1={FAILED:0,UNLOADED:1,RECEIVING:2,RECEIVED:3,TRANSFORMING:4,TRANSFORMED:5,READY:6},TerrainState$2=Object.freeze(TerrainState$1);function GlobeSurfaceTile(){this.imagery=[],this.waterMaskTexture=void 0,this.waterMaskTranslationAndScale=new Cartesian4(0,0,1,1),this.terrainData=void 0,this.vertexArray=void 0,this.tileBoundingRegion=void 0,this.occludeePointInScaledSpace=new Cartesian3,this.boundingVolumeSourceTile=void 0,this.boundingVolumeIsFromMesh=!1,this.terrainState=TerrainState$2.UNLOADED,this.mesh=void 0,this.fill=void 0,this.pickBoundingSphere=new BoundingSphere,this.surfaceShader=void 0,this.isClipped=!0,this.clippedByBoundaries=!1}Object.defineProperties(GlobeSurfaceTile.prototype,{eligibleForUnloading:{get:function(){const e=this.terrainState;let n=!(e===TerrainState$2.RECEIVING||e===TerrainState$2.TRANSFORMING);const i=this.imagery;for(let r=0,o=i.length;n&&r<o;++r){const a=i[r];n=!defined(a.loadingImagery)||a.loadingImagery.state!==ImageryState.TRANSITIONING}return n}},renderedMesh:{get:function(){if(defined(this.vertexArray))return this.mesh;if(defined(this.fill))return this.fill.mesh}}});const scratchCartographic$5=new Cartographic;function getPosition(e,t,n,i,r,o){let a=e.getExaggeratedPosition(i,r,o);if(defined(t)&&t!==SceneMode.SCENE3D){const l=n.ellipsoid.cartesianToCartographic(a,scratchCartographic$5);a=n.project(l,o),a=Cartesian3.fromElements(a.z,a.x,a.y,o)}return a}const scratchV0$1=new Cartesian3,scratchV1$1=new Cartesian3,scratchV2=new Cartesian3;GlobeSurfaceTile.prototype.pick=function(e,t,n,i,r){const o=this.renderedMesh;if(!defined(o))return;const a=o.vertices,s=o.indices,l=o.encoding,c=s.length;let d=Number.MAX_VALUE;for(let h=0;h<c;h+=3){const f=s[h],p=s[h+1],u=s[h+2],m=getPosition(l,t,n,a,f,scratchV0$1),g=getPosition(l,t,n,a,p,scratchV1$1),_=getPosition(l,t,n,a,u,scratchV2),C=IntersectionTests.rayTriangleParametric(e,m,g,_,i);defined(C)&&C<d&&C>=0&&(d=C)}return d!==Number.MAX_VALUE?Ray.getPoint(e,d,r):void 0};GlobeSurfaceTile.prototype.freeResources=function(){defined(this.waterMaskTexture)&&(--this.waterMaskTexture.referenceCount,this.waterMaskTexture.referenceCount===0&&this.waterMaskTexture.destroy(),this.waterMaskTexture=void 0),this.terrainData=void 0,this.terrainState=TerrainState$2.UNLOADED,this.mesh=void 0,this.fill=this.fill&&this.fill.destroy();const e=this.imagery;for(let t=0,n=e.length;t<n;++t)e[t].freeResources();this.imagery.length=0,this.freeVertexArray()};GlobeSurfaceTile.prototype.freeVertexArray=function(){GlobeSurfaceTile._freeVertexArray(this.vertexArray),this.vertexArray=void 0,GlobeSurfaceTile._freeVertexArray(this.wireframeVertexArray),this.wireframeVertexArray=void 0};GlobeSurfaceTile.initialize=function(e,t,n){let i=e.data;defined(i)||(i=e.data=new GlobeSurfaceTile),e.state===QuadtreeTileLoadState$1.START&&(prepareNewTile(e,t,n),e.state=QuadtreeTileLoadState$1.LOADING)};GlobeSurfaceTile.processStateMachine=function(e,t,n,i,r,o,a){GlobeSurfaceTile.initialize(e,n,i);const s=e.data;if(e.state===QuadtreeTileLoadState$1.LOADING&&processTerrainStateMachine(e,t,n,i,r,o),a)return;const l=e.renderable;e.renderable=defined(s.vertexArray);const c=s.terrainState===TerrainState$2.READY;e.upsampledFromParent=defined(s.terrainData)&&s.terrainData.wasCreatedByUpsampling();const d=s.processImagery(e,n,t);if(c&&d){const h=e._loadedCallbacks,f={};for(const p in h)h.hasOwnProperty(p)&&(h[p](e)||(f[p]=h[p]));e._loadedCallbacks=f,e.state=QuadtreeTileLoadState$1.DONE}l&&(e.renderable=!0)};GlobeSurfaceTile.prototype.processImagery=function(e,t,n,i){const r=e.data;let o=e.upsampledFromParent,a=!1,s=!0;const l=r.imagery;let c,d;for(c=0,d=l.length;c<d;++c){const h=l[c];if(!defined(h.loadingImagery)){o=!1;continue}if(h.loadingImagery.state===ImageryState.PLACEHOLDER){const p=h.loadingImagery.imageryLayer;if(p.ready){h.freeResources(),l.splice(c,1),p._createTileImagerySkeletons(e,t,c),--c,d=l.length;continue}else o=!1}const f=h.processStateMachine(e,n,i);s=s&&f,a=a||f||defined(h.readyImagery),o=o&&defined(h.loadingImagery)&&(h.loadingImagery.state===ImageryState.FAILED||h.loadingImagery.state===ImageryState.INVALID)}return e.upsampledFromParent=o,e.renderable=e.renderable&&(a||s),s};function toggleGeodeticSurfaceNormals(e,t,n,i){const r=e.renderedMesh,o=r.vertices,a=r.encoding,s=o.length/a.stride;let l=TerrainEncoding.clone(a);l.hasGeodeticSurfaceNormals=t,l=TerrainEncoding.clone(l);const c=l.stride,d=new Float32Array(s*c);t?a.addGeodeticSurfaceNormals(o,d,n):a.removeGeodeticSurfaceNormals(o,d),r.vertices=d,r.stride=c,r!==e.mesh?(GlobeSurfaceTile._freeVertexArray(e.fill.vertexArray),e.fill.vertexArray=GlobeSurfaceTile._createVertexArrayForMesh(i.context,r)):(GlobeSurfaceTile._freeVertexArray(e.vertexArray),e.vertexArray=GlobeSurfaceTile._createVertexArrayForMesh(i.context,r)),GlobeSurfaceTile._freeVertexArray(e.wireframeVertexArray),e.wireframeVertexArray=void 0}GlobeSurfaceTile.prototype.addGeodeticSurfaceNormals=function(e,t){toggleGeodeticSurfaceNormals(this,!0,e,t)};GlobeSurfaceTile.prototype.removeGeodeticSurfaceNormals=function(e){toggleGeodeticSurfaceNormals(this,!1,void 0,e)};GlobeSurfaceTile.prototype.updateExaggeration=function(e,t,n){const i=this,r=i.renderedMesh;if(r===void 0)return;const o=t.verticalExaggeration,a=t.verticalExaggerationRelativeHeight,s=o!==1,l=r.encoding,c=l.exaggeration!==o,d=l.exaggerationRelativeHeight!==a;if(c||d){if(c)if(s&&!l.hasGeodeticSurfaceNormals){const h=e.tilingScheme.ellipsoid;i.addGeodeticSurfaceNormals(h,t)}else!s&&l.hasGeodeticSurfaceNormals&&i.removeGeodeticSurfaceNormals(t);if(l.exaggeration=o,l.exaggerationRelativeHeight=a,n!==void 0){n._tileToUpdateHeights.push(e);const h=e.customData,f=h.length;for(let p=0;p<f;p++){const u=h[p];u.level=-1}}}};function prepareNewTile(e,t,n){let i=t.getTileDataAvailable(e.x,e.y,e.level);if(!defined(i)&&defined(e.parent)){const r=e.parent,o=r.data;defined(o)&&defined(o.terrainData)&&(i=o.terrainData.isChildAvailable(r.x,r.y,e.x,e.y))}i===!1&&(e.data.terrainState=TerrainState$2.FAILED);for(let r=0,o=n.length;r<o;++r){const a=n.get(r);a.show&&a._createTileImagerySkeletons(e,t)}}function processTerrainStateMachine(e,t,n,i,r,o){const a=e.data,s=e.parent;if(a.terrainState===TerrainState$2.FAILED&&s!==void 0&&(s.data!==void 0&&s.data.terrainData!==void 0&&s.data.terrainData.canUpsample!==!1||GlobeSurfaceTile.processStateMachine(s,t,n,i,r,o,!0)),a.terrainState===TerrainState$2.FAILED&&upsample(a,e,t,n,e.x,e.y,e.level),a.terrainState===TerrainState$2.UNLOADED&&requestTileGeometry$1(a,n,e.x,e.y,e.level),a.terrainState===TerrainState$2.RECEIVED&&transform(a,t,n,e.x,e.y,e.level),a.terrainState===TerrainState$2.TRANSFORMED&&(createResources$2(a,t.context,n,e.x,e.y,e.level,o),a.updateExaggeration(e,t,r)),a.terrainState>=TerrainState$2.RECEIVED&&a.waterMaskTexture===void 0&&n.hasWaterMask)if(a.terrainData.waterMask!==void 0)createWaterMaskTextureIfNeeded(t.context,a);else{const c=a._findAncestorTileWithTerrainData(e);defined(c)&&defined(c.data.waterMaskTexture)&&(a.waterMaskTexture=c.data.waterMaskTexture,++a.waterMaskTexture.referenceCount,a._computeWaterMaskTranslationAndScale(e,c,a.waterMaskTranslationAndScale))}}function upsample(e,t,n,i,r,o,a){const s=t.parent;if(!s){t.state=QuadtreeTileLoadState$1.FAILED;return}const l=s.data.terrainData,c=s.x,d=s.y,h=s.level;if(!defined(l))return;const f=l.upsample(i.tilingScheme,c,d,h,r,o,a);defined(f)&&(e.terrainState=TerrainState$2.RECEIVING,Promise.resolve(f).then(function(p){defined(p)&&(e.terrainData=p,e.terrainState=TerrainState$2.RECEIVED)}).catch(function(){e.terrainState=TerrainState$2.FAILED}))}function requestTileGeometry$1(e,t,n,i,r){function o(l){if(!defined(l)){e.terrainState=TerrainState$2.UNLOADED,e.request=void 0;return}e.terrainData=l,e.terrainState=TerrainState$2.RECEIVED,e.request=void 0}function a(l){if(e.request.state===RequestState.CANCELLED){e.terrainData=void 0,e.terrainState=TerrainState$2.UNLOADED,e.request=void 0;return}e.terrainState=TerrainState$2.FAILED,e.request=void 0;const c=`Failed to obtain terrain tile X: ${n} Y: ${i} Level: ${r}. Error message: "${l}"`;t._requestError=TileProviderError.reportError(t._requestError,t,t.errorEvent,c,n,i,r),t._requestError.retry&&s()}function s(){const l=new Request({throttle:!1,throttleByServer:!0,type:RequestType.TERRAIN});e.request=l;const c=t.requestTileGeometry(n,i,r,l);defined(c)?(e.terrainState=TerrainState$2.RECEIVING,Promise.resolve(c).then(function(d){o(d)}).catch(function(d){a(d)})):(e.terrainState=TerrainState$2.UNLOADED,e.request=void 0)}s()}const scratchCreateMeshOptions={tilingScheme:void 0,x:0,y:0,level:0,exaggeration:1,exaggerationRelativeHeight:0,throttle:!0};function transform(e,t,n,i,r,o){const a=n.tilingScheme,s=scratchCreateMeshOptions;s.tilingScheme=a,s.x=i,s.y=r,s.level=o,s.exaggeration=t.verticalExaggeration,s.exaggerationRelativeHeight=t.verticalExaggerationRelativeHeight,s.throttle=!0;const c=e.terrainData.createMesh(s);defined(c)&&(e.terrainState=TerrainState$2.TRANSFORMING,Promise.resolve(c).then(function(d){e.mesh=d,e.terrainState=TerrainState$2.TRANSFORMED}).catch(function(){e.terrainState=TerrainState$2.FAILED}))}GlobeSurfaceTile._createVertexArrayForMesh=function(e,t){const n=t.vertices,i=Buffer.createVertexBuffer({context:e,typedArray:n,usage:BufferUsage.STATIC_DRAW}),r=t.encoding.getAttributes(i),o=t.indices.indexBuffers||{};let a=o[e.id];if(!defined(a)||a.isDestroyed()){const s=t.indices;a=Buffer.createIndexBuffer({context:e,typedArray:s,usage:BufferUsage.STATIC_DRAW,indexDatatype:IndexDatatype.fromSizeInBytes(s.BYTES_PER_ELEMENT)}),a.vertexArrayDestroyable=!1,a.referenceCount=1,o[e.id]=a,t.indices.indexBuffers=o}else++a.referenceCount;return new VertexArray({context:e,attributes:r,indexBuffer:a})};GlobeSurfaceTile._freeVertexArray=function(e){if(defined(e)){const t=e.indexBuffer;e.isDestroyed()||e.destroy(),defined(t)&&!t.isDestroyed()&&defined(t.referenceCount)&&(--t.referenceCount,t.referenceCount===0&&t.destroy())}};function createResources$2(e,t,n,i,r,o,a){e.vertexArray=GlobeSurfaceTile._createVertexArrayForMesh(t,e.mesh),e.terrainState=TerrainState$2.READY,e.fill=e.fill&&e.fill.destroy(a)}function getContextWaterMaskData(e){let t=e.cache.tile_waterMaskData;if(!defined(t)){const n=Texture.create({context:e,pixelFormat:PixelFormat.LUMINANCE,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,source:{arrayBufferView:new Uint8Array([255]),width:1,height:1}});n.referenceCount=1;const i=new Sampler({wrapS:TextureWrap.CLAMP_TO_EDGE,wrapT:TextureWrap.CLAMP_TO_EDGE,minificationFilter:TextureMinificationFilter.LINEAR,magnificationFilter:TextureMagnificationFilter.LINEAR});t={allWaterTexture:n,sampler:i,destroy:function(){this.allWaterTexture.destroy()}},e.cache.tile_waterMaskData=t}return t}function createWaterMaskTextureIfNeeded(e,t){const n=t.terrainData.waterMask,i=getContextWaterMaskData(e);let r;const o=n.length;if(o===1)if(n[0]!==0)r=i.allWaterTexture;else return;else{const a=Math.sqrt(o);r=Texture.create({context:e,pixelFormat:PixelFormat.LUMINANCE,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,source:{width:a,height:a,arrayBufferView:n},sampler:i.sampler,flipY:!1}),r.referenceCount=0}++r.referenceCount,t.waterMaskTexture=r,Cartesian4.fromElements(0,0,1,1,t.waterMaskTranslationAndScale)}GlobeSurfaceTile.prototype._findAncestorTileWithTerrainData=function(e){let t=e.parent;for(;defined(t)&&(!defined(t.data)||!defined(t.data.terrainData)||t.data.terrainData.wasCreatedByUpsampling());)t=t.parent;return t};GlobeSurfaceTile.prototype._computeWaterMaskTranslationAndScale=function(e,t,n){const i=t.rectangle,r=e.rectangle,o=r.width,a=r.height,s=o/i.width,l=a/i.height;return n.x=s*(r.west-i.west)/o,n.y=l*(r.south-i.south)/a,n.z=s,n.w=l,n};const TileEdge={WEST:0,NORTH:1,EAST:2,SOUTH:3,NORTHWEST:4,NORTHEAST:5,SOUTHWEST:6,SOUTHEAST:7},TileEdge$1=TileEdge,TileSelectionResult={NONE:0,CULLED:1,RENDERED:2,REFINED:3,RENDERED_AND_KICKED:6,REFINED_AND_KICKED:7,CULLED_BUT_NEEDED:9,wasKicked:function(e){return e>=TileSelectionResult.RENDERED_AND_KICKED},originalResult:function(e){return e&3},kick:function(e){return e|4}},TileSelectionResult$1=TileSelectionResult;function TerrainFillMesh(e){this.tile=e,this.frameLastUpdated=void 0,this.westMeshes=[],this.westTiles=[],this.southMeshes=[],this.southTiles=[],this.eastMeshes=[],this.eastTiles=[],this.northMeshes=[],this.northTiles=[],this.southwestMesh=void 0,this.southwestTile=void 0,this.southeastMesh=void 0,this.southeastTile=void 0,this.northwestMesh=void 0,this.northwestTile=void 0,this.northeastMesh=void 0,this.northeastTile=void 0,this.changedThisFrame=!0,this.visitedFrame=void 0,this.enqueuedFrame=void 0,this.mesh=void 0,this.vertexArray=void 0,this.waterMaskTexture=void 0,this.waterMaskTranslationAndScale=new Cartesian4}TerrainFillMesh.prototype.update=function(e,t,n){this.changedThisFrame&&(createFillMesh(e,t,this.tile,n),this.changedThisFrame=!1)};TerrainFillMesh.prototype.destroy=function(e){this._destroyVertexArray(e),defined(this.waterMaskTexture)&&(--this.waterMaskTexture.referenceCount,this.waterMaskTexture.referenceCount===0&&this.waterMaskTexture.destroy(),this.waterMaskTexture=void 0)};TerrainFillMesh.prototype._destroyVertexArray=function(e){defined(this.vertexArray)&&(defined(e)?e.push(this.vertexArray):GlobeSurfaceTile._freeVertexArray(this.vertexArray),this.vertexArray=void 0)};const traversalQueueScratch=new Queue;TerrainFillMesh.updateFillTiles=function(e,t,n,i){const r=e._quadtree,o=r._levelZeroTiles,a=r._lastSelectionFrameNumber,s=traversalQueueScratch;s.clear();for(let c=0;c<t.length;++c){const d=t[c];defined(d.data.vertexArray)&&s.enqueue(t[c])}let l=s.dequeue();for(;l!==void 0;){const c=l.findTileToWest(o),d=l.findTileToSouth(o),h=l.findTileToEast(o),f=l.findTileToNorth(o);visitRenderedTiles(e,n,l,c,a,TileEdge$1.EAST,!1,s,i),visitRenderedTiles(e,n,l,d,a,TileEdge$1.NORTH,!1,s,i),visitRenderedTiles(e,n,l,h,a,TileEdge$1.WEST,!1,s,i),visitRenderedTiles(e,n,l,f,a,TileEdge$1.SOUTH,!1,s,i);const p=c.findTileToNorth(o),u=c.findTileToSouth(o),m=h.findTileToNorth(o),g=h.findTileToSouth(o);visitRenderedTiles(e,n,l,p,a,TileEdge$1.SOUTHEAST,!1,s,i),visitRenderedTiles(e,n,l,m,a,TileEdge$1.SOUTHWEST,!1,s,i),visitRenderedTiles(e,n,l,u,a,TileEdge$1.NORTHEAST,!1,s,i),visitRenderedTiles(e,n,l,g,a,TileEdge$1.NORTHWEST,!1,s,i),l=s.dequeue()}};function visitRenderedTiles(e,t,n,i,r,o,a,s,l){if(i===void 0)return;let c=i;for(;c&&(c._lastSelectionResultFrame!==r||TileSelectionResult$1.wasKicked(c._lastSelectionResult)||TileSelectionResult$1.originalResult(c._lastSelectionResult)===TileSelectionResult$1.CULLED);){if(a)return;const d=c.parent;if(o>=TileEdge$1.NORTHWEST&&d!==void 0)switch(o){case TileEdge$1.NORTHWEST:c=c===d.northwestChild?d:void 0;break;case TileEdge$1.NORTHEAST:c=c===d.northeastChild?d:void 0;break;case TileEdge$1.SOUTHWEST:c=c===d.southwestChild?d:void 0;break;case TileEdge$1.SOUTHEAST:c=c===d.southeastChild?d:void 0;break}else c=d}if(c!==void 0){if(c._lastSelectionResult===TileSelectionResult$1.RENDERED){if(defined(c.data.vertexArray))return;visitTile$1(e,t,n,c,o,r,s,l);return}if(TileSelectionResult$1.originalResult(i._lastSelectionResult)!==TileSelectionResult$1.CULLED)switch(o){case TileEdge$1.WEST:visitRenderedTiles(e,t,n,i.northwestChild,r,o,!0,s,l),visitRenderedTiles(e,t,n,i.southwestChild,r,o,!0,s,l);break;case TileEdge$1.EAST:visitRenderedTiles(e,t,n,i.southeastChild,r,o,!0,s,l),visitRenderedTiles(e,t,n,i.northeastChild,r,o,!0,s,l);break;case TileEdge$1.SOUTH:visitRenderedTiles(e,t,n,i.southwestChild,r,o,!0,s,l),visitRenderedTiles(e,t,n,i.southeastChild,r,o,!0,s,l);break;case TileEdge$1.NORTH:visitRenderedTiles(e,t,n,i.northeastChild,r,o,!0,s,l),visitRenderedTiles(e,t,n,i.northwestChild,r,o,!0,s,l);break;case TileEdge$1.NORTHWEST:visitRenderedTiles(e,t,n,i.northwestChild,r,o,!0,s,l);break;case TileEdge$1.NORTHEAST:visitRenderedTiles(e,t,n,i.northeastChild,r,o,!0,s,l);break;case TileEdge$1.SOUTHWEST:visitRenderedTiles(e,t,n,i.southwestChild,r,o,!0,s,l);break;case TileEdge$1.SOUTHEAST:visitRenderedTiles(e,t,n,i.southeastChild,r,o,!0,s,l);break;default:throw new DeveloperError("Invalid edge")}}}function visitTile$1(e,t,n,i,r,o,a,s){const l=i.data;if(l.fill===void 0)l.fill=new TerrainFillMesh(i);else if(l.fill.visitedFrame===o)return;l.fill.enqueuedFrame!==o&&(l.fill.enqueuedFrame=o,l.fill.changedThisFrame=!1,a.enqueue(i)),propagateEdge(e,t,n,i,r,s)}function propagateEdge(e,t,n,i,r,o){const a=i.data.fill;let s;const l=n.data.fill;defined(l)?(l.visitedFrame=t.frameNumber,l.changedThisFrame&&(createFillMesh(e,t,n,o),l.changedThisFrame=!1),s=n.data.fill.mesh):s=n.data.mesh;let c,d;switch(r){case TileEdge$1.WEST:c=a.westMeshes,d=a.westTiles;break;case TileEdge$1.SOUTH:c=a.southMeshes,d=a.southTiles;break;case TileEdge$1.EAST:c=a.eastMeshes,d=a.eastTiles;break;case TileEdge$1.NORTH:c=a.northMeshes,d=a.northTiles;break;case TileEdge$1.NORTHWEST:a.changedThisFrame=a.changedThisFrame||a.northwestMesh!==s,a.northwestMesh=s,a.northwestTile=n;return;case TileEdge$1.NORTHEAST:a.changedThisFrame=a.changedThisFrame||a.northeastMesh!==s,a.northeastMesh=s,a.northeastTile=n;return;case TileEdge$1.SOUTHWEST:a.changedThisFrame=a.changedThisFrame||a.southwestMesh!==s,a.southwestMesh=s,a.southwestTile=n;return;case TileEdge$1.SOUTHEAST:a.changedThisFrame=a.changedThisFrame||a.southeastMesh!==s,a.southeastMesh=s,a.southeastTile=n;return}if(n.level<=i.level){a.changedThisFrame=a.changedThisFrame||c[0]!==s||c.length!==1,c[0]=s,d[0]=n,c.length=1,d.length=1;return}let h,f,p,u;const m=n.rectangle;let g;const _=i.rectangle;switch(r){case TileEdge$1.WEST:for(g=(_.north-_.south)*CesiumMath.EPSILON5,h=0;h<d.length&&(p=d[h],u=p.rectangle,!CesiumMath.greaterThan(m.north,u.south,g));++h);for(f=h;f<d.length&&(p=d[f],u=p.rectangle,!CesiumMath.greaterThanOrEquals(m.south,u.north,g));++f);break;case TileEdge$1.SOUTH:for(g=(_.east-_.west)*CesiumMath.EPSILON5,h=0;h<d.length&&(p=d[h],u=p.rectangle,!CesiumMath.lessThan(m.west,u.east,g));++h);for(f=h;f<d.length&&(p=d[f],u=p.rectangle,!CesiumMath.lessThanOrEquals(m.east,u.west,g));++f);break;case TileEdge$1.EAST:for(g=(_.north-_.south)*CesiumMath.EPSILON5,h=0;h<d.length&&(p=d[h],u=p.rectangle,!CesiumMath.lessThan(m.south,u.north,g));++h);for(f=h;f<d.length&&(p=d[f],u=p.rectangle,!CesiumMath.lessThanOrEquals(m.north,u.south,g));++f);break;case TileEdge$1.NORTH:for(g=(_.east-_.west)*CesiumMath.EPSILON5,h=0;h<d.length&&(p=d[h],u=p.rectangle,!CesiumMath.greaterThan(m.east,u.west,g));++h);for(f=h;f<d.length&&(p=d[f],u=p.rectangle,!CesiumMath.greaterThanOrEquals(m.west,u.east,g));++f);break}f-h===1?(a.changedThisFrame=a.changedThisFrame||c[h]!==s,c[h]=s,d[h]=n):(a.changedThisFrame=!0,c.splice(h,f-h,s),d.splice(h,f-h,n))}const cartographicScratch$1=new Cartographic,centerCartographicScratch=new Cartographic,cartesianScratch=new Cartesian3,normalScratch$1=new Cartesian3,octEncodedNormalScratch=new Cartesian2,uvScratch2=new Cartesian2,uvScratch=new Cartesian2;function HeightAndNormal(){this.height=0,this.encodedNormal=new Cartesian2}function fillMissingCorner(e,t,n,i,r,o,a,s,l){if(defined(r))return r;let c;if(defined(o)&&defined(a))c=(o.height+a.height)*.5;else if(defined(o))c=o.height;else if(defined(a))c=a.height;else if(defined(s))c=s.height;else{const h=e.tile.data.tileBoundingRegion;let f=0,p=0;defined(h)&&(f=h.minimumHeight,p=h.maximumHeight),c=(f+p)*.5}return getVertexWithHeightAtCorner(e,t,n,i,c,l),l}const heightRangeScratch={minimumHeight:0,maximumHeight:0},scratchCenter$3=new Cartesian3,swVertexScratch=new HeightAndNormal,seVertexScratch=new HeightAndNormal,nwVertexScratch=new HeightAndNormal,neVertexScratch=new HeightAndNormal,heightmapBuffer=typeof Uint8Array<"u"?new Uint8Array(9*9):void 0,scratchCreateMeshSyncOptions={tilingScheme:void 0,x:0,y:0,level:0,exaggeration:1,exaggerationRelativeHeight:0};function createFillMesh(e,t,n,i){GlobeSurfaceTile.initialize(n,e.terrainProvider,e._imageryLayers);const r=n.data,o=r.fill,a=n.rectangle,s=t.verticalExaggeration,l=t.verticalExaggerationRelativeHeight,c=s!==1,d=n.tilingScheme.ellipsoid;let h=getCorner(o,d,0,1,o.northwestTile,o.northwestMesh,o.northTiles,o.northMeshes,o.westTiles,o.westMeshes,nwVertexScratch),f=getCorner(o,d,0,0,o.southwestTile,o.southwestMesh,o.westTiles,o.westMeshes,o.southTiles,o.southMeshes,swVertexScratch),p=getCorner(o,d,1,0,o.southeastTile,o.southeastMesh,o.southTiles,o.southMeshes,o.eastTiles,o.eastMeshes,seVertexScratch),u=getCorner(o,d,1,1,o.northeastTile,o.northeastMesh,o.eastTiles,o.eastMeshes,o.northTiles,o.northMeshes,neVertexScratch);h=fillMissingCorner(o,d,0,1,h,f,u,p,nwVertexScratch),f=fillMissingCorner(o,d,0,0,f,h,p,u,swVertexScratch),p=fillMissingCorner(o,d,1,1,p,f,u,h,seVertexScratch),u=fillMissingCorner(o,d,1,1,u,p,h,f,neVertexScratch);const m=f.height,g=p.height,_=h.height,C=u.height;let A=Math.min(m,g,_,C),S=Math.max(m,g,_,C);const v=(A+S)*.5;let b,D;const I=e.getLevelMaximumGeometricError(n.level),L=d.maximumRadius-I;let N=Math.acos(L/d.maximumRadius)*4;if(N*=1.5,a.width>N&&S-A<=I){const T=new HeightmapTerrainData({width:9,height:9,buffer:heightmapBuffer,structure:{heightOffset:S}}),E=scratchCreateMeshSyncOptions;E.tilingScheme=n.tilingScheme,E.x=n.x,E.y=n.y,E.level=n.level,E.exaggeration=s,E.exaggerationRelativeHeight=l,o.mesh=T._createMeshSync(E)}else{const T=c,E=Rectangle.center(a,centerCartographicScratch);E.height=v;const P=d.cartographicToCartesian(E,scratchCenter$3),M=new TerrainEncoding(P,void 0,void 0,void 0,void 0,!0,!0,T,s,l);let O=5,V;for(V=o.westMeshes,b=0,D=V.length;b<D;++b)O+=V[b].eastIndicesNorthToSouth.length;for(V=o.southMeshes,b=0,D=V.length;b<D;++b)O+=V[b].northIndicesWestToEast.length;for(V=o.eastMeshes,b=0,D=V.length;b<D;++b)O+=V[b].westIndicesSouthToNorth.length;for(V=o.northMeshes,b=0,D=V.length;b<D;++b)O+=V[b].southIndicesEastToWest.length;const R=heightRangeScratch;R.minimumHeight=A,R.maximumHeight=S;const w=M.stride;let U=new Float32Array(O*w),k=0;const H=k;k=addVertexWithComputedPosition(d,a,M,U,k,0,1,h.height,h.encodedNormal,1,R),k=addEdge(o,d,M,U,k,o.westTiles,o.westMeshes,TileEdge$1.EAST,R);const F=k;k=addVertexWithComputedPosition(d,a,M,U,k,0,0,f.height,f.encodedNormal,0,R),k=addEdge(o,d,M,U,k,o.southTiles,o.southMeshes,TileEdge$1.NORTH,R);const G=k;k=addVertexWithComputedPosition(d,a,M,U,k,1,0,p.height,p.encodedNormal,0,R),k=addEdge(o,d,M,U,k,o.eastTiles,o.eastMeshes,TileEdge$1.WEST,R);const B=k;k=addVertexWithComputedPosition(d,a,M,U,k,1,1,u.height,u.encodedNormal,1,R),k=addEdge(o,d,M,U,k,o.northTiles,o.northMeshes,TileEdge$1.SOUTH,R),A=R.minimumHeight,S=R.maximumHeight;const W=OrientedBoundingBox.fromRectangle(a,A,S,n.tilingScheme.ellipsoid),Y=WebMercatorProjection.geodeticLatitudeToMercatorAngle(a.south),z=1/(WebMercatorProjection.geodeticLatitudeToMercatorAngle(a.north)-Y),X=(WebMercatorProjection.geodeticLatitudeToMercatorAngle(E.latitude)-Y)*z,q=d.geodeticSurfaceNormalCartographic(cartographicScratch$1,normalScratch$1),Q=AttributeCompression.octEncode(q,octEncodedNormalScratch),Z=k;M.encode(U,k*w,W.center,Cartesian2.fromElements(.5,.5,uvScratch),v,Q,X,q),++k;const K=k,J=K<256?1:2,se=(K-1)*3,ae=se*J,te=(U.length-K*w)*Float32Array.BYTES_PER_ELEMENT;let ee;if(te>=ae){const j=K*w*Float32Array.BYTES_PER_ELEMENT;ee=K<256?new Uint8Array(U.buffer,j,se):new Uint16Array(U.buffer,j,se)}else ee=K<256?new Uint8Array(se):new Uint16Array(se);U=new Float32Array(U.buffer,0,K*w);let ce=0;for(b=0;b<K-2;++b)ee[ce++]=Z,ee[ce++]=b,ee[ce++]=b+1;ee[ce++]=Z,ee[ce++]=b,ee[ce++]=0;const re=[];for(b=F;b>=H;--b)re.push(b);const ne=[];for(b=G;b>=F;--b)ne.push(b);const le=[];for(b=B;b>=G;--b)le.push(b);const $=[];for($.push(0),b=Z-1;b>=B;--b)$.push(b);o.mesh=new TerrainMesh(M.center,U,ee,se,K,A,S,BoundingSphere.fromOrientedBoundingBox(W),computeOccludeePoint$1(e,W.center,a,A,S),M.stride,W,M,re,ne,le,$)}const y=t.context;o._destroyVertexArray(i),o.vertexArray=GlobeSurfaceTile._createVertexArrayForMesh(y,o.mesh),r.processImagery(n,e.terrainProvider,t,!0);const x=o.waterMaskTexture;if(o.waterMaskTexture=void 0,e.terrainProvider.hasWaterMask){const T=r._findAncestorTileWithTerrainData(n);defined(T)&&defined(T.data.waterMaskTexture)&&(o.waterMaskTexture=T.data.waterMaskTexture,++o.waterMaskTexture.referenceCount,r._computeWaterMaskTranslationAndScale(n,T,o.waterMaskTranslationAndScale))}defined(x)&&(--x.referenceCount,x.referenceCount===0&&x.destroy())}function addVertexWithComputedPosition(e,t,n,i,r,o,a,s,l,c,d){const h=cartographicScratch$1;h.longitude=CesiumMath.lerp(t.west,t.east,o),h.latitude=CesiumMath.lerp(t.south,t.north,a),h.height=s;const f=e.cartographicToCartesian(h,cartesianScratch);let p;n.hasGeodeticSurfaceNormals&&(p=e.geodeticSurfaceNormal(f,normalScratch$1));const u=uvScratch2;return u.x=o,u.y=a,n.encode(i,r*n.stride,f,u,s,l,c,p),d.minimumHeight=Math.min(d.minimumHeight,s),d.maximumHeight=Math.max(d.maximumHeight,s),r+1}const sourceRectangleScratch=new Rectangle;function transformTextureCoordinates(e,t,n,i){let r=e.rectangle;const o=t.rectangle;t.x===0&&n.x===1&&e.x===e.tilingScheme.getNumberOfXTilesAtLevel(e.level)-1?(r=Rectangle.clone(e.rectangle,sourceRectangleScratch),r.west-=CesiumMath.TWO_PI,r.east-=CesiumMath.TWO_PI):e.x===0&&n.x===0&&t.x===t.tilingScheme.getNumberOfXTilesAtLevel(t.level)-1&&(r=Rectangle.clone(e.rectangle,sourceRectangleScratch),r.west+=CesiumMath.TWO_PI,r.east+=CesiumMath.TWO_PI);const a=r.east-r.west,s=(o.west-r.west)/a,l=(o.east-r.west)/a,c=r.north-r.south,d=(o.south-r.south)/c,h=(o.north-r.south)/c;let f=(n.x-s)/(l-s),p=(n.y-d)/(h-d);return Math.abs(f)<Math.EPSILON5?f=0:Math.abs(f-1)<Math.EPSILON5&&(f=1),Math.abs(p)<Math.EPSILON5?p=0:Math.abs(p-1)<Math.EPSILON5&&(p=1),i.x=f,i.y=p,i}const encodedNormalScratch=new Cartesian2;function getVertexFromTileAtCorner(e,t,n,i,r){const o=e.encoding,a=e.vertices;if(r.height=o.decodeHeight(a,t),o.hasVertexNormals)o.getOctEncodedNormal(a,t,r.encodedNormal);else{const s=r.encodedNormal;s.x=0,s.y=0}}const encodedNormalScratch2=new Cartesian2,cartesianScratch2=new Cartesian3;function getInterpolatedVertexAtCorner(e,t,n,i,r,o,a,s,l,c){const d=i.encoding,h=i.vertices,f=transformTextureCoordinates(t,n,d.decodeTextureCoordinates(h,r,uvScratch),uvScratch),p=transformTextureCoordinates(t,n,d.decodeTextureCoordinates(h,o,uvScratch2),uvScratch2);let u;l?u=(a-f.x)/(p.x-f.x):u=(s-f.y)/(p.y-f.y);const m=d.decodeHeight(h,r),g=d.decodeHeight(h,o),_=n.rectangle;cartographicScratch$1.longitude=CesiumMath.lerp(_.west,_.east,a),cartographicScratch$1.latitude=CesiumMath.lerp(_.south,_.north,s),c.height=cartographicScratch$1.height=CesiumMath.lerp(m,g,u);let C;if(d.hasVertexNormals){const A=d.getOctEncodedNormal(h,r,encodedNormalScratch),S=d.getOctEncodedNormal(h,o,encodedNormalScratch2),v=AttributeCompression.octDecode(A.x,A.y,cartesianScratch),b=AttributeCompression.octDecode(S.x,S.y,cartesianScratch2);C=Cartesian3.lerp(v,b,u,cartesianScratch),Cartesian3.normalize(C,C),AttributeCompression.octEncode(C,c.encodedNormal)}else C=e.geodeticSurfaceNormalCartographic(cartographicScratch$1,cartesianScratch),AttributeCompression.octEncode(C,c.encodedNormal)}function getVertexWithHeightAtCorner(e,t,n,i,r,o){o.height=r;const a=t.geodeticSurfaceNormalCartographic(cartographicScratch$1,cartesianScratch);AttributeCompression.octEncode(a,o.encodedNormal)}function getCorner(e,t,n,i,r,o,a,s,l,c,d){if(getCornerFromEdge(e,t,s,a,!1,n,i,d)||getCornerFromEdge(e,t,c,l,!0,n,i,d))return d;let f;if(meshIsUsable(r,o))return n===0?i===0?f=o.eastIndicesNorthToSouth[0]:f=o.southIndicesEastToWest[0]:i===0?f=o.northIndicesWestToEast[0]:f=o.westIndicesSouthToNorth[0],getVertexFromTileAtCorner(o,f,n,i,d),d;let p;if(n===0?i===0?p=getClosestHeightToCorner(e.westMeshes,e.westTiles,TileEdge$1.EAST,e.southMeshes,e.southTiles,TileEdge$1.NORTH):p=getClosestHeightToCorner(e.northMeshes,e.northTiles,TileEdge$1.SOUTH,e.westMeshes,e.westTiles,TileEdge$1.EAST):i===0?p=getClosestHeightToCorner(e.southMeshes,e.southTiles,TileEdge$1.NORTH,e.eastMeshes,e.eastTiles,TileEdge$1.WEST):p=getClosestHeightToCorner(e.eastMeshes,e.eastTiles,TileEdge$1.WEST,e.northMeshes,e.northTiles,TileEdge$1.SOUTH),defined(p))return getVertexWithHeightAtCorner(e,t,n,i,p,d),d}function getClosestHeightToCorner(e,t,n,i,r,o,a,s){const l=getNearestHeightOnEdge(e,t,!1,n),c=getNearestHeightOnEdge(i,r,!0,o);return defined(l)&&defined(c)?(l+c)*.5:defined(l)?l:c}function addEdge(e,t,n,i,r,o,a,s,l){for(let c=0;c<o.length;++c)r=addEdgeMesh(e,t,n,i,r,o[c],a[c],s,l);return r}function addEdgeMesh(e,t,n,i,r,o,a,s,l){let c=o.rectangle;s===TileEdge$1.EAST&&e.tile.x===0?(c=Rectangle.clone(o.rectangle,sourceRectangleScratch),c.west-=CesiumMath.TWO_PI,c.east-=CesiumMath.TWO_PI):s===TileEdge$1.WEST&&o.x===0&&(c=Rectangle.clone(o.rectangle,sourceRectangleScratch),c.west+=CesiumMath.TWO_PI,c.east+=CesiumMath.TWO_PI);const d=e.tile.rectangle;let h,f;r>0&&(n.decodeTextureCoordinates(i,r-1,uvScratch),h=uvScratch.x,f=uvScratch.y);let p,u;switch(s){case TileEdge$1.WEST:p=a.westIndicesSouthToNorth,u=!1;break;case TileEdge$1.NORTH:p=a.northIndicesWestToEast,u=!0;break;case TileEdge$1.EAST:p=a.eastIndicesNorthToSouth,u=!1;break;case TileEdge$1.SOUTH:p=a.southIndicesEastToWest,u=!0;break}const m=o,g=e.tile,_=a.encoding,C=a.vertices,A=n.stride;let S,v;_.hasWebMercatorT&&(S=WebMercatorProjection.geodeticLatitudeToMercatorAngle(d.south),v=1/(WebMercatorProjection.geodeticLatitudeToMercatorAngle(d.north)-S));for(let b=0;b<p.length;++b){const D=p[b],I=_.decodeTextureCoordinates(C,D,uvScratch);transformTextureCoordinates(m,g,I,I);const L=I.x,N=I.y,y=u?L:N;if(y<0||y>1||Math.abs(L-h)<CesiumMath.EPSILON5&&Math.abs(N-f)<CesiumMath.EPSILON5)continue;const x=Math.abs(L)<CesiumMath.EPSILON5||Math.abs(L-1)<CesiumMath.EPSILON5,T=Math.abs(N)<CesiumMath.EPSILON5||Math.abs(N-1)<CesiumMath.EPSILON5;if(x&&T)continue;const E=_.decodePosition(C,D,cartesianScratch),P=_.decodeHeight(C,D);let M;_.hasVertexNormals?M=_.getOctEncodedNormal(C,D,octEncodedNormalScratch):(M=octEncodedNormalScratch,M.x=0,M.y=0);let O=N;if(_.hasWebMercatorT){const R=CesiumMath.lerp(d.south,d.north,N);O=(WebMercatorProjection.geodeticLatitudeToMercatorAngle(R)-S)*v}let V;n.hasGeodeticSurfaceNormals&&(V=t.geodeticSurfaceNormal(E,normalScratch$1)),n.encode(i,r*A,E,I,P,M,O,V),l.minimumHeight=Math.min(l.minimumHeight,P),l.maximumHeight=Math.max(l.maximumHeight,P),++r}return r}function getNearestHeightOnEdge(e,t,n,i,r,o){let a,s,l;n?(a=0,s=e.length,l=1):(a=e.length-1,s=-1,l=-1);for(let c=a;c!==s;c+=l){const d=e[c],h=t[c];if(!meshIsUsable(h,d))continue;let f;switch(i){case TileEdge$1.WEST:f=d.westIndicesSouthToNorth;break;case TileEdge$1.SOUTH:f=d.southIndicesEastToWest;break;case TileEdge$1.EAST:f=d.eastIndicesNorthToSouth;break;case TileEdge$1.NORTH:f=d.northIndicesWestToEast;break}const p=f[n?0:f.length-1];if(defined(p))return d.encoding.decodeHeight(d.vertices,p)}}function meshIsUsable(e,t){return defined(t)&&(!defined(e.data.fill)||!e.data.fill.changedThisFrame)}function getCornerFromEdge(e,t,n,i,r,o,a,s){let l,c,d,h,f;const p=i[r?0:n.length-1],u=n[r?0:n.length-1];if(meshIsUsable(p,u)&&(o===0?a===0?(l=r?u.northIndicesWestToEast:u.eastIndicesNorthToSouth,c=r,d=r):(l=r?u.eastIndicesNorthToSouth:u.southIndicesEastToWest,c=!r,d=!1):a===0?(l=r?u.westIndicesSouthToNorth:u.northIndicesWestToEast,c=!r,d=!0):(l=r?u.southIndicesEastToWest:u.westIndicesSouthToNorth,c=r,d=!r),l.length>0)){h=r?0:l.length-1,f=l[h],u.encoding.decodeTextureCoordinates(u.vertices,f,uvScratch);const m=transformTextureCoordinates(p,e.tile,uvScratch,uvScratch);if(m.x===o&&m.y===a)return getVertexFromTileAtCorner(u,f,o,a,s),!0;if(h=binarySearch(l,c?o:a,function(g,_){u.encoding.decodeTextureCoordinates(u.vertices,g,uvScratch);const C=transformTextureCoordinates(p,e.tile,uvScratch,uvScratch);return d?c?C.x-o:C.y-a:c?o-C.x:a-C.y}),h<0){if(h=~h,h>0&&h<l.length)return getInterpolatedVertexAtCorner(t,p,e.tile,u,l[h-1],l[h],o,a,c,s),!0}else return getVertexFromTileAtCorner(u,l[h],o,a,s),!0}return!1}const cornerPositionsScratch$1=[new Cartesian3,new Cartesian3,new Cartesian3,new Cartesian3];function computeOccludeePoint$1(e,t,n,i,r,o){const a=e.quadtree._occluders.ellipsoid,s=a.ellipsoid,l=cornerPositionsScratch$1;return Cartesian3.fromRadians(n.west,n.south,r,s,l[0]),Cartesian3.fromRadians(n.east,n.south,r,s,l[1]),Cartesian3.fromRadians(n.west,n.north,r,s,l[2]),Cartesian3.fromRadians(n.east,n.north,r,s,l[3]),a.computeHorizonCullingPointPossiblyUnderEllipsoid(t,l,i,o)}function GlobeSurfaceTileProvider(e){if(!defined(e))throw new DeveloperError("options is required.");if(defined(e.terrainProvider))if(defined(e.imageryLayers)){if(!defined(e.surfaceShaderSet))throw new DeveloperError("options.surfaceShaderSet is required.")}else throw new DeveloperError("options.imageryLayers is required.");else throw new DeveloperError("options.terrainProvider is required.");this.lightingFadeOutDistance=65e5,this.lightingFadeInDistance=9e6,this.hasWaterMask=!1,this.oceanNormalMap=void 0,this.zoomedOutOceanSpecularIntensity=.5,this.enableLighting=!1,this.dynamicAtmosphereLighting=!1,this.dynamicAtmosphereLightingFromSun=!1,this.showGroundAtmosphere=!1,this.shadows=ShadowMode.RECEIVE_ONLY,this.vertexShadowDarkness=.3,this.fillHighlightColor=void 0,this.hueShift=0,this.saturationShift=0,this.brightnessShift=0,this.showSkirts=!0,this.backFaceCulling=!0,this.undergroundColor=void 0,this.undergroundColorAlphaByDistance=void 0,this.lambertDiffuseMultiplier=0,this.materialUniformMap=void 0,this._materialUniformMap=void 0,this._quadtree=void 0,this._terrainProvider=e.terrainProvider,this._imageryLayers=e.imageryLayers,this._surfaceShaderSet=e.surfaceShaderSet,this._renderState=void 0,this._blendRenderState=void 0,this._disableCullingRenderState=void 0,this._disableCullingBlendRenderState=void 0,this._errorEvent=new Event,this._removeLayerAddedListener=this._imageryLayers.layerAdded.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerAdded,this),this._removeLayerRemovedListener=this._imageryLayers.layerRemoved.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerRemoved,this),this._removeLayerMovedListener=this._imageryLayers.layerMoved.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerMoved,this),this._removeLayerShownListener=this._imageryLayers.layerShownOrHidden.addEventListener(GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden,this),this._imageryLayersUpdatedEvent=new Event,this._layerOrderChanged=!1,this._tilesToRenderByTextureCount=[],this._drawCommands=[],this._uniformMaps=[],this._usedDrawCommands=0,this._vertexArraysToDestroy=[],this._debug={wireframe:!1,boundingSphereTile:void 0},this._baseColor=void 0,this._firstPassInitialColor=void 0,this.baseColor=new Color(0,0,.5,1),this._clippingPlanes=void 0,this._clippingPolygons=void 0,this.cartographicLimitRectangle=Rectangle.clone(Rectangle.MAX_VALUE),this._hasLoadedTilesThisFrame=!1,this._hasFillTilesThisFrame=!1,this._oldVerticalExaggeration=void 0,this._oldVerticalExaggerationRelativeHeight=void 0}Object.defineProperties(GlobeSurfaceTileProvider.prototype,{baseColor:{get:function(){return this._baseColor},set:function(e){if(!defined(e))throw new DeveloperError("value is required.");this._baseColor=e,this._firstPassInitialColor=Cartesian4.fromColor(e,this._firstPassInitialColor)}},quadtree:{get:function(){return this._quadtree},set:function(e){if(!defined(e))throw new DeveloperError("value is required.");this._quadtree=e}},tilingScheme:{get:function(){if(defined(this._terrainProvider))return this._terrainProvider.tilingScheme}},errorEvent:{get:function(){return this._errorEvent}},imageryLayersUpdatedEvent:{get:function(){return this._imageryLayersUpdatedEvent}},terrainProvider:{get:function(){return this._terrainProvider},set:function(e){this._terrainProvider!==e&&(this._terrainProvider=e,defined(this._quadtree)&&this._quadtree.invalidateAllTiles())}},clippingPlanes:{get:function(){return this._clippingPlanes},set:function(e){ClippingPlaneCollection.setOwner(e,this,"_clippingPlanes")}},clippingPolygons:{get:function(){return this._clippingPolygons},set:function(e){ClippingPolygonCollection.setOwner(e,this,"_clippingPolygons")}}});function sortTileImageryByLayerIndex(e,t){let n=e.loadingImagery;defined(n)||(n=e.readyImagery);let i=t.loadingImagery;return defined(i)||(i=t.readyImagery),n.imageryLayer._layerIndex-i.imageryLayer._layerIndex}GlobeSurfaceTileProvider.prototype.update=function(e){this._imageryLayers._update()};function updateCredits$1(e,t){const n=t.creditDisplay,i=e._terrainProvider;defined(i)&&defined(i.credit)&&n.addCreditToNextFrame(i.credit);const r=e._imageryLayers;for(let o=0,a=r.length;o<a;++o){const s=r.get(o);s.ready&&s.show&&defined(s.imageryProvider.credit)&&n.addCreditToNextFrame(s.imageryProvider.credit)}}GlobeSurfaceTileProvider.prototype.initialize=function(e){this._imageryLayers.queueReprojectionCommands(e),this._layerOrderChanged&&(this._layerOrderChanged=!1,this._quadtree.forEachLoadedTile(function(i){i.data.imagery.sort(sortTileImageryByLayerIndex)})),updateCredits$1(this,e);const t=this._vertexArraysToDestroy,n=t.length;for(let i=0;i<n;++i)GlobeSurfaceTile._freeVertexArray(t[i]);t.length=0};GlobeSurfaceTileProvider.prototype.beginUpdate=function(e){const t=this._tilesToRenderByTextureCount;for(let r=0,o=t.length;r<o;++r){const a=t[r];defined(a)&&(a.length=0)}const n=this._clippingPlanes;defined(n)&&n.enabled&&n.update(e);const i=this._clippingPolygons;defined(i)&&i.enabled&&(i.update(e),i.queueCommands(e)),this._usedDrawCommands=0,this._hasLoadedTilesThisFrame=!1,this._hasFillTilesThisFrame=!1};GlobeSurfaceTileProvider.prototype.endUpdate=function(e){if(!defined(this._renderState)){this._renderState=RenderState.fromCache({cull:{enabled:!0},depthTest:{enabled:!0,func:DepthFunction.LESS}}),this._blendRenderState=RenderState.fromCache({cull:{enabled:!0},depthTest:{enabled:!0,func:DepthFunction.LESS_OR_EQUAL},blending:BlendingState.ALPHA_BLEND});let a=clone(this._renderState,!0);a.cull.enabled=!1,this._disableCullingRenderState=RenderState.fromCache(a),a=clone(this._blendRenderState,!0),a.cull.enabled=!1,this._disableCullingBlendRenderState=RenderState.fromCache(a)}this._hasFillTilesThisFrame&&this._hasLoadedTilesThisFrame&&TerrainFillMesh.updateFillTiles(this,this._quadtree._tilesToRender,e,this._vertexArraysToDestroy);const t=this.quadtree,n=e.verticalExaggeration,i=e.verticalExaggerationRelativeHeight,r=this._oldVerticalExaggeration!==n||this._oldVerticalExaggerationRelativeHeight!==i;this._oldVerticalExaggeration=n,this._oldVerticalExaggerationRelativeHeight=i,r&&t.forEachLoadedTile(function(a){a.data.updateExaggeration(a,e,t)});const o=this._tilesToRenderByTextureCount;for(let a=0,s=o.length;a<s;++a){const l=o[a];if(defined(l))for(let c=0,d=l.length;c<d;++c){const h=l[c],f=h.data.tileBoundingRegion;addDrawCommandsForTile(this,h,e),e.minimumTerrainHeight=Math.min(e.minimumTerrainHeight,f.minimumHeight)}}};function pushCommand(e,t){const n=t.globeTranslucencyState;if(n.translucent){const i=e.renderState.blending.enabled;n.pushDerivedCommands(e,i,t)}else t.commandList.push(e)}GlobeSurfaceTileProvider.prototype.updateForPick=function(e){const t=this._drawCommands;for(let n=0,i=this._usedDrawCommands;n<i;++n)pushCommand(t[n],e)};GlobeSurfaceTileProvider.prototype.cancelReprojections=function(){this._imageryLayers.cancelReprojections()};GlobeSurfaceTileProvider.prototype.getLevelMaximumGeometricError=function(e){return defined(this._terrainProvider)?this._terrainProvider.getLevelMaximumGeometricError(e):0};GlobeSurfaceTileProvider.prototype.loadTile=function(e,t){let n=t.data,i=!0,r;defined(n)&&(i=n.boundingVolumeSourceTile!==t||t._lastSelectionResult===TileSelectionResult$1.CULLED_BUT_NEEDED,r=n.terrainState),GlobeSurfaceTile.processStateMachine(t,e,this.terrainProvider,this._imageryLayers,this.quadtree,this._vertexArraysToDestroy,i),n=t.data,i&&r!==t.data.terrainState&&this.computeTileVisibility(t,e,this.quadtree.occluders)!==Visibility$1.NONE&&n.boundingVolumeSourceTile===t&&(i=!1,GlobeSurfaceTile.processStateMachine(t,e,this.terrainProvider,this._imageryLayers,this.quadtree,this._vertexArraysToDestroy,i))};const boundingSphereScratch$1=new BoundingSphere,rectangleIntersectionScratch=new Rectangle,splitCartographicLimitRectangleScratch=new Rectangle,rectangleCenterScratch=new Cartographic;function clipRectangleAntimeridian(e,t){if(t.west<t.east)return t;const n=Rectangle.clone(t,splitCartographicLimitRectangleScratch);return Rectangle.center(e,rectangleCenterScratch).longitude>0?n.east=CesiumMath.PI:n.west=-CesiumMath.PI,n}function isUndergroundVisible(e,t){if(t.cameraUnderground||t.globeTranslucencyState.translucent)return!0;if(e.backFaceCulling)return!1;const n=e._clippingPlanes;if(defined(n)&&n.enabled)return!0;const i=e._clippingPolygons;return!!(defined(i)&&i.enabled||!Rectangle.equals(e.cartographicLimitRectangle,Rectangle.MAX_VALUE))}GlobeSurfaceTileProvider.prototype.computeTileVisibility=function(e,t,n){const i=this.computeDistanceToTile(e,t);e._distance=i;const r=isUndergroundVisible(this,t);if(t.fog.enabled&&!r&&CesiumMath.fog(i,t.fog.density)>=1)return Visibility$1.NONE;const o=e.data,a=o.tileBoundingRegion;if(o.boundingVolumeSourceTile===void 0)return Visibility$1.PARTIAL;const s=t.cullingVolume;let l=a.boundingVolume;defined(l)||(l=a.boundingSphere),o.clippedByBoundaries=!1;const c=clipRectangleAntimeridian(e.rectangle,this.cartographicLimitRectangle),d=Rectangle.simpleIntersection(c,e.rectangle,rectangleIntersectionScratch);if(!defined(d))return Visibility$1.NONE;if(Rectangle.equals(d,e.rectangle)||(o.clippedByBoundaries=!0),t.mode!==SceneMode.SCENE3D&&(l=boundingSphereScratch$1,BoundingSphere.fromRectangleWithHeights2D(e.rectangle,t.mapProjection,a.minimumHeight,a.maximumHeight,l),Cartesian3.fromElements(l.center.z,l.center.x,l.center.y,l.center),t.mode===SceneMode.MORPHING&&defined(o.renderedMesh)&&(l=BoundingSphere.union(a.boundingSphere,l,l))),!defined(l))return Visibility$1.PARTIAL;const h=this._clippingPlanes;if(defined(h)&&h.enabled){const g=h.computeIntersectionWithBoundingVolume(l);if(e.isClipped=g!==Intersect.INSIDE,g===Intersect.OUTSIDE)return Visibility$1.NONE}const f=this._clippingPolygons;if(defined(f)&&f.enabled){const g=f.computeIntersectionWithBoundingVolume(a);e.isClipped=g!==Intersect.OUTSIDE}let p;const u=s.computeVisibility(l);if(u===Intersect.OUTSIDE?p=Visibility$1.NONE:u===Intersect.INTERSECTING?p=Visibility$1.PARTIAL:u===Intersect.INSIDE&&(p=Visibility$1.FULL),p===Visibility$1.NONE)return p;const m=t.mode===SceneMode.SCENE3D&&t.camera.frustum instanceof OrthographicFrustum;if(t.mode===SceneMode.SCENE3D&&!m&&defined(n)&&!r){const g=o.occludeePointInScaledSpace;return!defined(g)||n.ellipsoid.isScaledSpacePointVisiblePossiblyUnderEllipsoid(g,a.minimumHeight)?p:Visibility$1.NONE}return p};GlobeSurfaceTileProvider.prototype.canRefine=function(e){return defined(e.data.terrainData)?!0:this.terrainProvider.getTileDataAvailable(e.x*2,e.y*2,e.level+1)!==void 0};const readyImageryScratch=[],canRenderTraversalStack=[];GlobeSurfaceTileProvider.prototype.canRenderWithoutLosingDetail=function(e,t){const n=e.data,i=readyImageryScratch;i.length=this._imageryLayers.length;let r=!1,o=!1,a;defined(n)&&(r=n.terrainState===TerrainState$2.READY,o=!0,a=n.imagery);let s,l;for(s=0,l=i.length;s<l;++s)i[s]=o;if(defined(a))for(s=0,l=a.length;s<l;++s){const h=a[s],f=h.loadingImagery,p=!defined(f)||f.state===ImageryState.FAILED||f.state===ImageryState.INVALID,u=(h.loadingImagery||h.readyImagery).imageryLayer._layerIndex;i[u]=p&&i[u]}const c=this.quadtree._lastSelectionFrameNumber,d=canRenderTraversalStack;for(d.length=0,d.push(e.southwestChild,e.southeastChild,e.northwestChild,e.northeastChild);d.length>0;){const h=d.pop(),f=h._lastSelectionResultFrame===c?h._lastSelectionResult:TileSelectionResult$1.NONE;if(f===TileSelectionResult$1.RENDERED){const p=h.data;if(!defined(p))continue;if(!r&&h.data.terrainState===TerrainState$2.READY)return!1;const u=h.data.imagery;for(s=0,l=u.length;s<l;++s){const m=u[s],g=m.loadingImagery,_=!defined(g)||g.state===ImageryState.FAILED||g.state===ImageryState.INVALID,C=(m.loadingImagery||m.readyImagery).imageryLayer._layerIndex;if(_&&!i[C])return!1}}else f===TileSelectionResult$1.REFINED&&d.push(h.southwestChild,h.southeastChild,h.northwestChild,h.northeastChild)}return!0};const tileDirectionScratch=new Cartesian3;GlobeSurfaceTileProvider.prototype.computeTileLoadPriority=function(e,t){const n=e.data;if(n===void 0)return 0;const i=n.tileBoundingRegion.boundingVolume;if(i===void 0)return 0;const r=t.camera.positionWC,o=t.camera.directionWC,a=Cartesian3.subtract(i.center,r,tileDirectionScratch),s=Cartesian3.magnitude(a);return s<CesiumMath.EPSILON5?0:(Cartesian3.divideByScalar(a,s,a),(1-Cartesian3.dot(a,o))*e._distance)};const modifiedModelViewScratch=new Matrix4,modifiedModelViewProjectionScratch=new Matrix4,tileRectangleScratch=new Cartesian4,localizedCartographicLimitRectangleScratch=new Cartesian4,localizedTranslucencyRectangleScratch=new Cartesian4,rtcScratch=new Cartesian3,centerEyeScratch=new Cartesian3,southwestScratch=new Cartesian3,northeastScratch=new Cartesian3;GlobeSurfaceTileProvider.prototype.showTileThisFrame=function(e,t){let n=0;const i=e.data.imagery;for(let s=0,l=i.length;s<l;++s){const c=i[s];defined(c.readyImagery)&&c.readyImagery.imageryLayer.alpha!==0&&++n}let r=this._tilesToRenderByTextureCount[n];defined(r)||(r=[],this._tilesToRenderByTextureCount[n]=r),r.push(e);const o=e.data;defined(o.vertexArray)?this._hasLoadedTilesThisFrame=!0:this._hasFillTilesThisFrame=!0;const a=this._debug;++a.tilesRendered,a.texturesRendered+=n};const cornerPositionsScratch=[new Cartesian3,new Cartesian3,new Cartesian3,new Cartesian3];function computeOccludeePoint(e,t,n,i,r,o){const a=e.quadtree._occluders.ellipsoid,s=a.ellipsoid,l=cornerPositionsScratch;return Cartesian3.fromRadians(n.west,n.south,r,s,l[0]),Cartesian3.fromRadians(n.east,n.south,r,s,l[1]),Cartesian3.fromRadians(n.west,n.north,r,s,l[2]),Cartesian3.fromRadians(n.east,n.north,r,s,l[3]),a.computeHorizonCullingPointPossiblyUnderEllipsoid(t,l,i,o)}GlobeSurfaceTileProvider.prototype.computeDistanceToTile=function(e,t){updateTileBoundingRegion(e,this,t);const n=e.data;if(n.boundingVolumeSourceTile===void 0)return 9999999999;const r=n.tileBoundingRegion,o=r.minimumHeight,a=r.maximumHeight;if(n.boundingVolumeSourceTile!==e){const l=t.camera.positionCartographic.height,c=Math.abs(l-o),d=Math.abs(l-a);c>d?(r.minimumHeight=o,r.maximumHeight=o):(r.minimumHeight=a,r.maximumHeight=a)}const s=r.distanceToCamera(t);return r.minimumHeight=o,r.maximumHeight=a,s};function updateTileBoundingRegion(e,t,n){let i=e.data;i===void 0&&(i=e.data=new GlobeSurfaceTile);const r=e.tilingScheme.ellipsoid;i.tileBoundingRegion===void 0&&(i.tileBoundingRegion=new TileBoundingRegion({computeBoundingVolumes:!1,rectangle:e.rectangle,ellipsoid:r,minimumHeight:0,maximumHeight:0}));const o=i.tileBoundingRegion,a=o.minimumHeight,s=o.maximumHeight;let l=!1,c=e;const d=i.mesh,h=i.terrainData;if(d!==void 0&&d.minimumHeight!==void 0&&d.maximumHeight!==void 0)o.minimumHeight=d.minimumHeight,o.maximumHeight=d.maximumHeight,l=!0;else if(h!==void 0&&h._minimumHeight!==void 0&&h._maximumHeight!==void 0)o.minimumHeight=h._minimumHeight,o.maximumHeight=h._maximumHeight;else{o.minimumHeight=Number.NaN,o.maximumHeight=Number.NaN;let f=e.parent;for(;f!==void 0;){const p=f.data;if(p!==void 0){const u=p.mesh,m=p.terrainData;if(u!==void 0&&u.minimumHeight!==void 0&&u.maximumHeight!==void 0){o.minimumHeight=u.minimumHeight,o.maximumHeight=u.maximumHeight;break}else if(m!==void 0&&m._minimumHeight!==void 0&&m._maximumHeight!==void 0){o.minimumHeight=m._minimumHeight,o.maximumHeight=m._maximumHeight;break}}f=f.parent}c=f}if(c!==void 0){const f=n.verticalExaggeration,p=n.verticalExaggerationRelativeHeight;if(f!==1&&(l=!1,o.minimumHeight=VerticalExaggeration.getHeight(o.minimumHeight,f,p),o.maximumHeight=VerticalExaggeration.getHeight(o.maximumHeight,f,p)),l)i.boundingVolumeIsFromMesh||(o._orientedBoundingBox=OrientedBoundingBox.clone(d.orientedBoundingBox,o._orientedBoundingBox),o._boundingSphere=BoundingSphere.clone(d.boundingSphere3D,o._boundingSphere),i.occludeePointInScaledSpace=Cartesian3.clone(d.occludeePointInScaledSpace,i.occludeePointInScaledSpace),defined(i.occludeePointInScaledSpace)||(i.occludeePointInScaledSpace=computeOccludeePoint(t,o._orientedBoundingBox.center,e.rectangle,o.minimumHeight,o.maximumHeight,i.occludeePointInScaledSpace)));else{const m=o._orientedBoundingBox===void 0||o._boundingSphere===void 0;(o.minimumHeight!==a||o.maximumHeight!==s||m)&&(o.computeBoundingVolumes(r),i.occludeePointInScaledSpace=computeOccludeePoint(t,o._orientedBoundingBox.center,e.rectangle,o.minimumHeight,o.maximumHeight,i.occludeePointInScaledSpace))}i.boundingVolumeSourceTile=c,i.boundingVolumeIsFromMesh=l}else i.boundingVolumeSourceTile=void 0,i.boundingVolumeIsFromMesh=!1}GlobeSurfaceTileProvider.prototype.isDestroyed=function(){return!1};GlobeSurfaceTileProvider.prototype.destroy=function(){return this._tileProvider=this._tileProvider&&this._tileProvider.destroy(),this._clippingPlanes=this._clippingPlanes&&this._clippingPlanes.destroy(),this._clippingPolygons=this._clippingPolygons&&this._clippingPolygons.destroy(),this._removeLayerAddedListener=this._removeLayerAddedListener&&this._removeLayerAddedListener(),this._removeLayerRemovedListener=this._removeLayerRemovedListener&&this._removeLayerRemovedListener(),this._removeLayerMovedListener=this._removeLayerMovedListener&&this._removeLayerMovedListener(),this._removeLayerShownListener=this._removeLayerShownListener&&this._removeLayerShownListener(),destroyObject(this)};function getTileReadyCallback(e,t,n){return function(i){let r,o,a=-1;const s=i.data.imagery,l=s.length;let c;for(c=0;c<l;++c)if(r=s[c],o=defaultValue(r.readyImagery,r.loadingImagery),o.imageryLayer===t){a=c;break}if(a!==-1){const d=a+e;if(r=s[d],o=defined(r)?defaultValue(r.readyImagery,r.loadingImagery):void 0,!defined(o)||o.imageryLayer!==t)return!t._createTileImagerySkeletons(i,n,d);for(c=a;c<d;++c)s[c].freeResources();s.splice(a,e)}return!0}}GlobeSurfaceTileProvider.prototype._onLayerAdded=function(e,t){if(!this.isDestroyed()&&e.show){const n=this._terrainProvider,i=this,r=this._imageryLayersUpdatedEvent,o=function(){e._imageryCache={},i._quadtree.forEachLoadedTile(function(a){if(defined(a._loadedCallbacks[e._layerIndex]))return;let s;const l=a.data.imagery,c=l.length;let d=-1,h=0;for(s=0;s<c;++s){const p=l[s];if(defaultValue(p.readyImagery,p.loadingImagery).imageryLayer===e)d===-1&&(d=s),++h;else if(d!==-1)break}if(d===-1)return;const f=d+h;e._createTileImagerySkeletons(a,n,f)&&(a._loadedCallbacks[e._layerIndex]=getTileReadyCallback(h,e,n),a.state=QuadtreeTileLoadState$1.LOADING)})};if(e.ready){const a=e.imageryProvider;a._reload=o}this._quadtree.forEachLoadedTile(function(a){e._createTileImagerySkeletons(a,n)&&(a.state=QuadtreeTileLoadState$1.LOADING,a.level!==0&&(a._lastSelectionResultFrame!==i.quadtree._lastSelectionFrameNumber||a._lastSelectionResult!==TileSelectionResult$1.RENDERED)&&(a.renderable=!1))}),this._layerOrderChanged=!0,r.raiseEvent()}};GlobeSurfaceTileProvider.prototype._onLayerRemoved=function(e,t){this._quadtree.forEachLoadedTile(function(n){const i=n.data.imagery;let r=-1,o=0;for(let a=0,s=i.length;a<s;++a){const l=i[a];let c=l.loadingImagery;if(defined(c)||(c=l.readyImagery),c.imageryLayer===e)r===-1&&(r=a),l.freeResources(),++o;else if(r!==-1)break}r!==-1&&i.splice(r,o)}),defined(e.imageryProvider)&&(e.imageryProvider._reload=void 0),this._imageryLayersUpdatedEvent.raiseEvent()};GlobeSurfaceTileProvider.prototype._onLayerMoved=function(e,t,n){this._layerOrderChanged=!0,this._imageryLayersUpdatedEvent.raiseEvent()};GlobeSurfaceTileProvider.prototype._onLayerShownOrHidden=function(e,t,n){n?this._onLayerAdded(e,t):this._onLayerRemoved(e,t)};const scratchClippingPlanesMatrix$1=new Matrix4,scratchInverseTransposeClippingPlanesMatrix$1=new Matrix4;function createTileUniformMap(e,t){const n={u_initialColor:function(){return this.properties.initialColor},u_fillHighlightColor:function(){return this.properties.fillHighlightColor},u_zoomedOutOceanSpecularIntensity:function(){return this.properties.zoomedOutOceanSpecularIntensity},u_oceanNormalMap:function(){return this.properties.oceanNormalMap},u_atmosphereLightIntensity:function(){return this.properties.atmosphereLightIntensity},u_atmosphereRayleighCoefficient:function(){return this.properties.atmosphereRayleighCoefficient},u_atmosphereMieCoefficient:function(){return this.properties.atmosphereMieCoefficient},u_atmosphereRayleighScaleHeight:function(){return this.properties.atmosphereRayleighScaleHeight},u_atmosphereMieScaleHeight:function(){return this.properties.atmosphereMieScaleHeight},u_atmosphereMieAnisotropy:function(){return this.properties.atmosphereMieAnisotropy},u_lightingFadeDistance:function(){return this.properties.lightingFadeDistance},u_nightFadeDistance:function(){return this.properties.nightFadeDistance},u_center3D:function(){return this.properties.center3D},u_verticalExaggerationAndRelativeHeight:function(){return this.properties.verticalExaggerationAndRelativeHeight},u_tileRectangle:function(){return this.properties.tileRectangle},u_modifiedModelView:function(){const i=e.context.uniformState.view,r=Matrix4.multiplyByPoint(i,this.properties.rtc,centerEyeScratch);return Matrix4.setTranslation(i,r,modifiedModelViewScratch),modifiedModelViewScratch},u_modifiedModelViewProjection:function(){const i=e.context.uniformState.view,r=e.context.uniformState.projection,o=Matrix4.multiplyByPoint(i,this.properties.rtc,centerEyeScratch);return Matrix4.setTranslation(i,o,modifiedModelViewProjectionScratch),Matrix4.multiply(r,modifiedModelViewProjectionScratch,modifiedModelViewProjectionScratch),modifiedModelViewProjectionScratch},u_dayTextures:function(){return this.properties.dayTextures},u_dayTextureTranslationAndScale:function(){return this.properties.dayTextureTranslationAndScale},u_dayTextureTexCoordsRectangle:function(){return this.properties.dayTextureTexCoordsRectangle},u_dayTextureUseWebMercatorT:function(){return this.properties.dayTextureUseWebMercatorT},u_dayTextureAlpha:function(){return this.properties.dayTextureAlpha},u_dayTextureNightAlpha:function(){return this.properties.dayTextureNightAlpha},u_dayTextureDayAlpha:function(){return this.properties.dayTextureDayAlpha},u_dayTextureBrightness:function(){return this.properties.dayTextureBrightness},u_dayTextureContrast:function(){return this.properties.dayTextureContrast},u_dayTextureHue:function(){return this.properties.dayTextureHue},u_dayTextureSaturation:function(){return this.properties.dayTextureSaturation},u_dayTextureOneOverGamma:function(){return this.properties.dayTextureOneOverGamma},u_dayIntensity:function(){return this.properties.dayIntensity},u_southAndNorthLatitude:function(){return this.properties.southAndNorthLatitude},u_southMercatorYAndOneOverHeight:function(){return this.properties.southMercatorYAndOneOverHeight},u_waterMask:function(){return this.properties.waterMask},u_waterMaskTranslationAndScale:function(){return this.properties.waterMaskTranslationAndScale},u_minMaxHeight:function(){return this.properties.minMaxHeight},u_scaleAndBias:function(){return this.properties.scaleAndBias},u_dayTextureSplit:function(){return this.properties.dayTextureSplit},u_dayTextureCutoutRectangles:function(){return this.properties.dayTextureCutoutRectangles},u_clippingPlanes:function(){const i=t._clippingPlanes;return defined(i)&&defined(i.texture)?i.texture:e.context.defaultTexture},u_cartographicLimitRectangle:function(){return this.properties.localizedCartographicLimitRectangle},u_clippingPlanesMatrix:function(){const i=t._clippingPlanes,r=defined(i)?Matrix4.multiply(e.context.uniformState.view,i.modelMatrix,scratchClippingPlanesMatrix$1):Matrix4.IDENTITY;return Matrix4.inverseTranspose(r,scratchInverseTransposeClippingPlanesMatrix$1)},u_clippingPlanesEdgeStyle:function(){const i=this.properties.clippingPlanesEdgeColor;return i.alpha=this.properties.clippingPlanesEdgeWidth,i},u_clippingDistance:function(){const i=t._clippingPolygons.clippingTexture;return defined(i)?i:e.context.defaultTexture},u_clippingExtents:function(){const i=t._clippingPolygons.extentsTexture;return defined(i)?i:e.context.defaultTexture},u_minimumBrightness:function(){return e.fog.minimumBrightness},u_hsbShift:function(){return this.properties.hsbShift},u_colorsToAlpha:function(){return this.properties.colorsToAlpha},u_frontFaceAlphaByDistance:function(){return this.properties.frontFaceAlphaByDistance},u_backFaceAlphaByDistance:function(){return this.properties.backFaceAlphaByDistance},u_translucencyRectangle:function(){return this.properties.localizedTranslucencyRectangle},u_undergroundColor:function(){return this.properties.undergroundColor},u_undergroundColorAlphaByDistance:function(){return this.properties.undergroundColorAlphaByDistance},u_lambertDiffuseMultiplier:function(){return this.properties.lambertDiffuseMultiplier},u_vertexShadowDarkness:function(){return this.properties.vertexShadowDarkness},properties:{initialColor:new Cartesian4(0,0,.5,1),fillHighlightColor:new Color(0,0,0,0),zoomedOutOceanSpecularIntensity:.5,oceanNormalMap:void 0,lightingFadeDistance:new Cartesian2(65e5,9e6),nightFadeDistance:new Cartesian2(1e7,4e7),atmosphereLightIntensity:10,atmosphereRayleighCoefficient:new Cartesian3(55e-7,13e-6,284e-7),atmosphereMieCoefficient:new Cartesian3(21e-6,21e-6,21e-6),atmosphereRayleighScaleHeight:1e4,atmosphereMieScaleHeight:3200,atmosphereMieAnisotropy:.9,hsbShift:new Cartesian3,center3D:void 0,rtc:new Cartesian3,modifiedModelView:new Matrix4,tileRectangle:new Cartesian4,verticalExaggerationAndRelativeHeight:new Cartesian2(1,0),dayTextures:[],dayTextureTranslationAndScale:[],dayTextureTexCoordsRectangle:[],dayTextureUseWebMercatorT:[],dayTextureAlpha:[],dayTextureNightAlpha:[],dayTextureDayAlpha:[],dayTextureBrightness:[],dayTextureContrast:[],dayTextureHue:[],dayTextureSaturation:[],dayTextureOneOverGamma:[],dayTextureSplit:[],dayTextureCutoutRectangles:[],dayIntensity:0,colorsToAlpha:[],southAndNorthLatitude:new Cartesian2,southMercatorYAndOneOverHeight:new Cartesian2,waterMask:void 0,waterMaskTranslationAndScale:new Cartesian4,minMaxHeight:new Cartesian2,scaleAndBias:new Matrix4,clippingPlanesEdgeColor:Color.clone(Color.WHITE),clippingPlanesEdgeWidth:0,localizedCartographicLimitRectangle:new Cartesian4,frontFaceAlphaByDistance:new Cartesian4,backFaceAlphaByDistance:new Cartesian4,localizedTranslucencyRectangle:new Cartesian4,undergroundColor:Color.clone(Color.TRANSPARENT),undergroundColorAlphaByDistance:new Cartesian4,lambertDiffuseMultiplier:0,vertexShadowDarkness:0}};return defined(t.materialUniformMap)?combine$2(n,t.materialUniformMap):n}function createWireframeVertexArrayIfNecessary(e,t,n){const i=n.data;let r,o;if(defined(i.vertexArray)?(r=i.mesh,o=i.vertexArray):defined(i.fill)&&defined(i.fill.vertexArray)&&(r=i.fill.mesh,o=i.fill.vertexArray),!(!defined(r)||!defined(o))){if(defined(i.wireframeVertexArray)){if(i.wireframeVertexArray.mesh===r)return;i.wireframeVertexArray.destroy(),i.wireframeVertexArray=void 0}i.wireframeVertexArray=createWireframeVertexArray(e,o,r),i.wireframeVertexArray.mesh=r}}function createWireframeVertexArray(e,t,n){const r={indices:n.indices,primitiveType:PrimitiveType.TRIANGLES};GeometryPipeline.toWireframe(r);const o=r.indices,a=Buffer.createIndexBuffer({context:e,typedArray:o,usage:BufferUsage.STATIC_DRAW,indexDatatype:IndexDatatype.fromSizeInBytes(o.BYTES_PER_ELEMENT)});return new VertexArray({context:e,attributes:t._attributes,indexBuffer:a})}let getDebugOrientedBoundingBox,getDebugBoundingSphere,debugDestroyPrimitive;(function(){const e=new GeometryInstance({geometry:BoxOutlineGeometry.fromDimensions({dimensions:new Cartesian3(2,2,2)})}),t=new GeometryInstance({geometry:new SphereOutlineGeometry({radius:1})});let n=new Matrix4,i,r;function o(a){return new Primitive({geometryInstances:a,appearance:new PerInstanceColorAppearance({translucent:!1,flat:!0}),asynchronous:!1})}getDebugOrientedBoundingBox=function(a,s){return a===i||(debugDestroyPrimitive(),i=a,n=Matrix4.fromRotationTranslation(a.halfAxes,a.center,n),e.modelMatrix=n,e.attributes.color=ColorGeometryInstanceAttribute.fromColor(s),r=o(e)),r},getDebugBoundingSphere=function(a,s){return a===i||(debugDestroyPrimitive(),i=a,n=Matrix4.fromTranslation(a.center,n),n=Matrix4.multiplyByUniformScale(n,a.radius,n),t.modelMatrix=n,t.attributes.color=ColorGeometryInstanceAttribute.fromColor(s),r=o(t)),r},debugDestroyPrimitive=function(){defined(r)&&(r.destroy(),r=void 0,i=void 0)}})();const otherPassesInitialColor=new Cartesian4(0,0,0,0),surfaceShaderSetOptionsScratch={frameState:void 0,surfaceTile:void 0,numberOfDayTextures:void 0,applyBrightness:void 0,applyContrast:void 0,applyHue:void 0,applySaturation:void 0,applyGamma:void 0,applyAlpha:void 0,applyDayNightAlpha:void 0,applySplit:void 0,showReflectiveOcean:void 0,showOceanWaves:void 0,enableLighting:void 0,dynamicAtmosphereLighting:void 0,dynamicAtmosphereLightingFromSun:void 0,showGroundAtmosphere:void 0,perFragmentGroundAtmosphere:void 0,hasVertexNormals:void 0,useWebMercatorProjection:void 0,enableFog:void 0,enableClippingPlanes:void 0,clippingPlanes:void 0,enableClippingPolygons:void 0,clippingPolygons:void 0,clippedByBoundaries:void 0,hasImageryLayerCutout:void 0,colorCorrect:void 0,colorToAlpha:void 0,hasGeodeticSurfaceNormals:void 0,hasExaggeration:void 0},defaultUndergroundColor=Color.TRANSPARENT,defaultUndergroundColorAlphaByDistance=new NearFarScalar;function addDrawCommandsForTile(e,t,n){const i=t.data;defined(i.vertexArray)||(i.fill===void 0&&(i.fill=new TerrainFillMesh(t)),i.fill.update(e,n));const r=n.creditDisplay,o=i.terrainData;if(defined(o)&&defined(o.credits)){const $=o.credits;for(let j=0,oe=$.length;j<oe;++j)r.addCreditToNextFrame($[j])}let a=ContextLimits.maximumTextureImageUnits,s=i.waterMaskTexture,l=i.waterMaskTranslationAndScale;!defined(s)&&defined(i.fill)&&(s=i.fill.waterMaskTexture,l=i.fill.waterMaskTranslationAndScale);const c=n.cameraUnderground,d=n.globeTranslucencyState,h=d.translucent,f=d.frontFaceAlphaByDistance,p=d.backFaceAlphaByDistance,u=d.rectangle,m=defaultValue(e.undergroundColor,defaultUndergroundColor),g=defaultValue(e.undergroundColorAlphaByDistance,defaultUndergroundColorAlphaByDistance),_=isUndergroundVisible(e,n)&&n.mode===SceneMode.SCENE3D&&m.alpha>0&&(g.nearValue>0||g.farValue>0),C=e.lambertDiffuseMultiplier,A=e.vertexShadowDarkness,S=e.hasWaterMask&&defined(s),v=e.oceanNormalMap,b=S&&defined(v),D=e.terrainProvider,I=defined(D)&&e.terrainProvider.hasVertexNormals,L=n.fog.enabled&&n.fog.renderable&&!c,N=e.showGroundAtmosphere&&n.mode===SceneMode.SCENE3D,y=ShadowMode.castShadows(e.shadows)&&!h,x=ShadowMode.receiveShadows(e.shadows)&&!h,T=e.hueShift,E=e.saturationShift,P=e.brightnessShift;let M=!(CesiumMath.equalsEpsilon(T,0,CesiumMath.EPSILON7)&&CesiumMath.equalsEpsilon(E,0,CesiumMath.EPSILON7)&&CesiumMath.equalsEpsilon(P,0,CesiumMath.EPSILON7)),O=!1;if(N){const $=Cartesian3.magnitude(n.camera.positionWC),j=e.nightFadeOutDistance;O=$>j}S&&--a,b&&--a,defined(n.shadowState)&&n.shadowState.shadowsEnabled&&--a,defined(e.clippingPlanes)&&e.clippingPlanes.enabled&&--a,defined(e.clippingPolygons)&&e.clippingPolygons.enabled&&(--a,--a),a-=d.numberOfTextureUniforms;const V=i.renderedMesh;let R=V.center;const w=V.encoding,U=i.tileBoundingRegion,k=n.verticalExaggeration,H=n.verticalExaggerationRelativeHeight,F=k!==1,G=w.hasGeodeticSurfaceNormals,B=tileRectangleScratch;let W=0,Y=0,z=0,X=0,q=!1;if(n.mode!==SceneMode.SCENE3D){const $=n.mapProjection,j=$.project(Rectangle.southwest(t.rectangle),southwestScratch),oe=$.project(Rectangle.northeast(t.rectangle),northeastScratch);if(B.x=j.x,B.y=j.y,B.z=oe.x,B.w=oe.y,n.mode!==SceneMode.MORPHING&&(R=rtcScratch,R.x=0,R.y=(B.z+B.x)*.5,R.z=(B.w+B.y)*.5,B.x-=R.y,B.y-=R.z,B.z-=R.y,B.w-=R.z),n.mode===SceneMode.SCENE2D&&w.quantization===TerrainQuantization$1.BITS12){const ie=1/(Math.pow(2,12)-1)*.5,de=(B.z-B.x)*ie,ue=(B.w-B.y)*ie;B.x-=de,B.y-=ue,B.z+=de,B.w+=ue}$ instanceof WebMercatorProjection&&(W=t.rectangle.south,Y=t.rectangle.north,z=WebMercatorProjection.geodeticLatitudeToMercatorAngle(W),X=1/(WebMercatorProjection.geodeticLatitudeToMercatorAngle(Y)-z),q=!0)}const Q=surfaceShaderSetOptionsScratch;Q.frameState=n,Q.surfaceTile=i,Q.showReflectiveOcean=S,Q.showOceanWaves=b,Q.enableLighting=e.enableLighting,Q.dynamicAtmosphereLighting=e.dynamicAtmosphereLighting,Q.dynamicAtmosphereLightingFromSun=e.dynamicAtmosphereLightingFromSun,Q.showGroundAtmosphere=N,Q.atmosphereLightIntensity=e.atmosphereLightIntensity,Q.atmosphereRayleighCoefficient=e.atmosphereRayleighCoefficient,Q.atmosphereMieCoefficient=e.atmosphereMieCoefficient,Q.atmosphereRayleighScaleHeight=e.atmosphereRayleighScaleHeight,Q.atmosphereMieScaleHeight=e.atmosphereMieScaleHeight,Q.atmosphereMieAnisotropy=e.atmosphereMieAnisotropy,Q.perFragmentGroundAtmosphere=O,Q.hasVertexNormals=I,Q.useWebMercatorProjection=q,Q.clippedByBoundaries=i.clippedByBoundaries,Q.hasGeodeticSurfaceNormals=G,Q.hasExaggeration=F;const Z=i.imagery;let K=0;const J=Z.length,se=e.showSkirts&&!c&&!h,ae=e.backFaceCulling&&!c&&!h,te=ae?e._renderState:e._disableCullingRenderState,ee=ae?e._blendRenderState:e._disableCullingBlendRenderState;let ce=te,re=e._firstPassInitialColor;const ne=n.context;if(defined(e._debug.boundingSphereTile)||debugDestroyPrimitive(),e._materialUniformMap!==e.materialUniformMap){e._materialUniformMap=e.materialUniformMap;const $=e._drawCommands.length;for(let j=0;j<$;++j)e._uniformMaps[j]=createTileUniformMap(n,e)}do{let $=0,j,oe;if(e._drawCommands.length<=e._usedDrawCommands?(j=new DrawCommand,j.owner=t,j.cull=!1,j.boundingVolume=new BoundingSphere,j.orientedBoundingBox=void 0,oe=createTileUniformMap(n,e),e._drawCommands.push(j),e._uniformMaps.push(oe)):(j=e._drawCommands[e._usedDrawCommands],oe=e._uniformMaps[e._usedDrawCommands]),j.owner=t,++e._usedDrawCommands,t===e._debug.boundingSphereTile){const Ce=U.boundingVolume,ve=U.boundingSphere;defined(Ce)?getDebugOrientedBoundingBox(Ce,Color.RED).update(n):defined(ve)&&getDebugBoundingSphere(ve,Color.RED).update(n)}const ie=oe.properties;Cartesian4.clone(re,ie.initialColor),ie.oceanNormalMap=v,ie.lightingFadeDistance.x=e.lightingFadeOutDistance,ie.lightingFadeDistance.y=e.lightingFadeInDistance,ie.nightFadeDistance.x=e.nightFadeOutDistance,ie.nightFadeDistance.y=e.nightFadeInDistance,ie.atmosphereLightIntensity=e.atmosphereLightIntensity,ie.atmosphereRayleighCoefficient=e.atmosphereRayleighCoefficient,ie.atmosphereMieCoefficient=e.atmosphereMieCoefficient,ie.atmosphereRayleighScaleHeight=e.atmosphereRayleighScaleHeight,ie.atmosphereMieScaleHeight=e.atmosphereMieScaleHeight,ie.atmosphereMieAnisotropy=e.atmosphereMieAnisotropy,ie.zoomedOutOceanSpecularIntensity=e.zoomedOutOceanSpecularIntensity;const de=c?p:f,ue=c?f:p;defined(de)&&(Cartesian4.fromElements(de.near,de.nearValue,de.far,de.farValue,ie.frontFaceAlphaByDistance),Cartesian4.fromElements(ue.near,ue.nearValue,ue.far,ue.farValue,ie.backFaceAlphaByDistance)),Cartesian4.fromElements(g.near,g.nearValue,g.far,g.farValue,ie.undergroundColorAlphaByDistance),Color.clone(m,ie.undergroundColor),ie.lambertDiffuseMultiplier=C,ie.vertexShadowDarkness=A;const Ee=!defined(i.vertexArray)&&defined(e.fillHighlightColor)&&e.fillHighlightColor.alpha>0;Ee&&Color.clone(e.fillHighlightColor,ie.fillHighlightColor),ie.verticalExaggerationAndRelativeHeight.x=k,ie.verticalExaggerationAndRelativeHeight.y=H,ie.center3D=V.center,Cartesian3.clone(R,ie.rtc),Cartesian4.clone(B,ie.tileRectangle),ie.southAndNorthLatitude.x=W,ie.southAndNorthLatitude.y=Y,ie.southMercatorYAndOneOverHeight.x=z,ie.southMercatorYAndOneOverHeight.y=X;const Pe=localizedCartographicLimitRectangleScratch,De=clipRectangleAntimeridian(t.rectangle,e.cartographicLimitRectangle),Me=localizedTranslucencyRectangleScratch,we=clipRectangleAntimeridian(t.rectangle,u);Cartesian3.fromElements(T,E,P,ie.hsbShift);const pe=t.rectangle,Ie=1/pe.width,he=1/pe.height;Pe.x=(De.west-pe.west)*Ie,Pe.y=(De.south-pe.south)*he,Pe.z=(De.east-pe.west)*Ie,Pe.w=(De.north-pe.south)*he,Cartesian4.clone(Pe,ie.localizedCartographicLimitRectangle),Me.x=(we.west-pe.west)*Ie,Me.y=(we.south-pe.south)*he,Me.z=(we.east-pe.west)*Ie,Me.w=(we.north-pe.south)*he,Cartesian4.clone(Me,ie.localizedTranslucencyRectangle);const be=L&&CesiumMath.fog(t._distance,n.fog.density)>CesiumMath.EPSILON3;M=M&&(be||N);let ye=!1,Be=!1,Fe=!1,Ve=!1,Ge=!1,Ue=!1,ke=!1,He=!1,Re=!1,Ae=!1;for(;$<a&&K<J;){const Ce=Z[K],ve=Ce.readyImagery;if(++K,!defined(ve)||ve.imageryLayer.alpha===0)continue;const je=Ce.useWebMercatorT?ve.textureWebMercator:ve.texture;if(!defined(je))throw new DeveloperError("readyImagery is not actually ready!");const fe=ve.imageryLayer;defined(Ce.textureTranslationAndScale)||(Ce.textureTranslationAndScale=fe._calculateTextureTranslationAndScale(t,Ce)),ie.dayTextures[$]=je,ie.dayTextureTranslationAndScale[$]=Ce.textureTranslationAndScale,ie.dayTextureTexCoordsRectangle[$]=Ce.textureCoordinateRectangle,ie.dayTextureUseWebMercatorT[$]=Ce.useWebMercatorT,ie.dayTextureAlpha[$]=fe.alpha,Ue=Ue||ie.dayTextureAlpha[$]!==1,ie.dayTextureNightAlpha[$]=fe.nightAlpha,ke=ke||ie.dayTextureNightAlpha[$]!==1,ie.dayTextureDayAlpha[$]=fe.dayAlpha,ke=ke||ie.dayTextureDayAlpha[$]!==1,ie.dayTextureBrightness[$]=fe.brightness,ye=ye||ie.dayTextureBrightness[$]!==ImageryLayer.DEFAULT_BRIGHTNESS,ie.dayTextureContrast[$]=fe.contrast,Be=Be||ie.dayTextureContrast[$]!==ImageryLayer.DEFAULT_CONTRAST,ie.dayTextureHue[$]=fe.hue,Fe=Fe||ie.dayTextureHue[$]!==ImageryLayer.DEFAULT_HUE,ie.dayTextureSaturation[$]=fe.saturation,Ve=Ve||ie.dayTextureSaturation[$]!==ImageryLayer.DEFAULT_SATURATION,ie.dayTextureOneOverGamma[$]=1/fe.gamma,Ge=Ge||ie.dayTextureOneOverGamma[$]!==1/ImageryLayer.DEFAULT_GAMMA,ie.dayTextureSplit[$]=fe.splitDirection,He=He||ie.dayTextureSplit[$]!==0;let Le=ie.dayTextureCutoutRectangles[$];if(defined(Le)||(Le=ie.dayTextureCutoutRectangles[$]=new Cartesian4),Cartesian4.clone(Cartesian4.ZERO,Le),defined(fe.cutoutRectangle)){const ge=clipRectangleAntimeridian(pe,fe.cutoutRectangle),_e=Rectangle.simpleIntersection(ge,pe,rectangleIntersectionScratch);Re=defined(_e)||Re,Le.x=(ge.west-pe.west)*Ie,Le.y=(ge.south-pe.south)*he,Le.z=(ge.east-pe.west)*Ie,Le.w=(ge.north-pe.south)*he}let Ne=ie.colorsToAlpha[$];defined(Ne)||(Ne=ie.colorsToAlpha[$]=new Cartesian4);const qe=defined(fe.colorToAlpha)&&fe.colorToAlphaThreshold>0;if(Ae=Ae||qe,qe){const ge=fe.colorToAlpha;Ne.x=ge.red,Ne.y=ge.green,Ne.z=ge.blue,Ne.w=fe.colorToAlphaThreshold}else Ne.w=-1;if(defined(ve.credits)){const ge=ve.credits;for(let _e=0,We=ge.length;_e<We;++_e)r.addCreditToNextFrame(ge[_e])}++$}ie.dayTextures.length=$,ie.waterMask=s,Cartesian4.clone(l,ie.waterMaskTranslationAndScale),ie.minMaxHeight.x=w.minimumHeight,ie.minMaxHeight.y=w.maximumHeight,Matrix4.clone(w.matrix,ie.scaleAndBias);const Oe=e._clippingPlanes,me=defined(Oe)&&Oe.enabled&&t.isClipped;me&&(ie.clippingPlanesEdgeColor=Color.clone(Oe.edgeColor,ie.clippingPlanesEdgeColor),ie.clippingPlanesEdgeWidth=Oe.edgeWidth);const Se=e._clippingPolygons,ze=defined(Se)&&Se.enabled&&t.isClipped;Q.numberOfDayTextures=$,Q.applyBrightness=ye,Q.applyContrast=Be,Q.applyHue=Fe,Q.applySaturation=Ve,Q.applyGamma=Ge,Q.applyAlpha=Ue,Q.applyDayNightAlpha=ke,Q.applySplit=He,Q.enableFog=be,Q.enableClippingPlanes=me,Q.clippingPlanes=Oe,Q.enableClippingPolygons=ze,Q.clippingPolygons=Se,Q.hasImageryLayerCutout=Re,Q.colorCorrect=M,Q.highlightFillTile=Ee,Q.colorToAlpha=Ae,Q.showUndergroundColor=_,Q.translucent=h;let xe=i.renderedMesh.indices.length;se||(xe=i.renderedMesh.indexCountWithoutSkirts),j.shaderProgram=e._surfaceShaderSet.getShaderProgram(Q),j.castShadows=y,j.receiveShadows=x,j.renderState=ce,j.primitiveType=PrimitiveType.TRIANGLES,j.vertexArray=i.vertexArray||i.fill.vertexArray,j.count=xe,j.uniformMap=oe,j.pass=Pass.GLOBE,e._debug.wireframe&&(createWireframeVertexArrayIfNecessary(ne,e,t),defined(i.wireframeVertexArray)&&(j.vertexArray=i.wireframeVertexArray,j.primitiveType=PrimitiveType.LINES,j.count=xe*2));let Te=j.boundingVolume;const $e=j.orientedBoundingBox;n.mode!==SceneMode.SCENE3D?(BoundingSphere.fromRectangleWithHeights2D(t.rectangle,n.mapProjection,U.minimumHeight,U.maximumHeight,Te),Cartesian3.fromElements(Te.center.z,Te.center.x,Te.center.y,Te.center),n.mode===SceneMode.MORPHING&&(Te=BoundingSphere.union(U.boundingSphere,Te,Te))):(j.boundingVolume=BoundingSphere.clone(U.boundingSphere,Te),j.orientedBoundingBox=OrientedBoundingBox.clone(U.boundingVolume,$e)),j.dirty=!0,h&&d.updateDerivedCommands(j,n),pushCommand(j,n),ce=ee,re=otherPassesInitialColor}while(K<J)}function GlobeTranslucency(){this._enabled=!1,this._frontFaceAlpha=1,this._frontFaceAlphaByDistance=void 0,this._backFaceAlpha=1,this._backFaceAlphaByDistance=void 0,this._rectangle=Rectangle.clone(Rectangle.MAX_VALUE)}Object.defineProperties(GlobeTranslucency.prototype,{enabled:{get:function(){return this._enabled},set:function(e){Check.typeOf.bool("enabled",e),this._enabled=e}},frontFaceAlpha:{get:function(){return this._frontFaceAlpha},set:function(e){Check.typeOf.number.greaterThanOrEquals("frontFaceAlpha",e,0),Check.typeOf.number.lessThanOrEquals("frontFaceAlpha",e,1),this._frontFaceAlpha=e}},frontFaceAlphaByDistance:{get:function(){return this._frontFaceAlphaByDistance},set:function(e){if(defined(e)&&e.far<e.near)throw new DeveloperError("far distance must be greater than near distance.");this._frontFaceAlphaByDistance=NearFarScalar.clone(e,this._frontFaceAlphaByDistance)}},backFaceAlpha:{get:function(){return this._backFaceAlpha},set:function(e){Check.typeOf.number.greaterThanOrEquals("backFaceAlpha",e,0),Check.typeOf.number.lessThanOrEquals("backFaceAlpha",e,1),this._backFaceAlpha=e}},backFaceAlphaByDistance:{get:function(){return this._backFaceAlphaByDistance},set:function(e){if(defined(e)&&e.far<e.near)throw new DeveloperError("far distance must be greater than near distance.");this._backFaceAlphaByDistance=NearFarScalar.clone(e,this._backFaceAlphaByDistance)}},rectangle:{get:function(){return this._rectangle},set:function(e){defined(e)||(e=Rectangle.clone(Rectangle.MAX_VALUE)),Rectangle.clone(e,this._rectangle)}}});function ImageryLayerCollection(){this._layers=[],this.layerAdded=new Event,this.layerRemoved=new Event,this.layerMoved=new Event,this.layerShownOrHidden=new Event}Object.defineProperties(ImageryLayerCollection.prototype,{length:{get:function(){return this._layers.length}}});ImageryLayerCollection.prototype.add=function(e,t){const n=defined(t);if(!defined(e))throw new DeveloperError("layer is required.");if(n){if(t<0)throw new DeveloperError("index must be greater than or equal to zero.");if(t>this._layers.length)throw new DeveloperError("index must be less than or equal to the number of layers.")}n?this._layers.splice(t,0,e):(t=this._layers.length,this._layers.push(e)),this._update(),this.layerAdded.raiseEvent(e,t);const i=e.readyEvent.addEventListener(()=>{this.layerShownOrHidden.raiseEvent(e,e._layerIndex,e.show),i()})};ImageryLayerCollection.prototype.addImageryProvider=function(e,t){if(!defined(e))throw new DeveloperError("imageryProvider is required.");const n=new ImageryLayer(e);return this.add(n,t),n};ImageryLayerCollection.prototype.remove=function(e,t){t=defaultValue(t,!0);const n=this._layers.indexOf(e);return n!==-1?(this._layers.splice(n,1),this._update(),this.layerRemoved.raiseEvent(e,n),t&&e.destroy(),!0):!1};ImageryLayerCollection.prototype.removeAll=function(e){e=defaultValue(e,!0);const t=this._layers;for(let n=0,i=t.length;n<i;n++){const r=t[n];this.layerRemoved.raiseEvent(r,n),e&&r.destroy()}this._layers=[]};ImageryLayerCollection.prototype.contains=function(e){return this.indexOf(e)!==-1};ImageryLayerCollection.prototype.indexOf=function(e){return this._layers.indexOf(e)};ImageryLayerCollection.prototype.get=function(e){if(!defined(e))throw new DeveloperError("index is required.");return this._layers[e]};function getLayerIndex(e,t){if(!defined(t))throw new DeveloperError("layer is required.");const n=e.indexOf(t);if(n===-1)throw new DeveloperError("layer is not in this collection.");return n}function swapLayers(e,t,n){const i=e._layers;if(t=CesiumMath.clamp(t,0,i.length-1),n=CesiumMath.clamp(n,0,i.length-1),t===n)return;const r=i[t];i[t]=i[n],i[n]=r,e._update(),e.layerMoved.raiseEvent(r,n,t)}ImageryLayerCollection.prototype.raise=function(e){const t=getLayerIndex(this._layers,e);swapLayers(this,t,t+1)};ImageryLayerCollection.prototype.lower=function(e){const t=getLayerIndex(this._layers,e);swapLayers(this,t,t-1)};ImageryLayerCollection.prototype.raiseToTop=function(e){const t=getLayerIndex(this._layers,e);t!==this._layers.length-1&&(this._layers.splice(t,1),this._layers.push(e),this._update(),this.layerMoved.raiseEvent(e,this._layers.length-1,t))};ImageryLayerCollection.prototype.lowerToBottom=function(e){const t=getLayerIndex(this._layers,e);t!==0&&(this._layers.splice(t,1),this._layers.splice(0,0,e),this._update(),this.layerMoved.raiseEvent(e,0,t))};const applicableRectangleScratch=new Rectangle;function pickImageryHelper(e,t,n,i){const r=e.globe._surface._tilesToRender;let o;for(let s=0;!defined(o)&&s<r.length;++s){const l=r[s];Rectangle.contains(l.rectangle,t)&&(o=l)}if(!defined(o))return;const a=o.data.imagery;for(let s=a.length-1;s>=0;--s){const l=a[s],c=l.readyImagery;if(!defined(c)||!c.imageryLayer.ready)continue;const d=c.imageryLayer.imageryProvider;if(n&&!defined(d.pickFeatures)||!Rectangle.contains(c.rectangle,t))continue;const h=applicableRectangleScratch,f=1/1024;h.west=CesiumMath.lerp(o.rectangle.west,o.rectangle.east,l.textureCoordinateRectangle.x-f),h.east=CesiumMath.lerp(o.rectangle.west,o.rectangle.east,l.textureCoordinateRectangle.z+f),h.south=CesiumMath.lerp(o.rectangle.south,o.rectangle.north,l.textureCoordinateRectangle.y-f),h.north=CesiumMath.lerp(o.rectangle.south,o.rectangle.north,l.textureCoordinateRectangle.w+f),Rectangle.contains(h,t)&&i(c)}}ImageryLayerCollection.prototype.pickImageryLayers=function(e,t){const n=t.globe.pick(e,t);if(!defined(n))return;const i=t.ellipsoid.cartesianToCartographic(n),r=[];if(pickImageryHelper(t,i,!1,function(o){r.push(o.imageryLayer)}),r.length!==0)return r};ImageryLayerCollection.prototype.pickImageryLayerFeatures=function(e,t){const n=t.globe.pick(e,t);if(!defined(n))return;const i=t.ellipsoid.cartesianToCartographic(n),r=[],o=[];if(pickImageryHelper(t,i,!0,function(a){if(!a.imageryLayer.ready)return;const l=a.imageryLayer.imageryProvider.pickFeatures(a.x,a.y,a.level,i.longitude,i.latitude);defined(l)&&(r.push(l),o.push(a.imageryLayer))}),r.length!==0)return Promise.all(r).then(function(a){const s=[];for(let l=0;l<a.length;++l){const c=a[l],d=o[l];if(defined(c)&&c.length>0)for(let h=0;h<c.length;++h){const f=c[h];f.imageryLayer=d,defined(f.position)||(f.position=i),s.push(f)}}return s})};ImageryLayerCollection.prototype.queueReprojectionCommands=function(e){const t=this._layers;for(let n=0,i=t.length;n<i;++n)t[n].queueReprojectionCommands(e)};ImageryLayerCollection.prototype.cancelReprojections=function(){const e=this._layers;for(let t=0,n=e.length;t<n;++t)e[t].cancelReprojections()};ImageryLayerCollection.prototype.isDestroyed=function(){return!1};ImageryLayerCollection.prototype.destroy=function(){return this.removeAll(!0),destroyObject(this)};ImageryLayerCollection.prototype._update=function(){let e=!0;const t=this._layers;let n,i,r,o;for(r=0,o=t.length;r<o;++r)i=t[r],i._layerIndex=r,i.show?(i._isBaseLayer=e,e=!1):i._isBaseLayer=!1,i.show!==i._show&&(defined(i._show)&&(defined(n)||(n=[]),n.push(i)),i._show=i.show);if(defined(n))for(r=0,o=n.length;r<o;++r)i=n[r],this.layerShownOrHidden.raiseEvent(i,i._layerIndex,i.show)};function QuadtreeOccluders(e){this._ellipsoid=new EllipsoidalOccluder(e.ellipsoid,Cartesian3.ZERO)}Object.defineProperties(QuadtreeOccluders.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}});function QuadtreeTile(e){if(!defined(e))throw new DeveloperError("options is required.");if(defined(e.x))if(defined(e.y)){if(e.x<0||e.y<0)throw new DeveloperError("options.x and options.y must be greater than or equal to zero.")}else throw new DeveloperError("options.y is required.");else throw new DeveloperError("options.x is required.");if(!defined(e.level))throw new DeveloperError("options.level is required and must be greater than or equal to zero.");if(!defined(e.tilingScheme))throw new DeveloperError("options.tilingScheme is required.");this._tilingScheme=e.tilingScheme,this._x=e.x,this._y=e.y,this._level=e.level,this._parent=e.parent,this._rectangle=this._tilingScheme.tileXYToRectangle(this._x,this._y,this._level),this._southwestChild=void 0,this._southeastChild=void 0,this._northwestChild=void 0,this._northeastChild=void 0,this.replacementPrevious=void 0,this.replacementNext=void 0,this._distance=0,this._loadPriority=0,this._customData=[],this._frameUpdated=void 0,this._lastSelectionResult=TileSelectionResult$1.NONE,this._lastSelectionResultFrame=void 0,this._loadedCallbacks={},this.state=QuadtreeTileLoadState$1.START,this.renderable=!1,this.upsampledFromParent=!1,this.data=void 0}QuadtreeTile.createLevelZeroTiles=function(e){if(!defined(e))throw new DeveloperError("tilingScheme is required.");const t=e.getNumberOfXTilesAtLevel(0),n=e.getNumberOfYTilesAtLevel(0),i=new Array(t*n);let r=0;for(let o=0;o<n;++o)for(let a=0;a<t;++a)i[r++]=new QuadtreeTile({tilingScheme:e,x:a,y:o,level:0});return i};QuadtreeTile.prototype._updateCustomData=function(e,t,n){let i=this.customData,r,o,a;if(defined(t)&&defined(n)){for(i=i.filter(function(s){return n.indexOf(s)===-1}),this._customData=i,a=this._rectangle,r=0;r<t.length;++r)o=t[r],Rectangle.contains(a,o.positionCartographic)&&i.push(o);this._frameUpdated=e}else{const s=this._parent;if(defined(s)&&this._frameUpdated!==s._frameUpdated){i.length=0,a=this._rectangle;const l=s.customData;for(r=0;r<l.length;++r)o=l[r],Rectangle.contains(a,o.positionCartographic)&&i.push(o);this._frameUpdated=s._frameUpdated}}};Object.defineProperties(QuadtreeTile.prototype,{tilingScheme:{get:function(){return this._tilingScheme}},x:{get:function(){return this._x}},y:{get:function(){return this._y}},level:{get:function(){return this._level}},parent:{get:function(){return this._parent}},rectangle:{get:function(){return this._rectangle}},children:{get:function(){return[this.northwestChild,this.northeastChild,this.southwestChild,this.southeastChild]}},southwestChild:{get:function(){return defined(this._southwestChild)||(this._southwestChild=new QuadtreeTile({tilingScheme:this.tilingScheme,x:this.x*2,y:this.y*2+1,level:this.level+1,parent:this})),this._southwestChild}},southeastChild:{get:function(){return defined(this._southeastChild)||(this._southeastChild=new QuadtreeTile({tilingScheme:this.tilingScheme,x:this.x*2+1,y:this.y*2+1,level:this.level+1,parent:this})),this._southeastChild}},northwestChild:{get:function(){return defined(this._northwestChild)||(this._northwestChild=new QuadtreeTile({tilingScheme:this.tilingScheme,x:this.x*2,y:this.y*2,level:this.level+1,parent:this})),this._northwestChild}},northeastChild:{get:function(){return defined(this._northeastChild)||(this._northeastChild=new QuadtreeTile({tilingScheme:this.tilingScheme,x:this.x*2+1,y:this.y*2,level:this.level+1,parent:this})),this._northeastChild}},customData:{get:function(){return this._customData}},needsLoading:{get:function(){return this.state<QuadtreeTileLoadState$1.DONE}},eligibleForUnloading:{get:function(){let e=!0;return defined(this.data)&&(e=this.data.eligibleForUnloading,defined(e)||(e=!0)),e}}});QuadtreeTile.prototype.findLevelZeroTile=function(e,t,n){const i=this.tilingScheme.getNumberOfXTilesAtLevel(0);if(t<0?t+=i:t>=i&&(t-=i),!(n<0||n>=this.tilingScheme.getNumberOfYTilesAtLevel(0)))return e.filter(function(r){return r.x===t&&r.y===n})[0]};QuadtreeTile.prototype.findTileToWest=function(e){const t=this.parent;if(t===void 0)return this.findLevelZeroTile(e,this.x-1,this.y);if(t.southeastChild===this)return t.southwestChild;if(t.northeastChild===this)return t.northwestChild;const n=t.findTileToWest(e);if(n!==void 0)return t.southwestChild===this?n.southeastChild:n.northeastChild};QuadtreeTile.prototype.findTileToEast=function(e){const t=this.parent;if(t===void 0)return this.findLevelZeroTile(e,this.x+1,this.y);if(t.southwestChild===this)return t.southeastChild;if(t.northwestChild===this)return t.northeastChild;const n=t.findTileToEast(e);if(n!==void 0)return t.southeastChild===this?n.southwestChild:n.northwestChild};QuadtreeTile.prototype.findTileToSouth=function(e){const t=this.parent;if(t===void 0)return this.findLevelZeroTile(e,this.x,this.y+1);if(t.northwestChild===this)return t.southwestChild;if(t.northeastChild===this)return t.southeastChild;const n=t.findTileToSouth(e);if(n!==void 0)return t.southwestChild===this?n.northwestChild:n.northeastChild};QuadtreeTile.prototype.findTileToNorth=function(e){const t=this.parent;if(t===void 0)return this.findLevelZeroTile(e,this.x,this.y-1);if(t.southwestChild===this)return t.northwestChild;if(t.southeastChild===this)return t.northeastChild;const n=t.findTileToNorth(e);if(n!==void 0)return t.northwestChild===this?n.southwestChild:n.southeastChild};QuadtreeTile.prototype.freeResources=function(){this.state=QuadtreeTileLoadState$1.START,this.renderable=!1,this.upsampledFromParent=!1,defined(this.data)&&defined(this.data.freeResources)&&this.data.freeResources(),freeTile(this._southwestChild),this._southwestChild=void 0,freeTile(this._southeastChild),this._southeastChild=void 0,freeTile(this._northwestChild),this._northwestChild=void 0,freeTile(this._northeastChild),this._northeastChild=void 0};function freeTile(e){defined(e)&&e.freeResources()}function TileReplacementQueue(){this.head=void 0,this.tail=void 0,this.count=0,this._lastBeforeStartOfFrame=void 0}TileReplacementQueue.prototype.markStartOfRenderFrame=function(){this._lastBeforeStartOfFrame=this.head};TileReplacementQueue.prototype.trimTiles=function(e){let t=this.tail,n=!0;for(;n&&defined(this._lastBeforeStartOfFrame)&&this.count>e&&defined(t);){n=t!==this._lastBeforeStartOfFrame;const i=t.replacementPrevious;t.eligibleForUnloading&&(t.freeResources(),remove(this,t)),t=i}};function remove(e,t){const n=t.replacementPrevious,i=t.replacementNext;t===e._lastBeforeStartOfFrame&&(e._lastBeforeStartOfFrame=i),t===e.head?e.head=i:n.replacementNext=i,t===e.tail?e.tail=n:i.replacementPrevious=n,t.replacementPrevious=void 0,t.replacementNext=void 0,--e.count}TileReplacementQueue.prototype.markTileRendered=function(e){const t=this.head;if(t===e){e===this._lastBeforeStartOfFrame&&(this._lastBeforeStartOfFrame=e.replacementNext);return}if(++this.count,!defined(t)){e.replacementPrevious=void 0,e.replacementNext=void 0,this.head=e,this.tail=e;return}(defined(e.replacementPrevious)||defined(e.replacementNext))&&remove(this,e),e.replacementPrevious=void 0,e.replacementNext=t,t.replacementPrevious=e,this.head=e};function QuadtreePrimitive(e){if(!defined(e)||!defined(e.tileProvider))throw new DeveloperError("options.tileProvider is required.");if(defined(e.tileProvider.quadtree))throw new DeveloperError("A QuadtreeTileProvider can only be used with a single QuadtreePrimitive");this._tileProvider=e.tileProvider,this._tileProvider.quadtree=this,this._debug={enableDebugOutput:!1,maxDepth:0,maxDepthVisited:0,tilesVisited:0,tilesCulled:0,tilesRendered:0,tilesWaitingForChildren:0,lastMaxDepth:-1,lastMaxDepthVisited:-1,lastTilesVisited:-1,lastTilesCulled:-1,lastTilesRendered:-1,lastTilesWaitingForChildren:-1,suspendLodUpdate:!1};const n=this._tileProvider.tilingScheme.ellipsoid;this._tilesToRender=[],this._tileLoadQueueHigh=[],this._tileLoadQueueMedium=[],this._tileLoadQueueLow=[],this._tileReplacementQueue=new TileReplacementQueue,this._levelZeroTiles=void 0,this._loadQueueTimeSlice=5,this._tilesInvalidated=!1,this._addHeightCallbacks=[],this._removeHeightCallbacks=[],this._tileToUpdateHeights=[],this._lastTileIndex=0,this._updateHeightsTimeSlice=2,this._cameraPositionCartographic=void 0,this._cameraReferenceFrameOriginCartographic=void 0,this.maximumScreenSpaceError=defaultValue(e.maximumScreenSpaceError,2),this.tileCacheSize=defaultValue(e.tileCacheSize,100),this.loadingDescendantLimit=20,this.preloadAncestors=!0,this.preloadSiblings=!1,this._occluders=new QuadtreeOccluders({ellipsoid:n}),this._tileLoadProgressEvent=new Event,this._lastTileLoadQueueLength=0,this._lastSelectionFrameNumber=void 0}Object.defineProperties(QuadtreePrimitive.prototype,{tileProvider:{get:function(){return this._tileProvider}},tileLoadProgressEvent:{get:function(){return this._tileLoadProgressEvent}},occluders:{get:function(){return this._occluders}}});QuadtreePrimitive.prototype.invalidateAllTiles=function(){this._tilesInvalidated=!0};function invalidateAllTiles(e){const t=e._tileReplacementQueue;t.head=void 0,t.tail=void 0,t.count=0,clearTileLoadQueue(e);const n=e._levelZeroTiles;if(defined(n))for(let i=0;i<n.length;++i){const o=n[i].customData,a=o.length;for(let s=0;s<a;++s){const l=o[s];l.level=0,e._addHeightCallbacks.push(l)}n[i].freeResources()}e._levelZeroTiles=void 0,e._tileProvider.cancelReprojections()}QuadtreePrimitive.prototype.forEachLoadedTile=function(e){let t=this._tileReplacementQueue.head;for(;defined(t);)t.state!==QuadtreeTileLoadState$1.START&&e(t),t=t.replacementNext};QuadtreePrimitive.prototype.forEachRenderedTile=function(e){const t=this._tilesToRender;for(let n=0,i=t.length;n<i;++n)e(t[n])};QuadtreePrimitive.prototype.updateHeight=function(e,t){const n=this,i={positionOnEllipsoidSurface:void 0,positionCartographic:e,level:-1,callback:t};return i.removeFunc=function(){const r=n._addHeightCallbacks,o=r.length;for(let a=0;a<o;++a)if(r[a]===i){r.splice(a,1);break}n._removeHeightCallbacks.push(i),i.callback&&(i.callback=void 0)},n._addHeightCallbacks.push(i),i.removeFunc};QuadtreePrimitive.prototype.update=function(e){defined(this._tileProvider.update)&&this._tileProvider.update(e)};function clearTileLoadQueue(e){const t=e._debug;t.maxDepth=0,t.maxDepthVisited=0,t.tilesVisited=0,t.tilesCulled=0,t.tilesRendered=0,t.tilesWaitingForChildren=0,e._tileLoadQueueHigh.length=0,e._tileLoadQueueMedium.length=0,e._tileLoadQueueLow.length=0}QuadtreePrimitive.prototype.beginFrame=function(e){e.passes.render&&(this._tilesInvalidated&&(invalidateAllTiles(this),this._tilesInvalidated=!1),this._tileProvider.initialize(e),clearTileLoadQueue(this),!this._debug.suspendLodUpdate&&this._tileReplacementQueue.markStartOfRenderFrame())};QuadtreePrimitive.prototype.render=function(e){const t=e.passes,n=this._tileProvider;t.render&&(n.beginUpdate(e),selectTilesForRendering(this,e),createRenderCommandsForSelectedTiles(this,e),n.endUpdate(e)),t.pick&&this._tilesToRender.length>0&&n.updateForPick(e)};function updateTileLoadProgress(e,t){const n=e._tileLoadQueueHigh.length+e._tileLoadQueueMedium.length+e._tileLoadQueueLow.length;if(n!==e._lastTileLoadQueueLength||e._tilesInvalidated){const r=Event.prototype.raiseEvent.bind(e._tileLoadProgressEvent,n);t.afterRender.push(()=>(r(),!0)),e._lastTileLoadQueueLength=n}const i=e._debug;i.enableDebugOutput&&!i.suspendLodUpdate&&(i.maxDepth=e._tilesToRender.reduce(function(r,o){return Math.max(r,o.level)},-1),i.tilesRendered=e._tilesToRender.length,(i.tilesVisited!==i.lastTilesVisited||i.tilesRendered!==i.lastTilesRendered||i.tilesCulled!==i.lastTilesCulled||i.maxDepth!==i.lastMaxDepth||i.tilesWaitingForChildren!==i.lastTilesWaitingForChildren||i.maxDepthVisited!==i.lastMaxDepthVisited)&&(console.log(`Visited ${i.tilesVisited}, Rendered: ${i.tilesRendered}, Culled: ${i.tilesCulled}, Max Depth Rendered: ${i.maxDepth}, Max Depth Visited: ${i.maxDepthVisited}, Waiting for children: ${i.tilesWaitingForChildren}`),i.lastTilesVisited=i.tilesVisited,i.lastTilesRendered=i.tilesRendered,i.lastTilesCulled=i.tilesCulled,i.lastMaxDepth=i.maxDepth,i.lastTilesWaitingForChildren=i.tilesWaitingForChildren,i.lastMaxDepthVisited=i.maxDepthVisited))}QuadtreePrimitive.prototype.endFrame=function(e){!e.passes.render||e.mode===SceneMode.MORPHING||(processTileLoadQueue(this,e),updateHeights(this,e),updateTileLoadProgress(this,e))};QuadtreePrimitive.prototype.isDestroyed=function(){return!1};QuadtreePrimitive.prototype.destroy=function(){this._tileProvider=this._tileProvider&&this._tileProvider.destroy()};let comparisonPoint;const centerScratch$1=new Cartographic;function compareDistanceToPoint(e,t){let n=Rectangle.center(e.rectangle,centerScratch$1);const i=n.longitude-comparisonPoint.longitude,r=n.latitude-comparisonPoint.latitude;n=Rectangle.center(t.rectangle,centerScratch$1);const o=n.longitude-comparisonPoint.longitude,a=n.latitude-comparisonPoint.latitude;return i*i+r*r-(o*o+a*a)}const cameraOriginScratch=new Cartesian3;let rootTraversalDetails=[];function selectTilesForRendering(e,t){const n=e._debug;if(n.suspendLodUpdate)return;const i=e._tilesToRender;i.length=0;let r;const o=e._tileProvider;if(!defined(e._levelZeroTiles)){const m=o.tilingScheme;if(defined(m)){const g=o.tilingScheme;e._levelZeroTiles=QuadtreeTile.createLevelZeroTiles(g);const _=e._levelZeroTiles.length;if(rootTraversalDetails.length<_)for(rootTraversalDetails=new Array(_),r=0;r<_;++r)rootTraversalDetails[r]===void 0&&(rootTraversalDetails[r]=new TraversalDetails)}else return}e._occluders.ellipsoid.cameraPosition=t.camera.positionWC;let a;const s=e._levelZeroTiles,l=s.length>1?e._occluders:void 0;comparisonPoint=t.camera.positionCartographic,s.sort(compareDistanceToPoint);const c=e._addHeightCallbacks,d=e._removeHeightCallbacks,h=t.frameNumber;let f;if(c.length>0||d.length>0){for(r=0,f=s.length;r<f;++r)a=s[r],a._updateCustomData(h,c,d);c.length=0,d.length=0}const p=t.camera;e._cameraPositionCartographic=p.positionCartographic;const u=Matrix4.getTranslation(p.transform,cameraOriginScratch);for(e._cameraReferenceFrameOriginCartographic=e.tileProvider.tilingScheme.ellipsoid.cartesianToCartographic(u,e._cameraReferenceFrameOriginCartographic),r=0,f=s.length;r<f;++r)a=s[r],e._tileReplacementQueue.markTileRendered(a),a.renderable?visitIfVisible(e,a,o,t,l,!1,rootTraversalDetails[r]):(queueTileLoad(e,e._tileLoadQueueHigh,a,t),++n.tilesWaitingForChildren);e._lastSelectionFrameNumber=h}function queueTileLoad(e,t,n,i){n.needsLoading&&(e.tileProvider.computeTileLoadPriority!==void 0&&(n._loadPriority=e.tileProvider.computeTileLoadPriority(n,i)),t.push(n))}function TraversalDetails(){this.allAreRenderable=!0,this.anyWereRenderedLastFrame=!1,this.notYetRenderableCount=0}function TraversalQuadDetails(){this.southwest=new TraversalDetails,this.southeast=new TraversalDetails,this.northwest=new TraversalDetails,this.northeast=new TraversalDetails}TraversalQuadDetails.prototype.combine=function(e){const t=this.southwest,n=this.southeast,i=this.northwest,r=this.northeast;e.allAreRenderable=t.allAreRenderable&&n.allAreRenderable&&i.allAreRenderable&&r.allAreRenderable,e.anyWereRenderedLastFrame=t.anyWereRenderedLastFrame||n.anyWereRenderedLastFrame||i.anyWereRenderedLastFrame||r.anyWereRenderedLastFrame,e.notYetRenderableCount=t.notYetRenderableCount+n.notYetRenderableCount+i.notYetRenderableCount+r.notYetRenderableCount};const traversalQuadsByLevel=new Array(31);for(let e=0;e<traversalQuadsByLevel.length;++e)traversalQuadsByLevel[e]=new TraversalQuadDetails;function visitTile(e,t,n,i,r){const o=e._debug;++o.tilesVisited,e._tileReplacementQueue.markTileRendered(n),n._updateCustomData(t.frameNumber),n.level>o.maxDepthVisited&&(o.maxDepthVisited=n.level);const a=screenSpaceError(e,t,n)<e.maximumScreenSpaceError,s=n.southwestChild,l=n.southeastChild,c=n.northwestChild,d=n.northeastChild,h=e._lastSelectionFrameNumber,f=n._lastSelectionResultFrame===h?n._lastSelectionResult:TileSelectionResult$1.NONE,p=e.tileProvider;if(a||i){const u=TileSelectionResult$1.originalResult(f)===TileSelectionResult$1.RENDERED,m=TileSelectionResult$1.originalResult(f)===TileSelectionResult$1.CULLED||f===TileSelectionResult$1.NONE,g=n.state===QuadtreeTileLoadState$1.DONE;let _=u||m||g;if(_||defined(p.canRenderWithoutLosingDetail)&&(_=p.canRenderWithoutLosingDetail(n)),_){a&&queueTileLoad(e,e._tileLoadQueueMedium,n,t),addTileToRenderList(e,n),r.allAreRenderable=n.renderable,r.anyWereRenderedLastFrame=f===TileSelectionResult$1.RENDERED,r.notYetRenderableCount=n.renderable?0:1,n._lastSelectionResultFrame=t.frameNumber,n._lastSelectionResult=TileSelectionResult$1.RENDERED,r.anyWereRenderedLastFrame||e._tileToUpdateHeights.push(n);return}i=!0,a&&queueTileLoad(e,e._tileLoadQueueHigh,n,t)}if(p.canRefine(n)){if(s.upsampledFromParent&&l.upsampledFromParent&&c.upsampledFromParent&&d.upsampledFromParent){addTileToRenderList(e,n),queueTileLoad(e,e._tileLoadQueueMedium,n,t),e._tileReplacementQueue.markTileRendered(s),e._tileReplacementQueue.markTileRendered(l),e._tileReplacementQueue.markTileRendered(c),e._tileReplacementQueue.markTileRendered(d),r.allAreRenderable=n.renderable,r.anyWereRenderedLastFrame=f===TileSelectionResult$1.RENDERED,r.notYetRenderableCount=n.renderable?0:1,n._lastSelectionResultFrame=t.frameNumber,n._lastSelectionResult=TileSelectionResult$1.RENDERED,r.anyWereRenderedLastFrame||e._tileToUpdateHeights.push(n);return}n._lastSelectionResultFrame=t.frameNumber,n._lastSelectionResult=TileSelectionResult$1.REFINED;const m=e._tilesToRender.length,g=e._tileLoadQueueLow.length,_=e._tileLoadQueueMedium.length,C=e._tileLoadQueueHigh.length,A=e._tileToUpdateHeights.length;if(visitVisibleChildrenNearToFar(e,s,l,c,d,t,i,r),m!==e._tilesToRender.length){const S=r.allAreRenderable,v=r.anyWereRenderedLastFrame,b=r.notYetRenderableCount;let D=!1;if(!S&&!v){const I=e._tilesToRender;for(let N=m;N<I.length;++N){let y=I[N];for(;y!==void 0&&y._lastSelectionResult!==TileSelectionResult$1.KICKED&&y!==n;)y._lastSelectionResult=TileSelectionResult$1.kick(y._lastSelectionResult),y=y.parent}e._tilesToRender.length=m,e._tileToUpdateHeights.length=A,addTileToRenderList(e,n),n._lastSelectionResult=TileSelectionResult$1.RENDERED;const L=f===TileSelectionResult$1.RENDERED;!L&&b>e.loadingDescendantLimit&&(e._tileLoadQueueLow.length=g,e._tileLoadQueueMedium.length=_,e._tileLoadQueueHigh.length=C,queueTileLoad(e,e._tileLoadQueueMedium,n,t),r.notYetRenderableCount=n.renderable?0:1,D=!0),r.allAreRenderable=n.renderable,r.anyWereRenderedLastFrame=L,L||e._tileToUpdateHeights.push(n),++o.tilesWaitingForChildren}e.preloadAncestors&&!D&&queueTileLoad(e,e._tileLoadQueueLow,n,t)}return}n._lastSelectionResultFrame=t.frameNumber,n._lastSelectionResult=TileSelectionResult$1.RENDERED,addTileToRenderList(e,n),queueTileLoad(e,e._tileLoadQueueHigh,n,t),r.allAreRenderable=n.renderable,r.anyWereRenderedLastFrame=f===TileSelectionResult$1.RENDERED,r.notYetRenderableCount=n.renderable?0:1}function visitVisibleChildrenNearToFar(e,t,n,i,r,o,a,s){const l=o.camera.positionCartographic,c=e._tileProvider,d=e._occluders,h=traversalQuadsByLevel[t.level],f=h.southwest,p=h.southeast,u=h.northwest,m=h.northeast;l.longitude<t.rectangle.east?l.latitude<t.rectangle.north?(visitIfVisible(e,t,c,o,d,a,f),visitIfVisible(e,n,c,o,d,a,p),visitIfVisible(e,i,c,o,d,a,u),visitIfVisible(e,r,c,o,d,a,m)):(visitIfVisible(e,i,c,o,d,a,u),visitIfVisible(e,t,c,o,d,a,f),visitIfVisible(e,r,c,o,d,a,m),visitIfVisible(e,n,c,o,d,a,p)):l.latitude<t.rectangle.north?(visitIfVisible(e,n,c,o,d,a,p),visitIfVisible(e,t,c,o,d,a,f),visitIfVisible(e,r,c,o,d,a,m),visitIfVisible(e,i,c,o,d,a,u)):(visitIfVisible(e,r,c,o,d,a,m),visitIfVisible(e,i,c,o,d,a,u),visitIfVisible(e,n,c,o,d,a,p),visitIfVisible(e,t,c,o,d,a,f)),h.combine(s)}function containsNeededPosition(e,t){const n=t.rectangle;return defined(e._cameraPositionCartographic)&&Rectangle.contains(n,e._cameraPositionCartographic)||defined(e._cameraReferenceFrameOriginCartographic)&&Rectangle.contains(n,e._cameraReferenceFrameOriginCartographic)}function visitIfVisible(e,t,n,i,r,o,a){if(n.computeTileVisibility(t,i,r)!==Visibility$1.NONE)return visitTile(e,i,t,o,a);if(++e._debug.tilesCulled,e._tileReplacementQueue.markTileRendered(t),a.allAreRenderable=!0,a.anyWereRenderedLastFrame=!1,a.notYetRenderableCount=0,containsNeededPosition(e,t)){(!defined(t.data)||!defined(t.data.vertexArray))&&queueTileLoad(e,e._tileLoadQueueMedium,t,i);const s=e._lastSelectionFrameNumber,l=t._lastSelectionResultFrame===s?t._lastSelectionResult:TileSelectionResult$1.NONE;l!==TileSelectionResult$1.CULLED_BUT_NEEDED&&l!==TileSelectionResult$1.RENDERED&&e._tileToUpdateHeights.push(t),t._lastSelectionResult=TileSelectionResult$1.CULLED_BUT_NEEDED}else(e.preloadSiblings||t.level===0)&&queueTileLoad(e,e._tileLoadQueueLow,t,i),t._lastSelectionResult=TileSelectionResult$1.CULLED;t._lastSelectionResultFrame=i.frameNumber}function screenSpaceError(e,t,n){if(t.mode===SceneMode.SCENE2D||t.camera.frustum instanceof OrthographicFrustum||t.camera.frustum instanceof OrthographicOffCenterFrustum)return screenSpaceError2D(e,t,n);const i=e._tileProvider.getLevelMaximumGeometricError(n.level),r=n._distance,o=t.context.drawingBufferHeight,a=t.camera.frustum.sseDenominator;let s=i*o/(r*a);return t.fog.enabled&&(s-=CesiumMath.fog(r,t.fog.density)*t.fog.sse),s/=t.pixelRatio,s}function screenSpaceError2D(e,t,n){let r=t.camera.frustum;const o=r.offCenterFrustum;defined(o)&&(r=o);const a=t.context,s=a.drawingBufferWidth,l=a.drawingBufferHeight,c=e._tileProvider.getLevelMaximumGeometricError(n.level),d=Math.max(r.top-r.bottom,r.right-r.left)/Math.max(s,l);let h=c/d;return t.fog.enabled&&t.mode!==SceneMode.SCENE2D&&(h-=CesiumMath.fog(n._distance,t.fog.density)*t.fog.sse),h/=t.pixelRatio,h}function addTileToRenderList(e,t){e._tilesToRender.push(t)}function processTileLoadQueue(e,t){const n=e._tileLoadQueueHigh,i=e._tileLoadQueueMedium,r=e._tileLoadQueueLow;if(n.length===0&&i.length===0&&r.length===0)return;e._tileReplacementQueue.trimTiles(e.tileCacheSize);const o=getTimestamp()+e._loadQueueTimeSlice,a=e._tileProvider;let s=processSinglePriorityLoadQueue(e,t,a,o,n,!1);s=processSinglePriorityLoadQueue(e,t,a,o,i,s),processSinglePriorityLoadQueue(e,t,a,o,r,s)}function sortByLoadPriority(e,t){return e._loadPriority-t._loadPriority}function processSinglePriorityLoadQueue(e,t,n,i,r,o){n.computeTileLoadPriority!==void 0&&r.sort(sortByLoadPriority);for(let a=0,s=r.length;a<s&&(getTimestamp()<i||!o);++a){const l=r[a];e._tileReplacementQueue.markTileRendered(l),n.loadTile(t,l),o=!0}return o}const scratchRay=new Ray,scratchCartographic$4=new Cartographic,scratchPosition$2=new Cartesian3,scratchArray$1=[];function updateHeights(e,t){if(!defined(e.tileProvider.tilingScheme))return;const n=scratchArray$1;n.length=0;const i=e._tileToUpdateHeights,r=getTimestamp(),o=e._updateHeightsTimeSlice,a=r+o,s=t.mode,l=t.mapProjection,c=e.tileProvider.tilingScheme.ellipsoid;let d;for(;i.length>0;){const h=i[0];if(!defined(h.data)||!defined(h.data.mesh)){const m=h._lastSelectionResultFrame===e._lastSelectionFrameNumber?h._lastSelectionResult:TileSelectionResult$1.NONE;(m===TileSelectionResult$1.RENDERED||m===TileSelectionResult$1.CULLED_BUT_NEEDED)&&n.push(h),i.shift(),e._lastTileIndex=0;continue}const f=h.customData,p=f.length;let u=!1;for(d=e._lastTileIndex;d<p;++d){const m=f[d],g=h.data.terrainData,_=defined(g)&&g.wasCreatedByUpsampling();if(h.level>m.level&&!_){if(defined(m.positionOnEllipsoidSurface)||(m.positionOnEllipsoidSurface=Cartesian3.fromRadians(m.positionCartographic.longitude,m.positionCartographic.latitude,0,c)),s===SceneMode.SCENE3D){const A=c.geodeticSurfaceNormal(m.positionOnEllipsoidSurface,scratchRay.direction),S=c.getSurfaceNormalIntersectionWithZAxis(m.positionOnEllipsoidSurface,11500,scratchRay.origin);if(!defined(S)){let v=0;defined(h.data.tileBoundingRegion)&&(v=h.data.tileBoundingRegion.minimumHeight);const b=Math.min(v,-11500),D=Cartesian3.multiplyByScalar(A,Math.abs(b)+1,scratchPosition$2);Cartesian3.subtract(m.positionOnEllipsoidSurface,D,scratchRay.origin)}}else Cartographic.clone(m.positionCartographic,scratchCartographic$4),scratchCartographic$4.height=-11500,l.project(scratchCartographic$4,scratchPosition$2),Cartesian3.fromElements(scratchPosition$2.z,scratchPosition$2.x,scratchPosition$2.y,scratchPosition$2),Cartesian3.clone(scratchPosition$2,scratchRay.origin),Cartesian3.clone(Cartesian3.UNIT_X,scratchRay.direction);const C=h.data.pick(scratchRay,s,l,!1,scratchPosition$2);defined(C)&&(defined(m.callback)&&m.callback(C),m.level=h.level)}if(getTimestamp()>=a){u=!0;break}}if(u){e._lastTileIndex=d;break}else e._lastTileIndex=0,i.shift()}for(d=0;d<n.length;d++)i.push(n[d])}function createRenderCommandsForSelectedTiles(e,t){const n=e._tileProvider,i=e._tilesToRender;for(let r=0,o=i.length;r<o;++r){const a=i[r];n.showTileThisFrame(a,t)}}function Globe(e){e=defaultValue(e,Ellipsoid.default);const t=new EllipsoidTerrainProvider({ellipsoid:e}),n=new ImageryLayerCollection;this._ellipsoid=e,this._imageryLayerCollection=n,this._surfaceShaderSet=new GlobeSurfaceShaderSet,this._material=void 0,this._surface=new QuadtreePrimitive({tileProvider:new GlobeSurfaceTileProvider({terrainProvider:t,imageryLayers:n,surfaceShaderSet:this._surfaceShaderSet})}),this._terrainProvider=t,this._terrainProviderChanged=new Event,this._undergroundColor=Color.clone(Color.BLACK),this._undergroundColorAlphaByDistance=new NearFarScalar(e.maximumRadius/1e3,0,e.maximumRadius/5,1),this._translucency=new GlobeTranslucency,makeShadersDirty(this),this.show=!0,this._oceanNormalMapResourceDirty=!0,this._oceanNormalMapResource=new Resource({url:buildModuleUrl("Assets/Textures/waterNormalsSmall.jpg")}),this.maximumScreenSpaceError=2,this.tileCacheSize=100,this.loadingDescendantLimit=20,this.preloadAncestors=!0,this.preloadSiblings=!1,this.fillHighlightColor=void 0,this.enableLighting=!1,this.lambertDiffuseMultiplier=.9,this.dynamicAtmosphereLighting=!0,this.dynamicAtmosphereLightingFromSun=!1,this.showGroundAtmosphere=Ellipsoid.WGS84.equals(e),this.atmosphereLightIntensity=10,this.atmosphereRayleighCoefficient=new Cartesian3(55e-7,13e-6,284e-7),this.atmosphereMieCoefficient=new Cartesian3(21e-6,21e-6,21e-6),this.atmosphereRayleighScaleHeight=1e4,this.atmosphereMieScaleHeight=3200,this.atmosphereMieAnisotropy=.9,this.lightingFadeOutDistance=CesiumMath.PI_OVER_TWO*e.minimumRadius,this.lightingFadeInDistance=CesiumMath.PI*e.minimumRadius,this.nightFadeOutDistance=CesiumMath.PI_OVER_TWO*e.minimumRadius,this.nightFadeInDistance=5*CesiumMath.PI_OVER_TWO*e.minimumRadius,this.showWaterEffect=!0,this.depthTestAgainstTerrain=!1,this.shadows=ShadowMode.RECEIVE_ONLY,this.atmosphereHueShift=0,this.atmosphereSaturationShift=0,this.atmosphereBrightnessShift=0,this.showSkirts=!0,this.backFaceCulling=!0,this._oceanNormalMap=void 0,this._zoomedOutOceanSpecularIntensity=void 0,this.vertexShadowDarkness=.3}Object.defineProperties(Globe.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},imageryLayers:{get:function(){return this._imageryLayerCollection}},imageryLayersUpdatedEvent:{get:function(){return this._surface.tileProvider.imageryLayersUpdatedEvent}},tilesLoaded:{get:function(){return defined(this._surface)?this._surface._tileLoadQueueHigh.length===0&&this._surface._tileLoadQueueMedium.length===0&&this._surface._tileLoadQueueLow.length===0:!0}},baseColor:{get:function(){return this._surface.tileProvider.baseColor},set:function(e){this._surface.tileProvider.baseColor=e}},clippingPlanes:{get:function(){return this._surface.tileProvider.clippingPlanes},set:function(e){this._surface.tileProvider.clippingPlanes=e}},clippingPolygons:{get:function(){return this._surface.tileProvider.clippingPolygons},set:function(e){this._surface.tileProvider.clippingPolygons=e}},cartographicLimitRectangle:{get:function(){return this._surface.tileProvider.cartographicLimitRectangle},set:function(e){defined(e)||(e=Rectangle.clone(Rectangle.MAX_VALUE)),this._surface.tileProvider.cartographicLimitRectangle=e}},oceanNormalMapUrl:{get:function(){return this._oceanNormalMapResource.url},set:function(e){this._oceanNormalMapResource.url=e,this._oceanNormalMapResourceDirty=!0}},terrainProvider:{get:function(){return this._terrainProvider},set:function(e){e!==this._terrainProvider&&(this._terrainProvider=e,this._terrainProviderChanged.raiseEvent(e),defined(this._material)&&makeShadersDirty(this))}},terrainProviderChanged:{get:function(){return this._terrainProviderChanged}},tileLoadProgressEvent:{get:function(){return this._surface.tileLoadProgressEvent}},material:{get:function(){return this._material},set:function(e){this._material!==e&&(this._material=e,makeShadersDirty(this))}},undergroundColor:{get:function(){return this._undergroundColor},set:function(e){this._undergroundColor=Color.clone(e,this._undergroundColor)}},undergroundColorAlphaByDistance:{get:function(){return this._undergroundColorAlphaByDistance},set:function(e){if(defined(e)&&e.far<e.near)throw new DeveloperError("far distance must be greater than near distance.");this._undergroundColorAlphaByDistance=NearFarScalar.clone(e,this._undergroundColorAlphaByDistance)}},translucency:{get:function(){return this._translucency}}});function makeShadersDirty(e){const t=[],n=defined(e._material)&&(defined(e._material.shaderSource.match(/slope/))||defined(e._material.shaderSource.match("normalEC"))),i=[AtmosphereCommon,GroundAtmosphere];defined(e._material)&&(!n||e._terrainProvider.requestVertexNormals)?(i.push(e._material.shaderSource),t.push("APPLY_MATERIAL"),e._surface._tileProvider.materialUniformMap=e._material._uniforms):e._surface._tileProvider.materialUniformMap=void 0,i.push(GlobeFS),e._surfaceShaderSet.baseVertexShaderSource=new ShaderSource({sources:[AtmosphereCommon,GroundAtmosphere,GlobeVS],defines:t}),e._surfaceShaderSet.baseFragmentShaderSource=new ShaderSource({sources:i,defines:t}),e._surfaceShaderSet.material=e._material}function createComparePickTileFunction(e){return function(t,n){const i=BoundingSphere.distanceSquaredTo(t.pickBoundingSphere,e),r=BoundingSphere.distanceSquaredTo(n.pickBoundingSphere,e);return i-r}}const scratchArray=[],scratchSphereIntersectionResult={start:0,stop:0};Globe.prototype.pickWorldCoordinates=function(e,t,n,i){if(!defined(e))throw new DeveloperError("ray is required");if(!defined(t))throw new DeveloperError("scene is required");n=defaultValue(n,!0);const r=t.mode,o=t.mapProjection,a=scratchArray;a.length=0;const s=this._surface._tilesToRender;let l=s.length,c,d;for(d=0;d<l;++d){c=s[d];const f=c.data;if(!defined(f))continue;let p=f.pickBoundingSphere;if(r!==SceneMode.SCENE3D)f.pickBoundingSphere=p=BoundingSphere.fromRectangleWithHeights2D(c.rectangle,o,f.tileBoundingRegion.minimumHeight,f.tileBoundingRegion.maximumHeight,p),Cartesian3.fromElements(p.center.z,p.center.x,p.center.y,p.center);else if(defined(f.renderedMesh))BoundingSphere.clone(f.tileBoundingRegion.boundingSphere,p);else continue;const u=IntersectionTests.raySphere(e,p,scratchSphereIntersectionResult);defined(u)&&a.push(f)}a.sort(createComparePickTileFunction(e.origin));let h;for(l=a.length,d=0;d<l&&(h=a[d].pick(e,t.mode,t.mapProjection,n,i),!defined(h));++d);return h};const cartoScratch=new Cartographic;Globe.prototype.pick=function(e,t,n){if(n=this.pickWorldCoordinates(e,t,!0,n),defined(n)&&t.mode!==SceneMode.SCENE3D){n=Cartesian3.fromElements(n.y,n.z,n.x,n);const i=t.mapProjection.unproject(n,cartoScratch);n=this._ellipsoid.cartographicToCartesian(i,n)}return n};const scratchGetHeightCartesian=new Cartesian3,scratchGetHeightIntersection=new Cartesian3,scratchGetHeightCartographic=new Cartographic,scratchGetHeightRay=new Ray;function tileIfContainsCartographic(e,t){return defined(e)&&Rectangle.contains(e.rectangle,t)?e:void 0}Globe.prototype.getHeight=function(e){if(!defined(e))throw new DeveloperError("cartographic is required");const t=this._surface._levelZeroTiles;if(!defined(t))return;let n,i;const r=t.length;for(i=0;i<r&&(n=t[i],!Rectangle.contains(n.rectangle,e));++i);if(i>=r)return;let o=n;for(;defined(n);)n=tileIfContainsCartographic(n._southwestChild,e)||tileIfContainsCartographic(n._southeastChild,e)||tileIfContainsCartographic(n._northwestChild,e)||n._northeastChild,defined(n)&&defined(n.data)&&defined(n.data.renderedMesh)&&(o=n);if(n=o,!defined(n)||!defined(n.data)||!defined(n.data.renderedMesh))return;const a=this._surface._tileProvider.tilingScheme.projection,s=this._surface._tileProvider.tilingScheme.ellipsoid,l=Cartesian3.fromRadians(e.longitude,e.latitude,0,s,scratchGetHeightCartesian),c=scratchGetHeightRay,d=s.geodeticSurfaceNormal(l,c.direction),h=s.getSurfaceNormalIntersectionWithZAxis(l,11500,c.origin);if(!defined(h)){let p;defined(n.data.tileBoundingRegion)&&(p=n.data.tileBoundingRegion.minimumHeight);const u=Math.min(defaultValue(p,0),-11500),m=Cartesian3.multiplyByScalar(d,Math.abs(u)+1,scratchGetHeightIntersection);Cartesian3.subtract(l,m,c.origin)}const f=n.data.pick(c,void 0,a,!1,scratchGetHeightIntersection);if(defined(f))return s.cartesianToCartographic(f,scratchGetHeightCartographic).height};Globe.prototype.update=function(e){this.show&&e.passes.render&&this._surface.update(e)};Globe.prototype.beginFrame=function(e){const t=this._surface,n=t.tileProvider,i=this.terrainProvider,r=this.showWaterEffect&&defined(i)&&i.hasWaterMask&&i.hasWaterMask;if(r&&this._oceanNormalMapResourceDirty){this._oceanNormalMapResourceDirty=!1;const s=this._oceanNormalMapResource,l=s.url;if(defined(l)){const c=this;s.fetchImage().then(function(d){l===c._oceanNormalMapResource.url&&(c._oceanNormalMap=c._oceanNormalMap&&c._oceanNormalMap.destroy(),c._oceanNormalMap=new Texture({context:e.context,source:d}))})}else this._oceanNormalMap=this._oceanNormalMap&&this._oceanNormalMap.destroy()}const o=e.passes,a=e.mode;o.render&&(this.showGroundAtmosphere?this._zoomedOutOceanSpecularIntensity=.4:this._zoomedOutOceanSpecularIntensity=.5,t.maximumScreenSpaceError=this.maximumScreenSpaceError,t.tileCacheSize=this.tileCacheSize,t.loadingDescendantLimit=this.loadingDescendantLimit,t.preloadAncestors=this.preloadAncestors,t.preloadSiblings=this.preloadSiblings,n.terrainProvider=this.terrainProvider,n.lightingFadeOutDistance=this.lightingFadeOutDistance,n.lightingFadeInDistance=this.lightingFadeInDistance,n.nightFadeOutDistance=this.nightFadeOutDistance,n.nightFadeInDistance=this.nightFadeInDistance,n.zoomedOutOceanSpecularIntensity=a===SceneMode.SCENE3D?this._zoomedOutOceanSpecularIntensity:0,n.hasWaterMask=r,n.oceanNormalMap=this._oceanNormalMap,n.enableLighting=this.enableLighting,n.dynamicAtmosphereLighting=this.dynamicAtmosphereLighting,n.dynamicAtmosphereLightingFromSun=this.dynamicAtmosphereLightingFromSun,n.showGroundAtmosphere=this.showGroundAtmosphere,n.atmosphereLightIntensity=this.atmosphereLightIntensity,n.atmosphereRayleighCoefficient=this.atmosphereRayleighCoefficient,n.atmosphereMieCoefficient=this.atmosphereMieCoefficient,n.atmosphereRayleighScaleHeight=this.atmosphereRayleighScaleHeight,n.atmosphereMieScaleHeight=this.atmosphereMieScaleHeight,n.atmosphereMieAnisotropy=this.atmosphereMieAnisotropy,n.shadows=this.shadows,n.hueShift=this.atmosphereHueShift,n.saturationShift=this.atmosphereSaturationShift,n.brightnessShift=this.atmosphereBrightnessShift,n.fillHighlightColor=this.fillHighlightColor,n.showSkirts=this.showSkirts,n.backFaceCulling=this.backFaceCulling,n.vertexShadowDarkness=this.vertexShadowDarkness,n.undergroundColor=this._undergroundColor,n.undergroundColorAlphaByDistance=this._undergroundColorAlphaByDistance,n.lambertDiffuseMultiplier=this.lambertDiffuseMultiplier,t.beginFrame(e))};Globe.prototype.render=function(e){this.show&&(defined(this._material)&&this._material.update(e.context),this._surface.render(e))};Globe.prototype.endFrame=function(e){this.show&&e.passes.render&&this._surface.endFrame(e)};Globe.prototype.isDestroyed=function(){return!1};Globe.prototype.destroy=function(){return this._surfaceShaderSet=this._surfaceShaderSet&&this._surfaceShaderSet.destroy(),this._surface=this._surface&&this._surface.destroy(),this._oceanNormalMap=this._oceanNormalMap&&this._oceanNormalMap.destroy(),destroyObject(this)};function IauOrientationParameters(e,t,n,i){this.rightAscension=e,this.declination=t,this.rotation=n,this.rotationRate=i}const Iau2000Orientation={},TdtMinusTai$1=32.184,J2000d$1=2451545,c1=-.0529921,c2=-.1059842,c3=13.0120009,c4=13.3407154,c5=.9856003,c6=26.4057084,c7=13.064993,c8=.3287146,c9=1.7484877,c10=-.1589763,c11=.0036096,c12=.1643573,c13=12.9590088;let dateTT=new JulianDate;Iau2000Orientation.ComputeMoon=function(e,t){defined(e)||(e=JulianDate.now()),dateTT=JulianDate.addSeconds(e,TdtMinusTai$1,dateTT);const n=JulianDate.totalDays(dateTT)-J2000d$1,i=n/TimeConstants.DAYS_PER_JULIAN_CENTURY,r=(125.045+c1*n)*CesiumMath.RADIANS_PER_DEGREE,o=(250.089+c2*n)*CesiumMath.RADIANS_PER_DEGREE,a=(260.008+c3*n)*CesiumMath.RADIANS_PER_DEGREE,s=(176.625+c4*n)*CesiumMath.RADIANS_PER_DEGREE,l=(357.529+c5*n)*CesiumMath.RADIANS_PER_DEGREE,c=(311.589+c6*n)*CesiumMath.RADIANS_PER_DEGREE,d=(134.963+c7*n)*CesiumMath.RADIANS_PER_DEGREE,h=(276.617+c8*n)*CesiumMath.RADIANS_PER_DEGREE,f=(34.226+c9*n)*CesiumMath.RADIANS_PER_DEGREE,p=(15.134+c10*n)*CesiumMath.RADIANS_PER_DEGREE,u=(119.743+c11*n)*CesiumMath.RADIANS_PER_DEGREE,m=(239.961+c12*n)*CesiumMath.RADIANS_PER_DEGREE,g=(25.053+c13*n)*CesiumMath.RADIANS_PER_DEGREE,_=Math.sin(r),C=Math.sin(o),A=Math.sin(a),S=Math.sin(s),v=Math.sin(l),b=Math.sin(c),D=Math.sin(d),I=Math.sin(h),L=Math.sin(f),N=Math.sin(p),y=Math.sin(u),x=Math.sin(m),T=Math.sin(g),E=Math.cos(r),P=Math.cos(o),M=Math.cos(a),O=Math.cos(s),V=Math.cos(l),R=Math.cos(c),w=Math.cos(d),U=Math.cos(h),k=Math.cos(f),H=Math.cos(p),F=Math.cos(u),G=Math.cos(m),B=Math.cos(g),W=(269.9949+.0031*i-3.8787*_-.1204*C+.07*A-.0172*S+.0072*b-.0052*N+.0043*T)*CesiumMath.RADIANS_PER_DEGREE,Y=(66.5392+.013*i+1.5419*E+.0239*P-.0278*M+.0068*O-.0029*R+9e-4*w+8e-4*H-9e-4*B)*CesiumMath.RADIANS_PER_DEGREE,z=(38.3213+13.17635815*n-14e-13*n*n+3.561*_+.1208*C-.0642*A+.0158*S+.0252*v-.0066*b-.0047*D-.0046*I+.0028*L+.0052*N+.004*y+.0019*x-.0044*T)*CesiumMath.RADIANS_PER_DEGREE,X=(13.17635815-14e-13*(2*n)+3.561*E*c1+.1208*P*c2-.0642*M*c3+.0158*O*c4+.0252*V*c5-.0066*R*c6-.0047*w*c7-.0046*U*c8+.0028*k*c9+.0052*H*c10+.004*F*c11+.0019*G*c12-.0044*B*c13)/86400*CesiumMath.RADIANS_PER_DEGREE;return defined(t)||(t=new IauOrientationParameters),t.rightAscension=W,t.declination=Y,t.rotation=z,t.rotationRate=X,t};const Iau2000Orientation$1=Iau2000Orientation;function IauOrientationAxes(e){(!defined(e)||typeof e!="function")&&(e=Iau2000Orientation$1.ComputeMoon),this._computeFunction=e}const xAxisScratch=new Cartesian3,yAxisScratch=new Cartesian3,zAxisScratch=new Cartesian3;function computeRotationMatrix(e,t,n){const i=xAxisScratch;i.x=Math.cos(e+CesiumMath.PI_OVER_TWO),i.y=Math.sin(e+CesiumMath.PI_OVER_TWO),i.z=0;const r=Math.cos(t),o=zAxisScratch;o.x=r*Math.cos(e),o.y=r*Math.sin(e),o.z=Math.sin(t);const a=Cartesian3.cross(o,i,yAxisScratch);return defined(n)||(n=new Matrix3),n[0]=i.x,n[1]=a.x,n[2]=o.x,n[3]=i.y,n[4]=a.y,n[5]=o.y,n[6]=i.z,n[7]=a.z,n[8]=o.z,n}const rotMtxScratch=new Matrix3,quatScratch=new Quaternion;IauOrientationAxes.prototype.evaluate=function(e,t){defined(e)||(e=JulianDate.now());const n=this._computeFunction(e),i=computeRotationMatrix(n.rightAscension,n.declination,t),r=CesiumMath.zeroToTwoPi(n.rotation),o=Quaternion.fromAxisAngle(Cartesian3.UNIT_Z,r,quatScratch),a=Matrix3.fromQuaternion(Quaternion.conjugate(o,o),rotMtxScratch);return Matrix3.multiply(a,i,i)};const Simon1994PlanetaryPositions={};function computeTdbMinusTtSpice(e){const t=6.239996+.0172019696544*e;return .001657*Math.sin(t+.01671*Math.sin(t))}const TdtMinusTai=32.184,J2000d=2451545;function taiToTdb(e,t){t=JulianDate.addSeconds(e,TdtMinusTai,t);const n=JulianDate.totalDays(t)-J2000d;return t=JulianDate.addSeconds(t,computeTdbMinusTtSpice(n),t),t}const epoch=new JulianDate(2451545,0,TimeStandard.TAI),MetersPerKilometer=1e3,RadiansPerDegree=CesiumMath.RADIANS_PER_DEGREE,RadiansPerArcSecond=CesiumMath.RADIANS_PER_ARCSECOND,MetersPerAstronomicalUnit=14959787e4,perifocalToEquatorial=new Matrix3;function elementsToCartesian(e,t,n,i,r,o,a){if(n<0&&(n=-n,r+=CesiumMath.PI),n<0||n>CesiumMath.PI)throw new DeveloperError("The inclination is out of range. Inclination must be greater than or equal to zero and less than or equal to Pi radians.");const s=e*(1-t),l=i-r,c=r,d=meanAnomalyToTrueAnomaly(o-i,t);if(chooseOrbit(t,0)==="Hyperbolic"&&Math.abs(CesiumMath.negativePiToPi(d))>=Math.acos(-1/t))throw new DeveloperError("The true anomaly of the hyperbolic orbit lies outside of the bounds of the hyperbola.");perifocalToCartesianMatrix(l,n,c,perifocalToEquatorial);const f=s*(1+t),p=Math.cos(d),u=Math.sin(d),m=1+t*p;if(m<=CesiumMath.Epsilon10)throw new DeveloperError("elements cannot be converted to cartesian");const g=f/m;return defined(a)?(a.x=g*p,a.y=g*u,a.z=0):a=new Cartesian3(g*p,g*u,0),Matrix3.multiplyByVector(perifocalToEquatorial,a,a)}function chooseOrbit(e,t){if(e<0)throw new DeveloperError("eccentricity cannot be negative.");return e<=t?"Circular":e<1-t?"Elliptical":e<=1+t?"Parabolic":"Hyperbolic"}function meanAnomalyToTrueAnomaly(e,t){if(t<0||t>=1)throw new DeveloperError("eccentricity out of range.");const n=meanAnomalyToEccentricAnomaly(e,t);return eccentricAnomalyToTrueAnomaly(n,t)}const maxIterationCount=50,keplerEqConvergence=CesiumMath.EPSILON8;function meanAnomalyToEccentricAnomaly(e,t){if(t<0||t>=1)throw new DeveloperError("eccentricity out of range.");const n=Math.floor(e/CesiumMath.TWO_PI);e-=n*CesiumMath.TWO_PI;let i=e+t*Math.sin(e)/(1-Math.sin(e+t)+Math.sin(e)),r=Number.MAX_VALUE,o;for(o=0;o<maxIterationCount&&Math.abs(r-i)>keplerEqConvergence;++o){r=i;const a=r-t*Math.sin(r)-e,s=1-t*Math.cos(r);i=r-a/s}if(o>=maxIterationCount)throw new DeveloperError("Kepler equation did not converge");return r=i+n*CesiumMath.TWO_PI,r}function eccentricAnomalyToTrueAnomaly(e,t){if(t<0||t>=1)throw new DeveloperError("eccentricity out of range.");const n=Math.floor(e/CesiumMath.TWO_PI);e-=n*CesiumMath.TWO_PI;const i=Math.cos(e)-t,r=Math.sin(e)*Math.sqrt(1-t*t);let o=Math.atan2(r,i);return o=CesiumMath.zeroToTwoPi(o),e<0&&(o-=CesiumMath.TWO_PI),o+=n*CesiumMath.TWO_PI,o}function perifocalToCartesianMatrix(e,t,n,i){if(t<0||t>CesiumMath.PI)throw new DeveloperError("inclination out of range");const r=Math.cos(e),o=Math.sin(e),a=Math.cos(t),s=Math.sin(t),l=Math.cos(n),c=Math.sin(n);return defined(i)?(i[0]=l*r-c*o*a,i[1]=c*r+l*o*a,i[2]=o*s,i[3]=-l*o-c*r*a,i[4]=-c*o+l*r*a,i[5]=r*s,i[6]=c*s,i[7]=-l*s,i[8]=a):i=new Matrix3(l*r-c*o*a,-l*o-c*r*a,c*s,c*r+l*o*a,-c*o+l*r*a,-l*s,o*s,r*s,a),i}const semiMajorAxis0=1.0000010178*MetersPerAstronomicalUnit,meanLongitude0=100.46645683*RadiansPerDegree,meanLongitude1=129597742283429e-5*RadiansPerArcSecond,p1u=16002,p2u=21863,p3u=32004,p4u=10931,p5u=14529,p6u=16368,p7u=15318,p8u=32794,Ca1=64*1e-7*MetersPerAstronomicalUnit,Ca2=-152*1e-7*MetersPerAstronomicalUnit,Ca3=62*1e-7*MetersPerAstronomicalUnit,Ca4=-8*1e-7*MetersPerAstronomicalUnit,Ca5=32*1e-7*MetersPerAstronomicalUnit,Ca6=-41*1e-7*MetersPerAstronomicalUnit,Ca7=19*1e-7*MetersPerAstronomicalUnit,Ca8=-11*1e-7*MetersPerAstronomicalUnit,Sa1=-150*1e-7*MetersPerAstronomicalUnit,Sa2=-46*1e-7*MetersPerAstronomicalUnit,Sa3=68*1e-7*MetersPerAstronomicalUnit,Sa4=54*1e-7*MetersPerAstronomicalUnit,Sa5=14*1e-7*MetersPerAstronomicalUnit,Sa6=24*1e-7*MetersPerAstronomicalUnit,Sa7=-28*1e-7*MetersPerAstronomicalUnit,Sa8=22*1e-7*MetersPerAstronomicalUnit,q1u=10,q2u=16002,q3u=21863,q4u=10931,q5u=1473,q6u=32004,q7u=4387,q8u=73,Cl1=-325*1e-7,Cl2=-322*1e-7,Cl3=-79*1e-7,Cl4=232*1e-7,Cl5=-52*1e-7,Cl6=97*1e-7,Cl7=55*1e-7,Cl8=-41*1e-7,Sl1=-105*1e-7,Sl2=-137*1e-7,Sl3=258*1e-7,Sl4=35*1e-7,Sl5=-116*1e-7,Sl6=-88*1e-7,Sl7=-112*1e-7,Sl8=-80*1e-7,scratchDate$1=new JulianDate(0,0,TimeStandard.TAI);function computeSimonEarthMoonBarycenter(e,t){taiToTdb(e,scratchDate$1);const i=(scratchDate$1.dayNumber-epoch.dayNumber+(scratchDate$1.secondsOfDay-epoch.secondsOfDay)/TimeConstants.SECONDS_PER_DAY)/(TimeConstants.DAYS_PER_JULIAN_CENTURY*10),r=.3595362*i,o=semiMajorAxis0+Ca1*Math.cos(p1u*r)+Sa1*Math.sin(p1u*r)+Ca2*Math.cos(p2u*r)+Sa2*Math.sin(p2u*r)+Ca3*Math.cos(p3u*r)+Sa3*Math.sin(p3u*r)+Ca4*Math.cos(p4u*r)+Sa4*Math.sin(p4u*r)+Ca5*Math.cos(p5u*r)+Sa5*Math.sin(p5u*r)+Ca6*Math.cos(p6u*r)+Sa6*Math.sin(p6u*r)+Ca7*Math.cos(p7u*r)+Sa7*Math.sin(p7u*r)+Ca8*Math.cos(p8u*r)+Sa8*Math.sin(p8u*r),a=meanLongitude0+meanLongitude1*i+Cl1*Math.cos(q1u*r)+Sl1*Math.sin(q1u*r)+Cl2*Math.cos(q2u*r)+Sl2*Math.sin(q2u*r)+Cl3*Math.cos(q3u*r)+Sl3*Math.sin(q3u*r)+Cl4*Math.cos(q4u*r)+Sl4*Math.sin(q4u*r)+Cl5*Math.cos(q5u*r)+Sl5*Math.sin(q5u*r)+Cl6*Math.cos(q6u*r)+Sl6*Math.sin(q6u*r)+Cl7*Math.cos(q7u*r)+Sl7*Math.sin(q7u*r)+Cl8*Math.cos(q8u*r)+Sl8*Math.sin(q8u*r),s=.0167086342-.0004203654*i,l=102.93734808*RadiansPerDegree+11612.3529*RadiansPerArcSecond*i,c=469.97289*RadiansPerArcSecond*i,d=174.87317577*RadiansPerDegree-8679.27034*RadiansPerArcSecond*i;return elementsToCartesian(o,s,c,l,d,a,t)}function computeSimonMoon(e,t){taiToTdb(e,scratchDate$1);const i=(scratchDate$1.dayNumber-epoch.dayNumber+(scratchDate$1.secondsOfDay-epoch.secondsOfDay)/TimeConstants.SECONDS_PER_DAY)/TimeConstants.DAYS_PER_JULIAN_CENTURY,r=i*i,o=r*i,a=o*i;let s=383397.7725+.004*i,l=.055545526-16e-9*i;const c=5.15668983*RadiansPerDegree;let d=-8e-5*i+.02966*r-42e-6*o-13e-8*a;const h=83.35324312*RadiansPerDegree;let f=146434202669e-4*i-38.2702*r-.045047*o+21301e-8*a;const p=125.04455501*RadiansPerDegree;let u=-69679193631e-4*i+6.3602*r+.007625*o-3586e-8*a;const m=218.31664563*RadiansPerDegree;let g=17325593434847e-4*i-6.391*r+.006588*o-3169e-8*a;const _=297.85019547*RadiansPerDegree+RadiansPerArcSecond*(1602961601209e-3*i-6.3706*r+.006593*o-3169e-8*a),C=93.27209062*RadiansPerDegree+RadiansPerArcSecond*(17395272628478e-4*i-12.7512*r-.001037*o+417e-8*a),A=134.96340251*RadiansPerDegree+RadiansPerArcSecond*(17179159232178e-4*i+31.8792*r+.051635*o-2447e-7*a),S=357.52910918*RadiansPerDegree+RadiansPerArcSecond*(1295965810481e-4*i-.5532*r+136e-6*o-1149e-8*a),v=310.17137918*RadiansPerDegree-RadiansPerArcSecond*(6967051436e-3*i+6.2068*r+.007618*o-3219e-8*a),b=2*_,D=4*_,I=6*_,L=2*A,N=3*A,y=4*A,x=2*C;s+=3400.4*Math.cos(b)-635.6*Math.cos(b-A)-235.6*Math.cos(A)+218.1*Math.cos(b-S)+181*Math.cos(b+A),l+=.014216*Math.cos(b-A)+.008551*Math.cos(b-L)-.001383*Math.cos(A)+.001356*Math.cos(b+A)-.001147*Math.cos(D-N)-914e-6*Math.cos(D-L)+869e-6*Math.cos(b-S-A)-627e-6*Math.cos(b)-394e-6*Math.cos(D-y)+282e-6*Math.cos(b-S-L)-279e-6*Math.cos(_-A)-236e-6*Math.cos(L)+231e-6*Math.cos(D)+229e-6*Math.cos(I-y)-201e-6*Math.cos(L-x),d+=486.26*Math.cos(b-x)-40.13*Math.cos(b)+37.51*Math.cos(x)+25.73*Math.cos(L-x)+19.97*Math.cos(b-S-x),f+=-55609*Math.sin(b-A)-34711*Math.sin(b-L)-9792*Math.sin(A)+9385*Math.sin(D-N)+7505*Math.sin(D-L)+5318*Math.sin(b+A)+3484*Math.sin(D-y)-3417*Math.sin(b-S-A)-2530*Math.sin(I-y)-2376*Math.sin(b)-2075*Math.sin(b-N)-1883*Math.sin(L)-1736*Math.sin(I-5*A)+1626*Math.sin(S)-1370*Math.sin(I-N),u+=-5392*Math.sin(b-x)-540*Math.sin(S)-441*Math.sin(b)+423*Math.sin(x)-288*Math.sin(L-x),g+=-3332.9*Math.sin(b)+1197.4*Math.sin(b-A)-662.5*Math.sin(S)+396.3*Math.sin(A)-218*Math.sin(b-S);const T=2*v,E=3*v;d+=46.997*Math.cos(v)*i-.614*Math.cos(b-x+v)*i+.614*Math.cos(b-x-v)*i-.0297*Math.cos(T)*r-.0335*Math.cos(v)*r+.0012*Math.cos(b-x+T)*r-16e-5*Math.cos(v)*o+4e-5*Math.cos(E)*o+4e-5*Math.cos(T)*o;const P=2.116*Math.sin(v)*i-.111*Math.sin(b-x-v)*i-.0015*Math.sin(v)*r;f+=P,g+=P,u+=-520.77*Math.sin(v)*i+13.66*Math.sin(b-x+v)*i+1.12*Math.sin(b-v)*i-1.06*Math.sin(x-v)*i+.66*Math.sin(T)*r+.371*Math.sin(v)*r-.035*Math.sin(b-x+T)*r-.015*Math.sin(b-x+v)*r+.0014*Math.sin(v)*o-.0011*Math.sin(E)*o-9e-4*Math.sin(T)*o,s*=MetersPerKilometer;const M=c+d*RadiansPerArcSecond,O=h+f*RadiansPerArcSecond,V=m+g*RadiansPerArcSecond,R=p+u*RadiansPerArcSecond;return elementsToCartesian(s,l,M,O,R,V,t)}const moonEarthMassRatio=.012300034,factor=moonEarthMassRatio/(moonEarthMassRatio+1)*-1;function computeSimonEarth(e,t){return t=computeSimonMoon(e,t),Cartesian3.multiplyByScalar(t,factor,t)}const axesTransformation=new Matrix3(1.0000000000000002,5619723173785822e-31,4690511510146299e-34,-5154129427414611e-31,.9174820620691819,-.39777715593191376,-223970096136568e-30,.39777715593191376,.9174820620691819);let translation=new Cartesian3;Simon1994PlanetaryPositions.computeSunPositionInEarthInertialFrame=function(e,t){return defined(e)||(e=JulianDate.now()),defined(t)||(t=new Cartesian3),translation=computeSimonEarthMoonBarycenter(e,translation),t=Cartesian3.negate(translation,t),computeSimonEarth(e,translation),Cartesian3.subtract(t,translation,t),Matrix3.multiplyByVector(axesTransformation,t,t),t};Simon1994PlanetaryPositions.computeMoonPositionInEarthInertialFrame=function(e,t){return defined(e)||(e=JulianDate.now()),t=computeSimonMoon(e,t),Matrix3.multiplyByVector(axesTransformation,t,t),t};const Simon1994PlanetaryPositions$1=Simon1994PlanetaryPositions,attributeLocations$1={position:0};function EllipsoidPrimitive(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this.center=Cartesian3.clone(defaultValue(e.center,Cartesian3.ZERO)),this._center=new Cartesian3,this.radii=Cartesian3.clone(e.radii),this._radii=new Cartesian3,this._oneOverEllipsoidRadiiSquared=new Cartesian3,this._boundingSphere=new BoundingSphere,this.modelMatrix=Matrix4.clone(defaultValue(e.modelMatrix,Matrix4.IDENTITY)),this._modelMatrix=new Matrix4,this._computedModelMatrix=new Matrix4,this.show=defaultValue(e.show,!0),this.material=defaultValue(e.material,Material.fromType(Material.ColorType)),this._material=void 0,this._translucent=void 0,this.id=e.id,this._id=void 0,this.debugShowBoundingVolume=defaultValue(e.debugShowBoundingVolume,!1),this.onlySunLighting=defaultValue(e.onlySunLighting,!1),this._onlySunLighting=!1,this._depthTestEnabled=defaultValue(e.depthTestEnabled,!0),this._useLogDepth=!1,this._sp=void 0,this._rs=void 0,this._va=void 0,this._pickSP=void 0,this._pickId=void 0,this._colorCommand=new DrawCommand({owner:defaultValue(e._owner,this)}),this._pickCommand=new DrawCommand({owner:defaultValue(e._owner,this),pickOnly:!0});const t=this;this._uniforms={u_radii:function(){return t.radii},u_oneOverEllipsoidRadiiSquared:function(){return t._oneOverEllipsoidRadiiSquared}},this._pickUniforms={czm_pickColor:function(){return t._pickId.color}}}function getVertexArray(e){let t=e.cache.ellipsoidPrimitive_vertexArray;if(defined(t))return t;const n=BoxGeometry.createGeometry(BoxGeometry.fromDimensions({dimensions:new Cartesian3(2,2,2),vertexFormat:VertexFormat.POSITION_ONLY}));return t=VertexArray.fromGeometry({context:e,geometry:n,attributeLocations:attributeLocations$1,bufferUsage:BufferUsage.STATIC_DRAW,interleave:!0}),e.cache.ellipsoidPrimitive_vertexArray=t,t}EllipsoidPrimitive.prototype.update=function(e){if(!this.show||e.mode!==SceneMode.SCENE3D||!defined(this.center)||!defined(this.radii))return;if(!defined(this.material))throw new DeveloperError("this.material must be defined.");const t=e.context,n=this.material.isTranslucent(),i=this._translucent!==n;(!defined(this._rs)||i)&&(this._translucent=n,this._rs=RenderState.fromCache({cull:{enabled:!0,face:CullFace.FRONT},depthTest:{enabled:this._depthTestEnabled},depthMask:!n&&t.fragmentDepth,blending:n?BlendingState.ALPHA_BLEND:void 0})),defined(this._va)||(this._va=getVertexArray(t));let r=!1;const o=this.radii;if(!Cartesian3.equals(this._radii,o)){Cartesian3.clone(o,this._radii);const m=this._oneOverEllipsoidRadiiSquared;m.x=1/(o.x*o.x),m.y=1/(o.y*o.y),m.z=1/(o.z*o.z),r=!0}(!Matrix4.equals(this.modelMatrix,this._modelMatrix)||!Cartesian3.equals(this.center,this._center))&&(Matrix4.clone(this.modelMatrix,this._modelMatrix),Cartesian3.clone(this.center,this._center),Matrix4.multiplyByTranslation(this.modelMatrix,this.center,this._computedModelMatrix),r=!0),r&&(Cartesian3.clone(Cartesian3.ZERO,this._boundingSphere.center),this._boundingSphere.radius=Cartesian3.maximumComponent(o),BoundingSphere.transform(this._boundingSphere,this._computedModelMatrix,this._boundingSphere));const a=this._material!==this.material;this._material=this.material,this._material.update(t);const s=this.onlySunLighting!==this._onlySunLighting;this._onlySunLighting=this.onlySunLighting;const l=e.useLogDepth,c=this._useLogDepth!==l;this._useLogDepth=l;const d=this._colorCommand;let h,f;(a||s||i||c)&&(h=new ShaderSource({sources:[EllipsoidVS]}),f=new ShaderSource({sources:[this.material.shaderSource,EllipsoidFS]}),this.onlySunLighting&&f.defines.push("ONLY_SUN_LIGHTING"),!n&&t.fragmentDepth&&f.defines.push("WRITE_DEPTH"),this._useLogDepth&&(h.defines.push("LOG_DEPTH"),f.defines.push("LOG_DEPTH")),this._sp=ShaderProgram.replaceCache({context:t,shaderProgram:this._sp,vertexShaderSource:h,fragmentShaderSource:f,attributeLocations:attributeLocations$1}),d.vertexArray=this._va,d.renderState=this._rs,d.shaderProgram=this._sp,d.uniformMap=combine$2(this._uniforms,this.material._uniforms),d.executeInClosestFrustum=n);const p=e.commandList,u=e.passes;if(u.render&&(d.boundingVolume=this._boundingSphere,d.debugShowBoundingVolume=this.debugShowBoundingVolume,d.modelMatrix=this._computedModelMatrix,d.pass=n?Pass.TRANSLUCENT:Pass.OPAQUE,p.push(d)),u.pick){const m=this._pickCommand;(!defined(this._pickId)||this._id!==this.id)&&(this._id=this.id,this._pickId=this._pickId&&this._pickId.destroy(),this._pickId=t.createPickId({primitive:this,id:this.id})),(a||s||!defined(this._pickSP)||c)&&(h=new ShaderSource({sources:[EllipsoidVS]}),f=new ShaderSource({sources:[this.material.shaderSource,EllipsoidFS],pickColorQualifier:"uniform"}),this.onlySunLighting&&f.defines.push("ONLY_SUN_LIGHTING"),!n&&t.fragmentDepth&&f.defines.push("WRITE_DEPTH"),this._useLogDepth&&(h.defines.push("LOG_DEPTH"),f.defines.push("LOG_DEPTH")),this._pickSP=ShaderProgram.replaceCache({context:t,shaderProgram:this._pickSP,vertexShaderSource:h,fragmentShaderSource:f,attributeLocations:attributeLocations$1}),m.vertexArray=this._va,m.renderState=this._rs,m.shaderProgram=this._pickSP,m.uniformMap=combine$2(combine$2(this._uniforms,this._pickUniforms),this.material._uniforms),m.executeInClosestFrustum=n),m.boundingVolume=this._boundingSphere,m.modelMatrix=this._computedModelMatrix,m.pass=n?Pass.TRANSLUCENT:Pass.OPAQUE,p.push(m)}};EllipsoidPrimitive.prototype.isDestroyed=function(){return!1};EllipsoidPrimitive.prototype.destroy=function(){return this._sp=this._sp&&this._sp.destroy(),this._pickSP=this._pickSP&&this._pickSP.destroy(),this._pickId=this._pickId&&this._pickId.destroy(),destroyObject(this)};function Moon(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);let t=e.textureUrl;defined(t)||(t=buildModuleUrl("Assets/Textures/moonSmall.jpg")),this.show=defaultValue(e.show,!0),this.textureUrl=t,this._ellipsoid=defaultValue(e.ellipsoid,Ellipsoid.MOON),this.onlySunLighting=defaultValue(e.onlySunLighting,!0),this._ellipsoidPrimitive=new EllipsoidPrimitive({radii:this.ellipsoid.radii,material:Material.fromType(Material.ImageType),depthTestEnabled:!1,_owner:this}),this._ellipsoidPrimitive.material.translucent=!1,this._axes=new IauOrientationAxes}Object.defineProperties(Moon.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}});const icrfToFixed=new Matrix3,rotationScratch=new Matrix3,translationScratch=new Cartesian3,scratchCommandList=[];Moon.prototype.update=function(e){if(!this.show)return;const t=this._ellipsoidPrimitive;t.material.uniforms.image=this.textureUrl,t.onlySunLighting=this.onlySunLighting;const n=e.time;defined(Transforms.computeIcrfToFixedMatrix(n,icrfToFixed))||Transforms.computeTemeToPseudoFixedMatrix(n,icrfToFixed);const i=this._axes.evaluate(n,rotationScratch);Matrix3.transpose(i,i),Matrix3.multiply(icrfToFixed,i,i);const r=Simon1994PlanetaryPositions$1.computeMoonPositionInEarthInertialFrame(n,translationScratch);Matrix3.multiplyByVector(icrfToFixed,r,r),Matrix4.fromRotationTranslation(i,r,t.modelMatrix);const o=e.commandList;return e.commandList=scratchCommandList,scratchCommandList.length=0,t.update(e),e.commandList=o,scratchCommandList.length===1?scratchCommandList[0]:void 0};Moon.prototype.isDestroyed=function(){return!1};Moon.prototype.destroy=function(){return this._ellipsoidPrimitive=this._ellipsoidPrimitive&&this._ellipsoidPrimitive.destroy(),destroyObject(this)};const leftScratchArray=[],rightScratchArray=[];function merge(e,t,n,i,r,o){const a=r-i+1,s=o-r,l=leftScratchArray,c=rightScratchArray;let d,h;for(d=0;d<a;++d)l[d]=e[i+d];for(h=0;h<s;++h)c[h]=e[r+h+1];d=0,h=0;for(let f=i;f<=o;++f){const p=l[d],u=c[h];d<a&&(h>=s||t(p,u,n)<=0)?(e[f]=p,++d):h<s&&(e[f]=u,++h)}}function sort(e,t,n,i,r){if(i>=r)return;const o=Math.floor((i+r)*.5);sort(e,t,n,i,o),sort(e,t,n,o+1,r),merge(e,t,n,i,o,r)}function mergeSort(e,t,n){if(!defined(e))throw new DeveloperError("array is required.");if(!defined(t))throw new DeveloperError("comparator is required.");const i=e.length,r=Math.ceil(i*.5);leftScratchArray.length=r,rightScratchArray.length=r,sort(e,t,n,0,i-1),leftScratchArray.length=0,rightScratchArray.length=0}function Occluder(e,t){if(!defined(e))throw new DeveloperError("occluderBoundingSphere is required.");if(!defined(t))throw new DeveloperError("camera position is required.");this._occluderPosition=Cartesian3.clone(e.center),this._occluderRadius=e.radius,this._horizonDistance=0,this._horizonPlaneNormal=void 0,this._horizonPlanePosition=void 0,this._cameraPosition=void 0,this.cameraPosition=t}const scratchCartesian3$2=new Cartesian3;Object.defineProperties(Occluder.prototype,{position:{get:function(){return this._occluderPosition}},radius:{get:function(){return this._occluderRadius}},cameraPosition:{set:function(e){if(!defined(e))throw new DeveloperError("cameraPosition is required.");e=Cartesian3.clone(e,this._cameraPosition);const t=Cartesian3.subtract(this._occluderPosition,e,scratchCartesian3$2);let n=Cartesian3.magnitudeSquared(t);const i=this._occluderRadius*this._occluderRadius;let r,o,a;if(n>i){r=Math.sqrt(n-i),n=1/Math.sqrt(n),o=Cartesian3.multiplyByScalar(t,n,scratchCartesian3$2);const s=r*r*n;a=Cartesian3.add(e,Cartesian3.multiplyByScalar(o,s,scratchCartesian3$2),scratchCartesian3$2)}else r=Number.MAX_VALUE;this._horizonDistance=r,this._horizonPlaneNormal=o,this._horizonPlanePosition=a,this._cameraPosition=e}}});Occluder.fromBoundingSphere=function(e,t,n){if(!defined(e))throw new DeveloperError("occluderBoundingSphere is required.");if(!defined(t))throw new DeveloperError("camera position is required.");return defined(n)?(Cartesian3.clone(e.center,n._occluderPosition),n._occluderRadius=e.radius,n.cameraPosition=t,n):new Occluder(e,t)};const tempVecScratch=new Cartesian3;Occluder.prototype.isPointVisible=function(e){if(this._horizonDistance!==Number.MAX_VALUE){let t=Cartesian3.subtract(e,this._occluderPosition,tempVecScratch),n=this._occluderRadius;if(n=Cartesian3.magnitudeSquared(t)-n*n,n>0)return n=Math.sqrt(n)+this._horizonDistance,t=Cartesian3.subtract(e,this._cameraPosition,t),n*n>Cartesian3.magnitudeSquared(t)}return!1};const occludeePositionScratch=new Cartesian3;Occluder.prototype.isBoundingSphereVisible=function(e){const t=Cartesian3.clone(e.center,occludeePositionScratch),n=e.radius;if(this._horizonDistance!==Number.MAX_VALUE){let i=Cartesian3.subtract(t,this._occluderPosition,tempVecScratch),r=this._occluderRadius-n;if(r=Cartesian3.magnitudeSquared(i)-r*r,n<this._occluderRadius)return r>0?(r=Math.sqrt(r)+this._horizonDistance,i=Cartesian3.subtract(t,this._cameraPosition,i),r*r+n*n>Cartesian3.magnitudeSquared(i)):!1;if(r>0){i=Cartesian3.subtract(t,this._cameraPosition,i);const o=Cartesian3.magnitudeSquared(i),a=this._occluderRadius*this._occluderRadius,s=n*n;return(this._horizonDistance*this._horizonDistance+a)*s>o*a?!0:(r=Math.sqrt(r)+this._horizonDistance,r*r+s>o)}return!0}return!1};const tempScratch=new Cartesian3;Occluder.prototype.computeVisibility=function(e){if(!defined(e))throw new DeveloperError("occludeeBS is required.");const t=Cartesian3.clone(e.center),n=e.radius;if(n>this._occluderRadius)return Visibility$1.FULL;if(this._horizonDistance!==Number.MAX_VALUE){let i=Cartesian3.subtract(t,this._occluderPosition,tempScratch),r=this._occluderRadius-n;const o=Cartesian3.magnitudeSquared(i);if(r=o-r*r,r>0){r=Math.sqrt(r)+this._horizonDistance,i=Cartesian3.subtract(t,this._cameraPosition,i);const a=Cartesian3.magnitudeSquared(i);return r*r+n*n<a?Visibility$1.NONE:(r=this._occluderRadius+n,r=o-r*r,r>0?(r=Math.sqrt(r)+this._horizonDistance,a<r*r+n*n?Visibility$1.FULL:Visibility$1.PARTIAL):(i=Cartesian3.subtract(t,this._horizonPlanePosition,i),Cartesian3.dot(i,this._horizonPlaneNormal)>-n?Visibility$1.PARTIAL:Visibility$1.FULL))}}return Visibility$1.NONE};const occludeePointScratch=new Cartesian3;Occluder.computeOccludeePoint=function(e,t,n){if(!defined(e))throw new DeveloperError("occluderBoundingSphere is required.");if(!defined(n))throw new DeveloperError("positions is required.");if(n.length===0)throw new DeveloperError("positions must contain at least one element");const i=Cartesian3.clone(t),r=Cartesian3.clone(e.center),o=e.radius,a=n.length;if(Cartesian3.equals(r,t))throw new DeveloperError("occludeePosition must be different than occluderBoundingSphere.center");const s=Cartesian3.normalize(Cartesian3.subtract(i,r,occludeePointScratch),occludeePointScratch),l=-Cartesian3.dot(s,r),c=Occluder._anyRotationVector(r,s,l);let d=Occluder._horizonToPlaneNormalDotProduct(e,s,l,c,n[0]);if(!d)return;let h;for(let p=1;p<a;++p){if(h=Occluder._horizonToPlaneNormalDotProduct(e,s,l,c,n[p]),!h)return;h<d&&(d=h)}if(d<.0017453283658983088)return;const f=o/d;return Cartesian3.add(r,Cartesian3.multiplyByScalar(s,f,occludeePointScratch),occludeePointScratch)};const computeOccludeePointFromRectangleScratch=[];Occluder.computeOccludeePointFromRectangle=function(e,t){if(!defined(e))throw new DeveloperError("rectangle is required.");t=defaultValue(t,Ellipsoid.default);const n=Rectangle.subsample(e,t,0,computeOccludeePointFromRectangleScratch),i=BoundingSphere.fromPoints(n),r=Cartesian3.ZERO;if(!Cartesian3.equals(r,i.center))return Occluder.computeOccludeePoint(new BoundingSphere(r,t.minimumRadius),i.center,n)};const tempVec0Scratch=new Cartesian3;Occluder._anyRotationVector=function(e,t,n){const i=Cartesian3.abs(t,tempVec0Scratch);let r=i.x>i.y?0:1;(r===0&&i.z>i.x||r===1&&i.z>i.y)&&(r=2);const o=new Cartesian3;let a;r===0?(i.x=e.x,i.y=e.y+1,i.z=e.z+1,a=Cartesian3.UNIT_X):r===1?(i.x=e.x+1,i.y=e.y,i.z=e.z+1,a=Cartesian3.UNIT_Y):(i.x=e.x+1,i.y=e.y+1,i.z=e.z,a=Cartesian3.UNIT_Z);const s=(Cartesian3.dot(t,i)+n)/-Cartesian3.dot(t,a);return Cartesian3.normalize(Cartesian3.subtract(Cartesian3.add(i,Cartesian3.multiplyByScalar(a,s,o),i),e,i),i)};const posDirectionScratch=new Cartesian3;Occluder._rotationVector=function(e,t,n,i,r){let o=Cartesian3.subtract(i,e,posDirectionScratch);if(o=Cartesian3.normalize(o,o),Cartesian3.dot(t,o)<.9999999847691291){const a=Cartesian3.cross(t,o,o);if(Cartesian3.magnitude(a)>CesiumMath.EPSILON13)return Cartesian3.normalize(a,new Cartesian3)}return r};const posScratch1=new Cartesian3,occluerPosScratch=new Cartesian3,posScratch2=new Cartesian3,horizonPlanePosScratch=new Cartesian3;Occluder._horizonToPlaneNormalDotProduct=function(e,t,n,i,r){const o=Cartesian3.clone(r,posScratch1),a=Cartesian3.clone(e.center,occluerPosScratch),s=e.radius;let l=Cartesian3.subtract(a,o,posScratch2);const c=Cartesian3.magnitudeSquared(l),d=s*s;if(c<d)return!1;const h=c-d,f=Math.sqrt(h),u=1/Math.sqrt(c),g=f*u*f;l=Cartesian3.normalize(l,l);const _=Cartesian3.add(o,Cartesian3.multiplyByScalar(l,g,horizonPlanePosScratch),horizonPlanePosScratch),C=Math.sqrt(h-g*g);let A=this._rotationVector(a,t,n,o,i),S=Cartesian3.fromElements(A.x*A.x*l.x+(A.x*A.y-A.z)*l.y+(A.x*A.z+A.y)*l.z,(A.x*A.y+A.z)*l.x+A.y*A.y*l.y+(A.y*A.z-A.x)*l.z,(A.x*A.z-A.y)*l.x+(A.y*A.z+A.x)*l.y+A.z*A.z*l.z,posScratch1);S=Cartesian3.normalize(S,S);const v=Cartesian3.multiplyByScalar(S,C,posScratch1);A=Cartesian3.normalize(Cartesian3.subtract(Cartesian3.add(_,v,posScratch2),a,posScratch2),posScratch2);const b=Cartesian3.dot(t,A);A=Cartesian3.normalize(Cartesian3.subtract(Cartesian3.subtract(_,v,A),a,A),A);const D=Cartesian3.dot(t,A);return b<D?b:D};function PerspectiveOffCenterFrustum(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this.left=e.left,this._left=void 0,this.right=e.right,this._right=void 0,this.top=e.top,this._top=void 0,this.bottom=e.bottom,this._bottom=void 0,this.near=defaultValue(e.near,1),this._near=this.near,this.far=defaultValue(e.far,5e8),this._far=this.far,this._cullingVolume=new CullingVolume,this._perspectiveMatrix=new Matrix4,this._infinitePerspective=new Matrix4}function update$2(e){if(!defined(e.right)||!defined(e.left)||!defined(e.top)||!defined(e.bottom)||!defined(e.near)||!defined(e.far))throw new DeveloperError("right, left, top, bottom, near, or far parameters are not set.");const t=e.top,n=e.bottom,i=e.right,r=e.left,o=e.near,a=e.far;if(t!==e._top||n!==e._bottom||r!==e._left||i!==e._right||o!==e._near||a!==e._far){if(e.near<=0||e.near>e.far)throw new DeveloperError("near must be greater than zero and less than far.");e._left=r,e._right=i,e._top=t,e._bottom=n,e._near=o,e._far=a,e._perspectiveMatrix=Matrix4.computePerspectiveOffCenter(r,i,n,t,o,a,e._perspectiveMatrix),e._infinitePerspective=Matrix4.computeInfinitePerspectiveOffCenter(r,i,n,t,o,e._infinitePerspective)}}Object.defineProperties(PerspectiveOffCenterFrustum.prototype,{projectionMatrix:{get:function(){return update$2(this),this._perspectiveMatrix}},infiniteProjectionMatrix:{get:function(){return update$2(this),this._infinitePerspective}}});const getPlanesRight=new Cartesian3,getPlanesNearCenter=new Cartesian3,getPlanesFarCenter=new Cartesian3,getPlanesNormal=new Cartesian3;PerspectiveOffCenterFrustum.prototype.computeCullingVolume=function(e,t,n){if(!defined(e))throw new DeveloperError("position is required.");if(!defined(t))throw new DeveloperError("direction is required.");if(!defined(n))throw new DeveloperError("up is required.");const i=this._cullingVolume.planes,r=this.top,o=this.bottom,a=this.right,s=this.left,l=this.near,c=this.far,d=Cartesian3.cross(t,n,getPlanesRight),h=getPlanesNearCenter;Cartesian3.multiplyByScalar(t,l,h),Cartesian3.add(e,h,h);const f=getPlanesFarCenter;Cartesian3.multiplyByScalar(t,c,f),Cartesian3.add(e,f,f);const p=getPlanesNormal;Cartesian3.multiplyByScalar(d,s,p),Cartesian3.add(h,p,p),Cartesian3.subtract(p,e,p),Cartesian3.normalize(p,p),Cartesian3.cross(p,n,p),Cartesian3.normalize(p,p);let u=i[0];return defined(u)||(u=i[0]=new Cartesian4),u.x=p.x,u.y=p.y,u.z=p.z,u.w=-Cartesian3.dot(p,e),Cartesian3.multiplyByScalar(d,a,p),Cartesian3.add(h,p,p),Cartesian3.subtract(p,e,p),Cartesian3.cross(n,p,p),Cartesian3.normalize(p,p),u=i[1],defined(u)||(u=i[1]=new Cartesian4),u.x=p.x,u.y=p.y,u.z=p.z,u.w=-Cartesian3.dot(p,e),Cartesian3.multiplyByScalar(n,o,p),Cartesian3.add(h,p,p),Cartesian3.subtract(p,e,p),Cartesian3.cross(d,p,p),Cartesian3.normalize(p,p),u=i[2],defined(u)||(u=i[2]=new Cartesian4),u.x=p.x,u.y=p.y,u.z=p.z,u.w=-Cartesian3.dot(p,e),Cartesian3.multiplyByScalar(n,r,p),Cartesian3.add(h,p,p),Cartesian3.subtract(p,e,p),Cartesian3.cross(p,d,p),Cartesian3.normalize(p,p),u=i[3],defined(u)||(u=i[3]=new Cartesian4),u.x=p.x,u.y=p.y,u.z=p.z,u.w=-Cartesian3.dot(p,e),u=i[4],defined(u)||(u=i[4]=new Cartesian4),u.x=t.x,u.y=t.y,u.z=t.z,u.w=-Cartesian3.dot(t,h),Cartesian3.negate(t,p),u=i[5],defined(u)||(u=i[5]=new Cartesian4),u.x=p.x,u.y=p.y,u.z=p.z,u.w=-Cartesian3.dot(p,f),this._cullingVolume};PerspectiveOffCenterFrustum.prototype.getPixelDimensions=function(e,t,n,i,r){if(update$2(this),!defined(e)||!defined(t))throw new DeveloperError("Both drawingBufferWidth and drawingBufferHeight are required.");if(e<=0)throw new DeveloperError("drawingBufferWidth must be greater than zero.");if(t<=0)throw new DeveloperError("drawingBufferHeight must be greater than zero.");if(!defined(n))throw new DeveloperError("distance is required.");if(!defined(i))throw new DeveloperError("pixelRatio is required");if(i<=0)throw new DeveloperError("pixelRatio must be greater than zero.");if(!defined(r))throw new DeveloperError("A result object is required.");const o=1/this.near;let a=this.top*o;const s=2*i*n*a/t;a=this.right*o;const l=2*i*n*a/e;return r.x=l,r.y=s,r};PerspectiveOffCenterFrustum.prototype.clone=function(e){return defined(e)||(e=new PerspectiveOffCenterFrustum),e.right=this.right,e.left=this.left,e.top=this.top,e.bottom=this.bottom,e.near=this.near,e.far=this.far,e._left=void 0,e._right=void 0,e._top=void 0,e._bottom=void 0,e._near=void 0,e._far=void 0,e};PerspectiveOffCenterFrustum.prototype.equals=function(e){return defined(e)&&e instanceof PerspectiveOffCenterFrustum&&this.right===e.right&&this.left===e.left&&this.top===e.top&&this.bottom===e.bottom&&this.near===e.near&&this.far===e.far};PerspectiveOffCenterFrustum.prototype.equalsEpsilon=function(e,t,n){return e===this||defined(e)&&e instanceof PerspectiveOffCenterFrustum&&CesiumMath.equalsEpsilon(this.right,e.right,t,n)&&CesiumMath.equalsEpsilon(this.left,e.left,t,n)&&CesiumMath.equalsEpsilon(this.top,e.top,t,n)&&CesiumMath.equalsEpsilon(this.bottom,e.bottom,t,n)&&CesiumMath.equalsEpsilon(this.near,e.near,t,n)&&CesiumMath.equalsEpsilon(this.far,e.far,t,n)};function PerspectiveFrustum(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._offCenterFrustum=new PerspectiveOffCenterFrustum,this.fov=e.fov,this._fov=void 0,this._fovy=void 0,this._sseDenominator=void 0,this.aspectRatio=e.aspectRatio,this._aspectRatio=void 0,this.near=defaultValue(e.near,1),this._near=this.near,this.far=defaultValue(e.far,5e8),this._far=this.far,this.xOffset=defaultValue(e.xOffset,0),this._xOffset=this.xOffset,this.yOffset=defaultValue(e.yOffset,0),this._yOffset=this.yOffset}PerspectiveFrustum.packedLength=6;PerspectiveFrustum.pack=function(e,t,n){return Check.typeOf.object("value",e),Check.defined("array",t),n=defaultValue(n,0),t[n++]=e.fov,t[n++]=e.aspectRatio,t[n++]=e.near,t[n++]=e.far,t[n++]=e.xOffset,t[n]=e.yOffset,t};PerspectiveFrustum.unpack=function(e,t,n){return Check.defined("array",e),t=defaultValue(t,0),defined(n)||(n=new PerspectiveFrustum),n.fov=e[t++],n.aspectRatio=e[t++],n.near=e[t++],n.far=e[t++],n.xOffset=e[t++],n.yOffset=e[t],n};function update$1(e){if(!defined(e.fov)||!defined(e.aspectRatio)||!defined(e.near)||!defined(e.far))throw new DeveloperError("fov, aspectRatio, near, or far parameters are not set.");const t=e._offCenterFrustum;if(e.fov!==e._fov||e.aspectRatio!==e._aspectRatio||e.near!==e._near||e.far!==e._far||e.xOffset!==e._xOffset||e.yOffset!==e._yOffset){if(e.fov<0||e.fov>=Math.PI)throw new DeveloperError("fov must be in the range [0, PI).");if(e.aspectRatio<0)throw new DeveloperError("aspectRatio must be positive.");if(e.near<0||e.near>e.far)throw new DeveloperError("near must be greater than zero and less than far.");e._aspectRatio=e.aspectRatio,e._fov=e.fov,e._fovy=e.aspectRatio<=1?e.fov:Math.atan(Math.tan(e.fov*.5)/e.aspectRatio)*2,e._near=e.near,e._far=e.far,e._sseDenominator=2*Math.tan(.5*e._fovy),e._xOffset=e.xOffset,e._yOffset=e.yOffset,t.top=e.near*Math.tan(.5*e._fovy),t.bottom=-t.top,t.right=e.aspectRatio*t.top,t.left=-t.right,t.near=e.near,t.far=e.far,t.right+=e.xOffset,t.left+=e.xOffset,t.top+=e.yOffset,t.bottom+=e.yOffset}}Object.defineProperties(PerspectiveFrustum.prototype,{projectionMatrix:{get:function(){return update$1(this),this._offCenterFrustum.projectionMatrix}},infiniteProjectionMatrix:{get:function(){return update$1(this),this._offCenterFrustum.infiniteProjectionMatrix}},fovy:{get:function(){return update$1(this),this._fovy}},sseDenominator:{get:function(){return update$1(this),this._sseDenominator}},offCenterFrustum:{get:function(){return update$1(this),this._offCenterFrustum}}});PerspectiveFrustum.prototype.computeCullingVolume=function(e,t,n){return update$1(this),this._offCenterFrustum.computeCullingVolume(e,t,n)};PerspectiveFrustum.prototype.getPixelDimensions=function(e,t,n,i,r){return update$1(this),this._offCenterFrustum.getPixelDimensions(e,t,n,i,r)};PerspectiveFrustum.prototype.clone=function(e){return defined(e)||(e=new PerspectiveFrustum),e.aspectRatio=this.aspectRatio,e.fov=this.fov,e.near=this.near,e.far=this.far,e._aspectRatio=void 0,e._fov=void 0,e._near=void 0,e._far=void 0,this._offCenterFrustum.clone(e._offCenterFrustum),e};PerspectiveFrustum.prototype.equals=function(e){return!defined(e)||!(e instanceof PerspectiveFrustum)?!1:(update$1(this),update$1(e),this.fov===e.fov&&this.aspectRatio===e.aspectRatio&&this._offCenterFrustum.equals(e._offCenterFrustum))};PerspectiveFrustum.prototype.equalsEpsilon=function(e,t,n){return!defined(e)||!(e instanceof PerspectiveFrustum)?!1:(update$1(this),update$1(e),CesiumMath.equalsEpsilon(this.fov,e.fov,t,n)&&CesiumMath.equalsEpsilon(this.aspectRatio,e.aspectRatio,t,n)&&this._offCenterFrustum.equalsEpsilon(e._offCenterFrustum,t,n))};function ComputeEngine(e){this._context=e}let renderStateScratch;const drawCommandScratch=new DrawCommand({primitiveType:PrimitiveType.TRIANGLES}),clearCommandScratch=new ClearCommand({color:new Color(0,0,0,0)});function createFramebuffer$1(e,t){return new Framebuffer({context:e,colorTextures:[t],destroyAttachments:!1})}function createViewportQuadShader(e,t){return ShaderProgram.fromCache({context:e,vertexShaderSource:ViewportQuadVS,fragmentShaderSource:t,attributeLocations:{position:0,textureCoordinates:1}})}function createRenderState$1(e,t){return(!defined(renderStateScratch)||renderStateScratch.viewport.width!==e||renderStateScratch.viewport.height!==t)&&(renderStateScratch=RenderState.fromCache({viewport:new BoundingRectangle(0,0,e,t)})),renderStateScratch}ComputeEngine.prototype.execute=function(e){if(Check.defined("computeCommand",e),defined(e.preExecute)&&e.preExecute(e),!defined(e.fragmentShaderSource)&&!defined(e.shaderProgram))throw new DeveloperError("computeCommand.fragmentShaderSource or computeCommand.shaderProgram is required.");Check.defined("computeCommand.outputTexture",e.outputTexture);const t=e.outputTexture,n=t.width,i=t.height,r=this._context,o=defined(e.vertexArray)?e.vertexArray:r.getViewportQuadVertexArray(),a=defined(e.shaderProgram)?e.shaderProgram:createViewportQuadShader(r,e.fragmentShaderSource),s=createFramebuffer$1(r,t),l=createRenderState$1(n,i),c=e.uniformMap,d=clearCommandScratch;d.framebuffer=s,d.renderState=l,d.execute(r);const h=drawCommandScratch;h.vertexArray=o,h.renderState=l,h.shaderProgram=a,h.uniformMap=c,h.framebuffer=s,h.execute(r),s.destroy(),e.persists||(a.destroy(),defined(e.vertexArray)&&o.destroy()),defined(e.postExecute)&&e.postExecute(t)};ComputeEngine.prototype.isDestroyed=function(){return!1};ComputeEngine.prototype.destroy=function(){return destroyObject(this)};function PassState(e){this.context=e,this.framebuffer=void 0,this.blendingEnabled=void 0,this.scissorTest=void 0,this.viewport=void 0}function ShaderCache(e){this._context=e,this._shaders={},this._numberOfShaders=0,this._shadersToRelease={}}Object.defineProperties(ShaderCache.prototype,{numberOfShaders:{get:function(){return this._numberOfShaders}}});ShaderCache.prototype.replaceShaderProgram=function(e){return defined(e.shaderProgram)&&e.shaderProgram.destroy(),this.getShaderProgram(e)};function toSortedJson(e){const t=Object.keys(e).sort();return JSON.stringify(e,t)}ShaderCache.prototype.getShaderProgram=function(e){let t=e.vertexShaderSource,n=e.fragmentShaderSource;const i=e.attributeLocations;typeof t=="string"&&(t=new ShaderSource({sources:[t]})),typeof n=="string"&&(n=new ShaderSource({sources:[n]}));const r=t.getCacheKey(),o=n.getCacheKey(),a=defined(i)?toSortedJson(i):"",s=`${r}:${o}:${a}`;let l;if(defined(this._shaders[s]))l=this._shaders[s],delete this._shadersToRelease[s];else{const c=this._context,d=t.createCombinedVertexShader(c),h=n.createCombinedFragmentShader(c),f=new ShaderProgram({gl:c._gl,logShaderCompilation:c.logShaderCompilation,debugShaders:c.debugShaders,vertexShaderSource:t,vertexShaderText:d,fragmentShaderSource:n,fragmentShaderText:h,attributeLocations:i});l={cache:this,shaderProgram:f,keyword:s,derivedKeywords:[],count:0},f._cachedShader=l,this._shaders[s]=l,++this._numberOfShaders}return++l.count,l.shaderProgram};ShaderCache.prototype.replaceDerivedShaderProgram=function(e,t,n){const i=e._cachedShader,r=t+i.keyword,o=this._shaders[r];if(defined(o)){destroyShader(this,o);const a=i.derivedKeywords.indexOf(t);a>-1&&i.derivedKeywords.splice(a,1)}return this.createDerivedShaderProgram(e,t,n)};ShaderCache.prototype.getDerivedShaderProgram=function(e,t){const n=e._cachedShader,i=t+n.keyword,r=this._shaders[i];if(defined(r))return r.shaderProgram};ShaderCache.prototype.createDerivedShaderProgram=function(e,t,n){const i=e._cachedShader,r=t+i.keyword;let o=n.vertexShaderSource,a=n.fragmentShaderSource;const s=n.attributeLocations;typeof o=="string"&&(o=new ShaderSource({sources:[o]})),typeof a=="string"&&(a=new ShaderSource({sources:[a]}));const l=this._context,c=o.createCombinedVertexShader(l),d=a.createCombinedFragmentShader(l),h=new ShaderProgram({gl:l._gl,logShaderCompilation:l.logShaderCompilation,debugShaders:l.debugShaders,vertexShaderSource:o,vertexShaderText:c,fragmentShaderSource:a,fragmentShaderText:d,attributeLocations:s}),f={cache:this,shaderProgram:h,keyword:r,derivedKeywords:[],count:0};return i.derivedKeywords.push(t),h._cachedShader=f,this._shaders[r]=f,h};function destroyShader(e,t){const n=t.derivedKeywords,i=n.length;for(let r=0;r<i;++r){const o=n[r]+t.keyword,a=e._shaders[o];destroyShader(e,a)}delete e._shaders[t.keyword],t.shaderProgram.finalDestroy()}ShaderCache.prototype.destroyReleasedShaderPrograms=function(){const e=this._shadersToRelease;for(const t in e)if(e.hasOwnProperty(t)){const n=e[t];destroyShader(this,n),--this._numberOfShaders}this._shadersToRelease={}};ShaderCache.prototype.releaseShaderProgram=function(e){if(defined(e)){const t=e._cachedShader;t&&--t.count===0&&(this._shadersToRelease[t.keyword]=t)}};ShaderCache.prototype.isDestroyed=function(){return!1};ShaderCache.prototype.destroy=function(){const e=this._shaders;for(const t in e)e.hasOwnProperty(t)&&e[t].shaderProgram.finalDestroy();return destroyObject(this)};function TextureCache(){this._textures={},this._numberOfTextures=0,this._texturesToRelease={}}Object.defineProperties(TextureCache.prototype,{numberOfTextures:{get:function(){return this._numberOfTextures}}});TextureCache.prototype.getTexture=function(e){const t=this._textures[e];if(defined(t))return delete this._texturesToRelease[e],++t.count,t.texture};TextureCache.prototype.addTexture=function(e,t){const n={texture:t,count:1};t.finalDestroy=t.destroy;const i=this;t.destroy=function(){--n.count===0&&(i._texturesToRelease[e]=n)},this._textures[e]=n,++this._numberOfTextures};TextureCache.prototype.destroyReleasedTextures=function(){const e=this._texturesToRelease;for(const t in e)if(e.hasOwnProperty(t)){const n=e[t];delete this._textures[t],n.texture.finalDestroy(),--this._numberOfTextures}this._texturesToRelease={}};TextureCache.prototype.isDestroyed=function(){return!1};TextureCache.prototype.destroy=function(){const e=this._textures;for(const t in e)e.hasOwnProperty(t)&&e[t].texture.finalDestroy();return destroyObject(this)};function SunLight(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this.color=Color.clone(defaultValue(e.color,Color.WHITE)),this.intensity=defaultValue(e.intensity,2)}function UniformState(){this.globeDepthTexture=void 0,this.gamma=void 0,this._viewport=new BoundingRectangle,this._viewportCartesian4=new Cartesian4,this._viewportDirty=!1,this._viewportOrthographicMatrix=Matrix4.clone(Matrix4.IDENTITY),this._viewportTransformation=Matrix4.clone(Matrix4.IDENTITY),this._model=Matrix4.clone(Matrix4.IDENTITY),this._view=Matrix4.clone(Matrix4.IDENTITY),this._inverseView=Matrix4.clone(Matrix4.IDENTITY),this._projection=Matrix4.clone(Matrix4.IDENTITY),this._infiniteProjection=Matrix4.clone(Matrix4.IDENTITY),this._entireFrustum=new Cartesian2,this._currentFrustum=new Cartesian2,this._frustumPlanes=new Cartesian4,this._farDepthFromNearPlusOne=void 0,this._log2FarDepthFromNearPlusOne=void 0,this._oneOverLog2FarDepthFromNearPlusOne=void 0,this._frameState=void 0,this._temeToPseudoFixed=Matrix3.clone(Matrix4.IDENTITY),this._view3DDirty=!0,this._view3D=new Matrix4,this._inverseView3DDirty=!0,this._inverseView3D=new Matrix4,this._inverseModelDirty=!0,this._inverseModel=new Matrix4,this._inverseTransposeModelDirty=!0,this._inverseTransposeModel=new Matrix3,this._viewRotation=new Matrix3,this._inverseViewRotation=new Matrix3,this._viewRotation3D=new Matrix3,this._inverseViewRotation3D=new Matrix3,this._inverseProjectionDirty=!0,this._inverseProjection=new Matrix4,this._modelViewDirty=!0,this._modelView=new Matrix4,this._modelView3DDirty=!0,this._modelView3D=new Matrix4,this._modelViewRelativeToEyeDirty=!0,this._modelViewRelativeToEye=new Matrix4,this._inverseModelViewDirty=!0,this._inverseModelView=new Matrix4,this._inverseModelView3DDirty=!0,this._inverseModelView3D=new Matrix4,this._viewProjectionDirty=!0,this._viewProjection=new Matrix4,this._inverseViewProjectionDirty=!0,this._inverseViewProjection=new Matrix4,this._modelViewProjectionDirty=!0,this._modelViewProjection=new Matrix4,this._inverseModelViewProjectionDirty=!0,this._inverseModelViewProjection=new Matrix4,this._modelViewProjectionRelativeToEyeDirty=!0,this._modelViewProjectionRelativeToEye=new Matrix4,this._modelViewInfiniteProjectionDirty=!0,this._modelViewInfiniteProjection=new Matrix4,this._normalDirty=!0,this._normal=new Matrix3,this._normal3DDirty=!0,this._normal3D=new Matrix3,this._inverseNormalDirty=!0,this._inverseNormal=new Matrix3,this._inverseNormal3DDirty=!0,this._inverseNormal3D=new Matrix3,this._encodedCameraPositionMCDirty=!0,this._encodedCameraPositionMC=new EncodedCartesian3,this._cameraPosition=new Cartesian3,this._sunPositionWC=new Cartesian3,this._sunPositionColumbusView=new Cartesian3,this._sunDirectionWC=new Cartesian3,this._sunDirectionEC=new Cartesian3,this._moonDirectionEC=new Cartesian3,this._lightDirectionWC=new Cartesian3,this._lightDirectionEC=new Cartesian3,this._lightColor=new Cartesian3,this._lightColorHdr=new Cartesian3,this._pass=void 0,this._mode=void 0,this._mapProjection=void 0,this._ellipsoid=void 0,this._cameraDirection=new Cartesian3,this._cameraRight=new Cartesian3,this._cameraUp=new Cartesian3,this._frustum2DWidth=0,this._eyeHeight=0,this._eyeHeight2D=new Cartesian2,this._eyeEllipsoidNormalEC=new Cartesian3,this._eyeEllipsoidCurvature=new Cartesian2,this._modelToEnu=new Matrix4,this._enuToModel=new Matrix4,this._pixelRatio=1,this._orthographicIn3D=!1,this._backgroundColor=new Color,this._brdfLut=void 0,this._environmentMap=void 0,this._sphericalHarmonicCoefficients=void 0,this._specularEnvironmentMaps=void 0,this._specularEnvironmentMapsDimensions=new Cartesian2,this._specularEnvironmentMapsMaximumLOD=void 0,this._fogDensity=void 0,this._fogMinimumBrightness=void 0,this._atmosphereHsbShift=void 0,this._atmosphereLightIntensity=void 0,this._atmosphereRayleighCoefficient=new Cartesian3,this._atmosphereRayleighScaleHeight=new Cartesian3,this._atmosphereMieCoefficient=new Cartesian3,this._atmosphereMieScaleHeight=void 0,this._atmosphereMieAnisotropy=void 0,this._atmosphereDynamicLighting=void 0,this._invertClassificationColor=void 0,this._splitPosition=0,this._pixelSizePerMeter=void 0,this._geometricToleranceOverMeter=void 0,this._minimumDisableDepthTestDistance=void 0}Object.defineProperties(UniformState.prototype,{frameState:{get:function(){return this._frameState}},viewport:{get:function(){return this._viewport},set:function(e){if(!BoundingRectangle.equals(e,this._viewport)){BoundingRectangle.clone(e,this._viewport);const t=this._viewport,n=this._viewportCartesian4;n.x=t.x,n.y=t.y,n.z=t.width,n.w=t.height,this._viewportDirty=!0}}},viewportCartesian4:{get:function(){return this._viewportCartesian4}},viewportOrthographic:{get:function(){return cleanViewport(this),this._viewportOrthographicMatrix}},viewportTransformation:{get:function(){return cleanViewport(this),this._viewportTransformation}},model:{get:function(){return this._model},set:function(e){Matrix4.clone(e,this._model),this._modelView3DDirty=!0,this._inverseModelView3DDirty=!0,this._inverseModelDirty=!0,this._inverseTransposeModelDirty=!0,this._modelViewDirty=!0,this._inverseModelViewDirty=!0,this._modelViewRelativeToEyeDirty=!0,this._inverseModelViewDirty=!0,this._modelViewProjectionDirty=!0,this._inverseModelViewProjectionDirty=!0,this._modelViewProjectionRelativeToEyeDirty=!0,this._modelViewInfiniteProjectionDirty=!0,this._normalDirty=!0,this._inverseNormalDirty=!0,this._normal3DDirty=!0,this._inverseNormal3DDirty=!0,this._encodedCameraPositionMCDirty=!0}},inverseModel:{get:function(){return this._inverseModelDirty&&(this._inverseModelDirty=!1,Matrix4.inverse(this._model,this._inverseModel)),this._inverseModel}},inverseTransposeModel:{get:function(){const e=this._inverseTransposeModel;return this._inverseTransposeModelDirty&&(this._inverseTransposeModelDirty=!1,Matrix4.getMatrix3(this.inverseModel,e),Matrix3.transpose(e,e)),e}},view:{get:function(){return this._view}},view3D:{get:function(){return updateView3D(this),this._view3D}},viewRotation:{get:function(){return updateView3D(this),this._viewRotation}},viewRotation3D:{get:function(){return updateView3D(this),this._viewRotation3D}},inverseView:{get:function(){return this._inverseView}},inverseView3D:{get:function(){return updateInverseView3D(this),this._inverseView3D}},inverseViewRotation:{get:function(){return this._inverseViewRotation}},inverseViewRotation3D:{get:function(){return updateInverseView3D(this),this._inverseViewRotation3D}},projection:{get:function(){return this._projection}},inverseProjection:{get:function(){return cleanInverseProjection(this),this._inverseProjection}},infiniteProjection:{get:function(){return this._infiniteProjection}},modelView:{get:function(){return cleanModelView(this),this._modelView}},modelView3D:{get:function(){return cleanModelView3D(this),this._modelView3D}},modelViewRelativeToEye:{get:function(){return cleanModelViewRelativeToEye(this),this._modelViewRelativeToEye}},inverseModelView:{get:function(){return cleanInverseModelView(this),this._inverseModelView}},inverseModelView3D:{get:function(){return cleanInverseModelView3D(this),this._inverseModelView3D}},viewProjection:{get:function(){return cleanViewProjection(this),this._viewProjection}},inverseViewProjection:{get:function(){return cleanInverseViewProjection(this),this._inverseViewProjection}},modelViewProjection:{get:function(){return cleanModelViewProjection(this),this._modelViewProjection}},inverseModelViewProjection:{get:function(){return cleanInverseModelViewProjection(this),this._inverseModelViewProjection}},modelViewProjectionRelativeToEye:{get:function(){return cleanModelViewProjectionRelativeToEye(this),this._modelViewProjectionRelativeToEye}},modelViewInfiniteProjection:{get:function(){return cleanModelViewInfiniteProjection(this),this._modelViewInfiniteProjection}},normal:{get:function(){return cleanNormal(this),this._normal}},normal3D:{get:function(){return cleanNormal3D(this),this._normal3D}},inverseNormal:{get:function(){return cleanInverseNormal(this),this._inverseNormal}},inverseNormal3D:{get:function(){return cleanInverseNormal3D(this),this._inverseNormal3D}},entireFrustum:{get:function(){return this._entireFrustum}},currentFrustum:{get:function(){return this._currentFrustum}},frustumPlanes:{get:function(){return this._frustumPlanes}},farDepthFromNearPlusOne:{get:function(){return this._farDepthFromNearPlusOne}},log2FarDepthFromNearPlusOne:{get:function(){return this._log2FarDepthFromNearPlusOne}},oneOverLog2FarDepthFromNearPlusOne:{get:function(){return this._oneOverLog2FarDepthFromNearPlusOne}},eyeHeight:{get:function(){return this._eyeHeight}},eyeHeight2D:{get:function(){return this._eyeHeight2D}},eyeEllipsoidNormalEC:{get:function(){return this._eyeEllipsoidNormalEC}},eyeEllipsoidCurvature:{get:function(){return this._eyeEllipsoidCurvature}},modelToEnu:{get:function(){return this._modelToEnu}},enuToModel:{get:function(){return this._enuToModel}},sunPositionWC:{get:function(){return this._sunPositionWC}},sunPositionColumbusView:{get:function(){return this._sunPositionColumbusView}},sunDirectionWC:{get:function(){return this._sunDirectionWC}},sunDirectionEC:{get:function(){return this._sunDirectionEC}},moonDirectionEC:{get:function(){return this._moonDirectionEC}},lightDirectionWC:{get:function(){return this._lightDirectionWC}},lightDirectionEC:{get:function(){return this._lightDirectionEC}},lightColor:{get:function(){return this._lightColor}},lightColorHdr:{get:function(){return this._lightColorHdr}},encodedCameraPositionMCHigh:{get:function(){return cleanEncodedCameraPositionMC(this),this._encodedCameraPositionMC.high}},encodedCameraPositionMCLow:{get:function(){return cleanEncodedCameraPositionMC(this),this._encodedCameraPositionMC.low}},temeToPseudoFixedMatrix:{get:function(){return this._temeToPseudoFixed}},pixelRatio:{get:function(){return this._pixelRatio}},fogDensity:{get:function(){return this._fogDensity}},fogMinimumBrightness:{get:function(){return this._fogMinimumBrightness}},atmosphereHsbShift:{get:function(){return this._atmosphereHsbShift}},atmosphereLightIntensity:{get:function(){return this._atmosphereLightIntensity}},atmosphereRayleighCoefficient:{get:function(){return this._atmosphereRayleighCoefficient}},atmosphereRayleighScaleHeight:{get:function(){return this._atmosphereRayleighScaleHeight}},atmosphereMieCoefficient:{get:function(){return this._atmosphereMieCoefficient}},atmosphereMieScaleHeight:{get:function(){return this._atmosphereMieScaleHeight}},atmosphereMieAnisotropy:{get:function(){return this._atmosphereMieAnisotropy}},atmosphereDynamicLighting:{get:function(){return this._atmosphereDynamicLighting}},geometricToleranceOverMeter:{get:function(){return this._geometricToleranceOverMeter}},pass:{get:function(){return this._pass}},backgroundColor:{get:function(){return this._backgroundColor}},brdfLut:{get:function(){return this._brdfLut}},environmentMap:{get:function(){return this._environmentMap}},sphericalHarmonicCoefficients:{get:function(){return this._sphericalHarmonicCoefficients}},specularEnvironmentMaps:{get:function(){return this._specularEnvironmentMaps}},specularEnvironmentMapsDimensions:{get:function(){return this._specularEnvironmentMapsDimensions}},specularEnvironmentMapsMaximumLOD:{get:function(){return this._specularEnvironmentMapsMaximumLOD}},splitPosition:{get:function(){return this._splitPosition}},minimumDisableDepthTestDistance:{get:function(){return this._minimumDisableDepthTestDistance}},invertClassificationColor:{get:function(){return this._invertClassificationColor}},orthographicIn3D:{get:function(){return this._orthographicIn3D}},ellipsoid:{get:function(){return defaultValue(this._ellipsoid,Ellipsoid.default)}}});function setView(e,t){Matrix4.clone(t,e._view),Matrix4.getMatrix3(t,e._viewRotation),e._view3DDirty=!0,e._inverseView3DDirty=!0,e._modelViewDirty=!0,e._modelView3DDirty=!0,e._modelViewRelativeToEyeDirty=!0,e._inverseModelViewDirty=!0,e._inverseModelView3DDirty=!0,e._viewProjectionDirty=!0,e._inverseViewProjectionDirty=!0,e._modelViewProjectionDirty=!0,e._modelViewProjectionRelativeToEyeDirty=!0,e._modelViewInfiniteProjectionDirty=!0,e._normalDirty=!0,e._inverseNormalDirty=!0,e._normal3DDirty=!0,e._inverseNormal3DDirty=!0}function setInverseView(e,t){Matrix4.clone(t,e._inverseView),Matrix4.getMatrix3(t,e._inverseViewRotation)}function setProjection(e,t){Matrix4.clone(t,e._projection),e._inverseProjectionDirty=!0,e._viewProjectionDirty=!0,e._inverseViewProjectionDirty=!0,e._modelViewProjectionDirty=!0,e._modelViewProjectionRelativeToEyeDirty=!0}function setInfiniteProjection(e,t){Matrix4.clone(t,e._infiniteProjection),e._modelViewInfiniteProjectionDirty=!0}const surfacePositionScratch=new Cartesian3,enuTransformScratch=new Matrix4;function setCamera(e,t){Cartesian3.clone(t.positionWC,e._cameraPosition),Cartesian3.clone(t.directionWC,e._cameraDirection),Cartesian3.clone(t.rightWC,e._cameraRight),Cartesian3.clone(t.upWC,e._cameraUp);const n=e._ellipsoid;let i;const r=t.positionCartographic;if(defined(r)?(e._eyeHeight=r.height,e._eyeEllipsoidNormalEC=n.geodeticSurfaceNormalCartographic(r,e._eyeEllipsoidNormalEC),i=Cartesian3.fromRadians(r.longitude,r.latitude,0,n,surfacePositionScratch)):(e._eyeHeight=-n.maximumRadius,Cartesian3.magnitude(t.positionWC)>0&&(e._eyeEllipsoidNormalEC=Cartesian3.normalize(t.positionWC,e._eyeEllipsoidNormalEC)),i=n.scaleToGeodeticSurface(t.positionWC,surfacePositionScratch)),e._encodedCameraPositionMCDirty=!0,!defined(i))return;e._eyeEllipsoidNormalEC=Matrix3.multiplyByVector(e._viewRotation,e._eyeEllipsoidNormalEC,e._eyeEllipsoidNormalEC);const o=Transforms.eastNorthUpToFixedFrame(i,n,enuTransformScratch);e._enuToModel=Matrix4.multiplyTransformation(e.inverseModel,o,e._enuToModel),e._modelToEnu=Matrix4.inverseTransformation(e._enuToModel,e._modelToEnu),CesiumMath.equalsEpsilon(n._radii.x,n._radii.y,CesiumMath.EPSILON15)&&(e._eyeEllipsoidCurvature=n.getLocalCurvature(i,e._eyeEllipsoidCurvature))}let transformMatrix=new Matrix3;const sunCartographicScratch=new Cartographic;function setSunAndMoonDirections(e,t){defined(Transforms.computeIcrfToFixedMatrix(t.time,transformMatrix))||(transformMatrix=Transforms.computeTemeToPseudoFixedMatrix(t.time,transformMatrix));let n=Simon1994PlanetaryPositions$1.computeSunPositionInEarthInertialFrame(t.time,e._sunPositionWC);Matrix3.multiplyByVector(transformMatrix,n,n),Cartesian3.normalize(n,e._sunDirectionWC),n=Matrix3.multiplyByVector(e.viewRotation3D,n,e._sunDirectionEC),Cartesian3.normalize(n,n),n=Simon1994PlanetaryPositions$1.computeMoonPositionInEarthInertialFrame(t.time,e._moonDirectionEC),Matrix3.multiplyByVector(transformMatrix,n,n),Matrix3.multiplyByVector(e.viewRotation3D,n,n),Cartesian3.normalize(n,n);const i=t.mapProjection,o=i.ellipsoid.cartesianToCartographic(e._sunPositionWC,sunCartographicScratch);i.project(o,e._sunPositionColumbusView)}UniformState.prototype.updateCamera=function(e){setView(this,e.viewMatrix),setInverseView(this,e.inverseViewMatrix),setCamera(this,e),this._entireFrustum.x=e.frustum.near,this._entireFrustum.y=e.frustum.far,this.updateFrustum(e.frustum),this._orthographicIn3D=this._mode!==SceneMode.SCENE2D&&e.frustum instanceof OrthographicFrustum};UniformState.prototype.updateFrustum=function(e){setProjection(this,e.projectionMatrix),defined(e.infiniteProjectionMatrix)&&setInfiniteProjection(this,e.infiniteProjectionMatrix),this._currentFrustum.x=e.near,this._currentFrustum.y=e.far,this._farDepthFromNearPlusOne=e.far-e.near+1,this._log2FarDepthFromNearPlusOne=CesiumMath.log2(this._farDepthFromNearPlusOne),this._oneOverLog2FarDepthFromNearPlusOne=1/this._log2FarDepthFromNearPlusOne;const t=e.offCenterFrustum;defined(t)&&(e=t),this._frustumPlanes.x=e.top,this._frustumPlanes.y=e.bottom,this._frustumPlanes.z=e.left,this._frustumPlanes.w=e.right};UniformState.prototype.updatePass=function(e){this._pass=e};const EMPTY_ARRAY=[],defaultLight=new SunLight;UniformState.prototype.update=function(e){this._mode=e.mode,this._mapProjection=e.mapProjection,this._ellipsoid=e.mapProjection.ellipsoid,this._pixelRatio=e.pixelRatio;const t=e.camera;this.updateCamera(t),e.mode===SceneMode.SCENE2D?(this._frustum2DWidth=t.frustum.right-t.frustum.left,this._eyeHeight2D.x=this._frustum2DWidth*.5,this._eyeHeight2D.y=this._eyeHeight2D.x*this._eyeHeight2D.x):(this._frustum2DWidth=0,this._eyeHeight2D.x=0,this._eyeHeight2D.y=0),setSunAndMoonDirections(this,e);const n=defaultValue(e.light,defaultLight);n instanceof SunLight?(this._lightDirectionWC=Cartesian3.clone(this._sunDirectionWC,this._lightDirectionWC),this._lightDirectionEC=Cartesian3.clone(this._sunDirectionEC,this._lightDirectionEC)):(this._lightDirectionWC=Cartesian3.normalize(Cartesian3.negate(n.direction,this._lightDirectionWC),this._lightDirectionWC),this._lightDirectionEC=Matrix3.multiplyByVector(this.viewRotation3D,this._lightDirectionWC,this._lightDirectionEC));const i=n.color;let r=Cartesian3.fromElements(i.red,i.green,i.blue,this._lightColorHdr);r=Cartesian3.multiplyByScalar(r,n.intensity,r);const o=Cartesian3.maximumComponent(r);o>1?Cartesian3.divideByScalar(r,o,this._lightColor):Cartesian3.clone(r,this._lightColor);const a=e.brdfLutGenerator,s=defined(a)?a.colorTexture:void 0;this._brdfLut=s,this._environmentMap=defaultValue(e.environmentMap,e.context.defaultCubeMap),this._sphericalHarmonicCoefficients=defaultValue(e.sphericalHarmonicCoefficients,EMPTY_ARRAY),this._specularEnvironmentMaps=e.specularEnvironmentMaps,this._specularEnvironmentMapsMaximumLOD=e.specularEnvironmentMapsMaximumLOD,defined(this._specularEnvironmentMaps)&&Cartesian2.clone(this._specularEnvironmentMaps.dimensions,this._specularEnvironmentMapsDimensions),this._fogDensity=e.fog.density,this._fogMinimumBrightness=e.fog.minimumBrightness;const l=e.atmosphere;defined(l)&&(this._atmosphereHsbShift=Cartesian3.fromElements(l.hueShift,l.saturationShift,l.brightnessShift,this._atmosphereHsbShift),this._atmosphereLightIntensity=l.lightIntensity,this._atmosphereRayleighCoefficient=Cartesian3.clone(l.rayleighCoefficient,this._atmosphereRayleighCoefficient),this._atmosphereRayleighScaleHeight=l.rayleighScaleHeight,this._atmosphereMieCoefficient=Cartesian3.clone(l.mieCoefficient,this._atmosphereMieCoefficient),this._atmosphereMieScaleHeight=l.mieScaleHeight,this._atmosphereMieAnisotropy=l.mieAnisotropy,this._atmosphereDynamicLighting=l.dynamicLighting),this._invertClassificationColor=e.invertClassificationColor,this._frameState=e,this._temeToPseudoFixed=Transforms.computeTemeToPseudoFixedMatrix(e.time,this._temeToPseudoFixed),this._splitPosition=e.splitPosition*e.context.drawingBufferWidth;const c=t.frustum.fov,d=this._viewport;let h;defined(c)?d.height>d.width?h=Math.tan(.5*c)*2/d.height:h=Math.tan(.5*c)*2/d.width:h=1/Math.max(d.width,d.height),this._geometricToleranceOverMeter=h*e.maximumScreenSpaceError,Color.clone(e.backgroundColor,this._backgroundColor),this._minimumDisableDepthTestDistance=e.minimumDisableDepthTestDistance,this._minimumDisableDepthTestDistance*=this._minimumDisableDepthTestDistance,this._minimumDisableDepthTestDistance===Number.POSITIVE_INFINITY&&(this._minimumDisableDepthTestDistance=-1)};function cleanViewport(e){if(e._viewportDirty){const t=e._viewport;Matrix4.computeOrthographicOffCenter(t.x,t.x+t.width,t.y,t.y+t.height,0,1,e._viewportOrthographicMatrix),Matrix4.computeViewportTransformation(t,0,1,e._viewportTransformation),e._viewportDirty=!1}}function cleanInverseProjection(e){e._inverseProjectionDirty&&(e._inverseProjectionDirty=!1,e._mode!==SceneMode.SCENE2D&&e._mode!==SceneMode.MORPHING&&!e._orthographicIn3D?Matrix4.inverse(e._projection,e._inverseProjection):Matrix4.clone(Matrix4.ZERO,e._inverseProjection))}function cleanModelView(e){e._modelViewDirty&&(e._modelViewDirty=!1,Matrix4.multiplyTransformation(e._view,e._model,e._modelView))}function cleanModelView3D(e){e._modelView3DDirty&&(e._modelView3DDirty=!1,Matrix4.multiplyTransformation(e.view3D,e._model,e._modelView3D))}function cleanInverseModelView(e){e._inverseModelViewDirty&&(e._inverseModelViewDirty=!1,Matrix4.inverse(e.modelView,e._inverseModelView))}function cleanInverseModelView3D(e){e._inverseModelView3DDirty&&(e._inverseModelView3DDirty=!1,Matrix4.inverse(e.modelView3D,e._inverseModelView3D))}function cleanViewProjection(e){e._viewProjectionDirty&&(e._viewProjectionDirty=!1,Matrix4.multiply(e._projection,e._view,e._viewProjection))}function cleanInverseViewProjection(e){e._inverseViewProjectionDirty&&(e._inverseViewProjectionDirty=!1,Matrix4.inverse(e.viewProjection,e._inverseViewProjection))}function cleanModelViewProjection(e){e._modelViewProjectionDirty&&(e._modelViewProjectionDirty=!1,Matrix4.multiply(e._projection,e.modelView,e._modelViewProjection))}function cleanModelViewRelativeToEye(e){if(e._modelViewRelativeToEyeDirty){e._modelViewRelativeToEyeDirty=!1;const t=e.modelView,n=e._modelViewRelativeToEye;n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=0,n[13]=0,n[14]=0,n[15]=t[15]}}function cleanInverseModelViewProjection(e){e._inverseModelViewProjectionDirty&&(e._inverseModelViewProjectionDirty=!1,Matrix4.inverse(e.modelViewProjection,e._inverseModelViewProjection))}function cleanModelViewProjectionRelativeToEye(e){e._modelViewProjectionRelativeToEyeDirty&&(e._modelViewProjectionRelativeToEyeDirty=!1,Matrix4.multiply(e._projection,e.modelViewRelativeToEye,e._modelViewProjectionRelativeToEye))}function cleanModelViewInfiniteProjection(e){e._modelViewInfiniteProjectionDirty&&(e._modelViewInfiniteProjectionDirty=!1,Matrix4.multiply(e._infiniteProjection,e.modelView,e._modelViewInfiniteProjection))}function cleanNormal(e){if(e._normalDirty){e._normalDirty=!1;const t=e._normal;Matrix4.getMatrix3(e.inverseModelView,t),Matrix3.transpose(t,t)}}function cleanNormal3D(e){if(e._normal3DDirty){e._normal3DDirty=!1;const t=e._normal3D;Matrix4.getMatrix3(e.inverseModelView3D,t),Matrix3.transpose(t,t)}}function cleanInverseNormal(e){if(e._inverseNormalDirty){e._inverseNormalDirty=!1;const t=e._inverseNormal;Matrix4.getMatrix3(e.modelView,t),Matrix3.transpose(t,t)}}function cleanInverseNormal3D(e){if(e._inverseNormal3DDirty){e._inverseNormal3DDirty=!1;const t=e._inverseNormal3D;Matrix4.getMatrix3(e.modelView3D,t),Matrix3.transpose(t,t)}}const cameraPositionMC=new Cartesian3;function cleanEncodedCameraPositionMC(e){e._encodedCameraPositionMCDirty&&(e._encodedCameraPositionMCDirty=!1,Matrix4.multiplyByPoint(e.inverseModel,e._cameraPosition,cameraPositionMC),EncodedCartesian3.fromCartesian(cameraPositionMC,e._encodedCameraPositionMC))}const view2Dto3DPScratch=new Cartesian3,view2Dto3DRScratch=new Cartesian3,view2Dto3DUScratch=new Cartesian3,view2Dto3DDScratch=new Cartesian3,view2Dto3DCartographicScratch=new Cartographic,view2Dto3DCartesian3Scratch=new Cartesian3,view2Dto3DMatrix4Scratch=new Matrix4;function view2Dto3D(e,t,n,i,r,o,a,s){const l=view2Dto3DPScratch;l.x=e.y,l.y=e.z,l.z=e.x;const c=view2Dto3DRScratch;c.x=n.y,c.y=n.z,c.z=n.x;const d=view2Dto3DUScratch;d.x=i.y,d.y=i.z,d.z=i.x;const h=view2Dto3DDScratch;h.x=t.y,h.y=t.z,h.z=t.x,o===SceneMode.SCENE2D&&(l.z=r*.5);const f=a.unproject(l,view2Dto3DCartographicScratch);f.longitude=CesiumMath.clamp(f.longitude,-Math.PI,Math.PI),f.latitude=CesiumMath.clamp(f.latitude,-CesiumMath.PI_OVER_TWO,CesiumMath.PI_OVER_TWO);const p=a.ellipsoid,u=p.cartographicToCartesian(f,view2Dto3DCartesian3Scratch),m=Transforms.eastNorthUpToFixedFrame(u,p,view2Dto3DMatrix4Scratch);return Matrix4.multiplyByPointAsVector(m,c,c),Matrix4.multiplyByPointAsVector(m,d,d),Matrix4.multiplyByPointAsVector(m,h,h),defined(s)||(s=new Matrix4),s[0]=c.x,s[1]=d.x,s[2]=-h.x,s[3]=0,s[4]=c.y,s[5]=d.y,s[6]=-h.y,s[7]=0,s[8]=c.z,s[9]=d.z,s[10]=-h.z,s[11]=0,s[12]=-Cartesian3.dot(c,u),s[13]=-Cartesian3.dot(d,u),s[14]=Cartesian3.dot(h,u),s[15]=1,s}function updateView3D(e){e._view3DDirty&&(e._mode===SceneMode.SCENE3D?Matrix4.clone(e._view,e._view3D):view2Dto3D(e._cameraPosition,e._cameraDirection,e._cameraRight,e._cameraUp,e._frustum2DWidth,e._mode,e._mapProjection,e._view3D),Matrix4.getMatrix3(e._view3D,e._viewRotation3D),e._view3DDirty=!1)}function updateInverseView3D(e){e._inverseView3DDirty&&(Matrix4.inverseTransformation(e.view3D,e._inverseView3D),Matrix4.getMatrix3(e._inverseView3D,e._inverseViewRotation3D),e._inverseView3DDirty=!1)}function Context(e,t){Check.defined("canvas",e);const{getWebGLStub:n,requestWebgl1:i,webgl:r={},allowTextureFilterAnisotropic:o=!0}=defaultValue(t,{});r.alpha=defaultValue(r.alpha,!1),r.stencil=defaultValue(r.stencil,!0),r.powerPreference=defaultValue(r.powerPreference,"high-performance");const a=defined(n)?n(e,r):getWebGLContext(e,r,i),l=typeof WebGL2RenderingContext<"u"&&a instanceof WebGL2RenderingContext;this._canvas=e,this._originalGLContext=a,this._gl=a,this._webgl2=l,this._id=createGuid(),this.validateFramebuffer=!1,this.validateShaderProgram=!1,this.logShaderCompilation=!1,this._throwOnWebGLError=!1,this._shaderCache=new ShaderCache(this),this._textureCache=new TextureCache;const c=a;this._stencilBits=c.getParameter(c.STENCIL_BITS),ContextLimits._maximumCombinedTextureImageUnits=c.getParameter(c.MAX_COMBINED_TEXTURE_IMAGE_UNITS),ContextLimits._maximumCubeMapSize=c.getParameter(c.MAX_CUBE_MAP_TEXTURE_SIZE),ContextLimits._maximumFragmentUniformVectors=c.getParameter(c.MAX_FRAGMENT_UNIFORM_VECTORS),ContextLimits._maximumTextureImageUnits=c.getParameter(c.MAX_TEXTURE_IMAGE_UNITS),ContextLimits._maximumRenderbufferSize=c.getParameter(c.MAX_RENDERBUFFER_SIZE),ContextLimits._maximumTextureSize=c.getParameter(c.MAX_TEXTURE_SIZE),ContextLimits._maximumVaryingVectors=c.getParameter(c.MAX_VARYING_VECTORS),ContextLimits._maximumVertexAttributes=c.getParameter(c.MAX_VERTEX_ATTRIBS),ContextLimits._maximumVertexTextureImageUnits=c.getParameter(c.MAX_VERTEX_TEXTURE_IMAGE_UNITS),ContextLimits._maximumVertexUniformVectors=c.getParameter(c.MAX_VERTEX_UNIFORM_VECTORS),ContextLimits._maximumSamples=this._webgl2?c.getParameter(c.MAX_SAMPLES):0;const d=c.getParameter(c.ALIASED_LINE_WIDTH_RANGE);ContextLimits._minimumAliasedLineWidth=d[0],ContextLimits._maximumAliasedLineWidth=d[1];const h=c.getParameter(c.ALIASED_POINT_SIZE_RANGE);ContextLimits._minimumAliasedPointSize=h[0],ContextLimits._maximumAliasedPointSize=h[1];const f=c.getParameter(c.MAX_VIEWPORT_DIMS);ContextLimits._maximumViewportWidth=f[0],ContextLimits._maximumViewportHeight=f[1];const p=c.getShaderPrecisionFormat(c.FRAGMENT_SHADER,c.HIGH_FLOAT);ContextLimits._highpFloatSupported=p.precision!==0;const u=c.getShaderPrecisionFormat(c.FRAGMENT_SHADER,c.HIGH_INT);ContextLimits._highpIntSupported=u.rangeMax!==0,this._antialias=c.getContextAttributes().antialias,this._standardDerivatives=!!getExtension(c,["OES_standard_derivatives"]),this._blendMinmax=!!getExtension(c,["EXT_blend_minmax"]),this._elementIndexUint=!!getExtension(c,["OES_element_index_uint"]),this._depthTexture=!!getExtension(c,["WEBGL_depth_texture","WEBKIT_WEBGL_depth_texture"]),this._fragDepth=!!getExtension(c,["EXT_frag_depth"]),this._debugShaders=getExtension(c,["WEBGL_debug_shaders"]),this._textureFloat=!!getExtension(c,["OES_texture_float"]),this._textureHalfFloat=!!getExtension(c,["OES_texture_half_float"]),this._textureFloatLinear=!!getExtension(c,["OES_texture_float_linear"]),this._textureHalfFloatLinear=!!getExtension(c,["OES_texture_half_float_linear"]),this._colorBufferFloat=!!getExtension(c,["EXT_color_buffer_float","WEBGL_color_buffer_float"]),this._floatBlend=!!getExtension(c,["EXT_float_blend"]),this._colorBufferHalfFloat=!!getExtension(c,["EXT_color_buffer_half_float"]),this._s3tc=!!getExtension(c,["WEBGL_compressed_texture_s3tc","MOZ_WEBGL_compressed_texture_s3tc","WEBKIT_WEBGL_compressed_texture_s3tc"]),this._pvrtc=!!getExtension(c,["WEBGL_compressed_texture_pvrtc","WEBKIT_WEBGL_compressed_texture_pvrtc"]),this._astc=!!getExtension(c,["WEBGL_compressed_texture_astc"]),this._etc=!!getExtension(c,["WEBG_compressed_texture_etc"]),this._etc1=!!getExtension(c,["WEBGL_compressed_texture_etc1"]),this._bc7=!!getExtension(c,["EXT_texture_compression_bptc"]),loadKTX2.setKTX2SupportedFormats(this._s3tc,this._pvrtc,this._astc,this._etc,this._etc1,this._bc7);const m=o?getExtension(c,["EXT_texture_filter_anisotropic","WEBKIT_EXT_texture_filter_anisotropic"]):void 0;this._textureFilterAnisotropic=m,ContextLimits._maximumTextureFilterAnisotropy=defined(m)?c.getParameter(m.MAX_TEXTURE_MAX_ANISOTROPY_EXT):1;let g,_,C,A,S,v,b,D,I,L;if(l){const T=this;g=function(){return T._gl.createVertexArray()},_=function(E){T._gl.bindVertexArray(E)},C=function(E){T._gl.deleteVertexArray(E)},A=function(E,P,M,O,V){c.drawElementsInstanced(E,P,M,O,V)},S=function(E,P,M,O){c.drawArraysInstanced(E,P,M,O)},v=function(E,P){c.vertexAttribDivisor(E,P)},b=function(E){c.drawBuffers(E)}}else D=getExtension(c,["OES_vertex_array_object"]),defined(D)&&(g=function(){return D.createVertexArrayOES()},_=function(T){D.bindVertexArrayOES(T)},C=function(T){D.deleteVertexArrayOES(T)}),I=getExtension(c,["ANGLE_instanced_arrays"]),defined(I)&&(A=function(T,E,P,M,O){I.drawElementsInstancedANGLE(T,E,P,M,O)},S=function(T,E,P,M){I.drawArraysInstancedANGLE(T,E,P,M)},v=function(T,E){I.vertexAttribDivisorANGLE(T,E)}),L=getExtension(c,["WEBGL_draw_buffers"]),defined(L)&&(b=function(T){L.drawBuffersWEBGL(T)});this.glCreateVertexArray=g,this.glBindVertexArray=_,this.glDeleteVertexArray=C,this.glDrawElementsInstanced=A,this.glDrawArraysInstanced=S,this.glVertexAttribDivisor=v,this.glDrawBuffers=b,this._vertexArrayObject=!!D,this._instancedArrays=!!I,this._drawBuffers=!!L,ContextLimits._maximumDrawBuffers=this.drawBuffers?c.getParameter(WebGLConstants.MAX_DRAW_BUFFERS):1,ContextLimits._maximumColorAttachments=this.drawBuffers?c.getParameter(WebGLConstants.MAX_COLOR_ATTACHMENTS):1,this._clearColor=new Color(0,0,0,0),this._clearDepth=1,this._clearStencil=0;const N=new UniformState,y=new PassState(this),x=RenderState.fromCache();this._defaultPassState=y,this._defaultRenderState=x,this._defaultTexture=void 0,this._defaultEmissiveTexture=void 0,this._defaultNormalTexture=void 0,this._defaultCubeMap=void 0,this._us=N,this._currentRenderState=x,this._currentPassState=y,this._currentFramebuffer=void 0,this._maxFrameTextureUnitIndex=0,this._vertexAttribDivisors=[],this._previousDrawInstanced=!1;for(let T=0;T<ContextLimits._maximumVertexAttributes;T++)this._vertexAttribDivisors.push(0);this._pickObjects={},this._nextPickColor=new Uint32Array(1),this.options={getWebGLStub:n,requestWebgl1:i,webgl:r,allowTextureFilterAnisotropic:o},this.cache={},RenderState.apply(c,x,y)}function getWebGLContext(e,t,n){if(typeof WebGLRenderingContext>"u")throw new RuntimeError("The browser does not support WebGL.  Visit http://get.webgl.org.");!n&&!(typeof WebGL2RenderingContext<"u")&&(n=!0);const r=n?"webgl":"webgl2",o=e.getContext(r,t);if(!defined(o))throw new RuntimeError("The browser supports WebGL, but initialization failed.");return o}function errorToString(e,t){let n="WebGL Error:  ";switch(t){case e.INVALID_ENUM:n+="INVALID_ENUM";break;case e.INVALID_VALUE:n+="INVALID_VALUE";break;case e.INVALID_OPERATION:n+="INVALID_OPERATION";break;case e.OUT_OF_MEMORY:n+="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:n+="CONTEXT_LOST_WEBGL lost";break;default:n+=`Unknown (${t})`}return n}function createErrorMessage(e,t,n,i){let r=`${errorToString(e,i)}: ${t.name}(`;for(let o=0;o<n.length;++o)o!==0&&(r+=", "),r+=n[o];return r+=");",r}function throwOnError(e,t,n){const i=e.getError();if(i!==e.NO_ERROR)throw new RuntimeError(createErrorMessage(e,t,n,i))}function makeGetterSetter(e,t,n){return{get:function(){const i=e[t];return n(e,`get: ${t}`,i),e[t]},set:function(i){e[t]=i,n(e,`set: ${t}`,i)}}}function wrapGL(e,t){if(!defined(t))return e;function n(r){return function(){const o=r.apply(e,arguments);return t(e,r,arguments),o}}const i={};for(const r in e){const o=e[r];o instanceof Function?i[r]=n(o):Object.defineProperty(i,r,makeGetterSetter(e,r,t))}return i}function getExtension(e,t){const n=t.length;for(let i=0;i<n;++i){const r=e.getExtension(t[i]);if(r)return r}}const defaultFramebufferMarker={};Object.defineProperties(Context.prototype,{id:{get:function(){return this._id}},webgl2:{get:function(){return this._webgl2}},canvas:{get:function(){return this._canvas}},shaderCache:{get:function(){return this._shaderCache}},textureCache:{get:function(){return this._textureCache}},uniformState:{get:function(){return this._us}},stencilBits:{get:function(){return this._stencilBits}},stencilBuffer:{get:function(){return this._stencilBits>=8}},antialias:{get:function(){return this._antialias}},msaa:{get:function(){return this._webgl2}},standardDerivatives:{get:function(){return this._standardDerivatives||this._webgl2}},floatBlend:{get:function(){return this._floatBlend}},blendMinmax:{get:function(){return this._blendMinmax||this._webgl2}},elementIndexUint:{get:function(){return this._elementIndexUint||this._webgl2}},depthTexture:{get:function(){return this._depthTexture||this._webgl2}},floatingPointTexture:{get:function(){return this._webgl2||this._textureFloat}},halfFloatingPointTexture:{get:function(){return this._webgl2||this._textureHalfFloat}},textureFloatLinear:{get:function(){return this._textureFloatLinear}},textureHalfFloatLinear:{get:function(){return this._webgl2&&this._textureFloatLinear||!this._webgl2&&this._textureHalfFloatLinear}},textureFilterAnisotropic:{get:function(){return!!this._textureFilterAnisotropic}},s3tc:{get:function(){return this._s3tc}},pvrtc:{get:function(){return this._pvrtc}},astc:{get:function(){return this._astc}},etc:{get:function(){return this._etc}},etc1:{get:function(){return this._etc1}},bc7:{get:function(){return this._bc7}},supportsBasis:{get:function(){return this._s3tc||this._pvrtc||this._astc||this._etc||this._etc1||this._bc7}},vertexArrayObject:{get:function(){return this._vertexArrayObject||this._webgl2}},fragmentDepth:{get:function(){return this._fragDepth||this._webgl2}},instancedArrays:{get:function(){return this._instancedArrays||this._webgl2}},colorBufferFloat:{get:function(){return this._colorBufferFloat}},colorBufferHalfFloat:{get:function(){return this._webgl2&&this._colorBufferFloat||!this._webgl2&&this._colorBufferHalfFloat}},drawBuffers:{get:function(){return this._drawBuffers||this._webgl2}},debugShaders:{get:function(){return this._debugShaders}},throwOnWebGLError:{get:function(){return this._throwOnWebGLError},set:function(e){this._throwOnWebGLError=e,this._gl=wrapGL(this._originalGLContext,e?throwOnError:void 0)}},defaultTexture:{get:function(){return this._defaultTexture===void 0&&(this._defaultTexture=new Texture({context:this,source:{width:1,height:1,arrayBufferView:new Uint8Array([255,255,255,255])},flipY:!1})),this._defaultTexture}},defaultEmissiveTexture:{get:function(){return this._defaultEmissiveTexture===void 0&&(this._defaultEmissiveTexture=new Texture({context:this,pixelFormat:PixelFormat.RGB,source:{width:1,height:1,arrayBufferView:new Uint8Array([0,0,0])},flipY:!1})),this._defaultEmissiveTexture}},defaultNormalTexture:{get:function(){return this._defaultNormalTexture===void 0&&(this._defaultNormalTexture=new Texture({context:this,pixelFormat:PixelFormat.RGB,source:{width:1,height:1,arrayBufferView:new Uint8Array([128,128,255])},flipY:!1})),this._defaultNormalTexture}},defaultCubeMap:{get:function(){if(this._defaultCubeMap===void 0){const e={width:1,height:1,arrayBufferView:new Uint8Array([255,255,255,255])};this._defaultCubeMap=new CubeMap({context:this,source:{positiveX:e,negativeX:e,positiveY:e,negativeY:e,positiveZ:e,negativeZ:e},flipY:!1})}return this._defaultCubeMap}},drawingBufferHeight:{get:function(){return this._gl.drawingBufferHeight}},drawingBufferWidth:{get:function(){return this._gl.drawingBufferWidth}},defaultFramebuffer:{get:function(){return defaultFramebufferMarker}}});function validateFramebuffer(e){if(e.validateFramebuffer){const t=e._gl,n=t.checkFramebufferStatus(t.FRAMEBUFFER);if(n!==t.FRAMEBUFFER_COMPLETE){let i;switch(n){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:i="Framebuffer is not complete.  Incomplete attachment: at least one attachment point with a renderbuffer or texture attached has its attached object no longer in existence or has an attached image with a width or height of zero, or the color attachment point has a non-color-renderable image attached, or the depth attachment point has a non-depth-renderable image attached, or the stencil attachment point has a non-stencil-renderable image attached.  Color-renderable formats include GL_RGBA4, GL_RGB5_A1, and GL_RGB565. GL_DEPTH_COMPONENT16 is the only depth-renderable format. GL_STENCIL_INDEX8 is the only stencil-renderable format.";break;case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:i="Framebuffer is not complete.  Incomplete dimensions: not all attached images have the same width and height.";break;case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:i="Framebuffer is not complete.  Missing attachment: no images are attached to the framebuffer.";break;case t.FRAMEBUFFER_UNSUPPORTED:i="Framebuffer is not complete.  Unsupported: the combination of internal formats of the attached images violates an implementation-dependent set of restrictions.";break}throw new DeveloperError(i)}}}function applyRenderState(e,t,n,i){const r=e._currentRenderState,o=e._currentPassState;e._currentRenderState=t,e._currentPassState=n,RenderState.partialApply(e._gl,r,t,o,n,i)}let scratchBackBufferArray;typeof WebGLRenderingContext<"u"&&(scratchBackBufferArray=[WebGLConstants.BACK]);function bindFramebuffer(e,t){if(t!==e._currentFramebuffer){e._currentFramebuffer=t;let n=scratchBackBufferArray;if(defined(t))t._bind(),validateFramebuffer(e),n=t._getActiveColorAttachments();else{const i=e._gl;i.bindFramebuffer(i.FRAMEBUFFER,null)}e.drawBuffers&&e.glDrawBuffers(n)}}const defaultClearCommand=new ClearCommand;Context.prototype.clear=function(e,t){e=defaultValue(e,defaultClearCommand),t=defaultValue(t,this._defaultPassState);const n=this._gl;let i=0;const r=e.color,o=e.depth,a=e.stencil;defined(r)&&(Color.equals(this._clearColor,r)||(Color.clone(r,this._clearColor),n.clearColor(r.red,r.green,r.blue,r.alpha)),i|=n.COLOR_BUFFER_BIT),defined(o)&&(o!==this._clearDepth&&(this._clearDepth=o,n.clearDepth(o)),i|=n.DEPTH_BUFFER_BIT),defined(a)&&(a!==this._clearStencil&&(this._clearStencil=a,n.clearStencil(a)),i|=n.STENCIL_BUFFER_BIT);const s=defaultValue(e.renderState,this._defaultRenderState);applyRenderState(this,s,t,!0);const l=defaultValue(e.framebuffer,t.framebuffer);bindFramebuffer(this,l),n.clear(i)};function beginDraw(e,t,n,i,r){if(defined(t)&&r.depthTest&&r.depthTest.enabled&&!t.hasDepthAttachment)throw new DeveloperError("The depth test can not be enabled (drawCommand.renderState.depthTest.enabled) because the framebuffer (drawCommand.framebuffer) does not have a depth or depth-stencil renderbuffer.");bindFramebuffer(e,t),applyRenderState(e,r,n,!1),i._bind(),e._maxFrameTextureUnitIndex=Math.max(e._maxFrameTextureUnitIndex,i.maximumTextureUnitIndex)}function continueDraw(e,t,n,i){const r=t._primitiveType,o=t._vertexArray;let a=t._offset,s=t._count;const l=t.instanceCount;if(!PrimitiveType.validate(r))throw new DeveloperError("drawCommand.primitiveType is required and must be valid.");if(Check.defined("drawCommand.vertexArray",o),Check.typeOf.number.greaterThanOrEquals("drawCommand.offset",a,0),defined(s)&&Check.typeOf.number.greaterThanOrEquals("drawCommand.count",s,0),Check.typeOf.number.greaterThanOrEquals("drawCommand.instanceCount",l,0),l>0&&!e.instancedArrays)throw new DeveloperError("Instanced arrays extension is not supported");e._us.model=defaultValue(t._modelMatrix,Matrix4.IDENTITY),n._setUniforms(i,e._us,e.validateShaderProgram),o._bind();const c=o.indexBuffer;defined(c)?(a=a*c.bytesPerIndex,defined(s)?s=Math.min(s,c.numberOfIndices):s=c.numberOfIndices,l===0?e._gl.drawElements(r,s,c.indexDatatype,a):e.glDrawElementsInstanced(r,s,c.indexDatatype,a,l)):(defined(s)?s=Math.min(s,o.numberOfVertices):s=o.numberOfVertices,l===0?e._gl.drawArrays(r,a,s):e.glDrawArraysInstanced(r,a,s,l)),o._unBind()}Context.prototype.draw=function(e,t,n,i){Check.defined("drawCommand",e),Check.defined("drawCommand.shaderProgram",e._shaderProgram),t=defaultValue(t,this._defaultPassState);const r=defaultValue(e._framebuffer,t.framebuffer),o=defaultValue(e._renderState,this._defaultRenderState);n=defaultValue(n,e._shaderProgram),i=defaultValue(i,e._uniformMap),beginDraw(this,r,t,n,o),continueDraw(this,e,n,i)};Context.prototype.endFrame=function(){const e=this._gl;e.useProgram(null),this._currentFramebuffer=void 0,e.bindFramebuffer(e.FRAMEBUFFER,null);const t=scratchBackBufferArray;this.drawBuffers&&this.glDrawBuffers(t);const n=this._maxFrameTextureUnitIndex;this._maxFrameTextureUnitIndex=0;for(let i=0;i<n;++i)e.activeTexture(e.TEXTURE0+i),e.bindTexture(e.TEXTURE_2D,null),e.bindTexture(e.TEXTURE_CUBE_MAP,null)};Context.prototype.readPixels=function(e){const t=this._gl;e=defaultValue(e,defaultValue.EMPTY_OBJECT);const n=Math.max(defaultValue(e.x,0),0),i=Math.max(defaultValue(e.y,0),0),r=defaultValue(e.width,t.drawingBufferWidth),o=defaultValue(e.height,t.drawingBufferHeight),a=e.framebuffer;Check.typeOf.number.greaterThan("readState.width",r,0),Check.typeOf.number.greaterThan("readState.height",o,0);let s=PixelDatatype.UNSIGNED_BYTE;defined(a)&&a.numberOfColorAttachments>0&&(s=a.getColorTexture(0).pixelDatatype);const l=PixelFormat.createTypedArray(PixelFormat.RGBA,s,r,o);return bindFramebuffer(this,a),t.readPixels(n,i,r,o,PixelFormat.RGBA,PixelDatatype.toWebGLConstant(s,this),l),l};const viewportQuadAttributeLocations={position:0,textureCoordinates:1};Context.prototype.getViewportQuadVertexArray=function(){let e=this.cache.viewportQuad_vertexArray;if(!defined(e)){const t=new Geometry({attributes:{position:new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:[-1,-1,1,-1,1,1,-1,1]}),textureCoordinates:new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:[0,0,1,0,1,1,0,1]})},indices:new Uint16Array([0,1,2,0,2,3]),primitiveType:PrimitiveType.TRIANGLES});e=VertexArray.fromGeometry({context:this,geometry:t,attributeLocations:viewportQuadAttributeLocations,bufferUsage:BufferUsage.STATIC_DRAW,interleave:!0}),this.cache.viewportQuad_vertexArray=e}return e};Context.prototype.createViewportQuadCommand=function(e,t){return t=defaultValue(t,defaultValue.EMPTY_OBJECT),new DrawCommand({vertexArray:this.getViewportQuadVertexArray(),primitiveType:PrimitiveType.TRIANGLES,renderState:t.renderState,shaderProgram:ShaderProgram.fromCache({context:this,vertexShaderSource:ViewportQuadVS,fragmentShaderSource:e,attributeLocations:viewportQuadAttributeLocations}),uniformMap:t.uniformMap,owner:t.owner,framebuffer:t.framebuffer,pass:t.pass})};Context.prototype.getObjectByPickColor=function(e){return Check.defined("pickColor",e),this._pickObjects[e.toRgba()]};function PickId(e,t,n){this._pickObjects=e,this.key=t,this.color=n}Object.defineProperties(PickId.prototype,{object:{get:function(){return this._pickObjects[this.key]},set:function(e){this._pickObjects[this.key]=e}}});PickId.prototype.destroy=function(){delete this._pickObjects[this.key]};Context.prototype.createPickId=function(e){Check.defined("object",e),++this._nextPickColor[0];const t=this._nextPickColor[0];if(t===0)throw new RuntimeError("Out of unique Pick IDs.");return this._pickObjects[t]=e,new PickId(this._pickObjects,t,Color.fromRgba(t))};Context.prototype.isDestroyed=function(){return!1};Context.prototype.destroy=function(){const e=this.cache;for(const t in e)if(e.hasOwnProperty(t)){const n=e[t];defined(n.destroy)&&n.destroy()}return this._shaderCache=this._shaderCache.destroy(),this._textureCache=this._textureCache.destroy(),this._defaultTexture=this._defaultTexture&&this._defaultTexture.destroy(),this._defaultEmissiveTexture=this._defaultEmissiveTexture&&this._defaultEmissiveTexture.destroy(),this._defaultNormalTexture=this._defaultNormalTexture&&this._defaultNormalTexture.destroy(),this._defaultCubeMap=this._defaultCubeMap&&this._defaultCubeMap.destroy(),destroyObject(this)};Context._deprecationWarning=deprecationWarning;const DynamicAtmosphereLightingType={NONE:0,SCENE_LIGHT:1,SUNLIGHT:2};DynamicAtmosphereLightingType.fromGlobeFlags=function(e){return e.enableLighting&&e.dynamicAtmosphereLighting?e.dynamicAtmosphereLightingFromSun?DynamicAtmosphereLightingType.SUNLIGHT:DynamicAtmosphereLightingType.SCENE_LIGHT:DynamicAtmosphereLightingType.NONE};const DynamicAtmosphereLightingType$1=Object.freeze(DynamicAtmosphereLightingType);function Atmosphere(){this.lightIntensity=10,this.rayleighCoefficient=new Cartesian3(55e-7,13e-6,284e-7),this.mieCoefficient=new Cartesian3(21e-6,21e-6,21e-6),this.rayleighScaleHeight=1e4,this.mieScaleHeight=3200,this.mieAnisotropy=.9,this.hueShift=0,this.saturationShift=0,this.brightnessShift=0,this.dynamicLighting=DynamicAtmosphereLightingType$1.NONE}function BrdfLutGenerator(){this._colorTexture=void 0,this._drawCommand=void 0}Object.defineProperties(BrdfLutGenerator.prototype,{colorTexture:{get:function(){return this._colorTexture}}});function createCommand$1(e,t,n){const i=t.createViewportQuadCommand(BrdfLutGeneratorFS,{framebuffer:n,renderState:RenderState.fromCache({viewport:new BoundingRectangle(0,0,256,256)})});e._drawCommand=i}BrdfLutGenerator.prototype.update=function(e){if(!defined(this._colorTexture)){const t=e.context,n=new Texture({context:t,width:256,height:256,pixelFormat:PixelFormat.RGBA,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,sampler:Sampler.NEAREST});this._colorTexture=n;const i=new Framebuffer({context:t,colorTextures:[n],destroyAttachments:!1});createCommand$1(this,t,i),this._drawCommand.execute(t),i.destroy(),this._drawCommand.shaderProgram=this._drawCommand.shaderProgram&&this._drawCommand.shaderProgram.destroy()}};BrdfLutGenerator.prototype.isDestroyed=function(){return!1};BrdfLutGenerator.prototype.destroy=function(){return this._colorTexture=this._colorTexture&&this._colorTexture.destroy(),destroyObject(this)};const CameraFlightPath={};function getAltitude(e,t,n){let i,r,o;if(e instanceof PerspectiveFrustum){const a=Math.tan(.5*e.fovy);return i=e.near,r=e.near*a,o=e.aspectRatio*r,Math.max(t*i/o,n*i/r)}else if(e instanceof PerspectiveOffCenterFrustum)return i=e.near,r=e.top,o=e.right,Math.max(t*i/o,n*i/r);return Math.max(t,n)}const scratchCart=new Cartesian3,scratchCart2=new Cartesian3;function createPitchFunction(e,t,n,i){if(defined(i)&&n(.5)>i){const r=n(0),o=n(1),a=n(.5),s=a-r,l=a-o;return function(c){const d=n(c);if(c<=.5){const f=(d-r)/s;return CesiumMath.lerp(e,-CesiumMath.PI_OVER_TWO,f)}const h=(d-o)/l;return CesiumMath.lerp(-CesiumMath.PI_OVER_TWO,t,1-h)}}return function(r){return CesiumMath.lerp(e,t,r)}}function createHeightFunction(e,t,n,i,r){let o=r;const a=Math.max(n,i);if(!defined(o)){const s=e.position,l=t,c=e.up,d=e.right,h=e.frustum,f=Cartesian3.subtract(s,l,scratchCart),p=Cartesian3.magnitude(Cartesian3.multiplyByScalar(c,Cartesian3.dot(f,c),scratchCart2)),u=Cartesian3.magnitude(Cartesian3.multiplyByScalar(d,Cartesian3.dot(f,d),scratchCart2));o=Math.min(getAltitude(h,p,u)*.2,1e9)}if(a<o){const c=-Math.pow((o-n)*1e6,.125),d=Math.pow((o-i)*1e6,1/8);return function(h){const f=h*(d-c)+c;return-Math.pow(f,8)/1e6+o}}return function(s){return CesiumMath.lerp(n,i,s)}}function adjustAngleForLERP(e,t){return CesiumMath.equalsEpsilon(e,CesiumMath.TWO_PI,CesiumMath.EPSILON11)&&(e=0),t>e+Math.PI?e+=CesiumMath.TWO_PI:t<e-Math.PI&&(e-=CesiumMath.TWO_PI),e}const scratchStart=new Cartesian3;function createUpdateCV(e,t,n,i,r,o,a,s){const l=e.camera,c=Cartesian3.clone(l.position,scratchStart),d=l.pitch,h=adjustAngleForLERP(l.heading,i),f=adjustAngleForLERP(l.roll,o),p=createHeightFunction(l,n,c.z,n.z,a),u=createPitchFunction(d,r,p,s);function m(g){const _=g.time/t;l.setView({orientation:{heading:CesiumMath.lerp(h,i,_),pitch:u(_),roll:CesiumMath.lerp(f,o,_)}}),Cartesian2.lerp(c,n,_,l.position),l.position.z=p(_)}return m}function useLongestFlight(e,t){e.longitude<t.longitude?e.longitude+=CesiumMath.TWO_PI:t.longitude+=CesiumMath.TWO_PI}function useShortestFlight(e,t){const n=e.longitude-t.longitude;n<-CesiumMath.PI?e.longitude+=CesiumMath.TWO_PI:n>CesiumMath.PI&&(t.longitude+=CesiumMath.TWO_PI)}const scratchStartCart=new Cartographic,scratchEndCart=new Cartographic;function createUpdate3D(e,t,n,i,r,o,a,s,l,c){const d=e.camera,f=e.mapProjection.ellipsoid,p=Cartographic.clone(d.positionCartographic,scratchStartCart),u=d.pitch,m=adjustAngleForLERP(d.heading,i),g=adjustAngleForLERP(d.roll,o),_=f.cartesianToCartographic(n,scratchEndCart);p.longitude=CesiumMath.zeroToTwoPi(p.longitude),_.longitude=CesiumMath.zeroToTwoPi(_.longitude);let C=!1;if(defined(s)){const b=CesiumMath.zeroToTwoPi(s),D=Math.min(p.longitude,_.longitude),I=Math.max(p.longitude,_.longitude),L=b>=D&&b<=I;if(defined(l)){const N=Math.abs(p.longitude-_.longitude),y=CesiumMath.TWO_PI-N;(L?N:y)<(L?y:N)*l&&!L&&(C=!0)}else L||(C=!0)}C?useLongestFlight(p,_):useShortestFlight(p,_);const A=createHeightFunction(d,n,p.height,_.height,a),S=createPitchFunction(u,r,A,c);function v(){const b=p.longitude,D=_.longitude,I=p.latitude,L=_.latitude;return function(y){const x=y.time/t,T=Cartesian3.fromRadians(CesiumMath.lerp(b,D,x),CesiumMath.lerp(I,L,x),A(x),f);d.setView({destination:T,orientation:{heading:CesiumMath.lerp(m,i,x),pitch:S(x),roll:CesiumMath.lerp(g,o,x)}})}}return v()}function createUpdate2D(e,t,n,i,r,o,a){const s=e.camera,l=Cartesian3.clone(s.position,scratchStart),c=adjustAngleForLERP(s.heading,i),d=s.frustum.right-s.frustum.left,h=createHeightFunction(s,n,d,n.z,a);function f(p){const u=p.time/t;s.setView({orientation:{heading:CesiumMath.lerp(c,i,u)}}),Cartesian2.lerp(l,n,u,s.position);const m=h(u),g=s.frustum,_=g.top/g.right,C=(m-(g.right-g.left))*.5;g.right+=C,g.left-=C,g.top=_*g.right,g.bottom=-g.top}return f}const scratchCartographic$3=new Cartographic,scratchDestination=new Cartesian3;function emptyFlight(e,t){return{startObject:{},stopObject:{},duration:0,complete:e,cancel:t}}function wrapCallback(e,t){function n(){typeof t=="function"&&t(),e.enableInputs=!0}return n}CameraFlightPath.createTween=function(e,t){t=defaultValue(t,defaultValue.EMPTY_OBJECT);let n=t.destination;if(!defined(e))throw new DeveloperError("scene is required.");if(!defined(n))throw new DeveloperError("destination is required.");const i=e.mode;if(i===SceneMode.MORPHING)return emptyFlight();const r=defaultValue(t.convert,!0),o=e.mapProjection,a=o.ellipsoid,s=t.maximumHeight,l=t.flyOverLongitude,c=t.flyOverLongitudeWeight,d=t.pitchAdjustHeight;let h=t.easingFunction;r&&i!==SceneMode.SCENE3D&&(a.cartesianToCartographic(n,scratchCartographic$3),n=o.project(scratchCartographic$3,scratchDestination));const f=e.camera,p=t.endTransform;defined(p)&&f._setTransform(p);let u=t.duration;defined(u)||(u=Math.ceil(Cartesian3.distance(f.position,n)/1e6)+2,u=Math.min(u,3));const m=defaultValue(t.heading,0),g=defaultValue(t.pitch,-CesiumMath.PI_OVER_TWO),_=defaultValue(t.roll,0),C=e.screenSpaceCameraController;C.enableInputs=!1;const A=wrapCallback(C,t.complete),S=wrapCallback(C,t.cancel),v=f.frustum;let b=e.mode===SceneMode.SCENE2D;if(b=b&&Cartesian2.equalsEpsilon(f.position,n,CesiumMath.EPSILON6),b=b&&CesiumMath.equalsEpsilon(Math.max(v.right-v.left,v.top-v.bottom),n.z,CesiumMath.EPSILON6),b=b||e.mode!==SceneMode.SCENE2D&&Cartesian3.equalsEpsilon(n,f.position,CesiumMath.EPSILON10),b=b&&CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(m),CesiumMath.negativePiToPi(f.heading),CesiumMath.EPSILON10)&&CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(g),CesiumMath.negativePiToPi(f.pitch),CesiumMath.EPSILON10)&&CesiumMath.equalsEpsilon(CesiumMath.negativePiToPi(_),CesiumMath.negativePiToPi(f.roll),CesiumMath.EPSILON10),b)return emptyFlight(A,S);const D=new Array(4);if(D[SceneMode.SCENE2D]=createUpdate2D,D[SceneMode.SCENE3D]=createUpdate3D,D[SceneMode.COLUMBUS_VIEW]=createUpdateCV,u<=0)return emptyFlight(function(){D[i](e,1,n,m,g,_,s,l,c,d)({time:1}),typeof A=="function"&&A()},S);const I=D[i](e,u,n,m,g,_,s,l,c,d);if(!defined(h)){const L=f.positionCartographic.height,N=i===SceneMode.SCENE3D?a.cartesianToCartographic(n).height:n.z;L>N&&L>11500?h=EasingFunction$1.CUBIC_OUT:h=EasingFunction$1.QUINTIC_IN_OUT}return{duration:u,easingFunction:h,startObject:{time:0},stopObject:{time:u},update:I,complete:A,cancel:S}};const CameraFlightPath$1=CameraFlightPath,MapMode2D={ROTATE:0,INFINITE_SCROLL:1},MapMode2D$1=Object.freeze(MapMode2D);function Camera(e){if(!defined(e))throw new DeveloperError("scene is required.");this._scene=e,this._transform=Matrix4.clone(Matrix4.IDENTITY),this._invTransform=Matrix4.clone(Matrix4.IDENTITY),this._actualTransform=Matrix4.clone(Matrix4.IDENTITY),this._actualInvTransform=Matrix4.clone(Matrix4.IDENTITY),this._transformChanged=!1,this.position=new Cartesian3,this._position=new Cartesian3,this._positionWC=new Cartesian3,this._positionCartographic=new Cartographic,this._oldPositionWC=void 0,this.positionWCDeltaMagnitude=0,this.positionWCDeltaMagnitudeLastFrame=0,this.timeSinceMoved=0,this._lastMovedTimestamp=0,this.direction=new Cartesian3,this._direction=new Cartesian3,this._directionWC=new Cartesian3,this.up=new Cartesian3,this._up=new Cartesian3,this._upWC=new Cartesian3,this.right=new Cartesian3,this._right=new Cartesian3,this._rightWC=new Cartesian3,this.frustum=new PerspectiveFrustum,this.frustum.aspectRatio=e.drawingBufferWidth/e.drawingBufferHeight,this.frustum.fov=CesiumMath.toRadians(60),this.defaultMoveAmount=1e5,this.defaultLookAmount=Math.PI/60,this.defaultRotateAmount=Math.PI/3600,this.defaultZoomAmount=1e5,this.constrainedAxis=void 0,this.maximumZoomFactor=1.5,this._moveStart=new Event,this._moveEnd=new Event,this._changed=new Event,this._changedPosition=void 0,this._changedDirection=void 0,this._changedFrustum=void 0,this._changedHeading=void 0,this._changedRoll=void 0,this.percentageChanged=.5,this._viewMatrix=new Matrix4,this._invViewMatrix=new Matrix4,updateViewMatrix(this),this._mode=SceneMode.SCENE3D,this._modeChanged=!0;const t=e.mapProjection;this._projection=t,this._maxCoord=t.project(new Cartographic(Math.PI,CesiumMath.PI_OVER_TWO)),this._max2Dfrustum=void 0,rectangleCameraPosition3D(this,Camera.DEFAULT_VIEW_RECTANGLE,this.position,!0);let n=Cartesian3.magnitude(this.position);n+=n*Camera.DEFAULT_VIEW_FACTOR,Cartesian3.normalize(this.position,this.position),Cartesian3.multiplyByScalar(this.position,n,this.position)}Camera.TRANSFORM_2D=new Matrix4(0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,1);Camera.TRANSFORM_2D_INVERSE=Matrix4.inverseTransformation(Camera.TRANSFORM_2D,new Matrix4);Camera.DEFAULT_VIEW_RECTANGLE=Rectangle.fromDegrees(-95,-20,-70,90);Camera.DEFAULT_VIEW_FACTOR=.5;Camera.DEFAULT_OFFSET=new HeadingPitchRange(0,-CesiumMath.PI_OVER_FOUR,0);function updateViewMatrix(e){Matrix4.computeView(e._position,e._direction,e._up,e._right,e._viewMatrix),Matrix4.multiply(e._viewMatrix,e._actualInvTransform,e._viewMatrix),Matrix4.inverseTransformation(e._viewMatrix,e._invViewMatrix)}function updateCameraDeltas(e){if(!defined(e._oldPositionWC))e._oldPositionWC=Cartesian3.clone(e.positionWC,e._oldPositionWC);else{e.positionWCDeltaMagnitudeLastFrame=e.positionWCDeltaMagnitude;const t=Cartesian3.subtract(e.positionWC,e._oldPositionWC,e._oldPositionWC);e.positionWCDeltaMagnitude=Cartesian3.magnitude(t),e._oldPositionWC=Cartesian3.clone(e.positionWC,e._oldPositionWC),e.positionWCDeltaMagnitude>0?(e.timeSinceMoved=0,e._lastMovedTimestamp=getTimestamp()):e.timeSinceMoved=Math.max(getTimestamp()-e._lastMovedTimestamp,0)/1e3}}Camera.prototype.canPreloadFlight=function(){return defined(this._currentFlight)&&this._mode!==SceneMode.SCENE2D};Camera.prototype._updateCameraChanged=function(){const e=this;if(updateCameraDeltas(e),e._changed.numberOfListeners===0)return;const t=e.percentageChanged,n=e.heading;defined(e._changedHeading)||(e._changedHeading=n);let i=Math.abs(e._changedHeading-n)%CesiumMath.TWO_PI;i=i>CesiumMath.PI?CesiumMath.TWO_PI-i:i;const r=i/Math.PI;r>t&&(e._changedHeading=n);const o=e.roll;defined(e._changedRoll)||(e._changedRoll=o);let a=Math.abs(e._changedRoll-o)%CesiumMath.TWO_PI;a=a>CesiumMath.PI?CesiumMath.TWO_PI-a:a;const s=a/Math.PI;if(s>t&&(e._changedRoll=o),(s>t||r>t)&&e._changed.raiseEvent(Math.max(s,r)),e._mode===SceneMode.SCENE2D){if(!defined(e._changedFrustum)){e._changedPosition=Cartesian3.clone(e.position,e._changedPosition),e._changedFrustum=e.frustum.clone();return}const f=e.position,p=e._changedPosition,u=e.frustum,m=e._changedFrustum,g=f.x+u.left,_=f.x+u.right,C=p.x+m.left,A=p.x+m.right,S=f.y+u.bottom,v=f.y+u.top,b=p.y+m.bottom,D=p.y+m.top,I=Math.max(g,C),L=Math.min(_,A),N=Math.max(S,b),y=Math.min(v,D);let x;if(I>=L||N>=v)x=1;else{let T=m;g<C&&_>A&&S<b&&v>D&&(T=u),x=1-(L-I)*(y-N)/((T.right-T.left)*(T.top-T.bottom))}x>t&&(e._changed.raiseEvent(x),e._changedPosition=Cartesian3.clone(e.position,e._changedPosition),e._changedFrustum=e.frustum.clone(e._changedFrustum));return}if(!defined(e._changedDirection)){e._changedPosition=Cartesian3.clone(e.positionWC,e._changedPosition),e._changedDirection=Cartesian3.clone(e.directionWC,e._changedDirection);return}const l=CesiumMath.acosClamped(Cartesian3.dot(e.directionWC,e._changedDirection));let c;defined(e.frustum.fovy)?c=l/(e.frustum.fovy*.5):c=l;const h=Cartesian3.distance(e.positionWC,e._changedPosition)/e.positionCartographic.height;(c>t||h>t)&&(e._changed.raiseEvent(Math.max(c,h)),e._changedPosition=Cartesian3.clone(e.positionWC,e._changedPosition),e._changedDirection=Cartesian3.clone(e.directionWC,e._changedDirection))};function convertTransformForColumbusView(e){Transforms.basisTo2D(e._projection,e._transform,e._actualTransform)}const scratchCartographic$2=new Cartographic,scratchCartesian3Projection=new Cartesian3,scratchCartesian3$1=new Cartesian3,scratchCartesian4Origin=new Cartesian4,scratchCartesian4NewOrigin=new Cartesian4,scratchCartesian4NewXAxis=new Cartesian4,scratchCartesian4NewYAxis=new Cartesian4,scratchCartesian4NewZAxis=new Cartesian4;function convertTransformFor2D(e){const t=e._projection,n=t.ellipsoid,i=Matrix4.getColumn(e._transform,3,scratchCartesian4Origin),r=n.cartesianToCartographic(i,scratchCartographic$2),o=t.project(r,scratchCartesian3Projection),a=scratchCartesian4NewOrigin;a.x=o.z,a.y=o.x,a.z=o.y,a.w=1;const s=Cartesian4.clone(Cartesian4.UNIT_X,scratchCartesian4NewZAxis),l=Cartesian4.add(Matrix4.getColumn(e._transform,0,scratchCartesian3$1),i,scratchCartesian3$1);n.cartesianToCartographic(l,r),t.project(r,o);const c=scratchCartesian4NewXAxis;c.x=o.z,c.y=o.x,c.z=o.y,c.w=0,Cartesian3.subtract(c,a,c),c.x=0;const d=scratchCartesian4NewYAxis;if(Cartesian3.magnitudeSquared(c)>CesiumMath.EPSILON10)Cartesian3.cross(s,c,d);else{const h=Cartesian4.add(Matrix4.getColumn(e._transform,1,scratchCartesian3$1),i,scratchCartesian3$1);n.cartesianToCartographic(h,r),t.project(r,o),d.x=o.z,d.y=o.x,d.z=o.y,d.w=0,Cartesian3.subtract(d,a,d),d.x=0,Cartesian3.magnitudeSquared(d)<CesiumMath.EPSILON10&&(Cartesian4.clone(Cartesian4.UNIT_Y,c),Cartesian4.clone(Cartesian4.UNIT_Z,d))}Cartesian3.cross(d,s,c),Cartesian3.normalize(c,c),Cartesian3.cross(s,c,d),Cartesian3.normalize(d,d),Matrix4.setColumn(e._actualTransform,0,c,e._actualTransform),Matrix4.setColumn(e._actualTransform,1,d,e._actualTransform),Matrix4.setColumn(e._actualTransform,2,s,e._actualTransform),Matrix4.setColumn(e._actualTransform,3,a,e._actualTransform)}const scratchCartesian$1=new Cartesian3;function updateMembers(e){const t=e._mode;let n=!1,i=0;t===SceneMode.SCENE2D&&(i=e.frustum.right-e.frustum.left,n=i!==e._positionCartographic.height);let r=e._position;const o=!Cartesian3.equals(r,e.position)||n;o&&(r=Cartesian3.clone(e.position,e._position));let a=e._direction;const s=!Cartesian3.equals(a,e.direction);s&&(Cartesian3.normalize(e.direction,e.direction),a=Cartesian3.clone(e.direction,e._direction));let l=e._up;const c=!Cartesian3.equals(l,e.up);c&&(Cartesian3.normalize(e.up,e.up),l=Cartesian3.clone(e.up,e._up));let d=e._right;const h=!Cartesian3.equals(d,e.right);h&&(Cartesian3.normalize(e.right,e.right),d=Cartesian3.clone(e.right,e._right));const f=e._transformChanged||e._modeChanged;e._transformChanged=!1,f&&(Matrix4.inverseTransformation(e._transform,e._invTransform),e._mode===SceneMode.COLUMBUS_VIEW||e._mode===SceneMode.SCENE2D?Matrix4.equals(Matrix4.IDENTITY,e._transform)?Matrix4.clone(Camera.TRANSFORM_2D,e._actualTransform):e._mode===SceneMode.COLUMBUS_VIEW?convertTransformForColumbusView(e):convertTransformFor2D(e):Matrix4.clone(e._transform,e._actualTransform),Matrix4.inverseTransformation(e._actualTransform,e._actualInvTransform),e._modeChanged=!1);const p=e._actualTransform;if(o||f)if(e._positionWC=Matrix4.multiplyByPoint(p,r,e._positionWC),t===SceneMode.SCENE3D||t===SceneMode.MORPHING)e._positionCartographic=e._projection.ellipsoid.cartesianToCartographic(e._positionWC,e._positionCartographic);else{const u=scratchCartesian$1;u.x=e._positionWC.y,u.y=e._positionWC.z,u.z=e._positionWC.x,t===SceneMode.SCENE2D&&(u.z=i),e._projection.unproject(u,e._positionCartographic)}if(s||c||h){const u=Cartesian3.dot(a,Cartesian3.cross(l,d,scratchCartesian$1));if(Math.abs(1-u)>CesiumMath.EPSILON2){const m=1/Cartesian3.magnitudeSquared(l),g=Cartesian3.dot(l,a)*m,_=Cartesian3.multiplyByScalar(a,g,scratchCartesian$1);l=Cartesian3.normalize(Cartesian3.subtract(l,_,e._up),e._up),Cartesian3.clone(l,e.up),d=Cartesian3.cross(a,l,e._right),Cartesian3.clone(d,e.right)}}(s||f)&&(e._directionWC=Matrix4.multiplyByPointAsVector(p,a,e._directionWC),Cartesian3.normalize(e._directionWC,e._directionWC)),(c||f)&&(e._upWC=Matrix4.multiplyByPointAsVector(p,l,e._upWC),Cartesian3.normalize(e._upWC,e._upWC)),(h||f)&&(e._rightWC=Matrix4.multiplyByPointAsVector(p,d,e._rightWC),Cartesian3.normalize(e._rightWC,e._rightWC)),(o||s||c||h||f)&&updateViewMatrix(e)}function getHeading(e,t){let n;return CesiumMath.equalsEpsilon(Math.abs(e.z),1,CesiumMath.EPSILON3)?n=Math.atan2(t.y,t.x)-CesiumMath.PI_OVER_TWO:n=Math.atan2(e.y,e.x)-CesiumMath.PI_OVER_TWO,CesiumMath.TWO_PI-CesiumMath.zeroToTwoPi(n)}function getPitch(e){return CesiumMath.PI_OVER_TWO-CesiumMath.acosClamped(e.z)}function getRoll(e,t,n){let i=0;return CesiumMath.equalsEpsilon(Math.abs(e.z),1,CesiumMath.EPSILON3)||(i=Math.atan2(-n.z,t.z),i=CesiumMath.zeroToTwoPi(i+CesiumMath.TWO_PI)),i}const scratchHPRMatrix1=new Matrix4,scratchHPRMatrix2=new Matrix4;Object.defineProperties(Camera.prototype,{transform:{get:function(){return this._transform}},inverseTransform:{get:function(){return updateMembers(this),this._invTransform}},viewMatrix:{get:function(){return updateMembers(this),this._viewMatrix}},inverseViewMatrix:{get:function(){return updateMembers(this),this._invViewMatrix}},positionCartographic:{get:function(){return updateMembers(this),this._positionCartographic}},positionWC:{get:function(){return updateMembers(this),this._positionWC}},directionWC:{get:function(){return updateMembers(this),this._directionWC}},upWC:{get:function(){return updateMembers(this),this._upWC}},rightWC:{get:function(){return updateMembers(this),this._rightWC}},heading:{get:function(){if(this._mode!==SceneMode.MORPHING){const e=this._projection.ellipsoid,t=Matrix4.clone(this._transform,scratchHPRMatrix1),n=Transforms.eastNorthUpToFixedFrame(this.positionWC,e,scratchHPRMatrix2);this._setTransform(n);const i=getHeading(this.direction,this.up);return this._setTransform(t),i}}},pitch:{get:function(){if(this._mode!==SceneMode.MORPHING){const e=this._projection.ellipsoid,t=Matrix4.clone(this._transform,scratchHPRMatrix1),n=Transforms.eastNorthUpToFixedFrame(this.positionWC,e,scratchHPRMatrix2);this._setTransform(n);const i=getPitch(this.direction);return this._setTransform(t),i}}},roll:{get:function(){if(this._mode!==SceneMode.MORPHING){const e=this._projection.ellipsoid,t=Matrix4.clone(this._transform,scratchHPRMatrix1),n=Transforms.eastNorthUpToFixedFrame(this.positionWC,e,scratchHPRMatrix2);this._setTransform(n);const i=getRoll(this.direction,this.up,this.right);return this._setTransform(t),i}}},moveStart:{get:function(){return this._moveStart}},moveEnd:{get:function(){return this._moveEnd}},changed:{get:function(){return this._changed}}});Camera.prototype.update=function(e){if(!defined(e))throw new DeveloperError("mode is required.");if(e===SceneMode.SCENE2D&&!(this.frustum instanceof OrthographicOffCenterFrustum))throw new DeveloperError("An OrthographicOffCenterFrustum is required in 2D.");if((e===SceneMode.SCENE3D||e===SceneMode.COLUMBUS_VIEW)&&!(this.frustum instanceof PerspectiveFrustum)&&!(this.frustum instanceof OrthographicFrustum))throw new DeveloperError("A PerspectiveFrustum or OrthographicFrustum is required in 3D and Columbus view");let t=!1;if(e!==this._mode&&(this._mode=e,this._modeChanged=e!==SceneMode.MORPHING,t=this._mode===SceneMode.SCENE2D),t){const n=this._max2Dfrustum=this.frustum.clone();if(!(n instanceof OrthographicOffCenterFrustum))throw new DeveloperError("The camera frustum is expected to be orthographic for 2D camera control.");const i=2,r=n.top/n.right;n.right=this._maxCoord.x*i,n.left=-n.right,n.top=r*n.right,n.bottom=-n.top}this._mode===SceneMode.SCENE2D&&clampMove2D(this,this.position)};const setTransformPosition=new Cartesian3,setTransformUp=new Cartesian3,setTransformDirection=new Cartesian3;Camera.prototype._setTransform=function(e){const t=Cartesian3.clone(this.positionWC,setTransformPosition),n=Cartesian3.clone(this.upWC,setTransformUp),i=Cartesian3.clone(this.directionWC,setTransformDirection);Matrix4.clone(e,this._transform),this._transformChanged=!0,updateMembers(this);const r=this._actualInvTransform;Matrix4.multiplyByPoint(r,t,this.position),Matrix4.multiplyByPointAsVector(r,i,this.direction),Matrix4.multiplyByPointAsVector(r,n,this.up),Cartesian3.cross(this.direction,this.up,this.right),updateMembers(this)};const scratchAdjustOrthographicFrustumMousePosition=new Cartesian2,scratchPickRay$1=new Ray,scratchRayIntersection$1=new Cartesian3,scratchDepthIntersection$1=new Cartesian3;function calculateOrthographicFrustumWidth(e){if(!Matrix4.equals(Matrix4.IDENTITY,e.transform))return Cartesian3.magnitude(e.position);const t=e._scene,n=t.globe,i=scratchAdjustOrthographicFrustumMousePosition;i.x=t.drawingBufferWidth/2,i.y=t.drawingBufferHeight/2;let r;if(defined(n)){const s=e.getPickRay(i,scratchPickRay$1);r=n.pickWorldCoordinates(s,t,!0,scratchRayIntersection$1)}let o;t.pickPositionSupported&&(o=t.pickPositionWorldCoordinates(i,scratchDepthIntersection$1));let a;if(defined(r)||defined(o)){const s=defined(o)?Cartesian3.distance(o,e.positionWC):Number.POSITIVE_INFINITY,l=defined(r)?Cartesian3.distance(r,e.positionWC):Number.POSITIVE_INFINITY;a=Math.min(s,l)}else a=Math.max(e.positionCartographic.height,0);return a}Camera.prototype._adjustOrthographicFrustum=function(e){this.frustum instanceof OrthographicFrustum&&(!e&&this._positionCartographic.height<15e4||(this.frustum.width=calculateOrthographicFrustumWidth(this)))};const scratchSetViewCartesian=new Cartesian3,scratchSetViewTransform1=new Matrix4,scratchSetViewTransform2=new Matrix4,scratchSetViewQuaternion=new Quaternion,scratchSetViewMatrix3=new Matrix3,scratchSetViewCartographic=new Cartographic;function setView3D(e,t,n){if(isNaN(t.x)||isNaN(t.y)||isNaN(t.z))throw new DeveloperError("position has a NaN component");const i=Matrix4.clone(e.transform,scratchSetViewTransform1),r=Transforms.eastNorthUpToFixedFrame(t,e._projection.ellipsoid,scratchSetViewTransform2);e._setTransform(r),Cartesian3.clone(Cartesian3.ZERO,e.position),n.heading=n.heading-CesiumMath.PI_OVER_TWO;const o=Quaternion.fromHeadingPitchRoll(n,scratchSetViewQuaternion),a=Matrix3.fromQuaternion(o,scratchSetViewMatrix3);Matrix3.getColumn(a,0,e.direction),Matrix3.getColumn(a,2,e.up),Cartesian3.cross(e.direction,e.up,e.right),e._setTransform(i),e._adjustOrthographicFrustum(!0)}function setViewCV(e,t,n,i){const r=Matrix4.clone(e.transform,scratchSetViewTransform1);if(e._setTransform(Matrix4.IDENTITY),!Cartesian3.equals(t,e.positionWC)){if(i){const s=e._projection,l=s.ellipsoid.cartesianToCartographic(t,scratchSetViewCartographic);t=s.project(l,scratchSetViewCartesian)}Cartesian3.clone(t,e.position)}n.heading=n.heading-CesiumMath.PI_OVER_TWO;const o=Quaternion.fromHeadingPitchRoll(n,scratchSetViewQuaternion),a=Matrix3.fromQuaternion(o,scratchSetViewMatrix3);Matrix3.getColumn(a,0,e.direction),Matrix3.getColumn(a,2,e.up),Cartesian3.cross(e.direction,e.up,e.right),e._setTransform(r),e._adjustOrthographicFrustum(!0)}function setView2D(e,t,n,i){const r=Matrix4.clone(e.transform,scratchSetViewTransform1);if(e._setTransform(Matrix4.IDENTITY),!Cartesian3.equals(t,e.positionWC)){if(i){const l=e._projection,c=l.ellipsoid.cartesianToCartographic(t,scratchSetViewCartographic);t=l.project(c,scratchSetViewCartesian)}Cartesian2.clone(t,e.position);const o=-t.z*.5,a=-o,s=e.frustum;if(a>o){const l=s.top/s.right;s.right=a,s.left=o,s.top=s.right*l,s.bottom=-s.top}}if(e._scene.mapMode2D===MapMode2D$1.ROTATE){n.heading=n.heading-CesiumMath.PI_OVER_TWO,n.pitch=-CesiumMath.PI_OVER_TWO,n.roll=0;const o=Quaternion.fromHeadingPitchRoll(n,scratchSetViewQuaternion),a=Matrix3.fromQuaternion(o,scratchSetViewMatrix3);Matrix3.getColumn(a,2,e.up),Cartesian3.cross(e.direction,e.up,e.right)}e._setTransform(r)}const scratchToHPRDirection=new Cartesian3,scratchToHPRUp=new Cartesian3,scratchToHPRRight=new Cartesian3;function directionUpToHeadingPitchRoll(e,t,n,i){const r=Cartesian3.clone(n.direction,scratchToHPRDirection),o=Cartesian3.clone(n.up,scratchToHPRUp);if(e._scene.mode===SceneMode.SCENE3D){const s=e._projection.ellipsoid,l=Transforms.eastNorthUpToFixedFrame(t,s,scratchHPRMatrix1),c=Matrix4.inverseTransformation(l,scratchHPRMatrix2);Matrix4.multiplyByPointAsVector(c,r,r),Matrix4.multiplyByPointAsVector(c,o,o)}const a=Cartesian3.cross(r,o,scratchToHPRRight);return i.heading=getHeading(r,o),i.pitch=getPitch(r),i.roll=getRoll(r,o,a),i}const scratchSetViewOptions={destination:void 0,orientation:{direction:void 0,up:void 0,heading:void 0,pitch:void 0,roll:void 0},convert:void 0,endTransform:void 0},scratchHpr=new HeadingPitchRoll;Camera.prototype.setView=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);let t=defaultValue(e.orientation,defaultValue.EMPTY_OBJECT);const n=this._mode;if(n===SceneMode.MORPHING)return;defined(e.endTransform)&&this._setTransform(e.endTransform);let i=defaultValue(e.convert,!0),r=defaultValue(e.destination,Cartesian3.clone(this.positionWC,scratchSetViewCartesian));if(defined(r)&&defined(r.west)){if(r=this.getRectangleCameraCoordinates(r,scratchSetViewCartesian),isNaN(r.x)||isNaN(r.y))throw new DeveloperError("destination has a NaN component");i=!1}defined(t.direction)&&(t=directionUpToHeadingPitchRoll(this,r,t,scratchSetViewOptions.orientation)),scratchHpr.heading=defaultValue(t.heading,0),scratchHpr.pitch=defaultValue(t.pitch,-CesiumMath.PI_OVER_TWO),scratchHpr.roll=defaultValue(t.roll,0),n===SceneMode.SCENE3D?setView3D(this,r,scratchHpr):n===SceneMode.SCENE2D?setView2D(this,r,scratchHpr,i):setViewCV(this,r,scratchHpr,i)};const pitchScratch=new Cartesian3;Camera.prototype.flyHome=function(e){const t=this._mode;if(t===SceneMode.MORPHING&&this._scene.completeMorph(),t===SceneMode.SCENE2D)this.flyTo({destination:Camera.DEFAULT_VIEW_RECTANGLE,duration:e,endTransform:Matrix4.IDENTITY});else if(t===SceneMode.SCENE3D){const n=this.getRectangleCameraCoordinates(Camera.DEFAULT_VIEW_RECTANGLE);let i=Cartesian3.magnitude(n);i+=i*Camera.DEFAULT_VIEW_FACTOR,Cartesian3.normalize(n,n),Cartesian3.multiplyByScalar(n,i,n),this.flyTo({destination:n,duration:e,endTransform:Matrix4.IDENTITY})}else if(t===SceneMode.COLUMBUS_VIEW){const n=this._projection.ellipsoid.maximumRadius;let i=new Cartesian3(0,-1,1);i=Cartesian3.multiplyByScalar(Cartesian3.normalize(i,i),5*n,i),this.flyTo({destination:i,duration:e,orientation:{heading:0,pitch:-Math.acos(Cartesian3.normalize(i,pitchScratch).z),roll:0},endTransform:Matrix4.IDENTITY,convert:!1})}};Camera.prototype.worldToCameraCoordinates=function(e,t){if(!defined(e))throw new DeveloperError("cartesian is required.");return defined(t)||(t=new Cartesian4),updateMembers(this),Matrix4.multiplyByVector(this._actualInvTransform,e,t)};Camera.prototype.worldToCameraCoordinatesPoint=function(e,t){if(!defined(e))throw new DeveloperError("cartesian is required.");return defined(t)||(t=new Cartesian3),updateMembers(this),Matrix4.multiplyByPoint(this._actualInvTransform,e,t)};Camera.prototype.worldToCameraCoordinatesVector=function(e,t){if(!defined(e))throw new DeveloperError("cartesian is required.");return defined(t)||(t=new Cartesian3),updateMembers(this),Matrix4.multiplyByPointAsVector(this._actualInvTransform,e,t)};Camera.prototype.cameraToWorldCoordinates=function(e,t){if(!defined(e))throw new DeveloperError("cartesian is required.");return defined(t)||(t=new Cartesian4),updateMembers(this),Matrix4.multiplyByVector(this._actualTransform,e,t)};Camera.prototype.cameraToWorldCoordinatesPoint=function(e,t){if(!defined(e))throw new DeveloperError("cartesian is required.");return defined(t)||(t=new Cartesian3),updateMembers(this),Matrix4.multiplyByPoint(this._actualTransform,e,t)};Camera.prototype.cameraToWorldCoordinatesVector=function(e,t){if(!defined(e))throw new DeveloperError("cartesian is required.");return defined(t)||(t=new Cartesian3),updateMembers(this),Matrix4.multiplyByPointAsVector(this._actualTransform,e,t)};function clampMove2D(e,t){const n=e._scene.mapMode2D===MapMode2D$1.ROTATE,i=e._maxCoord.x,r=e._maxCoord.y;let o,a;n?(a=i,o=-a):(a=t.x-i*2,o=t.x+i*2),t.x>i&&(t.x=a),t.x<-i&&(t.x=o),t.y>r&&(t.y=r),t.y<-r&&(t.y=-r)}const moveScratch=new Cartesian3;Camera.prototype.move=function(e,t){if(!defined(e))throw new DeveloperError("direction is required.");const n=this.position;Cartesian3.multiplyByScalar(e,t,moveScratch),Cartesian3.add(n,moveScratch,n),this._mode===SceneMode.SCENE2D&&clampMove2D(this,n),this._adjustOrthographicFrustum(!0)};Camera.prototype.moveForward=function(e){e=defaultValue(e,this.defaultMoveAmount),this._mode===SceneMode.SCENE2D?zoom2D$1(this,e):this.move(this.direction,e)};Camera.prototype.moveBackward=function(e){e=defaultValue(e,this.defaultMoveAmount),this._mode===SceneMode.SCENE2D?zoom2D$1(this,-e):this.move(this.direction,-e)};Camera.prototype.moveUp=function(e){e=defaultValue(e,this.defaultMoveAmount),this.move(this.up,e)};Camera.prototype.moveDown=function(e){e=defaultValue(e,this.defaultMoveAmount),this.move(this.up,-e)};Camera.prototype.moveRight=function(e){e=defaultValue(e,this.defaultMoveAmount),this.move(this.right,e)};Camera.prototype.moveLeft=function(e){e=defaultValue(e,this.defaultMoveAmount),this.move(this.right,-e)};Camera.prototype.lookLeft=function(e){e=defaultValue(e,this.defaultLookAmount),this._mode!==SceneMode.SCENE2D&&this.look(this.up,-e)};Camera.prototype.lookRight=function(e){e=defaultValue(e,this.defaultLookAmount),this._mode!==SceneMode.SCENE2D&&this.look(this.up,e)};Camera.prototype.lookUp=function(e){e=defaultValue(e,this.defaultLookAmount),this._mode!==SceneMode.SCENE2D&&this.look(this.right,-e)};Camera.prototype.lookDown=function(e){e=defaultValue(e,this.defaultLookAmount),this._mode!==SceneMode.SCENE2D&&this.look(this.right,e)};const lookScratchQuaternion=new Quaternion,lookScratchMatrix=new Matrix3;Camera.prototype.look=function(e,t){if(!defined(e))throw new DeveloperError("axis is required.");const n=defaultValue(t,this.defaultLookAmount),i=Quaternion.fromAxisAngle(e,-n,lookScratchQuaternion),r=Matrix3.fromQuaternion(i,lookScratchMatrix),o=this.direction,a=this.up,s=this.right;Matrix3.multiplyByVector(r,o,o),Matrix3.multiplyByVector(r,a,a),Matrix3.multiplyByVector(r,s,s)};Camera.prototype.twistLeft=function(e){e=defaultValue(e,this.defaultLookAmount),this.look(this.direction,e)};Camera.prototype.twistRight=function(e){e=defaultValue(e,this.defaultLookAmount),this.look(this.direction,-e)};const rotateScratchQuaternion=new Quaternion,rotateScratchMatrix=new Matrix3;Camera.prototype.rotate=function(e,t){if(!defined(e))throw new DeveloperError("axis is required.");const n=defaultValue(t,this.defaultRotateAmount),i=Quaternion.fromAxisAngle(e,-n,rotateScratchQuaternion),r=Matrix3.fromQuaternion(i,rotateScratchMatrix);Matrix3.multiplyByVector(r,this.position,this.position),Matrix3.multiplyByVector(r,this.direction,this.direction),Matrix3.multiplyByVector(r,this.up,this.up),Cartesian3.cross(this.direction,this.up,this.right),Cartesian3.cross(this.right,this.direction,this.up),this._adjustOrthographicFrustum(!1)};Camera.prototype.rotateDown=function(e){e=defaultValue(e,this.defaultRotateAmount),rotateVertical(this,e)};Camera.prototype.rotateUp=function(e){e=defaultValue(e,this.defaultRotateAmount),rotateVertical(this,-e)};const rotateVertScratchP=new Cartesian3,rotateVertScratchA=new Cartesian3,rotateVertScratchTan=new Cartesian3,rotateVertScratchNegate=new Cartesian3;function rotateVertical(e,t){const n=e.position;if(defined(e.constrainedAxis)&&!Cartesian3.equalsEpsilon(e.position,Cartesian3.ZERO,CesiumMath.EPSILON2)){const i=Cartesian3.normalize(n,rotateVertScratchP),r=Cartesian3.equalsEpsilon(i,e.constrainedAxis,CesiumMath.EPSILON2),o=Cartesian3.equalsEpsilon(i,Cartesian3.negate(e.constrainedAxis,rotateVertScratchNegate),CesiumMath.EPSILON2);if(!r&&!o){const a=Cartesian3.normalize(e.constrainedAxis,rotateVertScratchA);let s=Cartesian3.dot(i,a),l=CesiumMath.acosClamped(s);t>0&&t>l&&(t=l-CesiumMath.EPSILON4),s=Cartesian3.dot(i,Cartesian3.negate(a,rotateVertScratchNegate)),l=CesiumMath.acosClamped(s),t<0&&-t>l&&(t=-l+CesiumMath.EPSILON4);const c=Cartesian3.cross(a,i,rotateVertScratchTan);e.rotate(c,t)}else(r&&t<0||o&&t>0)&&e.rotate(e.right,t)}else e.rotate(e.right,t)}Camera.prototype.rotateRight=function(e){e=defaultValue(e,this.defaultRotateAmount),rotateHorizontal(this,-e)};Camera.prototype.rotateLeft=function(e){e=defaultValue(e,this.defaultRotateAmount),rotateHorizontal(this,e)};function rotateHorizontal(e,t){defined(e.constrainedAxis)?e.rotate(e.constrainedAxis,t):e.rotate(e.up,t)}function zoom2D$1(e,t){const n=e.frustum;if(!(n instanceof OrthographicOffCenterFrustum)||!defined(n.left)||!defined(n.right)||!defined(n.bottom)||!defined(n.top))throw new DeveloperError("The camera frustum is expected to be orthographic for 2D camera control.");let i;if(t=t*.5,Math.abs(n.top)+Math.abs(n.bottom)>Math.abs(n.left)+Math.abs(n.right)){let r=n.top-t,o=n.bottom+t,a=e._maxCoord.y;e._scene.mapMode2D===MapMode2D$1.ROTATE&&(a*=e.maximumZoomFactor),o>a&&(o=a,r=-a),r<=o&&(r=1,o=-1),i=n.right/n.top,n.top=r,n.bottom=o,n.right=n.top*i,n.left=-n.right}else{let r=n.right-t,o=n.left+t,a=e._maxCoord.x;e._scene.mapMode2D===MapMode2D$1.ROTATE&&(a*=e.maximumZoomFactor),r>a&&(r=a,o=-a),r<=o&&(r=1,o=-1),i=n.top/n.right,n.right=r,n.left=o,n.top=n.right*i,n.bottom=-n.top}}function zoom3D$1(e,t){e.move(e.direction,t)}Camera.prototype.zoomIn=function(e){e=defaultValue(e,this.defaultZoomAmount),this._mode===SceneMode.SCENE2D?zoom2D$1(this,e):zoom3D$1(this,e)};Camera.prototype.zoomOut=function(e){e=defaultValue(e,this.defaultZoomAmount),this._mode===SceneMode.SCENE2D?zoom2D$1(this,-e):zoom3D$1(this,-e)};Camera.prototype.getMagnitude=function(){if(this._mode===SceneMode.SCENE3D)return Cartesian3.magnitude(this.position);if(this._mode===SceneMode.COLUMBUS_VIEW)return Math.abs(this.position.z);if(this._mode===SceneMode.SCENE2D)return Math.max(this.frustum.right-this.frustum.left,this.frustum.top-this.frustum.bottom)};const scratchLookAtMatrix4=new Matrix4;Camera.prototype.lookAt=function(e,t){if(!defined(e))throw new DeveloperError("target is required");if(!defined(t))throw new DeveloperError("offset is required");if(this._mode===SceneMode.MORPHING)throw new DeveloperError("lookAt is not supported while morphing.");const n=this._scene,i=defaultValue(n.ellipsoid,Ellipsoid.default),r=Transforms.eastNorthUpToFixedFrame(e,i,scratchLookAtMatrix4);this.lookAtTransform(r,t)};const scratchLookAtHeadingPitchRangeOffset=new Cartesian3,scratchLookAtHeadingPitchRangeQuaternion1=new Quaternion,scratchLookAtHeadingPitchRangeQuaternion2=new Quaternion,scratchHeadingPitchRangeMatrix3=new Matrix3;function offsetFromHeadingPitchRange(e,t,n){t=CesiumMath.clamp(t,-CesiumMath.PI_OVER_TWO,CesiumMath.PI_OVER_TWO),e=CesiumMath.zeroToTwoPi(e)-CesiumMath.PI_OVER_TWO;const i=Quaternion.fromAxisAngle(Cartesian3.UNIT_Y,-t,scratchLookAtHeadingPitchRangeQuaternion1),r=Quaternion.fromAxisAngle(Cartesian3.UNIT_Z,-e,scratchLookAtHeadingPitchRangeQuaternion2),o=Quaternion.multiply(r,i,r),a=Matrix3.fromQuaternion(o,scratchHeadingPitchRangeMatrix3),s=Cartesian3.clone(Cartesian3.UNIT_X,scratchLookAtHeadingPitchRangeOffset);return Matrix3.multiplyByVector(a,s,s),Cartesian3.negate(s,s),Cartesian3.multiplyByScalar(s,n,s),s}Camera.prototype.lookAtTransform=function(e,t){if(!defined(e))throw new DeveloperError("transform is required");if(this._mode===SceneMode.MORPHING)throw new DeveloperError("lookAtTransform is not supported while morphing.");if(this._setTransform(e),!defined(t))return;let n;if(defined(t.heading)?n=offsetFromHeadingPitchRange(t.heading,t.pitch,t.range):n=t,this._mode===SceneMode.SCENE2D){Cartesian2.clone(Cartesian2.ZERO,this.position),Cartesian3.negate(n,this.up),this.up.z=0,Cartesian3.magnitudeSquared(this.up)<CesiumMath.EPSILON10&&Cartesian3.clone(Cartesian3.UNIT_Y,this.up),Cartesian3.normalize(this.up,this.up),this._setTransform(Matrix4.IDENTITY),Cartesian3.negate(Cartesian3.UNIT_Z,this.direction),Cartesian3.cross(this.direction,this.up,this.right),Cartesian3.normalize(this.right,this.right);const i=this.frustum,r=i.top/i.right;i.right=Cartesian3.magnitude(n)*.5,i.left=-i.right,i.top=r*i.right,i.bottom=-i.top,this._setTransform(e);return}Cartesian3.clone(n,this.position),Cartesian3.negate(this.position,this.direction),Cartesian3.normalize(this.direction,this.direction),Cartesian3.cross(this.direction,Cartesian3.UNIT_Z,this.right),Cartesian3.magnitudeSquared(this.right)<CesiumMath.EPSILON10&&Cartesian3.clone(Cartesian3.UNIT_X,this.right),Cartesian3.normalize(this.right,this.right),Cartesian3.cross(this.right,this.direction,this.up),Cartesian3.normalize(this.up,this.up),this._adjustOrthographicFrustum(!0)};const viewRectangle3DCartographic1=new Cartographic,viewRectangle3DCartographic2=new Cartographic,viewRectangle3DNorthEast=new Cartesian3,viewRectangle3DSouthWest=new Cartesian3,viewRectangle3DNorthWest=new Cartesian3,viewRectangle3DSouthEast=new Cartesian3,viewRectangle3DNorthCenter=new Cartesian3,viewRectangle3DSouthCenter=new Cartesian3,viewRectangle3DCenter=new Cartesian3,viewRectangle3DEquator=new Cartesian3,defaultRF={direction:new Cartesian3,right:new Cartesian3,up:new Cartesian3};let viewRectangle3DEllipsoidGeodesic;function computeD(e,t,n,i){return Math.abs(Cartesian3.dot(t,n))/i-Cartesian3.dot(e,n)}function rectangleCameraPosition3D(e,t,n,i){const r=e._projection.ellipsoid,o=i?e:defaultRF,a=t.north,s=t.south;let l=t.east;const c=t.west;c>l&&(l+=CesiumMath.TWO_PI);const d=(c+l)*.5;let h;if(s<-CesiumMath.PI_OVER_TWO+CesiumMath.RADIANS_PER_DEGREE&&a>CesiumMath.PI_OVER_TWO-CesiumMath.RADIANS_PER_DEGREE)h=0;else{const L=viewRectangle3DCartographic1;L.longitude=d,L.latitude=a,L.height=0;const N=viewRectangle3DCartographic2;N.longitude=d,N.latitude=s,N.height=0;let y=viewRectangle3DEllipsoidGeodesic;(!defined(y)||y.ellipsoid!==r)&&(viewRectangle3DEllipsoidGeodesic=y=new EllipsoidGeodesic(void 0,void 0,r)),y.setEndPoints(L,N),h=y.interpolateUsingFraction(.5,viewRectangle3DCartographic1).latitude}const f=viewRectangle3DCartographic1;f.longitude=d,f.latitude=h,f.height=0;const p=r.cartographicToCartesian(f,viewRectangle3DCenter),u=viewRectangle3DCartographic1;u.longitude=l,u.latitude=a;const m=r.cartographicToCartesian(u,viewRectangle3DNorthEast);u.longitude=c;const g=r.cartographicToCartesian(u,viewRectangle3DNorthWest);u.longitude=d;const _=r.cartographicToCartesian(u,viewRectangle3DNorthCenter);u.latitude=s;const C=r.cartographicToCartesian(u,viewRectangle3DSouthCenter);u.longitude=l;const A=r.cartographicToCartesian(u,viewRectangle3DSouthEast);u.longitude=c;const S=r.cartographicToCartesian(u,viewRectangle3DSouthWest);Cartesian3.subtract(g,p,g),Cartesian3.subtract(A,p,A),Cartesian3.subtract(m,p,m),Cartesian3.subtract(S,p,S),Cartesian3.subtract(_,p,_),Cartesian3.subtract(C,p,C);const v=r.geodeticSurfaceNormal(p,o.direction);Cartesian3.negate(v,v);const b=Cartesian3.cross(v,Cartesian3.UNIT_Z,o.right);Cartesian3.normalize(b,b);const D=Cartesian3.cross(b,v,o.up);let I;if(e.frustum instanceof OrthographicFrustum){const L=Math.max(Cartesian3.distance(m,g),Cartesian3.distance(A,S)),N=Math.max(Cartesian3.distance(m,A),Cartesian3.distance(g,S));let y,x;const T=e.frustum._offCenterFrustum,E=T.right/T.top,P=N*E;L>P?(y=L,x=y/E):(x=N,y=P),I=Math.max(y,x)}else{const L=Math.tan(e.frustum.fovy*.5),N=e.frustum.aspectRatio*L;if(I=Math.max(computeD(v,D,g,L),computeD(v,D,A,L),computeD(v,D,m,L),computeD(v,D,S,L),computeD(v,D,_,L),computeD(v,D,C,L),computeD(v,b,g,N),computeD(v,b,A,N),computeD(v,b,m,N),computeD(v,b,S,N),computeD(v,b,_,N),computeD(v,b,C,N)),s<0&&a>0){const y=viewRectangle3DCartographic1;y.longitude=c,y.latitude=0,y.height=0;let x=r.cartographicToCartesian(y,viewRectangle3DEquator);Cartesian3.subtract(x,p,x),I=Math.max(I,computeD(v,D,x,L),computeD(v,b,x,N)),y.longitude=l,x=r.cartographicToCartesian(y,viewRectangle3DEquator),Cartesian3.subtract(x,p,x),I=Math.max(I,computeD(v,D,x,L),computeD(v,b,x,N))}}return Cartesian3.add(p,Cartesian3.multiplyByScalar(v,-I,viewRectangle3DEquator),n)}const viewRectangleCVCartographic=new Cartographic,viewRectangleCVNorthEast=new Cartesian3,viewRectangleCVSouthWest=new Cartesian3;function rectangleCameraPositionColumbusView(e,t,n){const i=e._projection;t.west>t.east&&(t=Rectangle.MAX_VALUE);const r=e._actualTransform,o=e._actualInvTransform,a=viewRectangleCVCartographic;a.longitude=t.east,a.latitude=t.north;const s=i.project(a,viewRectangleCVNorthEast);Matrix4.multiplyByPoint(r,s,s),Matrix4.multiplyByPoint(o,s,s),a.longitude=t.west,a.latitude=t.south;const l=i.project(a,viewRectangleCVSouthWest);if(Matrix4.multiplyByPoint(r,l,l),Matrix4.multiplyByPoint(o,l,l),n.x=(s.x-l.x)*.5+l.x,n.y=(s.y-l.y)*.5+l.y,defined(e.frustum.fovy)){const c=Math.tan(e.frustum.fovy*.5),d=e.frustum.aspectRatio*c;n.z=Math.max((s.x-l.x)/d,(s.y-l.y)/c)*.5}else{const c=s.x-l.x,d=s.y-l.y;n.z=Math.max(c,d)}return n}const viewRectangle2DCartographic=new Cartographic,viewRectangle2DNorthEast=new Cartesian3,viewRectangle2DSouthWest=new Cartesian3;function rectangleCameraPosition2D(e,t,n){const i=e._projection;let r=t.east;t.west>t.east&&(e._scene.mapMode2D===MapMode2D$1.INFINITE_SCROLL?r+=CesiumMath.TWO_PI:(t=Rectangle.MAX_VALUE,r=t.east));let o=viewRectangle2DCartographic;o.longitude=r,o.latitude=t.north;const a=i.project(o,viewRectangle2DNorthEast);o.longitude=t.west,o.latitude=t.south;const s=i.project(o,viewRectangle2DSouthWest),l=Math.abs(a.x-s.x)*.5;let c=Math.abs(a.y-s.y)*.5,d,h;const f=e.frustum.right/e.frustum.top,p=c*f;return l>p?(d=l,h=d/f):(h=c,d=p),c=Math.max(2*d,2*h),n.x=(a.x-s.x)*.5+s.x,n.y=(a.y-s.y)*.5+s.y,o=i.unproject(n,o),o.height=c,n=i.project(o,n),n}Camera.prototype.getRectangleCameraCoordinates=function(e,t){if(!defined(e))throw new DeveloperError("rectangle is required");const n=this._mode;if(defined(t)||(t=new Cartesian3),n===SceneMode.SCENE3D)return rectangleCameraPosition3D(this,e,t);if(n===SceneMode.COLUMBUS_VIEW)return rectangleCameraPositionColumbusView(this,e,t);if(n===SceneMode.SCENE2D)return rectangleCameraPosition2D(this,e,t)};const pickEllipsoid3DRay=new Ray;function pickEllipsoid3D(e,t,n,i){n=defaultValue(n,Ellipsoid.default);const r=e.getPickRay(t,pickEllipsoid3DRay),o=IntersectionTests.rayEllipsoid(r,n);if(!o)return;const a=o.start>0?o.start:o.stop;return Ray.getPoint(r,a,i)}const pickEllipsoid2DRay=new Ray;function pickMap2D(e,t,n,i){let o=e.getPickRay(t,pickEllipsoid2DRay).origin;o=Cartesian3.fromElements(o.y,o.z,0,o);const a=n.unproject(o);if(!(a.latitude<-CesiumMath.PI_OVER_TWO||a.latitude>CesiumMath.PI_OVER_TWO))return n.ellipsoid.cartographicToCartesian(a,i)}const pickEllipsoidCVRay=new Ray;function pickMapColumbusView(e,t,n,i){const r=e.getPickRay(t,pickEllipsoidCVRay),o=-r.origin.x/r.direction.x;Ray.getPoint(r,o,i);const a=n.unproject(new Cartesian3(i.y,i.z,0));if(!(a.latitude<-CesiumMath.PI_OVER_TWO||a.latitude>CesiumMath.PI_OVER_TWO||a.longitude<-Math.PI||a.longitude>Math.PI))return n.ellipsoid.cartographicToCartesian(a,i)}Camera.prototype.pickEllipsoid=function(e,t,n){if(!defined(e))throw new DeveloperError("windowPosition is required.");const i=this._scene.canvas;if(!(i.clientWidth===0||i.clientHeight===0)){if(defined(n)||(n=new Cartesian3),t=defaultValue(t,Ellipsoid.default),this._mode===SceneMode.SCENE3D)n=pickEllipsoid3D(this,e,t,n);else if(this._mode===SceneMode.SCENE2D)n=pickMap2D(this,e,this._projection,n);else if(this._mode===SceneMode.COLUMBUS_VIEW)n=pickMapColumbusView(this,e,this._projection,n);else return;return n}};const pickPerspCenter=new Cartesian3,pickPerspXDir=new Cartesian3,pickPerspYDir=new Cartesian3;function getPickRayPerspective(e,t,n){const i=e._scene.canvas,r=i.clientWidth,o=i.clientHeight,a=Math.tan(e.frustum.fovy*.5),s=e.frustum.aspectRatio*a,l=e.frustum.near,c=2/r*t.x-1,d=2/o*(o-t.y)-1,h=e.positionWC;Cartesian3.clone(h,n.origin);const f=Cartesian3.multiplyByScalar(e.directionWC,l,pickPerspCenter);Cartesian3.add(h,f,f);const p=Cartesian3.multiplyByScalar(e.rightWC,c*l*s,pickPerspXDir),u=Cartesian3.multiplyByScalar(e.upWC,d*l*a,pickPerspYDir),m=Cartesian3.add(f,p,n.direction);return Cartesian3.add(m,u,m),Cartesian3.subtract(m,h,m),Cartesian3.normalize(m,m),n}const scratchDirection=new Cartesian3;function getPickRayOrthographic(e,t,n){const i=e._scene.canvas,r=i.clientWidth,o=i.clientHeight;let a=e.frustum;const s=a.offCenterFrustum;defined(s)&&(a=s);let l=2/r*t.x-1;l*=(a.right-a.left)*.5;let c=2/o*(o-t.y)-1;c*=(a.top-a.bottom)*.5;const d=n.origin;return Cartesian3.clone(e.position,d),Cartesian3.multiplyByScalar(e.right,l,scratchDirection),Cartesian3.add(scratchDirection,d,d),Cartesian3.multiplyByScalar(e.up,c,scratchDirection),Cartesian3.add(scratchDirection,d,d),Cartesian3.clone(e.directionWC,n.direction),(e._mode===SceneMode.COLUMBUS_VIEW||e._mode===SceneMode.SCENE2D)&&Cartesian3.fromElements(n.origin.z,n.origin.x,n.origin.y,n.origin),n}Camera.prototype.getPickRay=function(e,t){if(!defined(e))throw new DeveloperError("windowPosition is required.");defined(t)||(t=new Ray);const n=this._scene.canvas;if(n.clientWidth<=0||n.clientHeight<=0)return;const i=this.frustum;return defined(i.aspectRatio)&&defined(i.fov)&&defined(i.near)?getPickRayPerspective(this,e,t):getPickRayOrthographic(this,e,t)};const scratchToCenter=new Cartesian3,scratchProj=new Cartesian3;Camera.prototype.distanceToBoundingSphere=function(e){if(!defined(e))throw new DeveloperError("boundingSphere is required.");const t=Cartesian3.subtract(this.positionWC,e.center,scratchToCenter),n=Cartesian3.multiplyByScalar(this.directionWC,Cartesian3.dot(t,this.directionWC),scratchProj);return Math.max(0,Cartesian3.magnitude(n)-e.radius)};const scratchPixelSize=new Cartesian2;Camera.prototype.getPixelSize=function(e,t,n){if(!defined(e))throw new DeveloperError("boundingSphere is required.");if(!defined(t))throw new DeveloperError("drawingBufferWidth is required.");if(!defined(n))throw new DeveloperError("drawingBufferHeight is required.");const i=this.distanceToBoundingSphere(e),r=this.frustum.getPixelDimensions(t,n,i,this._scene.pixelRatio,scratchPixelSize);return Math.max(r.x,r.y)};function createAnimationTemplateCV(e,t,n,i,r,o){const a=Cartesian3.clone(t);n.y>i?a.y-=n.y-i:n.y<-i&&(a.y+=-i-n.y),n.z>r?a.z-=n.z-r:n.z<-r&&(a.z+=-r-n.z);function s(l){const c=Cartesian3.lerp(t,a,l.time,new Cartesian3);e.worldToCameraCoordinatesPoint(c,e.position)}return{easingFunction:EasingFunction$1.EXPONENTIAL_OUT,startObject:{time:0},stopObject:{time:1},duration:o,update:s}}const normalScratch=new Cartesian3,centerScratch=new Cartesian3,posScratch=new Cartesian3,scratchCartesian3Subtract=new Cartesian3;function createAnimationCV(e,t){let n=e.position;const i=e.direction,r=e.worldToCameraCoordinatesVector(Cartesian3.UNIT_X,normalScratch),o=-Cartesian3.dot(r,n)/Cartesian3.dot(r,i),a=Cartesian3.add(n,Cartesian3.multiplyByScalar(i,o,centerScratch),centerScratch);e.cameraToWorldCoordinatesPoint(a,a),n=e.cameraToWorldCoordinatesPoint(e.position,posScratch);const s=Math.tan(e.frustum.fovy*.5),l=e.frustum.aspectRatio*s,c=Cartesian3.magnitude(Cartesian3.subtract(n,a,scratchCartesian3Subtract)),d=l*c,h=s*c,f=e._maxCoord.x,p=e._maxCoord.y,u=Math.max(d-f,f),m=Math.max(h-p,p);if(n.z<-u||n.z>u||n.y<-m||n.y>m){const g=a.y<-u||a.y>u,_=a.z<-m||a.z>m;if(g||_)return createAnimationTemplateCV(e,n,a,u,m,t)}}Camera.prototype.createCorrectPositionTween=function(e){if(!defined(e))throw new DeveloperError("duration is required.");if(this._mode===SceneMode.COLUMBUS_VIEW)return createAnimationCV(this,e)};const scratchFlyToDestination=new Cartesian3,newOptions={destination:void 0,heading:void 0,pitch:void 0,roll:void 0,duration:void 0,complete:void 0,cancel:void 0,endTransform:void 0,maximumHeight:void 0,easingFunction:void 0};Camera.prototype.cancelFlight=function(){defined(this._currentFlight)&&(this._currentFlight.cancelTween(),this._currentFlight=void 0)};Camera.prototype.completeFlight=function(){if(defined(this._currentFlight)){this._currentFlight.cancelTween();const e={destination:void 0,orientation:{heading:void 0,pitch:void 0,roll:void 0}};e.destination=newOptions.destination,e.orientation.heading=newOptions.heading,e.orientation.pitch=newOptions.pitch,e.orientation.roll=newOptions.roll,this.setView(e),defined(this._currentFlight.complete)&&this._currentFlight.complete(),this._currentFlight=void 0}};Camera.prototype.flyTo=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);let t=e.destination;if(!defined(t))throw new DeveloperError("destination is required.");if(this._mode===SceneMode.MORPHING)return;this.cancelFlight();const i=t instanceof Rectangle;i&&(t=this.getRectangleCameraCoordinates(t,scratchFlyToDestination));let r=defaultValue(e.orientation,defaultValue.EMPTY_OBJECT);if(defined(r.direction)&&(r=directionUpToHeadingPitchRoll(this,t,r,scratchSetViewOptions.orientation)),defined(e.duration)&&e.duration<=0){const d=scratchSetViewOptions;d.destination=e.destination,d.orientation.heading=r.heading,d.orientation.pitch=r.pitch,d.orientation.roll=r.roll,d.convert=e.convert,d.endTransform=e.endTransform,this.setView(d),typeof e.complete=="function"&&e.complete();return}const o=this;let a;newOptions.destination=t,newOptions.heading=r.heading,newOptions.pitch=r.pitch,newOptions.roll=r.roll,newOptions.duration=e.duration,newOptions.complete=function(){a===o._currentFlight&&(o._currentFlight=void 0),defined(e.complete)&&e.complete()},newOptions.cancel=e.cancel,newOptions.endTransform=e.endTransform,newOptions.convert=i?!1:e.convert,newOptions.maximumHeight=e.maximumHeight,newOptions.pitchAdjustHeight=e.pitchAdjustHeight,newOptions.flyOverLongitude=e.flyOverLongitude,newOptions.flyOverLongitudeWeight=e.flyOverLongitudeWeight,newOptions.easingFunction=e.easingFunction;const s=this._scene,l=CameraFlightPath$1.createTween(s,newOptions);if(l.duration===0){typeof l.complete=="function"&&l.complete();return}a=s.tweens.add(l),this._currentFlight=a;let c=this._scene.preloadFlightCamera;this._mode!==SceneMode.SCENE2D&&(defined(c)||(c=Camera.clone(this)),c.setView({destination:t,orientation:r}),this._scene.preloadFlightCullingVolume=c.frustum.computeCullingVolume(c.positionWC,c.directionWC,c.upWC))};function distanceToBoundingSphere3D(e,t){const n=e.frustum,i=Math.tan(n.fovy*.5),r=n.aspectRatio*i;return Math.max(t/r,t/i)}function distanceToBoundingSphere2D(e,t){let n=e.frustum;const i=n.offCenterFrustum;defined(i)&&(n=i);let r,o;const a=n.right/n.top,s=t*a;return t>s?(r=t,o=r/a):(o=t,r=s),Math.max(r,o)*1.5}const MINIMUM_ZOOM=100;function adjustBoundingSphereOffset(e,t,n){n=HeadingPitchRange.clone(defined(n)?n:Camera.DEFAULT_OFFSET);const i=e._scene.screenSpaceCameraController.minimumZoomDistance,r=e._scene.screenSpaceCameraController.maximumZoomDistance,o=n.range;if(!defined(o)||o===0){const a=t.radius;a===0?n.range=MINIMUM_ZOOM:e.frustum instanceof OrthographicFrustum||e._mode===SceneMode.SCENE2D?n.range=distanceToBoundingSphere2D(e,a):n.range=distanceToBoundingSphere3D(e,a),n.range=CesiumMath.clamp(n.range,i,r)}return n}Camera.prototype.viewBoundingSphere=function(e,t){if(!defined(e))throw new DeveloperError("boundingSphere is required.");if(this._mode===SceneMode.MORPHING)throw new DeveloperError("viewBoundingSphere is not supported while morphing.");t=adjustBoundingSphereOffset(this,e,t),this.lookAt(e.center,t)};const scratchflyToBoundingSphereTransform=new Matrix4,scratchflyToBoundingSphereDestination=new Cartesian3,scratchflyToBoundingSphereDirection=new Cartesian3,scratchflyToBoundingSphereUp=new Cartesian3,scratchflyToBoundingSphereRight=new Cartesian3,scratchFlyToBoundingSphereCart4=new Cartesian4,scratchFlyToBoundingSphereQuaternion=new Quaternion,scratchFlyToBoundingSphereMatrix3=new Matrix3;Camera.prototype.flyToBoundingSphere=function(e,t){if(!defined(e))throw new DeveloperError("boundingSphere is required.");t=defaultValue(t,defaultValue.EMPTY_OBJECT);const n=this._mode===SceneMode.SCENE2D||this._mode===SceneMode.COLUMBUS_VIEW;this._setTransform(Matrix4.IDENTITY);const i=adjustBoundingSphereOffset(this,e,t.offset);let r;n?r=Cartesian3.multiplyByScalar(Cartesian3.UNIT_Z,i.range,scratchflyToBoundingSphereDestination):r=offsetFromHeadingPitchRange(i.heading,i.pitch,i.range);const o=this._scene,a=defaultValue(o.ellipsoid,Ellipsoid.default),s=Transforms.eastNorthUpToFixedFrame(e.center,a,scratchflyToBoundingSphereTransform);Matrix4.multiplyByPoint(s,r,r);let l,c;if(!n){if(l=Cartesian3.subtract(e.center,r,scratchflyToBoundingSphereDirection),Cartesian3.normalize(l,l),c=Matrix4.multiplyByPointAsVector(s,Cartesian3.UNIT_Z,scratchflyToBoundingSphereUp),1-Math.abs(Cartesian3.dot(l,c))<CesiumMath.EPSILON6){const h=Quaternion.fromAxisAngle(l,i.heading,scratchFlyToBoundingSphereQuaternion),f=Matrix3.fromQuaternion(h,scratchFlyToBoundingSphereMatrix3);Cartesian3.fromCartesian4(Matrix4.getColumn(s,1,scratchFlyToBoundingSphereCart4),c),Matrix3.multiplyByVector(f,c,c)}const d=Cartesian3.cross(l,c,scratchflyToBoundingSphereRight);Cartesian3.cross(d,l,c),Cartesian3.normalize(c,c)}this.flyTo({destination:r,orientation:{direction:l,up:c},duration:t.duration,complete:t.complete,cancel:t.cancel,endTransform:t.endTransform,maximumHeight:t.maximumHeight,easingFunction:t.easingFunction,flyOverLongitude:t.flyOverLongitude,flyOverLongitudeWeight:t.flyOverLongitudeWeight,pitchAdjustHeight:t.pitchAdjustHeight})};const scratchCartesian3_1=new Cartesian3,scratchCartesian3_2=new Cartesian3,scratchCartesian3_3=new Cartesian3,scratchCartesian3_4=new Cartesian3,horizonPoints=[new Cartesian3,new Cartesian3,new Cartesian3,new Cartesian3];function computeHorizonQuad(e,t){const n=t.radii,i=e.positionWC,r=Cartesian3.multiplyComponents(t.oneOverRadii,i,scratchCartesian3_1),o=Cartesian3.magnitude(r),a=Cartesian3.normalize(r,scratchCartesian3_2);let s,l;Cartesian3.equalsEpsilon(a,Cartesian3.UNIT_Z,CesiumMath.EPSILON10)?(s=new Cartesian3(0,1,0),l=new Cartesian3(0,0,1)):(s=Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z,a,scratchCartesian3_3),scratchCartesian3_3),l=Cartesian3.normalize(Cartesian3.cross(a,s,scratchCartesian3_4),scratchCartesian3_4));const c=Math.sqrt(Cartesian3.magnitudeSquared(r)-1),d=Cartesian3.multiplyByScalar(a,1/o,scratchCartesian3_1),h=c/o,f=Cartesian3.multiplyByScalar(s,h,scratchCartesian3_2),p=Cartesian3.multiplyByScalar(l,h,scratchCartesian3_3),u=Cartesian3.add(d,p,horizonPoints[0]);Cartesian3.subtract(u,f,u),Cartesian3.multiplyComponents(n,u,u);const m=Cartesian3.subtract(d,p,horizonPoints[1]);Cartesian3.subtract(m,f,m),Cartesian3.multiplyComponents(n,m,m);const g=Cartesian3.subtract(d,p,horizonPoints[2]);Cartesian3.add(g,f,g),Cartesian3.multiplyComponents(n,g,g);const _=Cartesian3.add(d,p,horizonPoints[3]);return Cartesian3.add(_,f,_),Cartesian3.multiplyComponents(n,_,_),horizonPoints}const scratchPickCartesian2=new Cartesian2,scratchRectCartesian=new Cartesian3,cartoArray=[new Cartographic,new Cartographic,new Cartographic,new Cartographic];function addToResult(e,t,n,i,r,o){scratchPickCartesian2.x=e,scratchPickCartesian2.y=t;const a=i.pickEllipsoid(scratchPickCartesian2,r,scratchRectCartesian);return defined(a)?(cartoArray[n]=r.cartesianToCartographic(a,cartoArray[n]),1):(cartoArray[n]=r.cartesianToCartographic(o[n],cartoArray[n]),0)}Camera.prototype.computeViewRectangle=function(e,t){e=defaultValue(e,Ellipsoid.default);const n=this.frustum.computeCullingVolume(this.positionWC,this.directionWC,this.upWC),i=new BoundingSphere(Cartesian3.ZERO,e.maximumRadius);if(n.computeVisibility(i)===Intersect.OUTSIDE)return;const o=this._scene.canvas,a=o.clientWidth,s=o.clientHeight;let l=0;const c=computeHorizonQuad(this,e);if(l+=addToResult(0,0,0,this,e,c),l+=addToResult(0,s,1,this,e,c),l+=addToResult(a,s,2,this,e,c),l+=addToResult(a,0,3,this,e,c),l<2)return Rectangle.MAX_VALUE;t=Rectangle.fromCartographicArray(cartoArray,t);let d=0,h=cartoArray[3].longitude;for(let f=0;f<4;++f){const p=cartoArray[f].longitude,u=Math.abs(p-h);u>CesiumMath.PI?d+=CesiumMath.TWO_PI-u:d+=u,h=p}return CesiumMath.equalsEpsilon(Math.abs(d),CesiumMath.TWO_PI,CesiumMath.EPSILON9)&&(t.west=-CesiumMath.PI,t.east=CesiumMath.PI,cartoArray[0].latitude>=0?t.north=CesiumMath.PI_OVER_TWO:t.south=-CesiumMath.PI_OVER_TWO),t};Camera.prototype.switchToPerspectiveFrustum=function(){if(this._mode===SceneMode.SCENE2D||this.frustum instanceof PerspectiveFrustum)return;const e=this._scene;this.frustum=new PerspectiveFrustum,this.frustum.aspectRatio=e.drawingBufferWidth/e.drawingBufferHeight,this.frustum.fov=CesiumMath.toRadians(60)};Camera.prototype.switchToOrthographicFrustum=function(){if(this._mode===SceneMode.SCENE2D||this.frustum instanceof OrthographicFrustum)return;const e=calculateOrthographicFrustumWidth(this),t=this._scene;this.frustum=new OrthographicFrustum,this.frustum.aspectRatio=t.drawingBufferWidth/t.drawingBufferHeight,this.frustum.width=e};Camera.clone=function(e,t){return defined(t)||(t=new Camera(e._scene)),Cartesian3.clone(e.position,t.position),Cartesian3.clone(e.direction,t.direction),Cartesian3.clone(e.up,t.up),Cartesian3.clone(e.right,t.right),Matrix4.clone(e._transform,t.transform),t._transformChanged=!0,t.frustum=e.frustum.clone(),t};function Cesium3DTilePassState(e){Check.typeOf.object("options",e),Check.typeOf.number("options.pass",e.pass),this.pass=e.pass,this.commandList=e.commandList,this.camera=e.camera,this.cullingVolume=e.cullingVolume,this.ready=!1}const mobileWidth=576,lightboxHeight=100,textColor="#ffffff",highlightColor$1="#48b";function CreditDisplayElement(e,t){this.credit=e,this.count=defaultValue(t,1)}function contains(e,t){const n=e.length;for(let i=0;i<n;i++){const r=e[i];if(Credit.equals(r,t))return!0}return!1}function swapCesiumCredit(e){const t=e._previousCesiumCredit,n=e._currentCesiumCredit;Credit.equals(n,t)||(defined(t)&&e._cesiumCreditContainer.removeChild(t.element),defined(n)&&e._cesiumCreditContainer.appendChild(n.element),e._previousCesiumCredit=n)}const delimiterClassName="cesium-credit-delimiter";function createDelimiterElement(e){const t=document.createElement("span");return t.textContent=e,t.className=delimiterClassName,t}function createCreditElement(e,t){if(defined(t)){const n=document.createElement(t);n._creditId=e._creditId,n.appendChild(e),e=n}return e}function displayCredits(e,t,n,i){const r=e.childNodes;let o=-1;t.sort(function(a,s){return s.count-a.count});for(let a=0;a<t.length;++a){const s=t[a].credit;if(defined(s)){if(o=a,defined(n)&&(o*=2,a>0)){const c=o-1;if(r.length<=c)e.appendChild(createDelimiterElement(n));else{const d=r[c];d.className!==delimiterClassName&&e.replaceChild(createDelimiterElement(n),d)}}const l=s.element;if(r.length<=o)e.appendChild(createCreditElement(l,i));else{const c=r[o];c._creditId!==s._id&&e.replaceChild(createCreditElement(l,i),c)}}}for(++o;o<r.length;)e.removeChild(r[o])}function styleLightboxContainer(e){const t=e._lightboxCredits,n=e.viewport.clientWidth,i=e.viewport.clientHeight;n!==e._lastViewportWidth&&(n<mobileWidth?(t.className="cesium-credit-lightbox cesium-credit-lightbox-mobile",t.style.marginTop="0"):(t.className="cesium-credit-lightbox cesium-credit-lightbox-expanded",t.style.marginTop=`${Math.floor((i-t.clientHeight)*.5)}px`),e._lastViewportWidth=n),n>=mobileWidth&&i!==e._lastViewportHeight&&(t.style.marginTop=`${Math.floor((i-t.clientHeight)*.5)}px`,e._lastViewportHeight=i)}function appendCss(e){const t=`
.cesium-credit-lightbox-overlay {
  display: none;
  z-index: 1;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(80, 80, 80, 0.8);
}

.cesium-credit-lightbox {
  background-color: #303336;
  color: ${textColor};
  position: relative;
  min-height: ${lightboxHeight}px;
  margin: auto;
}
.cesium-credit-lightbox > ul > li a,
.cesium-credit-lightbox > ul > li a:visited,
.cesium-credit-wrapper a,
.cesium-credit-wrapper a:visited {
  color: ${textColor};
}
.cesium-credit-lightbox > ul > li a:hover {
  color: ${highlightColor$1};
}
.cesium-credit-lightbox.cesium-credit-lightbox-expanded {
  border: 1px solid #444;
  border-radius: 5px;
  max-width: 370px;
}
.cesium-credit-lightbox.cesium-credit-lightbox-mobile {
  height: 100%;
  width: 100%;
}
.cesium-credit-lightbox-title {
  padding: 20px 20px 0 20px;
}
.cesium-credit-lightbox-close {
  font-size: 18pt;
  cursor: pointer;
  position: absolute;
  top: 0;
  right: 6px;
  color: ${textColor};
}
.cesium-credit-lightbox-close:hover {
  color: ${highlightColor$1};
}
.cesium-credit-lightbox > ul {
  margin: 0;
  padding: 12px 20px 12px 40px;
  font-size: 13px;
}
.cesium-credit-lightbox > ul > li {
  padding-bottom: 6px;
}
.cesium-credit-lightbox > ul > li * {
  padding: 0;
  margin: 0;
}

.cesium-credit-expand-link {
  padding-left: 5px;
  cursor: pointer;
  text-decoration: underline;
  color: ${textColor};
}
.cesium-credit-expand-link:hover {
  color: ${highlightColor$1};
}

.cesium-credit-text {
  color: ${textColor};
}

.cesium-credit-delimiter {
  padding: 0 5px;
}

.cesium-credit-textContainer *,
.cesium-credit-logoContainer * {
  display: inline;
}

.cesium-credit-textContainer a:hover {
  color: ${highlightColor$1}
}

.cesium-credit-textContainer .cesium-credit-wrapper:first-of-type {
  padding-left: 5px;
}
`;function n(o){if(o.shadowRoot)return o.shadowRoot;if(o.getRootNode){const a=o.getRootNode();if(a instanceof ShadowRoot)return a}}const i=defaultValue(n(e),document.head),r=document.createElement("style");r.innerHTML=t,i.appendChild(r)}function CreditDisplay(e,t,n){Check.defined("container",e);const i=this;n=defaultValue(n,document.body);const r=document.createElement("div");r.className="cesium-credit-lightbox-overlay",n.appendChild(r);const o=document.createElement("div");o.className="cesium-credit-lightbox",r.appendChild(o);function a(u){o.contains(u.target)||i.hideLightbox()}r.addEventListener("click",a,!1);const s=document.createElement("div");s.className="cesium-credit-lightbox-title",s.textContent="Data provided by:",o.appendChild(s);const l=document.createElement("a");l.onclick=this.hideLightbox.bind(this),l.innerHTML="&times;",l.className="cesium-credit-lightbox-close",o.appendChild(l);const c=document.createElement("ul");o.appendChild(c);const d=document.createElement("div");d.className="cesium-credit-logoContainer",d.style.display="inline",e.appendChild(d);const h=document.createElement("div");h.className="cesium-credit-textContainer",h.style.display="inline",e.appendChild(h);const f=document.createElement("a");f.className="cesium-credit-expand-link",f.onclick=this.showLightbox.bind(this),f.textContent="Data attribution",e.appendChild(f),appendCss(e);const p=Credit.clone(CreditDisplay.cesiumCredit);this._delimiter=defaultValue(t,""),this._screenContainer=h,this._cesiumCreditContainer=d,this._lastViewportHeight=void 0,this._lastViewportWidth=void 0,this._lightboxCredits=o,this._creditList=c,this._lightbox=r,this._hideLightbox=a,this._expandLink=f,this._expanded=!1,this._staticCredits=[],this._cesiumCredit=p,this._previousCesiumCredit=void 0,this._currentCesiumCredit=p,this._creditDisplayElementPool=[],this._creditDisplayElementIndex=0,this._currentFrameCredits={screenCredits:new AssociativeArray,lightboxCredits:new AssociativeArray},this._defaultCredit=void 0,this.viewport=n,this.container=e}function setCredit(e,t,n,i){i=defaultValue(i,1);let r=t.get(n.id);if(defined(r))r.count<Number.MAX_VALUE&&(r.count+=i);else{const o=e._creditDisplayElementPool,a=e._creditDisplayElementPoolIndex;a<o.length?(r=o[a],r.credit=n,r.count=i):(r=new CreditDisplayElement(n,i),o.push(r)),++e._creditDisplayElementPoolIndex,t.set(n.id,r)}}CreditDisplay.prototype.addCreditToNextFrame=function(e){if(Check.defined("credit",e),e.isIon()){defined(this._defaultCredit)||(this._defaultCredit=Credit.clone(getDefaultCredit())),this._currentCesiumCredit=this._defaultCredit;return}let t;e.showOnScreen?t=this._currentFrameCredits.screenCredits:t=this._currentFrameCredits.lightboxCredits,setCredit(this,t,e)};CreditDisplay.prototype.addStaticCredit=function(e){Check.defined("credit",e);const t=this._staticCredits;contains(t,e)||t.push(e)};CreditDisplay.prototype.removeStaticCredit=function(e){Check.defined("credit",e);const t=this._staticCredits,n=t.indexOf(e);n!==-1&&t.splice(n,1)};CreditDisplay.prototype.showLightbox=function(){this._lightbox.style.display="block",this._expanded=!0};CreditDisplay.prototype.hideLightbox=function(){this._lightbox.style.display="none",this._expanded=!1};CreditDisplay.prototype.update=function(){this._expanded&&styleLightboxContainer(this)};CreditDisplay.prototype.beginFrame=function(){const e=this._currentFrameCredits;this._creditDisplayElementPoolIndex=0;const t=e.screenCredits,n=e.lightboxCredits;t.removeAll(),n.removeAll();const i=this._staticCredits;for(let r=0;r<i.length;++r){const o=i[r],a=o.showOnScreen?t:n;o.isIon()&&Credit.equals(CreditDisplay.cesiumCredit,this._cesiumCredit)||setCredit(this,a,o,Number.MAX_VALUE)}Credit.equals(CreditDisplay.cesiumCredit,this._cesiumCredit)||(this._cesiumCredit=Credit.clone(CreditDisplay.cesiumCredit)),this._currentCesiumCredit=this._cesiumCredit};CreditDisplay.prototype.endFrame=function(){const e=this._currentFrameCredits.screenCredits.values;displayCredits(this._screenContainer,e,this._delimiter,void 0);const t=this._currentFrameCredits.lightboxCredits.values;this._expandLink.style.display=t.length>0?"inline":"none",displayCredits(this._creditList,t,void 0,"li"),swapCesiumCredit(this)};CreditDisplay.prototype.destroy=function(){return this._lightbox.removeEventListener("click",this._hideLightbox,!1),this.container.removeChild(this._cesiumCreditContainer),this.container.removeChild(this._screenContainer),this.container.removeChild(this._expandLink),this.viewport.removeChild(this._lightbox),destroyObject(this)};CreditDisplay.prototype.isDestroyed=function(){return!1};CreditDisplay._cesiumCredit=void 0;CreditDisplay._cesiumCreditInitialized=!1;let defaultCredit$2;function getDefaultCredit(){if(!defined(defaultCredit$2)){let e=buildModuleUrl("Assets/Images/ion-credit.png");e.indexOf("http://")!==0&&e.indexOf("https://")!==0&&e.indexOf("data:")!==0&&(e=new Uri(e).path()),defaultCredit$2=new Credit(`<a href="https://cesium.com/" target="_blank"><img src="${e}" style="vertical-align: -7px" title="Cesium ion"/></a>`,!0)}return CreditDisplay._cesiumCreditInitialized||(CreditDisplay._cesiumCredit=defaultCredit$2,CreditDisplay._cesiumCreditInitialized=!0),defaultCredit$2}Object.defineProperties(CreditDisplay,{cesiumCredit:{get:function(){return getDefaultCredit(),CreditDisplay._cesiumCredit},set:function(e){CreditDisplay._cesiumCredit=e,CreditDisplay._cesiumCreditInitialized=!0}}});CreditDisplay.CreditDisplayElement=CreditDisplayElement;const PERSPECTIVE$1=0,ORTHOGRAPHIC$1=1;function FrustumGeometry(e){Check.typeOf.object("options",e),Check.typeOf.object("options.frustum",e.frustum),Check.typeOf.object("options.origin",e.origin),Check.typeOf.object("options.orientation",e.orientation);const t=e.frustum,n=e.orientation,i=e.origin,r=defaultValue(e.vertexFormat,VertexFormat.DEFAULT),o=defaultValue(e._drawNearPlane,!0);let a,s;t instanceof PerspectiveFrustum?(a=PERSPECTIVE$1,s=PerspectiveFrustum.packedLength):t instanceof OrthographicFrustum&&(a=ORTHOGRAPHIC$1,s=OrthographicFrustum.packedLength),this._frustumType=a,this._frustum=t.clone(),this._origin=Cartesian3.clone(i),this._orientation=Quaternion.clone(n),this._drawNearPlane=o,this._vertexFormat=r,this._workerName="createFrustumGeometry",this.packedLength=2+s+Cartesian3.packedLength+Quaternion.packedLength+VertexFormat.packedLength}FrustumGeometry.pack=function(e,t,n){Check.typeOf.object("value",e),Check.defined("array",t),n=defaultValue(n,0);const i=e._frustumType,r=e._frustum;return t[n++]=i,i===PERSPECTIVE$1?(PerspectiveFrustum.pack(r,t,n),n+=PerspectiveFrustum.packedLength):(OrthographicFrustum.pack(r,t,n),n+=OrthographicFrustum.packedLength),Cartesian3.pack(e._origin,t,n),n+=Cartesian3.packedLength,Quaternion.pack(e._orientation,t,n),n+=Quaternion.packedLength,VertexFormat.pack(e._vertexFormat,t,n),n+=VertexFormat.packedLength,t[n]=e._drawNearPlane?1:0,t};const scratchPackPerspective$1=new PerspectiveFrustum,scratchPackOrthographic$1=new OrthographicFrustum,scratchPackQuaternion$1=new Quaternion,scratchPackorigin$1=new Cartesian3,scratchVertexFormat=new VertexFormat;FrustumGeometry.unpack=function(e,t,n){Check.defined("array",e),t=defaultValue(t,0);const i=e[t++];let r;i===PERSPECTIVE$1?(r=PerspectiveFrustum.unpack(e,t,scratchPackPerspective$1),t+=PerspectiveFrustum.packedLength):(r=OrthographicFrustum.unpack(e,t,scratchPackOrthographic$1),t+=OrthographicFrustum.packedLength);const o=Cartesian3.unpack(e,t,scratchPackorigin$1);t+=Cartesian3.packedLength;const a=Quaternion.unpack(e,t,scratchPackQuaternion$1);t+=Quaternion.packedLength;const s=VertexFormat.unpack(e,t,scratchVertexFormat);t+=VertexFormat.packedLength;const l=e[t]===1;if(!defined(n))return new FrustumGeometry({frustum:r,origin:o,orientation:a,vertexFormat:s,_drawNearPlane:l});const c=i===n._frustumType?n._frustum:void 0;return n._frustum=r.clone(c),n._frustumType=i,n._origin=Cartesian3.clone(o,n._origin),n._orientation=Quaternion.clone(a,n._orientation),n._vertexFormat=VertexFormat.clone(s,n._vertexFormat),n._drawNearPlane=l,n};function getAttributes(e,t,n,i,r,o,a,s){const l=e/3*2;for(let c=0;c<4;++c)defined(t)&&(t[e]=o.x,t[e+1]=o.y,t[e+2]=o.z),defined(n)&&(n[e]=a.x,n[e+1]=a.y,n[e+2]=a.z),defined(i)&&(i[e]=s.x,i[e+1]=s.y,i[e+2]=s.z),e+=3;r[l]=0,r[l+1]=0,r[l+2]=1,r[l+3]=0,r[l+4]=1,r[l+5]=1,r[l+6]=0,r[l+7]=1}const scratchRotationMatrix$1=new Matrix3,scratchViewMatrix=new Matrix4,scratchInverseMatrix=new Matrix4,scratchXDirection=new Cartesian3,scratchYDirection=new Cartesian3,scratchZDirection=new Cartesian3,scratchNegativeX=new Cartesian3,scratchNegativeY=new Cartesian3,scratchNegativeZ=new Cartesian3,frustumSplits=new Array(3),frustumCornersNDC$1=new Array(4);frustumCornersNDC$1[0]=new Cartesian4(-1,-1,1,1);frustumCornersNDC$1[1]=new Cartesian4(1,-1,1,1);frustumCornersNDC$1[2]=new Cartesian4(1,1,1,1);frustumCornersNDC$1[3]=new Cartesian4(-1,1,1,1);const scratchFrustumCorners$1=new Array(4);for(let e=0;e<4;++e)scratchFrustumCorners$1[e]=new Cartesian4;FrustumGeometry._computeNearFarPlanes=function(e,t,n,i,r,o,a,s){const l=Matrix3.fromQuaternion(t,scratchRotationMatrix$1);let c=defaultValue(o,scratchXDirection),d=defaultValue(a,scratchYDirection),h=defaultValue(s,scratchZDirection);c=Matrix3.getColumn(l,0,c),d=Matrix3.getColumn(l,1,d),h=Matrix3.getColumn(l,2,h),Cartesian3.normalize(c,c),Cartesian3.normalize(d,d),Cartesian3.normalize(h,h),Cartesian3.negate(c,c);const f=Matrix4.computeView(e,h,d,c,scratchViewMatrix);let p,u;const m=i.projectionMatrix;if(n===PERSPECTIVE$1){const g=Matrix4.multiply(m,f,scratchInverseMatrix);u=Matrix4.inverse(g,scratchInverseMatrix)}else p=Matrix4.inverseTransformation(f,scratchInverseMatrix);defined(u)?(frustumSplits[0]=i.near,frustumSplits[1]=i.far):(frustumSplits[0]=0,frustumSplits[1]=i.near,frustumSplits[2]=i.far);for(let g=0;g<2;++g)for(let _=0;_<4;++_){let C=Cartesian4.clone(frustumCornersNDC$1[_],scratchFrustumCorners$1[_]);if(defined(u)){C=Matrix4.multiplyByVector(u,C,C);const A=1/C.w;Cartesian3.multiplyByScalar(C,A,C),Cartesian3.subtract(C,e,C),Cartesian3.normalize(C,C);const S=Cartesian3.dot(h,C);Cartesian3.multiplyByScalar(C,frustumSplits[g]/S,C),Cartesian3.add(C,e,C)}else{const A=i.offCenterFrustum;defined(A)&&(i=A);const S=frustumSplits[g],v=frustumSplits[g+1];C.x=(C.x*(i.right-i.left)+i.left+i.right)*.5,C.y=(C.y*(i.top-i.bottom)+i.bottom+i.top)*.5,C.z=(C.z*(S-v)-S-v)*.5,C.w=1,Matrix4.multiplyByVector(p,C,C)}r[12*g+_*3]=C.x,r[12*g+_*3+1]=C.y,r[12*g+_*3+2]=C.z}};FrustumGeometry.createGeometry=function(e){const t=e._frustumType,n=e._frustum,i=e._origin,r=e._orientation,o=e._drawNearPlane,a=e._vertexFormat,s=o?6:5;let l=new Float64Array(3*4*6);FrustumGeometry._computeNearFarPlanes(i,r,t,n,l);let c=3*4*2;l[c]=l[3*4],l[c+1]=l[3*4+1],l[c+2]=l[3*4+2],l[c+3]=l[0],l[c+4]=l[1],l[c+5]=l[2],l[c+6]=l[3*3],l[c+7]=l[3*3+1],l[c+8]=l[3*3+2],l[c+9]=l[3*7],l[c+10]=l[3*7+1],l[c+11]=l[3*7+2],c+=3*4,l[c]=l[3*5],l[c+1]=l[3*5+1],l[c+2]=l[3*5+2],l[c+3]=l[3],l[c+4]=l[4],l[c+5]=l[5],l[c+6]=l[0],l[c+7]=l[1],l[c+8]=l[2],l[c+9]=l[3*4],l[c+10]=l[3*4+1],l[c+11]=l[3*4+2],c+=3*4,l[c]=l[3],l[c+1]=l[4],l[c+2]=l[5],l[c+3]=l[3*5],l[c+4]=l[3*5+1],l[c+5]=l[3*5+2],l[c+6]=l[3*6],l[c+7]=l[3*6+1],l[c+8]=l[3*6+2],l[c+9]=l[3*2],l[c+10]=l[3*2+1],l[c+11]=l[3*2+2],c+=3*4,l[c]=l[3*2],l[c+1]=l[3*2+1],l[c+2]=l[3*2+2],l[c+3]=l[3*6],l[c+4]=l[3*6+1],l[c+5]=l[3*6+2],l[c+6]=l[3*7],l[c+7]=l[3*7+1],l[c+8]=l[3*7+2],l[c+9]=l[3*3],l[c+10]=l[3*3+1],l[c+11]=l[3*3+2],o||(l=l.subarray(3*4));const d=new GeometryAttributes({position:new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:l})});if(defined(a.normal)||defined(a.tangent)||defined(a.bitangent)||defined(a.st)){const f=defined(a.normal)?new Float32Array(12*s):void 0,p=defined(a.tangent)?new Float32Array(3*4*s):void 0,u=defined(a.bitangent)?new Float32Array(3*4*s):void 0,m=defined(a.st)?new Float32Array(2*4*s):void 0,g=scratchXDirection,_=scratchYDirection,C=scratchZDirection,A=Cartesian3.negate(g,scratchNegativeX),S=Cartesian3.negate(_,scratchNegativeY),v=Cartesian3.negate(C,scratchNegativeZ);c=0,o&&(getAttributes(c,f,p,u,m,v,g,_),c+=3*4),getAttributes(c,f,p,u,m,C,A,_),c+=3*4,getAttributes(c,f,p,u,m,A,v,_),c+=3*4,getAttributes(c,f,p,u,m,S,v,A),c+=3*4,getAttributes(c,f,p,u,m,g,C,_),c+=3*4,getAttributes(c,f,p,u,m,_,C,A),defined(f)&&(d.normal=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:f})),defined(p)&&(d.tangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:p})),defined(u)&&(d.bitangent=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:u})),defined(m)&&(d.st=new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:2,values:m}))}const h=new Uint16Array(6*s);for(let f=0;f<s;++f){const p=f*6,u=f*4;h[p]=u,h[p+1]=u+1,h[p+2]=u+2,h[p+3]=u,h[p+4]=u+2,h[p+5]=u+3}return new Geometry({attributes:d,indices:h,primitiveType:PrimitiveType.TRIANGLES,boundingSphere:BoundingSphere.fromVertices(l)})};const PERSPECTIVE=0,ORTHOGRAPHIC=1;function FrustumOutlineGeometry(e){Check.typeOf.object("options",e),Check.typeOf.object("options.frustum",e.frustum),Check.typeOf.object("options.origin",e.origin),Check.typeOf.object("options.orientation",e.orientation);const t=e.frustum,n=e.orientation,i=e.origin,r=defaultValue(e._drawNearPlane,!0);let o,a;t instanceof PerspectiveFrustum?(o=PERSPECTIVE,a=PerspectiveFrustum.packedLength):t instanceof OrthographicFrustum&&(o=ORTHOGRAPHIC,a=OrthographicFrustum.packedLength),this._frustumType=o,this._frustum=t.clone(),this._origin=Cartesian3.clone(i),this._orientation=Quaternion.clone(n),this._drawNearPlane=r,this._workerName="createFrustumOutlineGeometry",this.packedLength=2+a+Cartesian3.packedLength+Quaternion.packedLength}FrustumOutlineGeometry.pack=function(e,t,n){Check.typeOf.object("value",e),Check.defined("array",t),n=defaultValue(n,0);const i=e._frustumType,r=e._frustum;return t[n++]=i,i===PERSPECTIVE?(PerspectiveFrustum.pack(r,t,n),n+=PerspectiveFrustum.packedLength):(OrthographicFrustum.pack(r,t,n),n+=OrthographicFrustum.packedLength),Cartesian3.pack(e._origin,t,n),n+=Cartesian3.packedLength,Quaternion.pack(e._orientation,t,n),n+=Quaternion.packedLength,t[n]=e._drawNearPlane?1:0,t};const scratchPackPerspective=new PerspectiveFrustum,scratchPackOrthographic=new OrthographicFrustum,scratchPackQuaternion=new Quaternion,scratchPackorigin=new Cartesian3;FrustumOutlineGeometry.unpack=function(e,t,n){Check.defined("array",e),t=defaultValue(t,0);const i=e[t++];let r;i===PERSPECTIVE?(r=PerspectiveFrustum.unpack(e,t,scratchPackPerspective),t+=PerspectiveFrustum.packedLength):(r=OrthographicFrustum.unpack(e,t,scratchPackOrthographic),t+=OrthographicFrustum.packedLength);const o=Cartesian3.unpack(e,t,scratchPackorigin);t+=Cartesian3.packedLength;const a=Quaternion.unpack(e,t,scratchPackQuaternion);t+=Quaternion.packedLength;const s=e[t]===1;if(!defined(n))return new FrustumOutlineGeometry({frustum:r,origin:o,orientation:a,_drawNearPlane:s});const l=i===n._frustumType?n._frustum:void 0;return n._frustum=r.clone(l),n._frustumType=i,n._origin=Cartesian3.clone(o,n._origin),n._orientation=Quaternion.clone(a,n._orientation),n._drawNearPlane=s,n};FrustumOutlineGeometry.createGeometry=function(e){const t=e._frustumType,n=e._frustum,i=e._origin,r=e._orientation,o=e._drawNearPlane,a=new Float64Array(3*4*2);FrustumGeometry._computeNearFarPlanes(i,r,t,n,a);const s=new GeometryAttributes({position:new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:a})});let l,c;const d=o?2:1,h=new Uint16Array(8*(d+1));let f=o?0:1;for(;f<2;++f)l=o?f*8:0,c=f*4,h[l]=c,h[l+1]=c+1,h[l+2]=c+1,h[l+3]=c+2,h[l+4]=c+2,h[l+5]=c+3,h[l+6]=c+3,h[l+7]=c;for(f=0;f<2;++f)l=(d+f)*8,c=f*4,h[l]=c,h[l+1]=c+4,h[l+2]=c+1,h[l+3]=c+5,h[l+4]=c+2,h[l+5]=c+6,h[l+6]=c+3,h[l+7]=c+7;return new Geometry({attributes:s,indices:h,primitiveType:PrimitiveType.LINES,boundingSphere:BoundingSphere.fromVertices(a)})};function DebugCameraPrimitive(e){if(e=defaultValue(e,defaultValue.EMPTY_OBJECT),!defined(e.camera))throw new DeveloperError("options.camera is required.");this._camera=e.camera,this._frustumSplits=e.frustumSplits,this._color=defaultValue(e.color,Color.CYAN),this._updateOnChange=defaultValue(e.updateOnChange,!0),this.show=defaultValue(e.show,!0),this.id=e.id,this._id=void 0,this._outlinePrimitives=[],this._planesPrimitives=[]}const scratchRight$2=new Cartesian3,scratchRotation$4=new Matrix3,scratchOrientation=new Quaternion,scratchPerspective=new PerspectiveFrustum,scratchPerspectiveOffCenter=new PerspectiveOffCenterFrustum,scratchOrthographic=new OrthographicFrustum,scratchOrthographicOffCenter=new OrthographicOffCenterFrustum,scratchColor$3=new Color,scratchSplits$1=[1,1e5];DebugCameraPrimitive.prototype.update=function(e){if(!this.show)return;const t=this._planesPrimitives,n=this._outlinePrimitives;let i,r;if(this._updateOnChange){for(r=t.length,i=0;i<r;++i)n[i]=n[i]&&n[i].destroy(),t[i]=t[i]&&t[i].destroy();t.length=0,n.length=0}if(t.length===0){const o=this._camera,a=o.frustum;let s;a instanceof PerspectiveFrustum?s=scratchPerspective:a instanceof PerspectiveOffCenterFrustum?s=scratchPerspectiveOffCenter:a instanceof OrthographicFrustum?s=scratchOrthographic:s=scratchOrthographicOffCenter,s=a.clone(s);let l,c=this._frustumSplits;!defined(c)||c.length<=1?(c=scratchSplits$1,c[0]=this._camera.frustum.near,c[1]=this._camera.frustum.far,l=1):l=c.length-1;const d=o.positionWC,h=o.directionWC,f=o.upWC;let p=o.rightWC;p=Cartesian3.negate(p,scratchRight$2);const u=scratchRotation$4;Matrix3.setColumn(u,0,p,u),Matrix3.setColumn(u,1,f,u),Matrix3.setColumn(u,2,h,u);const m=Quaternion.fromRotationMatrix(u,scratchOrientation);for(t.length=n.length=l,i=0;i<l;++i)s.near=c[i],s.far=c[i+1],t[i]=new Primitive({geometryInstances:new GeometryInstance({geometry:new FrustumGeometry({origin:d,orientation:m,frustum:s,_drawNearPlane:i===0}),attributes:{color:ColorGeometryInstanceAttribute.fromColor(Color.fromAlpha(this._color,.1,scratchColor$3))},id:this.id,pickPrimitive:this}),appearance:new PerInstanceColorAppearance({translucent:!0,flat:!0}),asynchronous:!1}),n[i]=new Primitive({geometryInstances:new GeometryInstance({geometry:new FrustumOutlineGeometry({origin:d,orientation:m,frustum:s,_drawNearPlane:i===0}),attributes:{color:ColorGeometryInstanceAttribute.fromColor(this._color)},id:this.id,pickPrimitive:this}),appearance:new PerInstanceColorAppearance({translucent:!1,flat:!0}),asynchronous:!1})}for(r=t.length,i=0;i<r;++i)n[i].update(e),t[i].update(e)};DebugCameraPrimitive.prototype.isDestroyed=function(){return!1};DebugCameraPrimitive.prototype.destroy=function(){const e=this._planesPrimitives.length;for(let t=0;t<e;++t)this._outlinePrimitives[t]=this._outlinePrimitives[t]&&this._outlinePrimitives[t].destroy(),this._planesPrimitives[t]=this._planesPrimitives[t]&&this._planesPrimitives[t].destroy();return destroyObject(this)};function DepthPlane(e){this._rs=void 0,this._sp=void 0,this._va=void 0,this._command=void 0,this._mode=void 0,this._useLogDepth=!1,this._ellipsoidOffset=defaultValue(e,0)}const depthQuadScratch=FeatureDetection.supportsTypedArrays()?new Float32Array(12):[],scratchCartesian1$1=new Cartesian3,scratchCartesian2$3=new Cartesian3,scratchCartesian3=new Cartesian3,scratchCartesian4$1=new Cartesian3,scratchCartesian5=new Cartesian3;function computeDepthQuad(e,t){const n=e.radii,i=t.camera;let r,o,a;if(i.frustum instanceof OrthographicFrustum)r=Cartesian3.ZERO,o=i.rightWC,a=i.upWC;else{const h=i.positionWC,f=Cartesian3.multiplyComponents(e.oneOverRadii,h,scratchCartesian1$1),p=Cartesian3.normalize(f,scratchCartesian2$3),u=Cartesian3.normalize(Cartesian3.cross(Cartesian3.UNIT_Z,f,scratchCartesian3),scratchCartesian3),m=Cartesian3.normalize(Cartesian3.cross(p,u,scratchCartesian4$1),scratchCartesian4$1),g=Cartesian3.magnitude(f),_=Math.sqrt(g*g-1);r=Cartesian3.multiplyByScalar(p,1/g,scratchCartesian1$1);const C=_/g;o=Cartesian3.multiplyByScalar(u,C,scratchCartesian2$3),a=Cartesian3.multiplyByScalar(m,C,scratchCartesian3)}const s=Cartesian3.add(r,a,scratchCartesian5);Cartesian3.subtract(s,o,s),Cartesian3.multiplyComponents(n,s,s),Cartesian3.pack(s,depthQuadScratch,0);const l=Cartesian3.subtract(r,a,scratchCartesian5);Cartesian3.subtract(l,o,l),Cartesian3.multiplyComponents(n,l,l),Cartesian3.pack(l,depthQuadScratch,3);const c=Cartesian3.add(r,a,scratchCartesian5);Cartesian3.add(c,o,c),Cartesian3.multiplyComponents(n,c,c),Cartesian3.pack(c,depthQuadScratch,6);const d=Cartesian3.subtract(r,a,scratchCartesian5);return Cartesian3.add(d,o,d),Cartesian3.multiplyComponents(n,d,d),Cartesian3.pack(d,depthQuadScratch,9),depthQuadScratch}DepthPlane.prototype.update=function(e){if(this._mode=e.mode,e.mode!==SceneMode.SCENE3D)return;const t=e.context,n=e.mapProjection.ellipsoid.radii,i=new Ellipsoid(n.x+this._ellipsoidOffset,n.y+this._ellipsoidOffset,n.z+this._ellipsoidOffset),r=e.useLogDepth;if(defined(this._command)||(this._rs=RenderState.fromCache({cull:{enabled:!0},depthTest:{enabled:!0},colorMask:{red:!1,green:!1,blue:!1,alpha:!1}}),this._command=new DrawCommand({renderState:this._rs,boundingVolume:new BoundingSphere(Cartesian3.ZERO,i.maximumRadius),pass:Pass.OPAQUE,owner:this})),!defined(this._sp)||this._useLogDepth!==r){this._useLogDepth=r;const a=new ShaderSource({sources:[DepthPlaneVS]}),s=new ShaderSource({sources:[DepthPlaneFS]});r&&(s.defines.push("LOG_DEPTH"),a.defines.push("LOG_DEPTH")),this._sp=ShaderProgram.replaceCache({shaderProgram:this._sp,context:t,vertexShaderSource:a,fragmentShaderSource:s,attributeLocations:{position:0}}),this._command.shaderProgram=this._sp}const o=computeDepthQuad(i,e);if(defined(this._va))this._va.getAttribute(0).vertexBuffer.copyFromArrayView(o);else{const a=new Geometry({attributes:{position:new GeometryAttribute({componentDatatype:ComponentDatatype.FLOAT,componentsPerAttribute:3,values:o})},indices:[0,1,2,2,1,3],primitiveType:PrimitiveType.TRIANGLES});this._va=VertexArray.fromGeometry({context:t,geometry:a,attributeLocations:{position:0},bufferUsage:BufferUsage.DYNAMIC_DRAW}),this._command.vertexArray=this._va}};DepthPlane.prototype.execute=function(e,t){this._mode===SceneMode.SCENE3D&&this._command.execute(e,t)};DepthPlane.prototype.isDestroyed=function(){return!1};DepthPlane.prototype.destroy=function(){this._sp=this._sp&&this._sp.destroy(),this._va=this._va&&this._va.destroy()};function DerivedCommand(){}const fragDepthRegex=/\bgl_FragDepth\b/,discardRegex=/\bdiscard\b/;function getDepthOnlyShaderProgram$1(e,t){let n=e.shaderCache.getDerivedShaderProgram(t,"depthOnly");if(!defined(n)){const i=t._attributeLocations;let r=t.fragmentShaderSource,o,a=!1;const s=r.sources;let l=s.length;for(o=0;o<l;++o)if(fragDepthRegex.test(s[o])||discardRegex.test(s[o])){a=!0;break}let c=!1;const d=r.defines;for(l=d.length,o=0;o<l;++o)if(d[o]==="LOG_DEPTH"){c=!0;break}let h;!a&&!c?(h=`void main() 
{ 
    out_FragColor = vec4(1.0); 
} 
`,r=new ShaderSource({sources:[h]})):!a&&c&&(h=`void main() 
{ 
    out_FragColor = vec4(1.0); 
    czm_writeLogDepth(); 
} 
`,r=new ShaderSource({defines:["LOG_DEPTH"],sources:[h]})),n=e.shaderCache.createDerivedShaderProgram(t,"depthOnly",{vertexShaderSource:t.vertexShaderSource,fragmentShaderSource:r,attributeLocations:i})}return n}function getDepthOnlyRenderState(e,t){const n=e._depthOnlyRenderStateCache;let i=n[t.id];if(!defined(i)){const r=RenderState.getState(t);r.depthMask=!0,r.colorMask={red:!1,green:!1,blue:!1,alpha:!1},i=RenderState.fromCache(r),n[t.id]=i}return i}DerivedCommand.createDepthOnlyDerivedCommand=function(e,t,n,i){defined(i)||(i={});let r,o;return defined(i.depthOnlyCommand)&&(r=i.depthOnlyCommand.shaderProgram,o=i.depthOnlyCommand.renderState),i.depthOnlyCommand=DrawCommand.shallowClone(t,i.depthOnlyCommand),!defined(r)||i.shaderProgramId!==t.shaderProgram.id?(i.depthOnlyCommand.shaderProgram=getDepthOnlyShaderProgram$1(n,t.shaderProgram),i.depthOnlyCommand.renderState=getDepthOnlyRenderState(e,t.renderState),i.shaderProgramId=t.shaderProgram.id):(i.depthOnlyCommand.shaderProgram=r,i.depthOnlyCommand.renderState=o),i};const writeLogDepthRegex=/\s+czm_writeLogDepth\(/,vertexlogDepthRegex=/\s+czm_vertexLogDepth\(/;function getLogDepthShaderProgram(e,t){if(t.fragmentShaderSource.defines.indexOf("LOG_DEPTH_READ_ONLY")>=0)return t;let i=e.shaderCache.getDerivedShaderProgram(t,"logDepth");if(!defined(i)){const r=t._attributeLocations,o=t.vertexShaderSource.clone(),a=t.fragmentShaderSource.clone();o.defines=defined(o.defines)?o.defines.slice(0):[],o.defines.push("LOG_DEPTH"),a.defines=defined(a.defines)?a.defines.slice(0):[],a.defines.push("LOG_DEPTH");let s,l,c=!1,d=o.sources,h=d.length;for(s=0;s<h;++s)if(vertexlogDepthRegex.test(d[s])){c=!0;break}if(!c){for(s=0;s<h;++s)d[s]=ShaderSource.replaceMain(d[s],"czm_log_depth_main");l=`

void main() 
{ 
    czm_log_depth_main(); 
    czm_vertexLogDepth(); 
} 
`,d.push(l)}for(d=a.sources,h=d.length,c=!1,s=0;s<h;++s)writeLogDepthRegex.test(d[s])&&(c=!0);a.defines.indexOf("LOG_DEPTH_WRITE")!==-1&&(c=!0);let f="";if(!c){for(s=0;s<h;s++)d[s]=ShaderSource.replaceMain(d[s],"czm_log_depth_main");f+=`
void main() 
{ 
    czm_log_depth_main(); 
    czm_writeLogDepth(); 
} 
`}d.push(f),i=e.shaderCache.createDerivedShaderProgram(t,"logDepth",{vertexShaderSource:o,fragmentShaderSource:a,attributeLocations:r})}return i}DerivedCommand.createLogDepthCommand=function(e,t,n){defined(n)||(n={});let i;return defined(n.command)&&(i=n.command.shaderProgram),n.command=DrawCommand.shallowClone(e,n.command),!defined(i)||n.shaderProgramId!==e.shaderProgram.id?(n.command.shaderProgram=getLogDepthShaderProgram(t,e.shaderProgram),n.shaderProgramId=e.shaderProgram.id):n.command.shaderProgram=i,n};function getPickShaderProgram$1(e,t,n){let i=e.shaderCache.getDerivedShaderProgram(t,"pick");if(!defined(i)){const r=t._attributeLocations;let o=t.fragmentShaderSource;const a=o.sources,s=a.length,c=a.some(f=>f.includes("out_FragData"))?"out_FragData_0":"out_FragColor",d=`void main () 
{ 
    czm_non_pick_main(); 
    if (${c}.a == 0.0) { 
        discard; 
    } 
    ${c} = ${n}; 
} `,h=new Array(s+1);for(let f=0;f<s;++f)h[f]=ShaderSource.replaceMain(a[f],"czm_non_pick_main");h[s]=d,o=new ShaderSource({sources:h,defines:o.defines}),i=e.shaderCache.createDerivedShaderProgram(t,"pick",{vertexShaderSource:t.vertexShaderSource,fragmentShaderSource:o,attributeLocations:r})}return i}function getPickRenderState(e,t){const n=e.picking.pickRenderStateCache;let i=n[t.id];if(!defined(i)){const r=RenderState.getState(t);r.blending.enabled=!1,r.depthMask=!0,i=RenderState.fromCache(r),n[t.id]=i}return i}DerivedCommand.createPickDerivedCommand=function(e,t,n,i){defined(i)||(i={});let r,o;return defined(i.pickCommand)&&(r=i.pickCommand.shaderProgram,o=i.pickCommand.renderState),i.pickCommand=DrawCommand.shallowClone(t,i.pickCommand),!defined(r)||i.shaderProgramId!==t.shaderProgram.id?(i.pickCommand.shaderProgram=getPickShaderProgram$1(n,t.shaderProgram,t.pickId),i.pickCommand.renderState=getPickRenderState(e,t.renderState),i.shaderProgramId=t.shaderProgram.id):(i.pickCommand.shaderProgram=r,i.pickCommand.renderState=o),i};function getHdrShaderProgram(e,t){let n=e.shaderCache.getDerivedShaderProgram(t,"HDR");if(!defined(n)){const i=t._attributeLocations,r=t.vertexShaderSource.clone(),o=t.fragmentShaderSource.clone();r.defines=defined(r.defines)?r.defines.slice(0):[],r.defines.push("HDR"),o.defines=defined(o.defines)?o.defines.slice(0):[],o.defines.push("HDR"),n=e.shaderCache.createDerivedShaderProgram(t,"HDR",{vertexShaderSource:r,fragmentShaderSource:o,attributeLocations:i})}return n}DerivedCommand.createHdrCommand=function(e,t,n){defined(n)||(n={});let i;return defined(n.command)&&(i=n.command.shaderProgram),n.command=DrawCommand.shallowClone(e,n.command),!defined(i)||n.shaderProgramId!==e.shaderProgram.id?(n.command.shaderProgram=getHdrShaderProgram(t,e.shaderProgram),n.shaderProgramId=e.shaderProgram.id):n.command.shaderProgram=i,n};function DeviceOrientationCameraController(e){if(!defined(e))throw new DeveloperError("scene is required.");this._scene=e,this._lastAlpha=void 0,this._lastBeta=void 0,this._lastGamma=void 0,this._alpha=void 0,this._beta=void 0,this._gamma=void 0;const t=this;function n(i){const r=i.alpha;if(!defined(r)){t._alpha=void 0,t._beta=void 0,t._gamma=void 0;return}t._alpha=CesiumMath.toRadians(r),t._beta=CesiumMath.toRadians(i.beta),t._gamma=CesiumMath.toRadians(i.gamma)}window.addEventListener("deviceorientation",n,!1),this._removeListener=function(){window.removeEventListener("deviceorientation",n,!1)}}const scratchQuaternion1=new Quaternion,scratchQuaternion2=new Quaternion,scratchMatrix3=new Matrix3;function rotate(e,t,n,i){const r=e.direction,o=e.right,a=e.up,s=Quaternion.fromAxisAngle(r,n,scratchQuaternion2),l=Quaternion.fromAxisAngle(o,i,scratchQuaternion1),c=Quaternion.multiply(l,s,l),d=Quaternion.fromAxisAngle(a,t,scratchQuaternion2);Quaternion.multiply(d,c,c);const h=Matrix3.fromQuaternion(c,scratchMatrix3);Matrix3.multiplyByVector(h,o,o),Matrix3.multiplyByVector(h,a,a),Matrix3.multiplyByVector(h,r,r)}DeviceOrientationCameraController.prototype.update=function(){if(!defined(this._alpha))return;defined(this._lastAlpha)||(this._lastAlpha=this._alpha,this._lastBeta=this._beta,this._lastGamma=this._gamma);const e=this._lastAlpha-this._alpha,t=this._lastBeta-this._beta,n=this._lastGamma-this._gamma;rotate(this._scene.camera,-e,t,n),this._lastAlpha=this._alpha,this._lastBeta=this._beta,this._lastGamma=this._gamma};DeviceOrientationCameraController.prototype.isDestroyed=function(){return!1};DeviceOrientationCameraController.prototype.destroy=function(){return this._removeListener(),destroyObject(this)};function Fog(){this.enabled=!0,this.renderable=!0,this.density=2e-4,this.screenSpaceErrorFactor=2,this.minimumBrightness=.03}const heightsTable=[359.393,800.749,1275.6501,2151.1192,3141.7763,4777.5198,6281.2493,12364.307,15900.765,49889.0549,78026.8259,99260.7344,120036.3873,151011.0158,156091.1953,203849.3112,274866.9803,319916.3149,493552.0528,628733.5874],densityTable=[2e-5,2e-4,1e-4,7e-5,5e-5,4e-5,3e-5,19e-6,1e-5,85e-7,62e-7,58e-7,53e-7,52e-7,51e-7,42e-7,4e-6,34e-7,26e-7,22e-7];for(let e=0;e<densityTable.length;++e)densityTable[e]*=1e6;const tableStartDensity=densityTable[1],tableEndDensity=densityTable[densityTable.length-1];for(let e=0;e<densityTable.length;++e)densityTable[e]=(densityTable[e]-tableEndDensity)/(tableStartDensity-tableEndDensity);let tableLastIndex=0;function findInterval(e){const t=heightsTable,n=t.length;if(e<t[0])return tableLastIndex=0,tableLastIndex;if(e>t[n-1])return tableLastIndex=n-2,tableLastIndex;if(e>=t[tableLastIndex]){if(tableLastIndex+1<n&&e<t[tableLastIndex+1])return tableLastIndex;if(tableLastIndex+2<n&&e<t[tableLastIndex+2])return++tableLastIndex,tableLastIndex}else if(tableLastIndex-1>=0&&e>=t[tableLastIndex-1])return--tableLastIndex,tableLastIndex;let i;for(i=0;i<n-2&&!(e>=t[i]&&e<t[i+1]);++i);return tableLastIndex=i,tableLastIndex}const scratchPositionNormal$1=new Cartesian3;Fog.prototype.update=function(e){if(!(e.fog.enabled=this.enabled))return;e.fog.renderable=this.renderable;const n=e.camera,i=n.positionCartographic;if(!defined(i)||i.height>8e5||e.mode!==SceneMode.SCENE3D){e.fog.enabled=!1,e.fog.density=0;return}const r=i.height,o=findInterval(r),a=CesiumMath.clamp((r-heightsTable[o])/(heightsTable[o+1]-heightsTable[o]),0,1);let s=CesiumMath.lerp(densityTable[o],densityTable[o+1],a);const l=this.density*1e6,c=l/tableStartDensity*tableEndDensity;s=s*(l-c)*1e-6;const d=Cartesian3.normalize(n.positionWC,scratchPositionNormal$1),h=Math.abs(Cartesian3.dot(n.directionWC,d));s*=1-h,e.fog.density=s,e.fog.sse=this.screenSpaceErrorFactor,e.fog.minimumBrightness=this.minimumBrightness};function FrameState(e,t,n){this.context=e,this.commandList=[],this.shadowMaps=[],this.brdfLutGenerator=void 0,this.environmentMap=void 0,this.sphericalHarmonicCoefficients=void 0,this.specularEnvironmentMaps=void 0,this.specularEnvironmentMapsMaximumLOD=void 0,this.mode=SceneMode.SCENE3D,this.morphTime=SceneMode.getMorphTime(SceneMode.SCENE3D),this.frameNumber=0,this.newFrame=!1,this.time=void 0,this.jobScheduler=n,this.mapProjection=void 0,this.camera=void 0,this.cameraUnderground=!1,this.globeTranslucencyState=void 0,this.cullingVolume=void 0,this.occluder=void 0,this.maximumScreenSpaceError=void 0,this.pixelRatio=1,this.passes={render:!1,pick:!1,pickVoxel:!1,depth:!1,postProcess:!1,offscreen:!1},this.creditDisplay=t,this.afterRender=[],this.scene3DOnly=!1,this.fog={enabled:!1,renderable:!1,density:void 0,sse:void 0,minimumBrightness:void 0},this.atmosphere=void 0,this.verticalExaggeration=1,this.verticalExaggerationRelativeHeight=0,this.shadowState={shadowsEnabled:!0,shadowMaps:[],lightShadowMaps:[],nearPlane:1,farPlane:5e3,closestObjectSize:1e3,lastDirtyTime:0,outOfView:!0},this.splitPosition=0,this.frustumSplits=[],this.backgroundColor=void 0,this.light=void 0,this.minimumDisableDepthTestDistance=void 0,this.invertClassification=!1,this.invertClassificationColor=void 0,this.useLogDepth=!1,this.tilesetPassState=void 0,this.minimumTerrainHeight=0}const DerivedCommandType={OPAQUE_FRONT_FACE:0,OPAQUE_BACK_FACE:1,DEPTH_ONLY_FRONT_FACE:2,DEPTH_ONLY_BACK_FACE:3,DEPTH_ONLY_FRONT_AND_BACK_FACE:4,TRANSLUCENT_FRONT_FACE:5,TRANSLUCENT_BACK_FACE:6,TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST:7,TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST:8,PICK_FRONT_FACE:9,PICK_BACK_FACE:10,DERIVED_COMMANDS_MAXIMUM_LENGTH:11},derivedCommandsMaximumLength=DerivedCommandType.DERIVED_COMMANDS_MAXIMUM_LENGTH,DerivedCommandNames=["opaqueFrontFaceCommand","opaqueBackFaceCommand","depthOnlyFrontFaceCommand","depthOnlyBackFaceCommand","depthOnlyFrontAndBackFaceCommand","translucentFrontFaceCommand","translucentBackFaceCommand","translucentFrontFaceManualDepthTestCommand","translucentBackFaceManualDepthTestCommand","pickFrontFaceCommand","pickBackFaceCommand"];function GlobeTranslucencyState(){this._frontFaceAlphaByDistance=new NearFarScalar(0,1,0,1),this._backFaceAlphaByDistance=new NearFarScalar(0,1,0,1),this._frontFaceTranslucent=!1,this._backFaceTranslucent=!1,this._requiresManualDepthTest=!1,this._sunVisibleThroughGlobe=!1,this._environmentVisible=!1,this._useDepthPlane=!1,this._numberOfTextureUniforms=0,this._globeTranslucencyFramebuffer=void 0,this._rectangle=Rectangle.clone(Rectangle.MAX_VALUE),this._derivedCommandKey=0,this._derivedCommandsDirty=!1,this._derivedCommandPacks=void 0,this._derivedCommandTypes=new Array(derivedCommandsMaximumLength),this._derivedBlendCommandTypes=new Array(derivedCommandsMaximumLength),this._derivedPickCommandTypes=new Array(derivedCommandsMaximumLength),this._derivedCommandTypesToUpdate=new Array(derivedCommandsMaximumLength),this._derivedCommandsLength=0,this._derivedBlendCommandsLength=0,this._derivedPickCommandsLength=0,this._derivedCommandsToUpdateLength=0}Object.defineProperties(GlobeTranslucencyState.prototype,{frontFaceAlphaByDistance:{get:function(){return this._frontFaceAlphaByDistance}},backFaceAlphaByDistance:{get:function(){return this._backFaceAlphaByDistance}},translucent:{get:function(){return this._frontFaceTranslucent}},sunVisibleThroughGlobe:{get:function(){return this._sunVisibleThroughGlobe}},environmentVisible:{get:function(){return this._environmentVisible}},useDepthPlane:{get:function(){return this._useDepthPlane}},numberOfTextureUniforms:{get:function(){return this._numberOfTextureUniforms}},rectangle:{get:function(){return this._rectangle}}});GlobeTranslucencyState.prototype.update=function(e){const t=e.globe;if(!defined(t)||!t.show){this._frontFaceTranslucent=!1,this._backFaceTranslucent=!1,this._sunVisibleThroughGlobe=!0,this._environmentVisible=!0,this._useDepthPlane=!1;return}this._frontFaceAlphaByDistance=updateAlphaByDistance(t.translucency.enabled,t.translucency.frontFaceAlpha,t.translucency.frontFaceAlphaByDistance,this._frontFaceAlphaByDistance),this._backFaceAlphaByDistance=updateAlphaByDistance(t.translucency.enabled,t.translucency.backFaceAlpha,t.translucency.backFaceAlphaByDistance,this._backFaceAlphaByDistance),this._frontFaceTranslucent=isFaceTranslucent(t.translucency.enabled,this._frontFaceAlphaByDistance,t),this._backFaceTranslucent=isFaceTranslucent(t.translucency.enabled,this._backFaceAlphaByDistance,t),this._requiresManualDepthTest=requiresManualDepthTest(this,e,t),this._sunVisibleThroughGlobe=isSunVisibleThroughGlobe(this,e),this._environmentVisible=isEnvironmentVisible(this,e),this._useDepthPlane=useDepthPlane(this,e),this._numberOfTextureUniforms=getNumberOfTextureUniforms(this),this._rectangle=Rectangle.clone(t.translucency.rectangle,this._rectangle),gatherDerivedCommandRequirements(this,e)};function updateAlphaByDistance(e,t,n,i){return e?defined(n)?(NearFarScalar.clone(n,i),i.nearValue*=t,i.farValue*=t,i):(i.nearValue=t,i.farValue=t,i):(i.nearValue=1,i.farValue=1,i)}function isFaceTranslucent(e,t,n){return e&&(n.baseColor.alpha<1||t.nearValue<1||t.farValue<1)}function isSunVisibleThroughGlobe(e,t){const n=e._frontFaceTranslucent,i=e._backFaceTranslucent;return n&&(t.cameraUnderground||i)}function isEnvironmentVisible(e,t){return!t.cameraUnderground||e._frontFaceTranslucent}function useDepthPlane(e,t){return!t.cameraUnderground&&!e._frontFaceTranslucent}function requiresManualDepthTest(e,t,n){return e._frontFaceTranslucent&&!e._backFaceTranslucent&&!n.depthTestAgainstTerrain&&t.mode!==SceneMode.SCENE2D&&t.context.depthTexture}function getNumberOfTextureUniforms(e){let t=0;return e._frontFaceTranslucent&&++t,e._requiresManualDepthTest&&++t,t}function gatherDerivedCommandRequirements(e,t){e._derivedCommandsLength=getDerivedCommandTypes(e,t,!1,!1,e._derivedCommandTypes),e._derivedBlendCommandsLength=getDerivedCommandTypes(e,t,!0,!1,e._derivedBlendCommandTypes),e._derivedPickCommandsLength=getDerivedCommandTypes(e,t,!1,!0,e._derivedPickCommandTypes);let n,i=0;for(n=0;n<e._derivedCommandsLength;++n)i|=1<<e._derivedCommandTypes[n];for(n=0;n<e._derivedBlendCommandsLength;++n)i|=1<<e._derivedBlendCommandTypes[n];for(n=0;n<e._derivedPickCommandsLength;++n)i|=1<<e._derivedPickCommandTypes[n];let r=0;for(n=0;n<derivedCommandsMaximumLength;++n)(i&1<<n)>0&&(e._derivedCommandTypesToUpdate[r++]=n);e._derivedCommandsToUpdateLength=r;const o=i!==e._derivedCommandKey;e._derivedCommandKey=i,e._derivedCommandsDirty=o,!defined(e._derivedCommandPacks)&&e._frontFaceTranslucent&&(e._derivedCommandPacks=createDerivedCommandPacks())}function getDerivedCommandTypes(e,t,n,i,r){let o=0;const a=e._frontFaceTranslucent,s=e._backFaceTranslucent;if(!a)return o;const l=t.cameraUnderground,c=e._requiresManualDepthTest,d=i?DerivedCommandType.PICK_FRONT_FACE:c?DerivedCommandType.TRANSLUCENT_FRONT_FACE_MANUAL_DEPTH_TEST:DerivedCommandType.TRANSLUCENT_FRONT_FACE,h=i?DerivedCommandType.PICK_BACK_FACE:c?DerivedCommandType.TRANSLUCENT_BACK_FACE_MANUAL_DEPTH_TEST:DerivedCommandType.TRANSLUCENT_BACK_FACE;return t.mode===SceneMode.SCENE2D?(r[o++]=DerivedCommandType.DEPTH_ONLY_FRONT_FACE,r[o++]=d,o):(s?(n||(r[o++]=DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE),l?(r[o++]=d,r[o++]=h):(r[o++]=h,r[o++]=d)):l?(n||(r[o++]=DerivedCommandType.DEPTH_ONLY_BACK_FACE),r[o++]=DerivedCommandType.OPAQUE_FRONT_FACE,r[o++]=h):(n||(r[o++]=DerivedCommandType.DEPTH_ONLY_FRONT_FACE),r[o++]=DerivedCommandType.OPAQUE_BACK_FACE,r[o++]=d),o)}function removeDefine(e,t){const n=e.indexOf(t);n>-1&&e.splice(n,1)}function hasDefine(e,t){return e.indexOf(t)>-1}function getOpaqueFrontFaceShaderProgram(e,t){removeDefine(e.defines,"TRANSLUCENT"),removeDefine(t.defines,"TRANSLUCENT")}function getOpaqueBackFaceShaderProgram(e,t){removeDefine(e.defines,"GROUND_ATMOSPHERE"),removeDefine(t.defines,"GROUND_ATMOSPHERE"),removeDefine(e.defines,"FOG"),removeDefine(t.defines,"FOG"),removeDefine(e.defines,"TRANSLUCENT"),removeDefine(t.defines,"TRANSLUCENT")}function getDepthOnlyShaderProgram(e,t){if(hasDefine(t.defines,"TILE_LIMIT_RECTANGLE")||hasDefine(t.defines,"ENABLE_CLIPPING_PLANES"))return;const n=`void main() 
{ 
    out_FragColor = vec4(1.0); 
} 
`;t.sources=[n]}function getTranslucentShaderProgram$1(e,t){const n=t.sources,i=n.length;for(let o=0;o<i;++o)n[o]=ShaderSource.replaceMain(n[o],"czm_globe_translucency_main");n.push(`

uniform sampler2D u_classificationTexture; 
void main() 
{ 
    vec2 st = gl_FragCoord.xy / czm_viewport.zw; 
#ifdef MANUAL_DEPTH_TEST 
    float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, st)); 
    if (logDepthOrDepth != 0.0) 
    { 
        vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth); 
        float depthEC = eyeCoordinate.z / eyeCoordinate.w; 
        if (v_positionEC.z < depthEC) 
        { 
            discard; 
        } 
    } 
#endif 
    czm_globe_translucency_main(); 
    vec4 classificationColor = texture(u_classificationTexture, st); 
    if (classificationColor.a > 0.0) 
    { 
        // Reverse premultiplication process to get the correct composited result of the classification primitives 
        classificationColor.rgb /= classificationColor.a; 
    } 
    out_FragColor = classificationColor * vec4(classificationColor.aaa, 1.0) + out_FragColor * (1.0 - classificationColor.a); 
} 
`)}function getTranslucentBackFaceShaderProgram(e,t){getTranslucentShaderProgram$1(e,t),removeDefine(e.defines,"GROUND_ATMOSPHERE"),removeDefine(t.defines,"GROUND_ATMOSPHERE"),removeDefine(e.defines,"FOG"),removeDefine(t.defines,"FOG")}function getTranslucentFrontFaceManualDepthTestShaderProgram(e,t){getTranslucentShaderProgram$1(e,t),e.defines.push("GENERATE_POSITION"),t.defines.push("MANUAL_DEPTH_TEST")}function getTranslucentBackFaceManualDepthTestShaderProgram(e,t){getTranslucentBackFaceShaderProgram(e,t),e.defines.push("GENERATE_POSITION"),t.defines.push("MANUAL_DEPTH_TEST")}function getPickShaderProgram(e,t){const n=`uniform sampler2D u_classificationTexture; 
void main() 
{ 
    vec2 st = gl_FragCoord.xy / czm_viewport.zw; 
    vec4 pickColor = texture(u_classificationTexture, st); 
    if (pickColor == vec4(0.0)) 
    { 
        discard; 
    } 
    out_FragColor = pickColor; 
} 
`;t.sources=[n]}function getDerivedShaderProgram(e,t,n,i,r,o){if(!defined(r))return t;if(!i&&defined(n))return n;let a=e.shaderCache.getDerivedShaderProgram(t,o);if(!defined(a)){const s=t._attributeLocations,l=t.vertexShaderSource.clone(),c=t.fragmentShaderSource.clone();l.defines=defined(l.defines)?l.defines.slice(0):[],c.defines=defined(c.defines)?c.defines.slice(0):[],r(l,c),a=e.shaderCache.createDerivedShaderProgram(t,o,{vertexShaderSource:l,fragmentShaderSource:c,attributeLocations:s})}return a}function getOpaqueFrontFaceRenderState(e){e.cull.face=CullFace.BACK,e.cull.enabled=!0}function getOpaqueBackFaceRenderState(e){e.cull.face=CullFace.FRONT,e.cull.enabled=!0}function getDepthOnlyFrontFaceRenderState(e){e.cull.face=CullFace.BACK,e.cull.enabled=!0,e.colorMask={red:!1,green:!1,blue:!1,alpha:!1}}function getDepthOnlyBackFaceRenderState(e){e.cull.face=CullFace.FRONT,e.cull.enabled=!0,e.colorMask={red:!1,green:!1,blue:!1,alpha:!1}}function getDepthOnlyFrontAndBackFaceRenderState(e){e.cull.enabled=!1,e.colorMask={red:!1,green:!1,blue:!1,alpha:!1}}function getTranslucentFrontFaceRenderState(e){e.cull.face=CullFace.BACK,e.cull.enabled=!0,e.depthMask=!1,e.blending=BlendingState.ALPHA_BLEND}function getTranslucentBackFaceRenderState(e){e.cull.face=CullFace.FRONT,e.cull.enabled=!0,e.depthMask=!1,e.blending=BlendingState.ALPHA_BLEND}function getPickFrontFaceRenderState(e){e.cull.face=CullFace.BACK,e.cull.enabled=!0,e.blending.enabled=!1}function getPickBackFaceRenderState(e){e.cull.face=CullFace.FRONT,e.cull.enabled=!0,e.blending.enabled=!1}function getDerivedRenderState(e,t,n,i,r){if(!defined(i))return e;if(!n&&defined(t))return t;let o=r[e.id];if(!defined(o)){const a=RenderState.getState(e);i(a),o=RenderState.fromCache(a),r[e.id]=o}return o}function getTranslucencyUniformMap(e){return{u_classificationTexture:function(){return e._globeTranslucencyFramebuffer.classificationTexture}}}function getDerivedUniformMap(e,t,n,i,r){return defined(r)?!i&&defined(n)?n:combine$2(t,r(e),!1):t}function DerivedCommandPack(e){this.pass=e.pass,this.pickOnly=e.pickOnly,this.getShaderProgramFunction=e.getShaderProgramFunction,this.getRenderStateFunction=e.getRenderStateFunction,this.getUniformMapFunction=e.getUniformMapFunction,this.renderStateCache={}}function createDerivedCommandPacks(){return[new DerivedCommandPack({pass:Pass.GLOBE,pickOnly:!1,getShaderProgramFunction:getOpaqueFrontFaceShaderProgram,getRenderStateFunction:getOpaqueFrontFaceRenderState,getUniformMapFunction:void 0}),new DerivedCommandPack({pass:Pass.GLOBE,pickOnly:!1,getShaderProgramFunction:getOpaqueBackFaceShaderProgram,getRenderStateFunction:getOpaqueBackFaceRenderState,getUniformMapFunction:void 0}),new DerivedCommandPack({pass:Pass.GLOBE,pickOnly:!1,getShaderProgramFunction:getDepthOnlyShaderProgram,getRenderStateFunction:getDepthOnlyFrontFaceRenderState,getUniformMapFunction:void 0}),new DerivedCommandPack({pass:Pass.GLOBE,pickOnly:!1,getShaderProgramFunction:getDepthOnlyShaderProgram,getRenderStateFunction:getDepthOnlyBackFaceRenderState,getUniformMapFunction:void 0}),new DerivedCommandPack({pass:Pass.GLOBE,pickOnly:!1,getShaderProgramFunction:getDepthOnlyShaderProgram,getRenderStateFunction:getDepthOnlyFrontAndBackFaceRenderState,getUniformMapFunction:void 0}),new DerivedCommandPack({pass:Pass.TRANSLUCENT,pickOnly:!1,getShaderProgramFunction:getTranslucentShaderProgram$1,getRenderStateFunction:getTranslucentFrontFaceRenderState,getUniformMapFunction:getTranslucencyUniformMap}),new DerivedCommandPack({pass:Pass.TRANSLUCENT,pickOnly:!1,getShaderProgramFunction:getTranslucentBackFaceShaderProgram,getRenderStateFunction:getTranslucentBackFaceRenderState,getUniformMapFunction:getTranslucencyUniformMap}),new DerivedCommandPack({pass:Pass.TRANSLUCENT,pickOnly:!1,getShaderProgramFunction:getTranslucentFrontFaceManualDepthTestShaderProgram,getRenderStateFunction:getTranslucentFrontFaceRenderState,getUniformMapFunction:getTranslucencyUniformMap}),new DerivedCommandPack({pass:Pass.TRANSLUCENT,pickOnly:!1,getShaderProgramFunction:getTranslucentBackFaceManualDepthTestShaderProgram,getRenderStateFunction:getTranslucentBackFaceRenderState,getUniformMapFunction:getTranslucencyUniformMap}),new DerivedCommandPack({pass:Pass.TRANSLUCENT,pickOnly:!0,getShaderProgramFunction:getPickShaderProgram,getRenderStateFunction:getPickFrontFaceRenderState,getUniformMapFunction:getTranslucencyUniformMap}),new DerivedCommandPack({pass:Pass.TRANSLUCENT,pickOnly:!0,getShaderProgramFunction:getPickShaderProgram,getRenderStateFunction:getPickBackFaceRenderState,getUniformMapFunction:getTranslucencyUniformMap})]}const derivedCommandNames=new Array(derivedCommandsMaximumLength),derivedCommandPacks=new Array(derivedCommandsMaximumLength);GlobeTranslucencyState.prototype.updateDerivedCommands=function(e,t){const n=this._derivedCommandTypesToUpdate,i=this._derivedCommandsToUpdateLength;if(i!==0){for(let r=0;r<i;++r)derivedCommandPacks[r]=this._derivedCommandPacks[n[r]],derivedCommandNames[r]=DerivedCommandNames[n[r]];updateDerivedCommands$1(this,e,i,n,derivedCommandNames,derivedCommandPacks,t)}};function updateDerivedCommands$1(e,t,n,i,r,o,a){let s=t.derivedCommands.globeTranslucency;const l=e._derivedCommandsDirty;if(t.dirty||!defined(s)||l){t.dirty=!1,defined(s)||(s={},t.derivedCommands.globeTranslucency=s);const c=a.frameNumber,d=defaultValue(s.uniformMapDirtyFrame,0),h=defaultValue(s.shaderProgramDirtyFrame,0),f=defaultValue(s.renderStateDirtyFrame,0),p=s.uniformMap!==t.uniformMap,u=s.shaderProgramId!==t.shaderProgram.id,m=s.renderStateId!==t.renderState.id;p&&(s.uniformMapDirtyFrame=c),u&&(s.shaderProgramDirtyFrame=c),m&&(s.renderStateDirtyFrame=c),s.uniformMap=t.uniformMap,s.shaderProgramId=t.shaderProgram.id,s.renderStateId=t.renderState.id;for(let g=0;g<n;++g){const _=o[g],C=i[g],A=r[g];let S=s[A],v,b,D;defined(S)?(v=S.uniformMap,b=S.shaderProgram,D=S.renderState):(v=void 0,b=void 0,D=void 0),S=DrawCommand.shallowClone(t,S),s[A]=S;const I=defaultValue(S.derivedCommands.uniformMapDirtyFrame,0),L=defaultValue(S.derivedCommands.shaderProgramDirtyFrame,0),N=defaultValue(S.derivedCommands.renderStateDirtyFrame,0),y=p||I<d,x=u||L<h,T=m||N<f;y&&(S.derivedCommands.uniformMapDirtyFrame=c),x&&(S.derivedCommands.shaderProgramDirtyFrame=c),T&&(S.derivedCommands.renderStateDirtyFrame=c),S.derivedCommands.type=C,S.pass=_.pass,S.pickOnly=_.pickOnly,S.uniformMap=getDerivedUniformMap(e,t.uniformMap,v,y,_.getUniformMapFunction),S.shaderProgram=getDerivedShaderProgram(a.context,t.shaderProgram,b,x,_.getShaderProgramFunction,A),S.renderState=getDerivedRenderState(t.renderState,D,T,_.getRenderStateFunction,_.renderStateCache)}}}GlobeTranslucencyState.prototype.pushDerivedCommands=function(e,t,n){const i=n.passes.pick||n.passes.pickVoxel;if(i&&t)return;let r=this._derivedCommandTypes,o=this._derivedCommandsLength;if(i?(r=this._derivedPickCommandTypes,o=this._derivedPickCommandsLength):t&&(r=this._derivedBlendCommandTypes,o=this._derivedBlendCommandsLength),o===0){n.commandList.push(e);return}const a=e.derivedCommands.globeTranslucency;for(let s=0;s<o;++s){const l=DerivedCommandNames[r[s]];n.commandList.push(a[l])}};function executeCommandsMatchingType(e,t,n,i,r,o,a){for(let s=0;s<t;++s){const l=e[s],c=l.derivedCommands.type;(!defined(a)||a.indexOf(c)>-1)&&n(l,i,r,o)}}function executeCommands$1(e,t,n,i,r,o){for(let a=0;a<t;++a)n(e[a],i,r,o)}const opaqueTypes=[DerivedCommandType.OPAQUE_FRONT_FACE,DerivedCommandType.OPAQUE_BACK_FACE],depthOnlyTypes=[DerivedCommandType.DEPTH_ONLY_FRONT_FACE,DerivedCommandType.DEPTH_ONLY_BACK_FACE,DerivedCommandType.DEPTH_ONLY_FRONT_AND_BACK_FACE];GlobeTranslucencyState.prototype.executeGlobeCommands=function(e,t,n,i,r){const o=i.context,a=e.commands[Pass.GLOBE],s=e.indices[Pass.GLOBE];s!==0&&(this._globeTranslucencyFramebuffer=n,n.clearClassification(o,r),executeCommandsMatchingType(a,s,t,i,o,r,opaqueTypes))};GlobeTranslucencyState.prototype.executeGlobeClassificationCommands=function(e,t,n,i,r){const o=i.context,a=e.commands[Pass.GLOBE],s=e.indices[Pass.GLOBE],l=e.commands[Pass.TERRAIN_CLASSIFICATION],c=e.indices[Pass.TERRAIN_CLASSIFICATION];if(s===0||c===0)return;const d=this._frontFaceTranslucent,h=this._backFaceTranslucent;if((!d||!h)&&executeCommands$1(l,c,t,i,o,r),!d&&!h)return;this._globeTranslucencyFramebuffer=n;const f=o.uniformState.globeDepthTexture,p=r.framebuffer;if(r.framebuffer=n.classificationFramebuffer,executeCommandsMatchingType(a,s,t,i,o,r,depthOnlyTypes),o.depthTexture){const u=n.packDepth(o,r);o.uniformState.globeDepthTexture=u}executeCommands$1(l,c,t,i,o,r),o.uniformState.globeDepthTexture=f,r.framebuffer=p};const PassThrough=`uniform sampler2D colorTexture;

in vec2 v_textureCoordinates;

void main()
{
    out_FragColor = texture(colorTexture, v_textureCoordinates);
}
`;function InvertClassification(){this._numSamples=1,this.previousFramebuffer=void 0,this._previousFramebuffer=void 0,this._depthStencilTexture=void 0,this._depthStencilRenderbuffer=void 0,this._fbo=new FramebufferManager({depthStencil:!0,createDepthAttachments:!1}),this._fboClassified=new FramebufferManager({depthStencil:!0,createDepthAttachments:!1}),this._rsUnclassified=void 0,this._rsClassified=void 0,this._unclassifiedCommand=void 0,this._classifiedCommand=void 0,this._translucentCommand=void 0,this._clearColorCommand=new ClearCommand({color:new Color(0,0,0,0),owner:this}),this._clearCommand=new ClearCommand({color:new Color(0,0,0,0),depth:1,stencil:0});const e=this;this._uniformMap={colorTexture:function(){return e._fbo.getColorTexture()},depthTexture:function(){return e._depthStencilTexture},classifiedTexture:function(){return e._fboClassified.getColorTexture()}}}Object.defineProperties(InvertClassification.prototype,{unclassifiedCommand:{get:function(){return this._unclassifiedCommand}}});InvertClassification.isTranslucencySupported=function(e){return e.depthTexture&&e.fragmentDepth};const rsUnclassified={depthMask:!1,stencilTest:{enabled:!0,frontFunction:StencilFunction.EQUAL,frontOperation:{fail:StencilOperation.KEEP,zFail:StencilOperation.KEEP,zPass:StencilOperation.KEEP},backFunction:StencilFunction.NEVER,reference:0,mask:StencilConstants.CLASSIFICATION_MASK},blending:BlendingState.ALPHA_BLEND},rsClassified={depthMask:!1,stencilTest:{enabled:!0,frontFunction:StencilFunction.NOT_EQUAL,frontOperation:{fail:StencilOperation.KEEP,zFail:StencilOperation.KEEP,zPass:StencilOperation.KEEP},backFunction:StencilFunction.NEVER,reference:0,mask:StencilConstants.CLASSIFICATION_MASK},blending:BlendingState.ALPHA_BLEND},rsDefault={depthMask:!0,depthTest:{enabled:!0},stencilTest:StencilConstants.setCesium3DTileBit(),stencilMask:StencilConstants.CESIUM_3D_TILE_MASK,blending:BlendingState.ALPHA_BLEND},translucentFS=`uniform sampler2D colorTexture;
uniform sampler2D depthTexture;
uniform sampler2D classifiedTexture;
in vec2 v_textureCoordinates;
void main()
{
    vec4 color = texture(colorTexture, v_textureCoordinates);
    if (color.a == 0.0)
    {
        discard;
    }
    bool isClassified = all(equal(texture(classifiedTexture, v_textureCoordinates), vec4(0.0)));
#ifdef UNCLASSIFIED
    vec4 highlightColor = czm_invertClassificationColor;
    if (isClassified)
    {
        discard;
    }
#else
    vec4 highlightColor = vec4(1.0);
    if (!isClassified)
    {
        discard;
    }
#endif
    out_FragColor = color * highlightColor;
    gl_FragDepth = texture(depthTexture, v_textureCoordinates).r;
}
`,opaqueFS=`uniform sampler2D colorTexture;
in vec2 v_textureCoordinates;
void main()
{
    vec4 color = texture(colorTexture, v_textureCoordinates);
    if (color.a == 0.0)
    {
        discard;
    }
#ifdef UNCLASSIFIED
    out_FragColor = color * czm_invertClassificationColor;
#else
    out_FragColor = color;
#endif
}
`;InvertClassification.prototype.update=function(e,t,n){const i=this._fbo.getColorTexture(),r=this.previousFramebuffer!==this._previousFramebuffer;this._previousFramebuffer=this.previousFramebuffer;const o=this._numSamples!==t,a=e.drawingBufferWidth,s=e.drawingBufferHeight,l=!defined(i)||i.width!==a||i.height!==s;if((l||r||o)&&(this._numSamples=t,this._depthStencilTexture=this._depthStencilTexture&&this._depthStencilTexture.destroy(),this._depthStencilRenderbuffer=this._depthStencilRenderbuffer&&this._depthStencilRenderbuffer.destroy(),defined(this._previousFramebuffer)||(this._depthStencilTexture=new Texture({context:e,width:a,height:s,pixelFormat:PixelFormat.DEPTH_STENCIL,pixelDatatype:PixelDatatype.UNSIGNED_INT_24_8}),t>1&&(this._depthStencilRenderbuffer=new Renderbuffer({context:e,width:a,height:s,format:RenderbufferFormat.DEPTH24_STENCIL8,numSamples:t})))),!defined(this._fbo.framebuffer)||l||r||o){this._fbo.destroy(),this._fboClassified.destroy();let c,d;defined(this._previousFramebuffer)?(c=n.getDepthStencilTexture(),d=n.getDepthStencilRenderbuffer()):(c=this._depthStencilTexture,d=this._depthStencilRenderbuffer),this._fbo.setDepthStencilTexture(c),defined(d)&&this._fbo.setDepthStencilRenderbuffer(d),this._fbo.update(e,a,s,t),defined(this._previousFramebuffer)||(this._fboClassified.setDepthStencilTexture(c),this._fboClassified.update(e,a,s))}if(defined(this._rsUnclassified)||(this._rsUnclassified=RenderState.fromCache(rsUnclassified),this._rsClassified=RenderState.fromCache(rsClassified),this._rsDefault=RenderState.fromCache(rsDefault)),!defined(this._unclassifiedCommand)||r||o){defined(this._unclassifiedCommand)&&(this._unclassifiedCommand.shaderProgram=this._unclassifiedCommand.shaderProgram&&this._unclassifiedCommand.shaderProgram.destroy(),this._classifiedCommand.shaderProgram=this._classifiedCommand.shaderProgram&&this._classifiedCommand.shaderProgram.destroy());const c=defined(this._previousFramebuffer)?opaqueFS:translucentFS,d=new ShaderSource({defines:["UNCLASSIFIED"],sources:[c]}),h=new ShaderSource({sources:[c]});this._unclassifiedCommand=e.createViewportQuadCommand(d,{renderState:defined(this._previousFramebuffer)?this._rsUnclassified:this._rsDefault,uniformMap:this._uniformMap,owner:this}),this._classifiedCommand=e.createViewportQuadCommand(h,{renderState:defined(this._previousFramebuffer)?this._rsClassified:this._rsDefault,uniformMap:this._uniformMap,owner:this}),defined(this._translucentCommand)&&(this._translucentCommand.shaderProgram=this._translucentCommand.shaderProgram&&this._translucentCommand.shaderProgram.destroy()),defined(this._previousFramebuffer)||(this._translucentCommand=e.createViewportQuadCommand(PassThrough,{renderState:this._rsUnclassified,uniformMap:this._uniformMap,owner:this}))}};InvertClassification.prototype.prepareTextures=function(e,t){this._fbo._numSamples>1&&this._fbo.prepareTextures(e,t)};InvertClassification.prototype.clear=function(e,t){defined(this._previousFramebuffer)?this._fbo.clear(e,this._clearColorCommand,t):(this._fbo.clear(e,this._clearCommand,t),this._fboClassified.clear(e,this._clearCommand,t))};InvertClassification.prototype.executeClassified=function(e,t){if(!defined(this._previousFramebuffer)){const n=t.framebuffer;this.prepareTextures(e,!0),t.framebuffer=this._fboClassified.framebuffer,this._translucentCommand.execute(e,t),t.framebuffer=n}this._classifiedCommand.execute(e,t)};InvertClassification.prototype.executeUnclassified=function(e,t){this._unclassifiedCommand.execute(e,t)};InvertClassification.prototype.isDestroyed=function(){return!1};InvertClassification.prototype.destroy=function(){return this._fbo.destroy(),this._fboClassified.destroy(),this._depthStencilTexture=this._depthStencilTexture&&this._depthStencilTexture.destroy(),this._depthStencilRenderbuffer=this._depthStencilRenderbuffer&&this._depthStencilRenderbuffer.destroy(),defined(this._unclassifiedCommand)&&(this._unclassifiedCommand.shaderProgram=this._unclassifiedCommand.shaderProgram&&this._unclassifiedCommand.shaderProgram.destroy(),this._classifiedCommand.shaderProgram=this._classifiedCommand.shaderProgram&&this._classifiedCommand.shaderProgram.destroy()),destroyObject(this)};function JobTypeBudget(e){this._total=e,this.usedThisFrame=0,this.stolenFromMeThisFrame=0,this.starvedThisFrame=!1,this.starvedLastFrame=!1}Object.defineProperties(JobTypeBudget.prototype,{total:{get:function(){return this._total}}});function JobScheduler(e){if(defined(e)&&e.length!==JobType.NUMBER_OF_JOB_TYPES)throw new DeveloperError("A budget must be specified for each job type; budgets.length should equal JobType.NUMBER_OF_JOB_TYPES.");const t=new Array(JobType.NUMBER_OF_JOB_TYPES);t[JobType.TEXTURE]=new JobTypeBudget(defined(e)?e[JobType.TEXTURE]:10),t[JobType.PROGRAM]=new JobTypeBudget(defined(e)?e[JobType.PROGRAM]:10),t[JobType.BUFFER]=new JobTypeBudget(defined(e)?e[JobType.BUFFER]:30);const n=t.length;let i,r=0;for(i=0;i<n;++i)r+=t[i].total;const o=new Array(n);for(i=0;i<n;++i)o[i]=!1;this._totalBudget=r,this._totalUsedThisFrame=0,this._budgets=t,this._executedThisFrame=o}JobScheduler.getTimestamp=getTimestamp;Object.defineProperties(JobScheduler.prototype,{totalBudget:{get:function(){return this._totalBudget}}});JobScheduler.prototype.disableThisFrame=function(){this._totalUsedThisFrame=this._totalBudget};JobScheduler.prototype.resetBudgets=function(){const e=this._budgets,t=e.length;for(let n=0;n<t;++n){const i=e[n];i.starvedLastFrame=i.starvedThisFrame,i.starvedThisFrame=!1,i.usedThisFrame=0,i.stolenFromMeThisFrame=0}this._totalUsedThisFrame=0};JobScheduler.prototype.execute=function(e,t){const n=this._budgets,i=n[t],r=this._executedThisFrame[t];if(this._totalUsedThisFrame>=this._totalBudget&&r)return i.starvedThisFrame=!0,!1;let o;if(i.usedThisFrame+i.stolenFromMeThisFrame>=i.total){const l=n.length;let c;for(c=0;c<l&&(o=n[c],!(o.usedThisFrame+o.stolenFromMeThisFrame<o.total&&!o.starvedLastFrame));++c);if(c===l&&r)return!1;r&&(i.starvedThisFrame=!0)}const a=JobScheduler.getTimestamp();e.execute();const s=JobScheduler.getTimestamp()-a;return this._totalUsedThisFrame+=s,o?o.stolenFromMeThisFrame+=s:i.usedThisFrame+=s,this._executedThisFrame[t]=!0,!0};function PerformanceDisplay(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=getElement(e.container);if(!defined(t))throw new DeveloperError("container is required");this._container=t;const n=document.createElement("div");n.className="cesium-performanceDisplay";const i=document.createElement("div");i.className="cesium-performanceDisplay-fps",this._fpsText=document.createTextNode(""),i.appendChild(this._fpsText);const r=document.createElement("div");r.className="cesium-performanceDisplay-ms",this._msText=document.createTextNode(""),r.appendChild(this._msText),n.appendChild(r),n.appendChild(i),this._container.appendChild(n),this._lastFpsSampleTime=getTimestamp(),this._lastMsSampleTime=getTimestamp(),this._fpsFrameCount=0,this._msFrameCount=0,this._throttled=!1;const o=document.createElement("div");o.className="cesium-performanceDisplay-throttled",this._throttledText=document.createTextNode(""),o.appendChild(this._throttledText),n.appendChild(o)}Object.defineProperties(PerformanceDisplay.prototype,{throttled:{get:function(){return this._throttled},set:function(e){this._throttled!==e&&(e?this._throttledText.nodeValue="(throttled)":this._throttledText.nodeValue="",this._throttled=e)}}});PerformanceDisplay.prototype.update=function(e){const t=getTimestamp(),n=defaultValue(e,!0);this._fpsFrameCount++;const i=t-this._lastFpsSampleTime;if(i>1e3){let o="N/A";n&&(o=this._fpsFrameCount*1e3/i|0),this._fpsText.nodeValue=`${o} FPS`,this._lastFpsSampleTime=t,this._fpsFrameCount=0}this._msFrameCount++;const r=t-this._lastMsSampleTime;if(r>200){let o="N/A";n&&(o=(r/this._msFrameCount).toFixed(2)),this._msText.nodeValue=`${o} MS`,this._lastMsSampleTime=t,this._msFrameCount=0}};PerformanceDisplay.prototype.destroy=function(){return destroyObject(this)};function PickDepth(){this._framebuffer=new FramebufferManager,this._textureToCopy=void 0,this._copyDepthCommand=void 0}Object.defineProperties(PickDepth.prototype,{framebuffer:{get:function(){return this._framebuffer.framebuffer}}});function updateFramebuffers$3(e,t,n){const i=n.width,r=n.height;e._framebuffer.update(t,i,r)}function updateCopyCommands$1(e,t,n){defined(e._copyDepthCommand)||(e._copyDepthCommand=t.createViewportQuadCommand(`uniform highp sampler2D colorTexture;

in vec2 v_textureCoordinates;

void main()
{
  vec4 globeDepthPacked = texture(czm_globeDepthTexture, v_textureCoordinates);
  float globeDepth = czm_unpackDepth(globeDepthPacked);
  float depth = texture(colorTexture, v_textureCoordinates).r;
  out_FragColor = czm_branchFreeTernary(globeDepth <= 0.0 || globeDepth >= 1.0 || depth < globeDepth && depth > 0.0 && depth < 1.0,
    czm_packDepth(depth), globeDepthPacked);
}
`,{renderState:RenderState.fromCache(),uniformMap:{colorTexture:function(){return e._textureToCopy}},owner:e})),e._textureToCopy=n,e._copyDepthCommand.framebuffer=e.framebuffer}PickDepth.prototype.update=function(e,t){updateFramebuffers$3(this,e,t),updateCopyCommands$1(this,e,t)};const scratchPackedDepth=new Cartesian4,packedDepthScale=new Cartesian4(1,1/255,1/65025,1/16581375);PickDepth.prototype.getDepth=function(e,t,n){if(!defined(this.framebuffer))return;const i=e.readPixels({x:t,y:n,width:1,height:1,framebuffer:this.framebuffer}),r=Cartesian4.unpack(i,0,scratchPackedDepth);return Cartesian4.divideByScalar(r,255,r),Cartesian4.dot(r,packedDepthScale)};PickDepth.prototype.executeCopyDepth=function(e,t){this._copyDepthCommand.execute(e,t)};PickDepth.prototype.isDestroyed=function(){return!1};PickDepth.prototype.destroy=function(){return this._framebuffer.destroy(),defined(this._copyDepthCommand)&&(this._copyDepthCommand.shaderProgram=defined(this._copyDepthCommand.shaderProgram)&&this._copyDepthCommand.shaderProgram.destroy()),destroyObject(this)};function FrustumCommands(e,t){this.near=defaultValue(e,0),this.far=defaultValue(t,0);const n=Pass.NUMBER_OF_PASSES,i=new Array(n),r=new Array(n);for(let o=0;o<n;++o)i[o]=[],r[o]=0;this.commands=i,this.indices=r}const PassThroughDepth=`uniform highp sampler2D u_depthTexture;

in vec2 v_textureCoordinates;

void main()
{
    out_FragColor = czm_packDepth(texture(u_depthTexture, v_textureCoordinates).r);
}
`;function GlobeDepth(){this._picking=!1,this._numSamples=1,this._tempCopyDepthTexture=void 0,this._pickColorFramebuffer=new FramebufferManager({depthStencil:!0,supportsDepthTexture:!0}),this._outputFramebuffer=new FramebufferManager({depthStencil:!0,supportsDepthTexture:!0}),this._copyDepthFramebuffer=new FramebufferManager,this._tempCopyDepthFramebuffer=new FramebufferManager,this._updateDepthFramebuffer=new FramebufferManager({createColorAttachments:!1,createDepthAttachments:!1,depthStencil:!0}),this._clearGlobeColorCommand=void 0,this._copyColorCommand=void 0,this._copyDepthCommand=void 0,this._tempCopyDepthCommand=void 0,this._updateDepthCommand=void 0,this._viewport=new BoundingRectangle,this._rs=void 0,this._rsBlend=void 0,this._rsUpdate=void 0,this._useScissorTest=!1,this._scissorRectangle=void 0,this._useHdr=void 0,this._clearGlobeDepth=void 0}Object.defineProperties(GlobeDepth.prototype,{colorFramebufferManager:{get:function(){return this._picking?this._pickColorFramebuffer:this._outputFramebuffer}},framebuffer:{get:function(){return this.colorFramebufferManager.framebuffer}},depthStencilTexture:{get:function(){return this.colorFramebufferManager.getDepthStencilTexture()}},picking:{get:function(){return this._picking},set:function(e){this._picking=e}}});function destroyFramebuffers$3(e){e._pickColorFramebuffer.destroy(),e._outputFramebuffer.destroy(),e._copyDepthFramebuffer.destroy(),e._tempCopyDepthFramebuffer.destroy(),e._updateDepthFramebuffer.destroy()}function updateCopyCommands(e,t,n,i,r){e._viewport.width=n,e._viewport.height=i;const o=!BoundingRectangle.equals(e._viewport,r.viewport);let a=o!==e._useScissorTest;e._useScissorTest=o,BoundingRectangle.equals(e._scissorRectangle,r.viewport)||(e._scissorRectangle=BoundingRectangle.clone(r.viewport,e._scissorRectangle),a=!0),(!defined(e._rs)||!BoundingRectangle.equals(e._viewport,e._rs.viewport)||a)&&(e._rs=RenderState.fromCache({viewport:e._viewport,scissorTest:{enabled:e._useScissorTest,rectangle:e._scissorRectangle}}),e._rsBlend=RenderState.fromCache({viewport:e._viewport,scissorTest:{enabled:e._useScissorTest,rectangle:e._scissorRectangle},blending:BlendingState.ALPHA_BLEND}),e._rsUpdate=RenderState.fromCache({viewport:e._viewport,scissorTest:{enabled:e._useScissorTest,rectangle:e._scissorRectangle},stencilTest:{enabled:!0,frontFunction:StencilFunction.EQUAL,frontOperation:{fail:StencilOperation.KEEP,zFail:StencilOperation.KEEP,zPass:StencilOperation.KEEP},backFunction:StencilFunction.NEVER,reference:StencilConstants.CESIUM_3D_TILE_MASK,mask:StencilConstants.CESIUM_3D_TILE_MASK}})),defined(e._copyDepthCommand)||(e._copyDepthCommand=t.createViewportQuadCommand(PassThroughDepth,{uniformMap:{u_depthTexture:function(){return e.colorFramebufferManager.getDepthStencilTexture()}},owner:e})),e._copyDepthCommand.framebuffer=e._copyDepthFramebuffer.framebuffer,e._copyDepthCommand.renderState=e._rs,defined(e._copyColorCommand)||(e._copyColorCommand=t.createViewportQuadCommand(PassThrough,{uniformMap:{colorTexture:function(){return e.colorFramebufferManager.getColorTexture()}},owner:e})),e._copyColorCommand.renderState=e._rs,defined(e._tempCopyDepthCommand)||(e._tempCopyDepthCommand=t.createViewportQuadCommand(PassThroughDepth,{uniformMap:{u_depthTexture:function(){return e._tempCopyDepthTexture}},owner:e})),e._tempCopyDepthCommand.framebuffer=e._tempCopyDepthFramebuffer.framebuffer,e._tempCopyDepthCommand.renderState=e._rs,defined(e._updateDepthCommand)||(e._updateDepthCommand=t.createViewportQuadCommand(PassThrough,{uniformMap:{colorTexture:function(){return e._tempCopyDepthFramebuffer.getColorTexture()}},owner:e})),e._updateDepthCommand.framebuffer=e._updateDepthFramebuffer.framebuffer,e._updateDepthCommand.renderState=e._rsUpdate,defined(e._clearGlobeColorCommand)||(e._clearGlobeColorCommand=new ClearCommand({color:new Color(0,0,0,0),stencil:0,owner:e})),e._clearGlobeColorCommand.framebuffer=e.framebuffer}GlobeDepth.prototype.update=function(e,t,n,i,r,o){const a=n.width,s=n.height,l=r?e.halfFloatingPointTexture?PixelDatatype.HALF_FLOAT:PixelDatatype.FLOAT:PixelDatatype.UNSIGNED_BYTE;this._numSamples=i,this.picking?this._pickColorFramebuffer.update(e,a,s):this._outputFramebuffer.update(e,a,s,i,l),this._copyDepthFramebuffer.update(e,a,s),updateCopyCommands(this,e,a,s,t),e.uniformState.globeDepthTexture=void 0,this._useHdr=r,this._clearGlobeDepth=o};GlobeDepth.prototype.prepareColorTextures=function(e,t){!this.picking&&this._numSamples>1&&this._outputFramebuffer.prepareTextures(e,t)};GlobeDepth.prototype.executeCopyDepth=function(e,t){defined(this._copyDepthCommand)&&(this.prepareColorTextures(e),this._copyDepthCommand.execute(e,t),e.uniformState.globeDepthTexture=this._copyDepthFramebuffer.getColorTexture())};GlobeDepth.prototype.executeUpdateDepth=function(e,t,n,i){const r=defined(i)?i:t.framebuffer.depthStencilTexture;if(n||r!==this.colorFramebufferManager.getDepthStencilTexture()){if(defined(this._updateDepthCommand)){if(!defined(this._updateDepthFramebuffer.framebuffer)||this._updateDepthFramebuffer.getDepthStencilTexture()!==r||this._updateDepthFramebuffer.getColorTexture()!==this._copyDepthFramebuffer.getColorTexture()){const o=this._copyDepthFramebuffer.getColorTexture().width,a=this._copyDepthFramebuffer.getColorTexture().height;this._tempCopyDepthFramebuffer.destroy(),this._tempCopyDepthFramebuffer.update(e,o,a);const s=this._copyDepthFramebuffer.getColorTexture();this._updateDepthFramebuffer.setColorTexture(s,0),this._updateDepthFramebuffer.setDepthStencilTexture(r),this._updateDepthFramebuffer.update(e,o,a),updateCopyCommands(this,e,o,a,t)}this._tempCopyDepthTexture=r,this._tempCopyDepthCommand.execute(e,t),this._updateDepthCommand.execute(e,t)}return}defined(this._copyDepthCommand)&&this._copyDepthCommand.execute(e,t)};GlobeDepth.prototype.executeCopyColor=function(e,t){defined(this._copyColorCommand)&&this._copyColorCommand.execute(e,t)};GlobeDepth.prototype.clear=function(e,t,n){const i=this._clearGlobeColorCommand;defined(i)&&(Color.clone(n,i.color),this.colorFramebufferManager.clear(e,i,t))};GlobeDepth.prototype.isDestroyed=function(){return!1};GlobeDepth.prototype.destroy=function(){return destroyFramebuffers$3(this),defined(this._copyColorCommand)&&(this._copyColorCommand.shaderProgram=this._copyColorCommand.shaderProgram.destroy()),defined(this._copyDepthCommand)&&(this._copyDepthCommand.shaderProgram=this._copyDepthCommand.shaderProgram.destroy()),defined(this._tempCopyDepthCommand)&&(this._tempCopyDepthCommand.shaderProgram=this._tempCopyDepthCommand.shaderProgram.destroy()),defined(this._updateDepthCommand)&&(this._updateDepthCommand.shaderProgram=this._updateDepthCommand.shaderProgram.destroy()),destroyObject(this)};function GlobeTranslucencyFramebuffer(){this._framebuffer=new FramebufferManager({depthStencil:!0,supportsDepthTexture:!0}),this._packedDepthFramebuffer=new FramebufferManager,this._renderState=void 0,this._packedDepthCommand=void 0,this._clearCommand=void 0,this._viewport=new BoundingRectangle,this._useScissorTest=!1,this._scissorRectangle=void 0,this._useHdr=void 0}Object.defineProperties(GlobeTranslucencyFramebuffer.prototype,{classificationTexture:{get:function(){return this._framebuffer.getColorTexture()}},classificationFramebuffer:{get:function(){return this._framebuffer.framebuffer}},packedDepthFramebuffer:{get:function(){return this._packedDepthFramebuffer.framebuffer}},depthStencilTexture:{get:function(){return this._framebuffer.getDepthStencilTexture()}},depthStencilRenderbuffer:{get:function(){return this._framebuffer.getDepthStencilRenderbuffer()}},packedDepthTexture:{get:function(){return this._packedDepthFramebuffer.getColorTexture()}}});function destroyResources$3(e){e._framebuffer.destroy(),e._packedDepthFramebuffer.destroy()}function updateResources$1(e,t,n,i,r){const o=r?t.halfFloatingPointTexture?PixelDatatype.HALF_FLOAT:PixelDatatype.FLOAT:PixelDatatype.UNSIGNED_BYTE;e._framebuffer.update(t,n,i,1,o),e._packedDepthFramebuffer.update(t,n,i)}function updateCommands(e,t,n,i,r){e._viewport.width=n,e._viewport.height=i;const o=!BoundingRectangle.equals(e._viewport,r.viewport);let a=o!==e._useScissorTest;e._useScissorTest=o,BoundingRectangle.equals(e._scissorRectangle,r.viewport)||(e._scissorRectangle=BoundingRectangle.clone(r.viewport,e._scissorRectangle),a=!0),(!defined(e._renderState)||!BoundingRectangle.equals(e._viewport,e._renderState.viewport)||a)&&(e._renderState=RenderState.fromCache({viewport:e._viewport,scissorTest:{enabled:e._useScissorTest,rectangle:e._scissorRectangle}})),defined(e._packedDepthCommand)||(e._packedDepthCommand=t.createViewportQuadCommand(PassThroughDepth,{uniformMap:{u_depthTexture:function(){return e.depthStencilTexture}},owner:e})),defined(e._clearCommand)||(e._clearCommand=new ClearCommand({color:new Color(0,0,0,0),depth:1,stencil:0,owner:e})),e._packedDepthCommand.framebuffer=e._packedDepthFramebuffer.framebuffer,e._packedDepthCommand.renderState=e._renderState,e._clearCommand.framebuffer=e.classificationFramebuffer,e._clearCommand.renderState=e._renderState}GlobeTranslucencyFramebuffer.prototype.updateAndClear=function(e,t,n,i){const r=t.width,o=t.height;updateResources$1(this,n,r,o,e),updateCommands(this,n,r,o,i),this._useHdr=e};GlobeTranslucencyFramebuffer.prototype.clearClassification=function(e,t){this._clearCommand.execute(e,t)};GlobeTranslucencyFramebuffer.prototype.packDepth=function(e,t){return this._packedDepthCommand.execute(e,t),this.packedDepthTexture};GlobeTranslucencyFramebuffer.prototype.isDestroyed=function(){return!1};GlobeTranslucencyFramebuffer.prototype.destroy=function(){return destroyResources$3(this),destroyObject(this)};function OIT(e){this._numSamples=1,this._translucentMultipassSupport=!1,this._translucentMRTSupport=!1;const t=e.colorBufferFloat&&e.depthTexture&&e.floatBlend;this._translucentMRTSupport=e.drawBuffers&&t,this._translucentMultipassSupport=!this._translucentMRTSupport&&t,this._opaqueFBO=void 0,this._opaqueTexture=void 0,this._depthStencilTexture=void 0,this._accumulationTexture=void 0,this._translucentFBO=new FramebufferManager({colorAttachmentsLength:this._translucentMRTSupport?2:1,createColorAttachments:!1,createDepthAttachments:!1,depth:!0}),this._alphaFBO=new FramebufferManager({createColorAttachments:!1,createDepthAttachments:!1,depth:!0}),this._adjustTranslucentFBO=new FramebufferManager({colorAttachmentsLength:this._translucentMRTSupport?2:1,createColorAttachments:!1}),this._adjustAlphaFBO=new FramebufferManager({createColorAttachments:!1}),this._opaqueClearCommand=new ClearCommand({color:new Color(0,0,0,0),owner:this}),this._translucentMRTClearCommand=new ClearCommand({color:new Color(0,0,0,1),owner:this}),this._translucentMultipassClearCommand=new ClearCommand({color:new Color(0,0,0,0),owner:this}),this._alphaClearCommand=new ClearCommand({color:new Color(1,1,1,1),owner:this}),this._translucentRenderStateCache={},this._alphaRenderStateCache={},this._compositeCommand=void 0,this._adjustTranslucentCommand=void 0,this._adjustAlphaCommand=void 0,this._viewport=new BoundingRectangle,this._rs=void 0,this._useScissorTest=!1,this._scissorRectangle=void 0,this._useHDR=!1}function destroyTextures$1(e){e._accumulationTexture=e._accumulationTexture&&!e._accumulationTexture.isDestroyed()&&e._accumulationTexture.destroy(),e._revealageTexture=e._revealageTexture&&!e._revealageTexture.isDestroyed()&&e._revealageTexture.destroy()}function destroyFramebuffers$2(e){e._translucentFBO.destroy(),e._alphaFBO.destroy(),e._adjustTranslucentFBO.destroy(),e._adjustAlphaFBO.destroy()}function destroyResources$2(e){destroyTextures$1(e),destroyFramebuffers$2(e)}function updateTextures$1(e,t,n,i){destroyTextures$1(e),e._accumulationTexture=new Texture({context:t,width:n,height:i,pixelFormat:PixelFormat.RGBA,pixelDatatype:PixelDatatype.FLOAT});const r=new Float32Array(n*i*4);e._revealageTexture=new Texture({context:t,pixelFormat:PixelFormat.RGBA,pixelDatatype:PixelDatatype.FLOAT,source:{arrayBufferView:r,width:n,height:i},flipY:!1})}function updateFramebuffers$2(e,t){destroyFramebuffers$2(e);const n=WebGLConstants.FRAMEBUFFER_COMPLETE;let i=!0;const{width:r,height:o}=e._accumulationTexture;if(e._translucentMRTSupport&&(e._translucentFBO.setColorTexture(e._accumulationTexture,0),e._translucentFBO.setColorTexture(e._revealageTexture,1),e._translucentFBO.setDepthStencilTexture(e._depthStencilTexture),e._translucentFBO.update(t,r,o),e._adjustTranslucentFBO.setColorTexture(e._accumulationTexture,0),e._adjustTranslucentFBO.setColorTexture(e._revealageTexture,1),e._adjustTranslucentFBO.update(t,r,o),(e._translucentFBO.status!==n||e._adjustTranslucentFBO.status!==n)&&(destroyFramebuffers$2(e),e._translucentMRTSupport=!1)),!e._translucentMRTSupport){e._translucentFBO.setColorTexture(e._accumulationTexture),e._translucentFBO.setDepthStencilTexture(e._depthStencilTexture),e._translucentFBO.update(t,r,o),e._alphaFBO.setColorTexture(e._revealageTexture),e._alphaFBO.setDepthStencilTexture(e._depthStencilTexture),e._alphaFBO.update(t,r,o),e._adjustTranslucentFBO.setColorTexture(e._accumulationTexture),e._adjustTranslucentFBO.update(t,r,o),e._adjustAlphaFBO.setColorTexture(e._revealageTexture),e._adjustAlphaFBO.update(t,r,o);const a=e._translucentFBO.status===n,s=e._alphaFBO.status===n,l=e._adjustTranslucentFBO.status===n,c=e._adjustAlphaFBO.status===n;(!a||!s||!l||!c)&&(destroyResources$2(e),e._translucentMultipassSupport=!1,i=!1)}return i}OIT.prototype.update=function(e,t,n,i,r){if(!this.isSupported())return;this._opaqueFBO=n,this._opaqueTexture=n.getColorTexture(0),this._depthStencilTexture=n.getDepthStencilTexture();const{width:o,height:a}=this._opaqueTexture,s=this._accumulationTexture,l=!defined(s)||s.width!==o||s.height!==a||i!==this._useHDR,c=this._numSamples!==r;if((l||c)&&(this._numSamples=r,updateTextures$1(this,e,o,a)),(!defined(this._translucentFBO.framebuffer)||l||c)&&!updateFramebuffers$2(this,e))return;this._useHDR=i;const d=this;let h,f;defined(this._compositeCommand)||(h=new ShaderSource({sources:[CompositeOITFS]}),this._translucentMRTSupport&&h.defines.push("MRT"),f={u_opaque:function(){return d._opaqueTexture},u_accumulation:function(){return d._accumulationTexture},u_revealage:function(){return d._revealageTexture}},this._compositeCommand=e.createViewportQuadCommand(h,{uniformMap:f,owner:this})),defined(this._adjustTranslucentCommand)||(this._translucentMRTSupport?(h=new ShaderSource({defines:["MRT"],sources:[AdjustTranslucentFS]}),f={u_bgColor:function(){return d._translucentMRTClearCommand.color},u_depthTexture:function(){return d._depthStencilTexture}},this._adjustTranslucentCommand=e.createViewportQuadCommand(h,{uniformMap:f,owner:this})):this._translucentMultipassSupport&&(h=new ShaderSource({sources:[AdjustTranslucentFS]}),f={u_bgColor:function(){return d._translucentMultipassClearCommand.color},u_depthTexture:function(){return d._depthStencilTexture}},this._adjustTranslucentCommand=e.createViewportQuadCommand(h,{uniformMap:f,owner:this}),f={u_bgColor:function(){return d._alphaClearCommand.color},u_depthTexture:function(){return d._depthStencilTexture}},this._adjustAlphaCommand=e.createViewportQuadCommand(h,{uniformMap:f,owner:this}))),this._viewport.width=o,this._viewport.height=a;const p=!BoundingRectangle.equals(this._viewport,t.viewport);let u=p!==this._useScissorTest;this._useScissorTest=p,BoundingRectangle.equals(this._scissorRectangle,t.viewport)||(this._scissorRectangle=BoundingRectangle.clone(t.viewport,this._scissorRectangle),u=!0),(!defined(this._rs)||!BoundingRectangle.equals(this._viewport,this._rs.viewport)||u)&&(this._rs=RenderState.fromCache({viewport:this._viewport,scissorTest:{enabled:this._useScissorTest,rectangle:this._scissorRectangle}})),defined(this._compositeCommand)&&(this._compositeCommand.renderState=this._rs),this._adjustTranslucentCommand&&(this._adjustTranslucentCommand.renderState=this._rs),defined(this._adjustAlphaCommand)&&(this._adjustAlphaCommand.renderState=this._rs)};const translucentMRTBlend={enabled:!0,color:new Color(0,0,0,0),equationRgb:BlendEquation.ADD,equationAlpha:BlendEquation.ADD,functionSourceRgb:BlendFunction.ONE,functionDestinationRgb:BlendFunction.ONE,functionSourceAlpha:BlendFunction.ZERO,functionDestinationAlpha:BlendFunction.ONE_MINUS_SOURCE_ALPHA},translucentColorBlend={enabled:!0,color:new Color(0,0,0,0),equationRgb:BlendEquation.ADD,equationAlpha:BlendEquation.ADD,functionSourceRgb:BlendFunction.ONE,functionDestinationRgb:BlendFunction.ONE,functionSourceAlpha:BlendFunction.ONE,functionDestinationAlpha:BlendFunction.ONE},translucentAlphaBlend={enabled:!0,color:new Color(0,0,0,0),equationRgb:BlendEquation.ADD,equationAlpha:BlendEquation.ADD,functionSourceRgb:BlendFunction.ZERO,functionDestinationRgb:BlendFunction.ONE_MINUS_SOURCE_ALPHA,functionSourceAlpha:BlendFunction.ZERO,functionDestinationAlpha:BlendFunction.ONE_MINUS_SOURCE_ALPHA};function getTranslucentRenderState(e,t,n,i){let r=n[i.id];if(!defined(r)){const o=RenderState.getState(i);o.depthMask=!1,o.blending=t,r=RenderState.fromCache(o),n[i.id]=r}return r}function getTranslucentMRTRenderState(e,t,n){return getTranslucentRenderState(t,translucentMRTBlend,e._translucentRenderStateCache,n)}function getTranslucentColorRenderState(e,t,n){return getTranslucentRenderState(t,translucentColorBlend,e._translucentRenderStateCache,n)}function getTranslucentAlphaRenderState(e,t,n){return getTranslucentRenderState(t,translucentAlphaBlend,e._alphaRenderStateCache,n)}const mrtShaderSource=`    vec3 Ci = czm_out_FragColor.rgb * czm_out_FragColor.a;
    float ai = czm_out_FragColor.a;
    float wzi = czm_alphaWeight(ai);
    out_FragData_0 = vec4(Ci * wzi, ai);
    out_FragData_1 = vec4(ai * wzi);
`,colorShaderSource=`    vec3 Ci = czm_out_FragColor.rgb * czm_out_FragColor.a;
    float ai = czm_out_FragColor.a;
    float wzi = czm_alphaWeight(ai);
    out_FragColor = vec4(Ci, ai) * wzi;
`,alphaShaderSource=`    float ai = czm_out_FragColor.a;
    out_FragColor = vec4(ai);
`;function getTranslucentShaderProgram(e,t,n,i){const{shaderCache:r}=e,o=r.getDerivedShaderProgram(t,n);if(defined(o))return o;const a=t._attributeLocations,s=t.fragmentShaderSource.clone();s.sources=s.sources.map(function(d){return ShaderSource.replaceMain(d,"czm_translucent_main").replace(/out_FragColor/g,"czm_out_FragColor").replace(/layout\s*\(location\s*=\s*0\)\s*out\s+vec4\s+out_FragColor;/g,"").replace(/\bdiscard\b/g,"czm_discard = true").replace(/czm_phong/g,"czm_translucentPhong")}),s.sources.splice(0,0,`vec4 czm_out_FragColor;
bool czm_discard = false;
`);const l=[...i.matchAll(/out_FragData_(\d+)/g)];let c="";for(let d=0;d<l.length;d++){const h=l[d];c=`layout (location = ${h[1]}) out vec4 ${h[0]};
${c}`}return s.sources.push(c),s.sources.push(`void main()
{
    czm_translucent_main();
    if (czm_discard)
    {
        discard;
    }
${i}}
`),r.createDerivedShaderProgram(t,n,{vertexShaderSource:t.vertexShaderSource,fragmentShaderSource:s,attributeLocations:a})}function getTranslucentMRTShaderProgram(e,t){return getTranslucentShaderProgram(e,t,"translucentMRT",mrtShaderSource)}function getTranslucentColorShaderProgram(e,t){return getTranslucentShaderProgram(e,t,"translucentMultipass",colorShaderSource)}function getTranslucentAlphaShaderProgram(e,t){return getTranslucentShaderProgram(e,t,"alphaMultipass",alphaShaderSource)}OIT.prototype.createDerivedCommands=function(e,t,n){if(defined(n)||(n={}),this._translucentMRTSupport){let s,l;return defined(n.translucentCommand)&&(s=n.translucentCommand.shaderProgram,l=n.translucentCommand.renderState),n.translucentCommand=DrawCommand.shallowClone(e,n.translucentCommand),!defined(s)||n.shaderProgramId!==e.shaderProgram.id?(n.translucentCommand.shaderProgram=getTranslucentMRTShaderProgram(t,e.shaderProgram),n.translucentCommand.renderState=getTranslucentMRTRenderState(this,t,e.renderState),n.shaderProgramId=e.shaderProgram.id):(n.translucentCommand.shaderProgram=s,n.translucentCommand.renderState=l),n}let i,r,o,a;return defined(n.translucentCommand)&&(i=n.translucentCommand.shaderProgram,r=n.translucentCommand.renderState,o=n.alphaCommand.shaderProgram,a=n.alphaCommand.renderState),n.translucentCommand=DrawCommand.shallowClone(e,n.translucentCommand),n.alphaCommand=DrawCommand.shallowClone(e,n.alphaCommand),!defined(i)||n.shaderProgramId!==e.shaderProgram.id?(n.translucentCommand.shaderProgram=getTranslucentColorShaderProgram(t,e.shaderProgram),n.translucentCommand.renderState=getTranslucentColorRenderState(this,t,e.renderState),n.alphaCommand.shaderProgram=getTranslucentAlphaShaderProgram(t,e.shaderProgram),n.alphaCommand.renderState=getTranslucentAlphaRenderState(this,t,e.renderState),n.shaderProgramId=e.shaderProgram.id):(n.translucentCommand.shaderProgram=i,n.translucentCommand.renderState=r,n.alphaCommand.shaderProgram=o,n.alphaCommand.renderState=a),n};function executeTranslucentCommandsSortedMultipass(e,t,n,i,r,o){let a,s,l;const{context:c,frameState:d}=t,{useLogDepth:h,shadowState:f}=d,p=t._hdr,u=i.framebuffer,m=f.lightShadowsEnabled;i.framebuffer=e._adjustTranslucentFBO.framebuffer,e._adjustTranslucentCommand.execute(c,i),i.framebuffer=e._adjustAlphaFBO.framebuffer,e._adjustAlphaCommand.execute(c,i);const g=e._opaqueFBO.framebuffer;for(i.framebuffer=e._translucentFBO.framebuffer,l=0;l<r.length;++l)a=r[l],a=h?a.derivedCommands.logDepth.command:a,a=p?a.derivedCommands.hdr.command:a,s=m&&a.receiveShadows?a.derivedCommands.oit.shadows.translucentCommand:a.derivedCommands.oit.translucentCommand,n(s,t,c,i,g);for(defined(o)&&(a=o.unclassifiedCommand,s=m&&a.receiveShadows?a.derivedCommands.oit.shadows.translucentCommand:a.derivedCommands.oit.translucentCommand,n(s,t,c,i,g)),i.framebuffer=e._alphaFBO.framebuffer,l=0;l<r.length;++l)a=r[l],a=h?a.derivedCommands.logDepth.command:a,a=p?a.derivedCommands.hdr.command:a,s=m&&a.receiveShadows?a.derivedCommands.oit.shadows.alphaCommand:a.derivedCommands.oit.alphaCommand,n(s,t,c,i,g);defined(o)&&(a=o.unclassifiedCommand,s=m&&a.receiveShadows?a.derivedCommands.oit.shadows.alphaCommand:a.derivedCommands.oit.alphaCommand,n(s,t,c,i,g)),i.framebuffer=u}function executeTranslucentCommandsSortedMRT(e,t,n,i,r,o){const{context:a,frameState:s}=t,{useLogDepth:l,shadowState:c}=s,d=t._hdr,h=i.framebuffer,f=c.lightShadowsEnabled;i.framebuffer=e._adjustTranslucentFBO.framebuffer,e._adjustTranslucentCommand.execute(a,i);const p=e._opaqueFBO.framebuffer;i.framebuffer=e._translucentFBO.framebuffer;let u,m;for(let g=0;g<r.length;++g)u=r[g],u=l?u.derivedCommands.logDepth.command:u,u=d?u.derivedCommands.hdr.command:u,m=f&&u.receiveShadows?u.derivedCommands.oit.shadows.translucentCommand:u.derivedCommands.oit.translucentCommand,n(m,t,a,i,p);defined(o)&&(u=o.unclassifiedCommand,m=f&&u.receiveShadows?u.derivedCommands.oit.shadows.translucentCommand:u.derivedCommands.oit.translucentCommand,n(m,t,a,i,p)),i.framebuffer=h}OIT.prototype.executeCommands=function(e,t,n,i,r){if(this._translucentMRTSupport){executeTranslucentCommandsSortedMRT(this,e,t,n,i,r);return}executeTranslucentCommandsSortedMultipass(this,e,t,n,i,r)};OIT.prototype.execute=function(e,t){this._compositeCommand.execute(e,t)};OIT.prototype.clear=function(e,t,n){const i=t.framebuffer;t.framebuffer=this._opaqueFBO.framebuffer,Color.clone(n,this._opaqueClearCommand.color),this._opaqueClearCommand.execute(e,t),t.framebuffer=this._translucentFBO.framebuffer,(this._translucentMRTSupport?this._translucentMRTClearCommand:this._translucentMultipassClearCommand).execute(e,t),this._translucentMultipassSupport&&(t.framebuffer=this._alphaFBO.framebuffer,this._alphaClearCommand.execute(e,t)),t.framebuffer=i};OIT.prototype.isSupported=function(){return this._translucentMRTSupport||this._translucentMultipassSupport};OIT.prototype.isDestroyed=function(){return!1};OIT.prototype.destroy=function(){return destroyResources$2(this),defined(this._compositeCommand)&&(this._compositeCommand.shaderProgram=this._compositeCommand.shaderProgram&&this._compositeCommand.shaderProgram.destroy()),defined(this._adjustTranslucentCommand)&&(this._adjustTranslucentCommand.shaderProgram=this._adjustTranslucentCommand.shaderProgram&&this._adjustTranslucentCommand.shaderProgram.destroy()),defined(this._adjustAlphaCommand)&&(this._adjustAlphaCommand.shaderProgram=this._adjustAlphaCommand.shaderProgram&&this._adjustAlphaCommand.shaderProgram.destroy()),destroyObject(this)};function PickDepthFramebuffer(){this._framebuffer=new FramebufferManager({color:!1,depthStencil:!0,supportsDepthTexture:!0}),this._passState=void 0}Object.defineProperties(PickDepthFramebuffer.prototype,{framebuffer:{get:function(){return this._framebuffer.framebuffer}}});function destroyResources$1(e){e._framebuffer.destroy()}function createResources$1(e,t){const n=t.drawingBufferWidth,i=t.drawingBufferHeight;e._framebuffer.update(t,n,i);const r=new PassState(t);r.blendingEnabled=!1,r.scissorTest={enabled:!0,rectangle:new BoundingRectangle},r.viewport=new BoundingRectangle,e._passState=r}PickDepthFramebuffer.prototype.update=function(e,t,n){const i=n.width,r=n.height;this._framebuffer.isDirty(i,r)&&createResources$1(this,e);const o=this.framebuffer,a=this._passState;return a.framebuffer=o,a.viewport.width=i,a.viewport.height=r,a.scissorTest.rectangle.x=t.x,a.scissorTest.rectangle.y=r-t.y,a.scissorTest.rectangle.width=1,a.scissorTest.rectangle.height=1,a};PickDepthFramebuffer.prototype.isDestroyed=function(){return!1};PickDepthFramebuffer.prototype.destroy=function(){return destroyResources$1(this),destroyObject(this)};function PickFramebuffer(e){const t=new PassState(e);t.blendingEnabled=!1,t.scissorTest={enabled:!0,rectangle:new BoundingRectangle},t.viewport=new BoundingRectangle,this._context=e,this._fb=new FramebufferManager({depthStencil:!0}),this._passState=t,this._width=0,this._height=0}PickFramebuffer.prototype.begin=function(e,t){const n=this._context,{width:i,height:r}=t;return BoundingRectangle.clone(e,this._passState.scissorTest.rectangle),this._width=i,this._height=r,this._fb.update(n,i,r),this._passState.framebuffer=this._fb.framebuffer,this._passState.viewport.width=i,this._passState.viewport.height=r,this._passState};const colorScratch=new Color;PickFramebuffer.prototype.end=function(e){const t=defaultValue(e.width,1),n=defaultValue(e.height,1),i=this._context,r=i.readPixels({x:e.x,y:e.y,width:t,height:n,framebuffer:this._fb.framebuffer}),o=Math.max(t,n),a=o*o,s=Math.floor(t*.5),l=Math.floor(n*.5);let c=0,d=0,h=0,f=-1;for(let p=0;p<a;++p){if(-s<=c&&c<=s&&-l<=d&&d<=l){const u=4*((l-d)*t+c+s);colorScratch.red=Color.byteToFloat(r[u]),colorScratch.green=Color.byteToFloat(r[u+1]),colorScratch.blue=Color.byteToFloat(r[u+2]),colorScratch.alpha=Color.byteToFloat(r[u+3]);const m=i.getObjectByPickColor(colorScratch);if(defined(m))return m}if(c===d||c<0&&-c===d||c>0&&c===1-d){const u=h;h=-f,f=u}c+=h,d+=f}};PickFramebuffer.prototype.readVoxelInfo=function(e){const t=defaultValue(e.width,1),n=defaultValue(e.height,1),r=this._context.readPixels({x:e.x,y:e.y,width:t,height:n,framebuffer:this._fb.framebuffer}),o=Math.floor(t*.5),s=4*(Math.floor(n*.5)*t+o);return r.slice(s,s+4)};PickFramebuffer.prototype.isDestroyed=function(){return!1};PickFramebuffer.prototype.destroy=function(){return this._fb.destroy(),destroyObject(this)};function SceneFramebuffer(){this._numSamples=1,this._colorFramebuffer=new FramebufferManager({depthStencil:!0,supportsDepthTexture:!0}),this._idFramebuffer=new FramebufferManager({depthStencil:!0,supportsDepthTexture:!0}),this._idClearColor=new Color(0,0,0,0),this._clearCommand=new ClearCommand({color:new Color(0,0,0,0),depth:1,owner:this})}function destroyResources(e){e._colorFramebuffer.destroy(),e._idFramebuffer.destroy()}Object.defineProperties(SceneFramebuffer.prototype,{framebuffer:{get:function(){return this._colorFramebuffer.framebuffer}},idFramebuffer:{get:function(){return this._idFramebuffer.framebuffer}},depthStencilTexture:{get:function(){return this._colorFramebuffer.getDepthStencilTexture()}}});SceneFramebuffer.prototype.update=function(e,t,n,i){const r=t.width,o=t.height,a=n?e.halfFloatingPointTexture?PixelDatatype.HALF_FLOAT:PixelDatatype.FLOAT:PixelDatatype.UNSIGNED_BYTE;this._numSamples=i,this._colorFramebuffer.update(e,r,o,i,a),this._idFramebuffer.update(e,r,o)};SceneFramebuffer.prototype.clear=function(e,t,n){Color.clone(n,this._clearCommand.color),Color.clone(this._idClearColor,this._clearCommand.color),this._colorFramebuffer.clear(e,this._clearCommand,t),this._idFramebuffer.clear(e,this._clearCommand,t)};SceneFramebuffer.prototype.getFramebuffer=function(){return this._colorFramebuffer.framebuffer};SceneFramebuffer.prototype.getIdFramebuffer=function(){return this._idFramebuffer.framebuffer};SceneFramebuffer.prototype.prepareColorTextures=function(e){this._numSamples>1&&this._colorFramebuffer.prepareTextures(e)};SceneFramebuffer.prototype.isDestroyed=function(){return!1};SceneFramebuffer.prototype.destroy=function(){return destroyResources(this),destroyObject(this)};function ShadowMapShader(){}ShadowMapShader.getShadowCastShaderKeyword=function(e,t,n,i){return`castShadow ${e} ${t} ${n} ${i}`};ShadowMapShader.createShadowCastVertexShader=function(e,t,n){const i=e.defines.slice(0),r=e.sources.slice(0);i.push("SHADOW_MAP"),n&&i.push("GENERATE_POSITION");const o=ShaderSource.findPositionVarying(e),a=defined(o);if(t&&!a){const s=r.length;for(let c=0;c<s;++c)r[c]=ShaderSource.replaceMain(r[c],"czm_shadow_cast_main");r.push(`out vec3 v_positionEC; 
void main() 
{ 
    czm_shadow_cast_main(); 
    v_positionEC = (czm_inverseProjection * gl_Position).xyz; 
}`)}return new ShaderSource({defines:i,sources:r})};ShadowMapShader.createShadowCastFragmentShader=function(e,t,n,i){const r=e.defines.slice(0),o=e.sources.slice(0);r.push("SHADOW_MAP");let a=ShaderSource.findPositionVarying(e);const s=defined(a);s||(a="v_positionEC");const l=o.length;for(let d=0;d<l;++d)o[d]=ShaderSource.replaceMain(o[d],"czm_shadow_cast_main");let c="";return t&&(s||(c+=`in vec3 v_positionEC; 
`),c+=`uniform vec4 shadowMap_lightPositionEC; 
`),i?c+=`void main() 
{ 
`:c+=`void main() 
{ 
    czm_shadow_cast_main(); 
    if (out_FragColor.a == 0.0) 
    { 
       discard; 
    } 
`,t?c+=`    float distance = length(${a}); 
    if (distance >= shadowMap_lightPositionEC.w) 
    { 
        discard; 
    } 
    distance /= shadowMap_lightPositionEC.w; // radius 
    out_FragColor = czm_packDepth(distance); 
`:n?c+=`    out_FragColor = vec4(1.0); 
`:c+=`    out_FragColor = czm_packDepth(gl_FragCoord.z); 
`,c+=`} 
`,o.push(c),new ShaderSource({defines:r,sources:o})};ShadowMapShader.getShadowReceiveShaderKeyword=function(e,t,n,i){const r=e._usesDepthTexture,o=e._polygonOffsetSupported,a=e._isPointLight,s=e._isSpotLight,l=e._numberOfCascades>1,c=e.debugCascadeColors,d=e.softShadows;return`receiveShadow ${r}${o}${a}${s}${l}${c}${d}${t}${n}${i}`};ShadowMapShader.createShadowReceiveVertexShader=function(e,t,n){const i=e.defines.slice(0),r=e.sources.slice(0);return i.push("SHADOW_MAP"),t&&(n?i.push("GENERATE_POSITION_AND_NORMAL"):i.push("GENERATE_POSITION")),new ShaderSource({defines:i,sources:r})};ShadowMapShader.createShadowReceiveFragmentShader=function(e,t,n,i,r){const o=ShaderSource.findNormalVarying(e),a=!i&&defined(o)||i&&r,s=ShaderSource.findPositionVarying(e),l=defined(s),c=t._usesDepthTexture,d=t._polygonOffsetSupported,h=t._isPointLight,f=t._isSpotLight,p=t._numberOfCascades>1,u=t.debugCascadeColors,m=t.softShadows,g=h?t._pointBias:i?t._terrainBias:t._primitiveBias,_=e.defines.slice(0),C=e.sources.slice(0),A=C.length;for(let b=0;b<A;++b)C[b]=ShaderSource.replaceMain(C[b],"czm_shadow_receive_main");h?_.push("USE_CUBE_MAP_SHADOW"):c&&_.push("USE_SHADOW_DEPTH_TEXTURE"),m&&!h&&_.push("USE_SOFT_SHADOWS"),p&&n&&i&&(a?_.push("ENABLE_VERTEX_LIGHTING"):_.push("ENABLE_DAYNIGHT_SHADING")),n&&g.normalShading&&a&&(_.push("USE_NORMAL_SHADING"),g.normalShadingSmooth>0&&_.push("USE_NORMAL_SHADING_SMOOTH"));let S="";h?S+=`uniform samplerCube shadowMap_textureCube; 
`:S+=`uniform sampler2D shadowMap_texture; 
`;let v;return l?v=`    return vec4(${s}, 1.0); 
`:v=`#ifndef LOG_DEPTH 
    return czm_windowToEyeCoordinates(gl_FragCoord); 
#else 
    return vec4(v_logPositionEC, 1.0); 
#endif 
`,S+=`uniform mat4 shadowMap_matrix; 
uniform vec3 shadowMap_lightDirectionEC; 
uniform vec4 shadowMap_lightPositionEC; 
uniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; 
uniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; 
#ifdef LOG_DEPTH 
in vec3 v_logPositionEC; 
#endif 
vec4 getPositionEC() 
{ 
${v}} 
vec3 getNormalEC() 
{ 
${a?`    return normalize(${o}); 
`:`    return vec3(1.0); 
`}} 
void applyNormalOffset(inout vec4 positionEC, vec3 normalEC, float nDotL) 
{ 
${g.normalOffset&&a?`    float normalOffset = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.x; 
    float normalOffsetScale = 1.0 - nDotL; 
    vec3 offset = normalOffset * normalOffsetScale * normalEC; 
    positionEC.xyz += offset; 
`:""}} 
`,S+=`void main() 
{ 
    czm_shadow_receive_main(); 
    vec4 positionEC = getPositionEC(); 
    vec3 normalEC = getNormalEC(); 
    float depth = -positionEC.z; 
`,S+=`    czm_shadowParameters shadowParameters; 
    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; 
    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; 
    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; 
    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; 
`,i?S+=`    shadowParameters.depthBias *= max(depth * 0.01, 1.0); 
`:d||(S+=`    shadowParameters.depthBias *= mix(1.0, 100.0, depth * 0.0015); 
`),h?S+=`    vec3 directionEC = positionEC.xyz - shadowMap_lightPositionEC.xyz; 
    float distance = length(directionEC); 
    directionEC = normalize(directionEC); 
    float radius = shadowMap_lightPositionEC.w; 
    // Stop early if the fragment is beyond the point light radius 
    if (distance > radius) 
    { 
        return; 
    } 
    vec3 directionWC  = czm_inverseViewRotation * directionEC; 
    shadowParameters.depth = distance / radius; 
    shadowParameters.nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); 
    shadowParameters.texCoords = directionWC; 
    float visibility = czm_shadowVisibility(shadowMap_textureCube, shadowParameters); 
`:f?S+=`    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); 
    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); 
    applyNormalOffset(positionEC, normalEC, nDotL); 
    vec4 shadowPosition = shadowMap_matrix * positionEC; 
    // Spot light uses a perspective projection, so perform the perspective divide 
    shadowPosition /= shadowPosition.w; 
    // Stop early if the fragment is not in the shadow bounds 
    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) 
    { 
        return; 
    } 
    shadowParameters.texCoords = shadowPosition.xy; 
    shadowParameters.depth = shadowPosition.z; 
    shadowParameters.nDotL = nDotL; 
    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); 
`:p?S+=`    float maxDepth = shadowMap_cascadeSplits[1].w; 
    // Stop early if the eye depth exceeds the last cascade 
    if (depth > maxDepth) 
    { 
        return; 
    } 
    // Get the cascade based on the eye-space depth 
    vec4 weights = czm_cascadeWeights(depth); 
    // Apply normal offset 
    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); 
    applyNormalOffset(positionEC, normalEC, nDotL); 
    // Transform position into the cascade 
    vec4 shadowPosition = czm_cascadeMatrix(weights) * positionEC; 
    // Get visibility 
    shadowParameters.texCoords = shadowPosition.xy; 
    shadowParameters.depth = shadowPosition.z; 
    shadowParameters.nDotL = nDotL; 
    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); 
    // Fade out shadows that are far away 
    float shadowMapMaximumDistance = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.z; 
    float fade = max((depth - shadowMapMaximumDistance * 0.8) / (shadowMapMaximumDistance * 0.2), 0.0); 
    visibility = mix(visibility, 1.0, fade); 
${u?`    // Draw cascade colors for debugging 
    out_FragColor *= czm_cascadeColor(weights); 
`:""}`:S+=`    float nDotL = clamp(dot(normalEC, shadowMap_lightDirectionEC), 0.0, 1.0); 
    applyNormalOffset(positionEC, normalEC, nDotL); 
    vec4 shadowPosition = shadowMap_matrix * positionEC; 
    // Stop early if the fragment is not in the shadow bounds 
    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) 
    { 
        return; 
    } 
    shadowParameters.texCoords = shadowPosition.xy; 
    shadowParameters.depth = shadowPosition.z; 
    shadowParameters.nDotL = nDotL; 
    float visibility = czm_shadowVisibility(shadowMap_texture, shadowParameters); 
`,S+=`    out_FragColor.rgb *= visibility; 
} 
`,C.push(S),new ShaderSource({defines:_,sources:C})};function ShadowMap(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.context;if(!defined(t))throw new DeveloperError("context is required.");if(!defined(e.lightCamera))throw new DeveloperError("lightCamera is required.");if(defined(e.numberOfCascades)&&e.numberOfCascades!==1&&e.numberOfCascades!==4)throw new DeveloperError("Only one or four cascades are supported.");this._enabled=defaultValue(e.enabled,!0),this._softShadows=defaultValue(e.softShadows,!1),this._normalOffset=defaultValue(e.normalOffset,!0),this.dirty=!0,this.fromLightSource=defaultValue(e.fromLightSource,!0),this.darkness=defaultValue(e.darkness,.3),this._darkness=this.darkness,this.fadingEnabled=defaultValue(e.fadingEnabled,!0),this.maximumDistance=defaultValue(e.maximumDistance,5e3),this._outOfView=!1,this._outOfViewPrevious=!1,this._needsUpdate=!0;let n=!0;(FeatureDetection.isInternetExplorer()||FeatureDetection.isEdge()||(FeatureDetection.isChrome()||FeatureDetection.isFirefox())&&FeatureDetection.isWindows()&&!t.depthTexture)&&(n=!1),this._polygonOffsetSupported=n,this._terrainBias={polygonOffset:n,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:.5,normalShading:!0,normalShadingSmooth:.3,depthBias:1e-4},this._primitiveBias={polygonOffset:n,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:.1,normalShading:!0,normalShadingSmooth:.05,depthBias:2e-5},this._pointBias={polygonOffset:!1,polygonOffsetFactor:1.1,polygonOffsetUnits:4,normalOffset:this._normalOffset,normalOffsetScale:0,normalShading:!0,normalShadingSmooth:.1,depthBias:5e-4},this._depthAttachment=void 0,this._colorAttachment=void 0,this._shadowMapMatrix=new Matrix4,this._shadowMapTexture=void 0,this._lightDirectionEC=new Cartesian3,this._lightPositionEC=new Cartesian4,this._distance=0,this._lightCamera=e.lightCamera,this._shadowMapCamera=new ShadowMapCamera,this._shadowMapCullingVolume=void 0,this._sceneCamera=void 0,this._boundingSphere=new BoundingSphere,this._isPointLight=defaultValue(e.isPointLight,!1),this._pointLightRadius=defaultValue(e.pointLightRadius,100),this._cascadesEnabled=this._isPointLight?!1:defaultValue(e.cascadesEnabled,!0),this._numberOfCascades=this._cascadesEnabled?defaultValue(e.numberOfCascades,4):0,this._fitNearFar=!0,this._maximumCascadeDistances=[25,150,700,Number.MAX_VALUE],this._textureSize=new Cartesian2,this._isSpotLight=!1,this._cascadesEnabled?this._shadowMapCamera.frustum=new OrthographicOffCenterFrustum:defined(this._lightCamera.frustum.fov)&&(this._isSpotLight=!0),this._cascadeSplits=[new Cartesian4,new Cartesian4],this._cascadeMatrices=[new Matrix4,new Matrix4,new Matrix4,new Matrix4],this._cascadeDistances=new Cartesian4;let i;this._isPointLight?i=6:this._cascadesEnabled?i=this._numberOfCascades:i=1,this._passes=new Array(i);for(let r=0;r<i;++r)this._passes[r]=new ShadowPass(t);this.debugShow=!1,this.debugFreezeFrame=!1,this._debugFreezeFrame=!1,this._debugCascadeColors=!1,this._debugLightFrustum=void 0,this._debugCameraFrustum=void 0,this._debugCascadeFrustums=new Array(this._numberOfCascades),this._debugShadowViewCommand=void 0,this._usesDepthTexture=t.depthTexture,this._isPointLight&&(this._usesDepthTexture=!1),this._primitiveRenderState=void 0,this._terrainRenderState=void 0,this._pointRenderState=void 0,createRenderStates(this),this._clearCommand=new ClearCommand({depth:1,color:new Color}),this._clearPassState=new PassState(t),this._size=defaultValue(e.size,2048),this.size=this._size}ShadowMap.MAXIMUM_DISTANCE=2e4;function ShadowPass(e){this.camera=new ShadowMapCamera,this.passState=new PassState(e),this.framebuffer=void 0,this.textureOffsets=void 0,this.commandList=[],this.cullingVolume=void 0}function createRenderState(e,t){return RenderState.fromCache({cull:{enabled:!0,face:CullFace.BACK},depthTest:{enabled:!0},colorMask:{red:e,green:e,blue:e,alpha:e},depthMask:!0,polygonOffset:{enabled:t.polygonOffset,factor:t.polygonOffsetFactor,units:t.polygonOffsetUnits}})}function createRenderStates(e){const t=!e._usesDepthTexture;e._primitiveRenderState=createRenderState(t,e._primitiveBias),e._terrainRenderState=createRenderState(t,e._terrainBias),e._pointRenderState=createRenderState(t,e._pointBias)}ShadowMap.prototype.debugCreateRenderStates=function(){createRenderStates(this)};Object.defineProperties(ShadowMap.prototype,{enabled:{get:function(){return this._enabled},set:function(e){this.dirty=this._enabled!==e,this._enabled=e}},normalOffset:{get:function(){return this._normalOffset},set:function(e){this.dirty=this._normalOffset!==e,this._normalOffset=e,this._terrainBias.normalOffset=e,this._primitiveBias.normalOffset=e,this._pointBias.normalOffset=e}},softShadows:{get:function(){return this._softShadows},set:function(e){this.dirty=this._softShadows!==e,this._softShadows=e}},size:{get:function(){return this._size},set:function(e){resize(this,e)}},outOfView:{get:function(){return this._outOfView}},shadowMapCullingVolume:{get:function(){return this._shadowMapCullingVolume}},passes:{get:function(){return this._passes}},isPointLight:{get:function(){return this._isPointLight}},debugCascadeColors:{get:function(){return this._debugCascadeColors},set:function(e){this.dirty=this._debugCascadeColors!==e,this._debugCascadeColors=e}}});function destroyFramebuffer(e){const t=e._passes.length;for(let n=0;n<t;++n){const i=e._passes[n],r=i.framebuffer;defined(r)&&!r.isDestroyed()&&r.destroy(),i.framebuffer=void 0}e._depthAttachment=e._depthAttachment&&e._depthAttachment.destroy(),e._colorAttachment=e._colorAttachment&&e._colorAttachment.destroy()}function createFramebufferColor(e,t){const n=new Renderbuffer({context:t,width:e._textureSize.x,height:e._textureSize.y,format:RenderbufferFormat.DEPTH_COMPONENT16}),i=new Texture({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:PixelFormat.RGBA,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,sampler:Sampler.NEAREST}),r=new Framebuffer({context:t,depthRenderbuffer:n,colorTextures:[i],destroyAttachments:!1}),o=e._passes.length;for(let a=0;a<o;++a){const s=e._passes[a];s.framebuffer=r,s.passState.framebuffer=r}e._shadowMapTexture=i,e._depthAttachment=n,e._colorAttachment=i}function createFramebufferDepth(e,t){const n=new Texture({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:PixelFormat.DEPTH_STENCIL,pixelDatatype:PixelDatatype.UNSIGNED_INT_24_8,sampler:Sampler.NEAREST}),i=new Framebuffer({context:t,depthStencilTexture:n,destroyAttachments:!1}),r=e._passes.length;for(let o=0;o<r;++o){const a=e._passes[o];a.framebuffer=i,a.passState.framebuffer=i}e._shadowMapTexture=n,e._depthAttachment=n}function createFramebufferCube(e,t){const n=new Renderbuffer({context:t,width:e._textureSize.x,height:e._textureSize.y,format:RenderbufferFormat.DEPTH_COMPONENT16}),i=new CubeMap({context:t,width:e._textureSize.x,height:e._textureSize.y,pixelFormat:PixelFormat.RGBA,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,sampler:Sampler.NEAREST}),r=[i.negativeX,i.negativeY,i.negativeZ,i.positiveX,i.positiveY,i.positiveZ];for(let o=0;o<6;++o){const a=new Framebuffer({context:t,depthRenderbuffer:n,colorTextures:[r[o]],destroyAttachments:!1}),s=e._passes[o];s.framebuffer=a,s.passState.framebuffer=a}e._shadowMapTexture=i,e._depthAttachment=n,e._colorAttachment=i}function createFramebuffer(e,t){e._isPointLight?createFramebufferCube(e,t):e._usesDepthTexture?createFramebufferDepth(e,t):createFramebufferColor(e,t)}function checkFramebuffer(e,t){e._usesDepthTexture&&e._passes[0].framebuffer.status!==WebGLConstants.FRAMEBUFFER_COMPLETE&&(e._usesDepthTexture=!1,createRenderStates(e),destroyFramebuffer(e),createFramebuffer(e,t))}function updateFramebuffer(e,t){(!defined(e._passes[0].framebuffer)||e._shadowMapTexture.width!==e._textureSize.x)&&(destroyFramebuffer(e),createFramebuffer(e,t),checkFramebuffer(e,t),clearFramebuffer(e,t))}function clearFramebuffer(e,t,n){n=defaultValue(n,0),(e._isPointLight||n===0)&&(e._clearCommand.framebuffer=e._passes[n].framebuffer,e._clearCommand.execute(t,e._clearPassState))}function resize(e,t){e._size=t;const n=e._passes,i=n.length,r=e._textureSize;if(e._isPointLight){t=ContextLimits.maximumCubeMapSize>=t?t:ContextLimits.maximumCubeMapSize,r.x=t,r.y=t;const o=new BoundingRectangle(0,0,t,t);n[0].passState.viewport=o,n[1].passState.viewport=o,n[2].passState.viewport=o,n[3].passState.viewport=o,n[4].passState.viewport=o,n[5].passState.viewport=o}else i===1?(t=ContextLimits.maximumTextureSize>=t?t:ContextLimits.maximumTextureSize,r.x=t,r.y=t,n[0].passState.viewport=new BoundingRectangle(0,0,t,t)):i===4&&(t=ContextLimits.maximumTextureSize>=t*2?t:ContextLimits.maximumTextureSize/2,r.x=t*2,r.y=t*2,n[0].passState.viewport=new BoundingRectangle(0,0,t,t),n[1].passState.viewport=new BoundingRectangle(t,0,t,t),n[2].passState.viewport=new BoundingRectangle(0,t,t,t),n[3].passState.viewport=new BoundingRectangle(t,t,t,t));e._clearPassState.viewport=new BoundingRectangle(0,0,r.x,r.y);for(let o=0;o<i;++o){const a=n[o],s=a.passState.viewport,l=s.x/r.x,c=s.y/r.y,d=s.width/r.x,h=s.height/r.y;a.textureOffsets=new Matrix4(d,0,0,l,0,h,0,c,0,0,1,0,0,0,0,1)}}const scratchViewport=new BoundingRectangle;function createDebugShadowViewCommand(e,t){let n;e._isPointLight?n=`uniform samplerCube shadowMap_textureCube; 
in vec2 v_textureCoordinates; 
void main() 
{ 
    vec2 uv = v_textureCoordinates; 
    vec3 dir; 
 
    if (uv.y < 0.5) 
    { 
        if (uv.x < 0.333) 
        { 
            dir.x = -1.0; 
            dir.y = uv.x * 6.0 - 1.0; 
            dir.z = uv.y * 4.0 - 1.0; 
        } 
        else if (uv.x < 0.666) 
        { 
            dir.y = -1.0; 
            dir.x = uv.x * 6.0 - 3.0; 
            dir.z = uv.y * 4.0 - 1.0; 
        } 
        else 
        { 
            dir.z = -1.0; 
            dir.x = uv.x * 6.0 - 5.0; 
            dir.y = uv.y * 4.0 - 1.0; 
        } 
    } 
    else 
    { 
        if (uv.x < 0.333) 
        { 
            dir.x = 1.0; 
            dir.y = uv.x * 6.0 - 1.0; 
            dir.z = uv.y * 4.0 - 3.0; 
        } 
        else if (uv.x < 0.666) 
        { 
            dir.y = 1.0; 
            dir.x = uv.x * 6.0 - 3.0; 
            dir.z = uv.y * 4.0 - 3.0; 
        } 
        else 
        { 
            dir.z = 1.0; 
            dir.x = uv.x * 6.0 - 5.0; 
            dir.y = uv.y * 4.0 - 3.0; 
        } 
    } 
 
    float shadow = czm_unpackDepth(czm_textureCube(shadowMap_textureCube, dir)); 
    out_FragColor = vec4(vec3(shadow), 1.0); 
} 
`:n=`uniform sampler2D shadowMap_texture; 
in vec2 v_textureCoordinates; 
void main() 
{ 
${e._usesDepthTexture?`    float shadow = texture(shadowMap_texture, v_textureCoordinates).r; 
`:`    float shadow = czm_unpackDepth(texture(shadowMap_texture, v_textureCoordinates)); 
`}    out_FragColor = vec4(vec3(shadow), 1.0); 
} 
`;const i=t.createViewportQuadCommand(n,{uniformMap:{shadowMap_texture:function(){return e._shadowMapTexture},shadowMap_textureCube:function(){return e._shadowMapTexture}}});return i.pass=Pass.OVERLAY,i}function updateDebugShadowViewCommand(e,t){const n=t.context,i=t.context.drawingBufferWidth,r=t.context.drawingBufferHeight,o=Math.min(i,r)*.3,a=scratchViewport;a.x=i-o,a.y=0,a.width=o,a.height=o;let s=e._debugShadowViewCommand;defined(s)||(s=createDebugShadowViewCommand(e,n),e._debugShadowViewCommand=s),(!defined(s.renderState)||!BoundingRectangle.equals(s.renderState.viewport,a))&&(s.renderState=RenderState.fromCache({viewport:BoundingRectangle.clone(a)})),t.commandList.push(e._debugShadowViewCommand)}const frustumCornersNDC=new Array(8);frustumCornersNDC[0]=new Cartesian4(-1,-1,-1,1);frustumCornersNDC[1]=new Cartesian4(1,-1,-1,1);frustumCornersNDC[2]=new Cartesian4(1,1,-1,1);frustumCornersNDC[3]=new Cartesian4(-1,1,-1,1);frustumCornersNDC[4]=new Cartesian4(-1,-1,1,1);frustumCornersNDC[5]=new Cartesian4(1,-1,1,1);frustumCornersNDC[6]=new Cartesian4(1,1,1,1);frustumCornersNDC[7]=new Cartesian4(-1,1,1,1);const scratchMatrix$1=new Matrix4,scratchFrustumCorners=new Array(8);for(let e=0;e<8;++e)scratchFrustumCorners[e]=new Cartesian4;function createDebugPointLight(e,t){const n=new GeometryInstance({geometry:new BoxOutlineGeometry({minimum:new Cartesian3(-.5,-.5,-.5),maximum:new Cartesian3(.5,.5,.5)}),attributes:{color:ColorGeometryInstanceAttribute.fromColor(t)}}),i=new GeometryInstance({geometry:new SphereOutlineGeometry({radius:.5}),attributes:{color:ColorGeometryInstanceAttribute.fromColor(t)}});return new Primitive({geometryInstances:[n,i],appearance:new PerInstanceColorAppearance({translucent:!1,flat:!0}),asynchronous:!1,modelMatrix:e})}const debugOutlineColors=[Color.RED,Color.GREEN,Color.BLUE,Color.MAGENTA],scratchScale$6=new Cartesian3;function applyDebugSettings(e,t){updateDebugShadowViewCommand(e,t);const n=e.debugFreezeFrame&&!e._debugFreezeFrame;if(e._debugFreezeFrame=e.debugFreezeFrame,e.debugFreezeFrame&&(n&&(e._debugCameraFrustum=e._debugCameraFrustum&&e._debugCameraFrustum.destroy(),e._debugCameraFrustum=new DebugCameraPrimitive({camera:e._sceneCamera,color:Color.CYAN,updateOnChange:!1})),e._debugCameraFrustum.update(t)),e._cascadesEnabled){if(e.debugFreezeFrame){n&&(e._debugLightFrustum=e._debugLightFrustum&&e._debugLightFrustum.destroy(),e._debugLightFrustum=new DebugCameraPrimitive({camera:e._shadowMapCamera,color:Color.YELLOW,updateOnChange:!1})),e._debugLightFrustum.update(t);for(let i=0;i<e._numberOfCascades;++i)n&&(e._debugCascadeFrustums[i]=e._debugCascadeFrustums[i]&&e._debugCascadeFrustums[i].destroy(),e._debugCascadeFrustums[i]=new DebugCameraPrimitive({camera:e._passes[i].camera,color:debugOutlineColors[i],updateOnChange:!1})),e._debugCascadeFrustums[i].update(t)}}else if(e._isPointLight){if(!defined(e._debugLightFrustum)||e._needsUpdate){const i=e._shadowMapCamera.positionWC,r=Quaternion.IDENTITY,o=e._pointLightRadius*2,a=Cartesian3.fromElements(o,o,o,scratchScale$6),s=Matrix4.fromTranslationQuaternionRotationScale(i,r,a,scratchMatrix$1);e._debugLightFrustum=e._debugLightFrustum&&e._debugLightFrustum.destroy(),e._debugLightFrustum=createDebugPointLight(s,Color.YELLOW)}e._debugLightFrustum.update(t)}else(!defined(e._debugLightFrustum)||e._needsUpdate)&&(e._debugLightFrustum=new DebugCameraPrimitive({camera:e._shadowMapCamera,color:Color.YELLOW,updateOnChange:!1})),e._debugLightFrustum.update(t)}function ShadowMapCamera(){this.viewMatrix=new Matrix4,this.inverseViewMatrix=new Matrix4,this.frustum=void 0,this.positionCartographic=new Cartographic,this.positionWC=new Cartesian3,this.directionWC=Cartesian3.clone(Cartesian3.UNIT_Z),this.upWC=Cartesian3.clone(Cartesian3.UNIT_Y),this.rightWC=Cartesian3.clone(Cartesian3.UNIT_X),this.viewProjectionMatrix=new Matrix4}ShadowMapCamera.prototype.clone=function(e){Matrix4.clone(e.viewMatrix,this.viewMatrix),Matrix4.clone(e.inverseViewMatrix,this.inverseViewMatrix),this.frustum=e.frustum.clone(this.frustum),Cartographic.clone(e.positionCartographic,this.positionCartographic),Cartesian3.clone(e.positionWC,this.positionWC),Cartesian3.clone(e.directionWC,this.directionWC),Cartesian3.clone(e.upWC,this.upWC),Cartesian3.clone(e.rightWC,this.rightWC)};const scaleBiasMatrix=new Matrix4(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);ShadowMapCamera.prototype.getViewProjection=function(){const e=this.viewMatrix,t=this.frustum.projectionMatrix;return Matrix4.multiply(t,e,this.viewProjectionMatrix),Matrix4.multiply(scaleBiasMatrix,this.viewProjectionMatrix,this.viewProjectionMatrix),this.viewProjectionMatrix};const scratchSplits=new Array(5),scratchFrustum=new PerspectiveFrustum,scratchCascadeDistances=new Array(4),scratchMin$1=new Cartesian3,scratchMax$1=new Cartesian3;function computeCascades(e,t){const n=e._shadowMapCamera,i=e._sceneCamera,r=i.frustum.near,o=i.frustum.far,a=e._numberOfCascades;let s;const l=o-r,c=o/r;let d=.9,h=!1;t.shadowState.closestObjectSize<200&&(h=!0,d=.9);const f=scratchCascadeDistances,p=scratchSplits;for(p[0]=r,p[a]=o,s=0;s<a;++s){const N=(s+1)/a,y=r*Math.pow(c,N),x=r+l*N,T=CesiumMath.lerp(x,y,d);p[s+1]=T,f[s]=T-p[s]}if(h){for(s=0;s<a;++s)f[s]=Math.min(f[s],e._maximumCascadeDistances[s]);let N=p[0];for(s=0;s<a-1;++s)N+=f[s],p[s+1]=N}Cartesian4.unpack(p,0,e._cascadeSplits[0]),Cartesian4.unpack(p,1,e._cascadeSplits[1]),Cartesian4.unpack(f,0,e._cascadeDistances);const u=n.frustum,m=u.left,g=u.right,_=u.bottom,C=u.top,A=u.near,S=u.far,v=n.positionWC,b=n.directionWC,D=n.upWC,I=i.frustum.clone(scratchFrustum),L=n.getViewProjection();for(s=0;s<a;++s){I.near=p[s],I.far=p[s+1];const N=Matrix4.multiply(I.projectionMatrix,i.viewMatrix,scratchMatrix$1),y=Matrix4.inverse(N,scratchMatrix$1),x=Matrix4.multiply(L,y,scratchMatrix$1),T=Cartesian3.fromElements(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,scratchMin$1),E=Cartesian3.fromElements(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,scratchMax$1);for(let R=0;R<8;++R){const w=Cartesian4.clone(frustumCornersNDC[R],scratchFrustumCorners[R]);Matrix4.multiplyByVector(x,w,w),Cartesian3.divideByScalar(w,w.w,w),Cartesian3.minimumByComponent(w,T,T),Cartesian3.maximumByComponent(w,E,E)}T.x=Math.max(T.x,0),T.y=Math.max(T.y,0),T.z=0,E.x=Math.min(E.x,1),E.y=Math.min(E.y,1),E.z=Math.min(E.z,1);const P=e._passes[s],M=P.camera;M.clone(n);const O=M.frustum;O.left=m+T.x*(g-m),O.right=m+E.x*(g-m),O.bottom=_+T.y*(C-_),O.top=_+E.y*(C-_),O.near=A+T.z*(S-A),O.far=A+E.z*(S-A),P.cullingVolume=M.frustum.computeCullingVolume(v,b,D);const V=e._cascadeMatrices[s];Matrix4.multiply(M.getViewProjection(),i.inverseViewMatrix,V),Matrix4.multiply(P.textureOffsets,V,V)}}const scratchLightView=new Matrix4,scratchRight$1=new Cartesian3,scratchUp$1=new Cartesian3,scratchTranslation$2=new Cartesian3;function fitShadowMapToScene(e,t){const n=e._shadowMapCamera,i=e._sceneCamera,r=Matrix4.multiply(i.frustum.projectionMatrix,i.viewMatrix,scratchMatrix$1),o=Matrix4.inverse(r,scratchMatrix$1),a=n.directionWC;let s=i.directionWC;Cartesian3.equalsEpsilon(a,s,CesiumMath.EPSILON10)&&(s=i.upWC);const l=Cartesian3.cross(a,s,scratchRight$1);s=Cartesian3.cross(l,a,scratchUp$1),Cartesian3.normalize(s,s),Cartesian3.normalize(l,l);const c=Cartesian3.fromElements(0,0,0,scratchTranslation$2);let d=Matrix4.computeView(c,a,s,l,scratchLightView);const h=Matrix4.multiply(d,o,scratchMatrix$1),f=Cartesian3.fromElements(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,scratchMin$1),p=Cartesian3.fromElements(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE,scratchMax$1);for(let S=0;S<8;++S){const v=Cartesian4.clone(frustumCornersNDC[S],scratchFrustumCorners[S]);Matrix4.multiplyByVector(h,v,v),Cartesian3.divideByScalar(v,v.w,v),Cartesian3.minimumByComponent(v,f,f),Cartesian3.maximumByComponent(v,p,p)}p.z+=1e3,f.z-=10;const u=scratchTranslation$2;u.x=-(.5*(f.x+p.x)),u.y=-(.5*(f.y+p.y)),u.z=-p.z;const m=Matrix4.fromTranslation(u,scratchMatrix$1);d=Matrix4.multiply(m,d,d);const g=.5*(p.x-f.x),_=.5*(p.y-f.y),C=p.z-f.z,A=n.frustum;A.left=-g,A.right=g,A.bottom=-_,A.top=_,A.near=.01,A.far=C,Matrix4.clone(d,n.viewMatrix),Matrix4.inverse(d,n.inverseViewMatrix),Matrix4.getTranslation(n.inverseViewMatrix,n.positionWC),t.mapProjection.ellipsoid.cartesianToCartographic(n.positionWC,n.positionCartographic),Cartesian3.clone(a,n.directionWC),Cartesian3.clone(s,n.upWC),Cartesian3.clone(l,n.rightWC)}const directions=[new Cartesian3(-1,0,0),new Cartesian3(0,-1,0),new Cartesian3(0,0,-1),new Cartesian3(1,0,0),new Cartesian3(0,1,0),new Cartesian3(0,0,1)],ups=[new Cartesian3(0,-1,0),new Cartesian3(0,0,-1),new Cartesian3(0,-1,0),new Cartesian3(0,-1,0),new Cartesian3(0,0,1),new Cartesian3(0,-1,0)],rights=[new Cartesian3(0,0,1),new Cartesian3(1,0,0),new Cartesian3(-1,0,0),new Cartesian3(0,0,-1),new Cartesian3(1,0,0),new Cartesian3(1,0,0)];function computeOmnidirectional(e,t){const n=new PerspectiveFrustum;n.fov=CesiumMath.PI_OVER_TWO,n.near=1,n.far=e._pointLightRadius,n.aspectRatio=1;for(let i=0;i<6;++i){const r=e._passes[i].camera;r.positionWC=e._shadowMapCamera.positionWC,r.positionCartographic=t.mapProjection.ellipsoid.cartesianToCartographic(r.positionWC,r.positionCartographic),r.directionWC=directions[i],r.upWC=ups[i],r.rightWC=rights[i],Matrix4.computeView(r.positionWC,r.directionWC,r.upWC,r.rightWC,r.viewMatrix),Matrix4.inverse(r.viewMatrix,r.inverseViewMatrix),r.frustum=n}}const scratchCartesian1=new Cartesian3,scratchCartesian2$2=new Cartesian3,scratchBoundingSphere=new BoundingSphere,scratchCenter$2=scratchBoundingSphere.center;function checkVisibility(e,t){const n=e._sceneCamera,i=e._shadowMapCamera,r=scratchBoundingSphere;if(e._cascadesEnabled){if(n.frustum.near>=e.maximumDistance){e._outOfView=!0,e._needsUpdate=!1;return}const o=t.mapProjection.ellipsoid.geodeticSurfaceNormal(n.positionWC,scratchCartesian1),a=Cartesian3.negate(i.directionWC,scratchCartesian2$2),s=Cartesian3.dot(o,a);if(e.fadingEnabled){const l=CesiumMath.clamp(s/.1,0,1);e._darkness=CesiumMath.lerp(1,e.darkness,l)}else e._darkness=e.darkness;if(s<0){e._outOfView=!0,e._needsUpdate=!1;return}e._needsUpdate=!0,e._outOfView=!1}else if(e._isPointLight)r.center=i.positionWC,r.radius=e._pointLightRadius,e._outOfView=t.cullingVolume.computeVisibility(r)===Intersect.OUTSIDE,e._needsUpdate=!e._outOfView&&!e._boundingSphere.equals(r),BoundingSphere.clone(r,e._boundingSphere);else{const o=i.frustum.far/2,a=Cartesian3.add(i.positionWC,Cartesian3.multiplyByScalar(i.directionWC,o,scratchCenter$2),scratchCenter$2);r.center=a,r.radius=o,e._outOfView=t.cullingVolume.computeVisibility(r)===Intersect.OUTSIDE,e._needsUpdate=!e._outOfView&&!e._boundingSphere.equals(r),BoundingSphere.clone(r,e._boundingSphere)}}function updateCameras(e,t){const n=t.camera,i=e._lightCamera,r=e._sceneCamera,o=e._shadowMapCamera;e._cascadesEnabled?Cartesian3.clone(i.directionWC,o.directionWC):e._isPointLight?Cartesian3.clone(i.positionWC,o.positionWC):o.clone(i);const a=e._lightDirectionEC;Matrix4.multiplyByPointAsVector(n.viewMatrix,o.directionWC,a),Cartesian3.normalize(a,a),Cartesian3.negate(a,a),Matrix4.multiplyByPoint(n.viewMatrix,o.positionWC,e._lightPositionEC),e._lightPositionEC.w=e._pointLightRadius;let s,l;e._fitNearFar?(s=Math.min(t.shadowState.nearPlane,e.maximumDistance),l=Math.min(t.shadowState.farPlane,e.maximumDistance),l=Math.max(l,s+1)):(s=n.frustum.near,l=e.maximumDistance),e._sceneCamera=Camera.clone(n,r),n.frustum.clone(e._sceneCamera.frustum),e._sceneCamera.frustum.near=s,e._sceneCamera.frustum.far=l,e._distance=l-s,checkVisibility(e,t),!e._outOfViewPrevious&&e._outOfView&&(e._needsUpdate=!0),e._outOfViewPrevious=e._outOfView}ShadowMap.prototype.update=function(e){if(updateCameras(this,e),this._needsUpdate)if(updateFramebuffer(this,e.context),this._isPointLight&&computeOmnidirectional(this,e),this._cascadesEnabled&&(fitShadowMapToScene(this,e),this._numberOfCascades>1&&computeCascades(this,e)),this._isPointLight)this._shadowMapCullingVolume=CullingVolume.fromBoundingSphere(this._boundingSphere);else{const t=this._shadowMapCamera,n=t.positionWC,i=t.directionWC,r=t.upWC;this._shadowMapCullingVolume=t.frustum.computeCullingVolume(n,i,r),this._passes.length===1&&this._passes[0].camera.clone(t)}if(this._passes.length===1){const t=this._sceneCamera.inverseViewMatrix;Matrix4.multiply(this._shadowMapCamera.getViewProjection(),t,this._shadowMapMatrix)}this.debugShow&&applyDebugSettings(this,e)};ShadowMap.prototype.updatePass=function(e,t){clearFramebuffer(this,e,t)};const scratchTexelStepSize=new Cartesian2;function combineUniforms(e,t,n){const i=e._isPointLight?e._pointBias:n?e._terrainBias:e._primitiveBias,r={shadowMap_texture:function(){return e._shadowMapTexture},shadowMap_textureCube:function(){return e._shadowMapTexture},shadowMap_matrix:function(){return e._shadowMapMatrix},shadowMap_cascadeSplits:function(){return e._cascadeSplits},shadowMap_cascadeMatrices:function(){return e._cascadeMatrices},shadowMap_lightDirectionEC:function(){return e._lightDirectionEC},shadowMap_lightPositionEC:function(){return e._lightPositionEC},shadowMap_cascadeDistances:function(){return e._cascadeDistances},shadowMap_texelSizeDepthBiasAndNormalShadingSmooth:function(){const o=scratchTexelStepSize;return o.x=1/e._textureSize.x,o.y=1/e._textureSize.y,Cartesian4.fromElements(o.x,o.y,i.depthBias,i.normalShadingSmooth,this.combinedUniforms1)},shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness:function(){return Cartesian4.fromElements(i.normalOffsetScale,e._distance,e.maximumDistance,e._darkness,this.combinedUniforms2)},combinedUniforms1:new Cartesian4,combinedUniforms2:new Cartesian4};return combine$2(t,r,!1)}function createCastDerivedCommand(e,t,n,i,r,o){let a,s,l;if(defined(o)&&(a=o.shaderProgram,s=o.renderState,l=o.uniformMap),o=DrawCommand.shallowClone(n,o),o.castShadows=!0,o.receiveShadows=!1,!defined(a)||r!==n.shaderProgram.id||t){const c=n.shaderProgram,d=n.pass===Pass.GLOBE,h=n.pass!==Pass.TRANSLUCENT,f=e._isPointLight,p=e._usesDepthTexture,u=ShadowMapShader.getShadowCastShaderKeyword(f,d,p,h);if(a=i.shaderCache.getDerivedShaderProgram(c,u),!defined(a)){const g=c.vertexShaderSource,_=c.fragmentShaderSource,C=ShadowMapShader.createShadowCastVertexShader(g,f,d),A=ShadowMapShader.createShadowCastFragmentShader(_,f,p,h);a=i.shaderCache.createDerivedShaderProgram(c,u,{vertexShaderSource:C,fragmentShaderSource:A,attributeLocations:c._attributeLocations})}s=e._primitiveRenderState,f?s=e._pointRenderState:d&&(s=e._terrainRenderState),n.renderState.cull.enabled||(s=clone(s,!1),s.cull=clone(s.cull,!1),s.cull.enabled=!1,s=RenderState.fromCache(s)),l=combineUniforms(e,n.uniformMap,d)}return o.shaderProgram=a,o.renderState=s,o.uniformMap=l,o}ShadowMap.createReceiveDerivedCommand=function(e,t,n,i,r){defined(r)||(r={});const o=e.length>0,a=t.shaderProgram,s=a.vertexShaderSource,l=a.fragmentShaderSource,c=t.pass===Pass.GLOBE;let d=!1;if(c&&(d=t.owner.data.renderedMesh.encoding.hasVertexNormals),t.receiveShadows&&o){let h,f;defined(r.receiveCommand)&&(h=r.receiveCommand.shaderProgram,f=r.receiveCommand.uniformMap),r.receiveCommand=DrawCommand.shallowClone(t,r.receiveCommand),r.castShadows=!1,r.receiveShadows=!0;const p=r.receiveShaderCastShadows!==t.castShadows,u=r.receiveShaderProgramId!==t.shaderProgram.id;if(!defined(h)||u||n||p){const m=ShadowMapShader.getShadowReceiveShaderKeyword(e[0],t.castShadows,c,d);if(h=i.shaderCache.getDerivedShaderProgram(a,m),!defined(h)){const g=ShadowMapShader.createShadowReceiveVertexShader(s,c,d),_=ShadowMapShader.createShadowReceiveFragmentShader(l,e[0],t.castShadows,c,d);h=i.shaderCache.createDerivedShaderProgram(a,m,{vertexShaderSource:g,fragmentShaderSource:_,attributeLocations:a._attributeLocations})}f=combineUniforms(e[0],t.uniformMap,c)}r.receiveCommand.shaderProgram=h,r.receiveCommand.uniformMap=f,r.receiveShaderProgramId=t.shaderProgram.id,r.receiveShaderCastShadows=t.castShadows}return r};ShadowMap.createCastDerivedCommand=function(e,t,n,i,r){if(defined(r)||(r={}),t.castShadows){let o=r.castCommands;defined(o)||(o=r.castCommands=[]);const a=r.castShaderProgramId,s=e.length;o.length=s;for(let l=0;l<s;++l)o[l]=createCastDerivedCommand(e[l],n,t,i,a,o[l]);r.castShaderProgramId=t.shaderProgram.id}return r};ShadowMap.prototype.isDestroyed=function(){return!1};ShadowMap.prototype.destroy=function(){destroyFramebuffer(this),this._debugLightFrustum=this._debugLightFrustum&&this._debugLightFrustum.destroy(),this._debugCameraFrustum=this._debugCameraFrustum&&this._debugCameraFrustum.destroy(),this._debugShadowViewCommand=this._debugShadowViewCommand&&this._debugShadowViewCommand.shaderProgram&&this._debugShadowViewCommand.shaderProgram.destroy();for(let e=0;e<this._numberOfCascades;++e)this._debugCascadeFrustums[e]=this._debugCascadeFrustums[e]&&this._debugCascadeFrustums[e].destroy();return destroyObject(this)};const CompositeTranslucentClassification=`uniform sampler2D colorTexture;

#ifdef DEBUG_SHOW_DEPTH
uniform sampler2D u_packedTranslucentDepth;
#endif

in vec2 v_textureCoordinates;

void main()
{
#ifdef DEBUG_SHOW_DEPTH
    if (v_textureCoordinates.x < 0.5)
    {
        out_FragColor.rgb = vec3(czm_unpackDepth(texture(u_packedTranslucentDepth, v_textureCoordinates)));
        out_FragColor.a = 1.0;
    }
#else
    vec4 color = texture(colorTexture, v_textureCoordinates);

#ifdef PICK
    if (color == vec4(0.0))
    {
        discard;
    }
#else
    // Reverse premultiplication process to get the correct composited result of the classification primitives
    color.rgb /= color.a;
#endif
    out_FragColor = color;
#endif
}
`;function TranslucentTileClassification(e){this._drawClassificationFBO=new FramebufferManager({createDepthAttachments:!1}),this._accumulationFBO=new FramebufferManager({createDepthAttachments:!1}),this._packFBO=new FramebufferManager,this._opaqueDepthStencilTexture=void 0,this._textureToComposite=void 0,this._translucentDepthStencilTexture=void 0,this._packDepthCommand=void 0,this._accumulateCommand=void 0,this._compositeCommand=void 0,this._copyCommand=void 0,this._clearColorCommand=new ClearCommand({color:new Color(0,0,0,0),owner:this}),this._clearDepthStencilCommand=new ClearCommand({depth:1,stencil:0,owner:this}),this._supported=e.depthTexture,this._viewport=new BoundingRectangle,this._rsDepth=void 0,this._rsAccumulate=void 0,this._rsComp=void 0,this._useScissorTest=void 0,this._scissorRectangle=void 0,this._hasTranslucentDepth=!1,this._frustumsDrawn=0}Object.defineProperties(TranslucentTileClassification.prototype,{hasTranslucentDepth:{get:function(){return this._hasTranslucentDepth}}});function destroyTextures(e){e._textureToComposite=void 0,e._translucentDepthStencilTexture=e._translucentDepthStencilTexture&&!e._translucentDepthStencilTexture.isDestroyed()&&e._translucentDepthStencilTexture.destroy()}function destroyFramebuffers$1(e){e._drawClassificationFBO.destroy(),e._accumulationFBO.destroy(),e._packFBO.destroy()}function updateTextures(e,t,n,i){destroyTextures(e),e._translucentDepthStencilTexture=new Texture({context:t,width:n,height:i,pixelFormat:PixelFormat.DEPTH_STENCIL,pixelDatatype:PixelDatatype.UNSIGNED_INT_24_8,sampler:Sampler.NEAREST})}function updateFramebuffers$1(e,t,n,i){destroyFramebuffers$1(e),e._drawClassificationFBO.setDepthStencilTexture(e._translucentDepthStencilTexture),e._drawClassificationFBO.update(t,n,i),e._accumulationFBO.setDepthStencilTexture(e._translucentDepthStencilTexture),e._accumulationFBO.update(t,n,i),e._packFBO.update(t,n,i)}function updateResources(e,t,n,i){if(!e.isSupported())return;e._opaqueDepthStencilTexture=i;const r=e._opaqueDepthStencilTexture.width,o=e._opaqueDepthStencilTexture.height;e._drawClassificationFBO.isDirty(r,o)&&(updateTextures(e,t,r,o),updateFramebuffers$1(e,t,r,o));let a,s;if(defined(e._packDepthCommand)||(a=new ShaderSource({sources:[CompareAndPackTranslucentDepth]}),s={u_opaqueDepthTexture:function(){return e._opaqueDepthStencilTexture},u_translucentDepthTexture:function(){return e._translucentDepthStencilTexture}},e._packDepthCommand=t.createViewportQuadCommand(a,{uniformMap:s,owner:e})),!defined(e._compositeCommand)){a=new ShaderSource({sources:[CompositeTranslucentClassification]}),s={colorTexture:function(){return e._textureToComposite}},e._compositeCommand=t.createViewportQuadCommand(a,{uniformMap:s,owner:e});const d=e._compositeCommand,h=d.shaderProgram,f=t.shaderCache.createDerivedShaderProgram(h,"pick",{vertexShaderSource:h.vertexShaderSource,fragmentShaderSource:new ShaderSource({sources:a.sources,defines:["PICK"]}),attributeLocations:h._attributeLocations}),p=DrawCommand.shallowClone(d);p.shaderProgram=f,d.derivedCommands.pick=p}defined(e._copyCommand)||(a=new ShaderSource({sources:[CompositeTranslucentClassification]}),s={colorTexture:function(){return e._drawClassificationFBO.getColorTexture()}},e._copyCommand=t.createViewportQuadCommand(a,{uniformMap:s,owner:e})),defined(e._accumulateCommand)||(a=new ShaderSource({sources:[CompositeTranslucentClassification]}),s={colorTexture:function(){return e._drawClassificationFBO.getColorTexture()}},e._accumulateCommand=t.createViewportQuadCommand(a,{uniformMap:s,owner:e})),e._viewport.width=r,e._viewport.height=o;const l=!BoundingRectangle.equals(e._viewport,n.viewport);let c=l!==e._useScissorTest;e._useScissorTest=l,BoundingRectangle.equals(e._scissorRectangle,n.viewport)||(e._scissorRectangle=BoundingRectangle.clone(n.viewport,e._scissorRectangle),c=!0),(!defined(e._rsDepth)||!BoundingRectangle.equals(e._viewport,e._rsDepth.viewport)||c)&&(e._rsDepth=RenderState.fromCache({viewport:e._viewport,scissorTest:{enabled:e._useScissorTest,rectangle:e._scissorRectangle}})),defined(e._packDepthCommand)&&(e._packDepthCommand.renderState=e._rsDepth),(!defined(e._rsAccumulate)||!BoundingRectangle.equals(e._viewport,e._rsAccumulate.viewport)||c)&&(e._rsAccumulate=RenderState.fromCache({viewport:e._viewport,scissorTest:{enabled:e._useScissorTest,rectangle:e._scissorRectangle},stencilTest:{enabled:!0,frontFunction:StencilFunction.EQUAL,reference:StencilConstants.CESIUM_3D_TILE_MASK}})),defined(e._accumulateCommand)&&(e._accumulateCommand.renderState=e._rsAccumulate),(!defined(e._rsComp)||!BoundingRectangle.equals(e._viewport,e._rsComp.viewport)||c)&&(e._rsComp=RenderState.fromCache({viewport:e._viewport,scissorTest:{enabled:e._useScissorTest,rectangle:e._scissorRectangle},blending:BlendingState.ALPHA_BLEND})),defined(e._compositeCommand)&&(e._compositeCommand.renderState=e._rsComp,e._compositeCommand.derivedCommands.pick.renderState=e._rsComp)}TranslucentTileClassification.prototype.executeTranslucentCommands=function(e,t,n,i,r){const o=i.length;let a,s;const l=e.frameState.useLogDepth,c=e.context,d=n.framebuffer;for(s=0;s<o;++s)if(a=i[s],a=l?a.derivedCommands.logDepth.command:a,a.depthForTranslucentClassification){this._hasTranslucentDepth=!0;break}if(this._hasTranslucentDepth){for(updateResources(this,c,n,r),n.framebuffer=this._drawClassificationFBO.framebuffer,this._clearDepthStencilCommand.execute(c,n),s=0;s<o;++s){if(a=i[s],a=l?a.derivedCommands.logDepth.command:a,!a.depthForTranslucentClassification)continue;const h=a.derivedCommands.depth.depthOnlyCommand;t(h,e,c,n)}this._frustumsDrawn+=this._hasTranslucentDepth?1:0,this._hasTranslucentDepth&&(n.framebuffer=this._packFBO.framebuffer,this._packDepthCommand.execute(c,n)),n.framebuffer=d}};TranslucentTileClassification.prototype.executeClassificationCommands=function(e,t,n,i){if(!this._hasTranslucentDepth)return;const r=e.context,o=r.uniformState,a=n.framebuffer;this._frustumsDrawn===2&&(n.framebuffer=this._accumulationFBO.framebuffer,this._copyCommand.execute(r,n)),n.framebuffer=this._drawClassificationFBO.framebuffer,this._frustumsDrawn>1&&this._clearColorCommand.execute(r,n),o.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION);const s=o.globeDepthTexture;o.globeDepthTexture=this._packFBO.getColorTexture();const l=i.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION],c=i.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION];for(let d=0;d<c;++d)t(l[d],e,r,n);o.globeDepthTexture=s,n.framebuffer=a,this._frustumsDrawn!==1&&(n.framebuffer=this._accumulationFBO.framebuffer,this._accumulateCommand.execute(r,n),n.framebuffer=a)};TranslucentTileClassification.prototype.execute=function(e,t){if(!this._hasTranslucentDepth)return;this._frustumsDrawn===1?this._textureToComposite=this._drawClassificationFBO.getColorTexture():this._textureToComposite=this._accumulationFBO.getColorTexture(),(e.frameState.passes.pick?this._compositeCommand.derivedCommands.pick:this._compositeCommand).execute(e.context,t),clear(this,e,t)};function clear(e,t,n){if(!e._hasTranslucentDepth)return;const i=n.framebuffer;n.framebuffer=e._drawClassificationFBO.framebuffer,e._clearColorCommand.execute(t._context,n),n.framebuffer=i,e._frustumsDrawn>1&&(n.framebuffer=e._accumulationFBO.framebuffer,e._clearColorCommand.execute(t._context,n)),e._hasTranslucentDepth=!1,e._frustumsDrawn=0}TranslucentTileClassification.prototype.isSupported=function(){return this._supported};TranslucentTileClassification.prototype.isDestroyed=function(){return!1};TranslucentTileClassification.prototype.destroy=function(){return destroyTextures(this),destroyFramebuffers$1(this),defined(this._compositeCommand)&&(this._compositeCommand.shaderProgram=this._compositeCommand.shaderProgram&&this._compositeCommand.shaderProgram.destroy()),defined(this._packDepthCommand)&&(this._packDepthCommand.shaderProgram=this._packDepthCommand.shaderProgram&&this._packDepthCommand.shaderProgram.destroy()),destroyObject(this)};function CommandExtent(){this.command=void 0,this.near=void 0,this.far=void 0}function View(e,t,n){const i=e.context;let r;i.depthTexture&&(r=new GlobeDepth);let o;e._useOIT&&i.depthTexture&&(o=new OIT(i));const a=new PassState(i);a.viewport=BoundingRectangle.clone(n),this.camera=t,this._cameraClone=Camera.clone(t),this._cameraStartFired=!1,this._cameraMovedTime=void 0,this.viewport=n,this.passState=a,this.pickFramebuffer=new PickFramebuffer(i),this.pickDepthFramebuffer=new PickDepthFramebuffer,this.sceneFramebuffer=new SceneFramebuffer,this.globeDepth=r,this.globeTranslucencyFramebuffer=new GlobeTranslucencyFramebuffer,this.oit=o,this.translucentTileClassification=new TranslucentTileClassification(i),this.pickDepths=[],this.frustumCommandsList=[],this.debugFrustumStatistics=void 0,this._commandExtents=[]}const scratchPosition0=new Cartesian3,scratchPosition1=new Cartesian3;function maxComponent(e,t){const n=Math.max(Math.abs(e.x),Math.abs(t.x)),i=Math.max(Math.abs(e.y),Math.abs(t.y)),r=Math.max(Math.abs(e.z),Math.abs(t.z));return Math.max(Math.max(n,i),r)}function cameraEqual(e,t,n){const i=1/Math.max(1,maxComponent(e.position,t.position));return Cartesian3.multiplyByScalar(e.position,i,scratchPosition0),Cartesian3.multiplyByScalar(t.position,i,scratchPosition1),Cartesian3.equalsEpsilon(scratchPosition0,scratchPosition1,n)&&Cartesian3.equalsEpsilon(e.direction,t.direction,n)&&Cartesian3.equalsEpsilon(e.up,t.up,n)&&Cartesian3.equalsEpsilon(e.right,t.right,n)&&Matrix4.equalsEpsilon(e.transform,t.transform,n)&&e.frustum.equalsEpsilon(t.frustum,n)}View.prototype.checkForCameraUpdates=function(e){const t=this.camera,n=this._cameraClone;return cameraEqual(t,n,CesiumMath.EPSILON15)?(this._cameraStartFired&&getTimestamp()-this._cameraMovedTime>e.cameraEventWaitTime&&(t.moveEnd.raiseEvent(),this._cameraStartFired=!1),!1):(this._cameraStartFired||(t.moveStart.raiseEvent(),this._cameraStartFired=!0),this._cameraMovedTime=getTimestamp(),Camera.clone(t,n),!0)};function updateFrustums(e,t,n,i){const r=t.frameState,o=r.camera,a=r.useLogDepth?t.logarithmicDepthFarToNearRatio:t.farToNearRatio,s=t.mode===SceneMode.SCENE2D,l=t.nearToFarDistance2D;i*=1+CesiumMath.EPSILON2,n=Math.min(Math.max(n,o.frustum.near),o.frustum.far),i=Math.max(Math.min(i,o.frustum.far),n);let c;s?(i=Math.min(i,o.position.z+t.nearToFarDistance2D),n=Math.min(n,i),c=Math.ceil(Math.max(1,i-n)/t.nearToFarDistance2D)):c=Math.ceil(Math.log(i/n)/Math.log(a));const d=e.frustumCommandsList;d.length=c;for(let h=0;h<c;++h){let f,p;s?(f=Math.min(i-l,n+h*l),p=Math.min(i,f+l)):(f=Math.max(n,Math.pow(a,h)*n),p=Math.min(i,a*f));let u=d[h];defined(u)?(u.near=f,u.far=p):u=d[h]=new FrustumCommands(f,p)}}function insertIntoBin(e,t,n,i,r){t.debugShowFrustums&&(n.debugOverlappingFrustums=0);const o=e.frustumCommandsList,a=o.length;for(let s=0;s<a;++s){const l=o[s],c=l.near,d=l.far;if(i>d)continue;if(r<c)break;const h=n.pass,f=l.indices[h]++;if(l.commands[h][f]=n,t.debugShowFrustums&&(n.debugOverlappingFrustums|=1<<s),n.executeInClosestFrustum)break}if(t.debugShowFrustums){const s=e.debugFrustumStatistics.commandsInFrustums;s[n.debugOverlappingFrustums]=defined(s[n.debugOverlappingFrustums])?s[n.debugOverlappingFrustums]+1:1,++e.debugFrustumStatistics.totalCommands}t.updateDerivedCommands(n)}const scratchCullingVolume$1=new CullingVolume,scratchNearFarInterval=new Interval;View.prototype.createPotentiallyVisibleSet=function(e){const t=e.frameState,n=t.camera,i=n.directionWC,r=n.positionWC,o=e._computeCommandList,a=e._overlayCommandList,s=t.commandList;e.debugShowFrustums&&(this.debugFrustumStatistics={totalCommands:0,commandsInFrustums:{}});const l=this.frustumCommandsList,c=l.length,d=Pass.NUMBER_OF_PASSES;for(let x=0;x<c;++x)for(let T=0;T<d;++T)l[x].indices[T]=0;o.length=0,a.length=0;const h=this._commandExtents,f=h.length;let p=0,u=+Number.MAX_VALUE,m=-Number.MAX_VALUE;const g=t.shadowState.shadowsEnabled;let _=+Number.MAX_VALUE,C=-Number.MAX_VALUE,A=Number.MAX_VALUE;const S=t.mode===SceneMode.SCENE3D?t.occluder:void 0;let v=t.cullingVolume;const b=scratchCullingVolume$1.planes;for(let x=0;x<5;++x)b[x]=v.planes[x];v=scratchCullingVolume$1;const D=s.length;for(let x=0;x<D;++x){const T=s[x],E=T.pass;if(E===Pass.COMPUTE)o.push(T);else if(E===Pass.OVERLAY)a.push(T);else{let P,M;const O=T.boundingVolume;if(defined(O)){if(!e.isVisible(T,v,S))continue;const R=O.computePlaneDistances(r,i,scratchNearFarInterval);if(P=R.start,M=R.stop,u=Math.min(u,P),m=Math.max(m,M),g&&T.receiveShadows&&P<ShadowMap.MAXIMUM_DISTANCE&&!(E===Pass.GLOBE&&P<-100&&M>100)){const w=M-P;E!==Pass.GLOBE&&P<100&&(A=Math.min(A,w)),_=Math.min(_,P),C=Math.max(C,M)}}else T instanceof ClearCommand?(P=n.frustum.near,M=n.frustum.far):(P=n.frustum.near,M=n.frustum.far,u=Math.min(u,P),m=Math.max(m,M));let V=h[p];defined(V)||(V=h[p]=new CommandExtent),V.command=T,V.near=P,V.far=M,p++}}g&&(_=Math.min(Math.max(_,n.frustum.near),n.frustum.far),C=Math.max(Math.min(C,n.frustum.far),_)),g&&(t.shadowState.nearPlane=_,t.shadowState.farPlane=C,t.shadowState.closestObjectSize=A),updateFrustums(this,e,u,m);let I,L;for(I=0;I<p;I++)L=h[I],insertIntoBin(this,e,L.command,L.near,L.far);if(p<f)for(I=p;I<f&&(L=h[I],!!defined(L.command));I++)L.command=void 0;const N=l.length,y=t.frustumSplits;y.length=N+1;for(let x=0;x<N;++x)y[x]=l[x].near,x===N-1&&(y[x+1]=l[x].far)};View.prototype.destroy=function(){this.pickFramebuffer=this.pickFramebuffer&&this.pickFramebuffer.destroy(),this.pickDepthFramebuffer=this.pickDepthFramebuffer&&this.pickDepthFramebuffer.destroy(),this.sceneFramebuffer=this.sceneFramebuffer&&this.sceneFramebuffer.destroy(),this.globeDepth=this.globeDepth&&this.globeDepth.destroy(),this.oit=this.oit&&this.oit.destroy(),this.translucentTileClassification=this.translucentTileClassification&&this.translucentTileClassification.destroy(),this.globeTranslucencyFramebuffer=this.globeTranslucencyFramebuffer&&this.globeTranslucencyFramebuffer.destroy();let e;const t=this.pickDepths,n=t.length;for(e=0;e<n;++e)t[e].destroy()};const offscreenDefaultWidth=.1,mostDetailedPreloadTilesetPassState=new Cesium3DTilePassState({pass:Cesium3DTilePass.MOST_DETAILED_PRELOAD}),mostDetailedPickTilesetPassState=new Cesium3DTilePassState({pass:Cesium3DTilePass.MOST_DETAILED_PICK}),pickTilesetPassState=new Cesium3DTilePassState({pass:Cesium3DTilePass.PICK});function Picking(e){this._mostDetailedRayPicks=[],this.pickRenderStateCache={},this._pickPositionCache={},this._pickPositionCacheDirty=!1;const t=new BoundingRectangle(0,0,1,1),n=new Camera(e);n.frustum=new OrthographicFrustum({width:offscreenDefaultWidth,aspectRatio:1,near:.1}),this._pickOffscreenView=new View(e,n,t)}Picking.prototype.update=function(){this._pickPositionCacheDirty=!0};Picking.prototype.getPickDepth=function(e,t){const n=e.view.pickDepths;let i=n[t];return defined(i)||(i=new PickDepth,n[t]=i),i};const scratchOrthoPickingFrustum=new OrthographicOffCenterFrustum,scratchOrthoOrigin=new Cartesian3,scratchOrthoDirection=new Cartesian3,scratchOrthoPixelSize=new Cartesian2,scratchOrthoPickVolumeMatrix4=new Matrix4;function getPickOrthographicCullingVolume(e,t,n,i,r){const o=e.camera;let a=o.frustum;const s=a.offCenterFrustum;defined(s)&&(a=s);let l=2*(t.x-r.x)/r.width-1;l*=(a.right-a.left)*.5;let c=2*(r.height-t.y-r.y)/r.height-1;c*=(a.top-a.bottom)*.5;const d=Matrix4.clone(o.transform,scratchOrthoPickVolumeMatrix4);o._setTransform(Matrix4.IDENTITY);const h=Cartesian3.clone(o.position,scratchOrthoOrigin);Cartesian3.multiplyByScalar(o.right,l,scratchOrthoDirection),Cartesian3.add(scratchOrthoDirection,h,h),Cartesian3.multiplyByScalar(o.up,c,scratchOrthoDirection),Cartesian3.add(scratchOrthoDirection,h,h),o._setTransform(d),e.mode===SceneMode.SCENE2D&&Cartesian3.fromElements(h.z,h.x,h.y,h);const f=a.getPixelDimensions(r.width,r.height,1,1,scratchOrthoPixelSize),p=scratchOrthoPickingFrustum;return p.right=f.x*.5,p.left=-p.right,p.top=f.y*.5,p.bottom=-p.top,p.near=a.near,p.far=a.far,p.computeCullingVolume(h,o.directionWC,o.upWC)}const scratchPerspPickingFrustum=new PerspectiveOffCenterFrustum,scratchPerspPixelSize=new Cartesian2;function getPickPerspectiveCullingVolume(e,t,n,i,r){const o=e.camera,a=o.frustum,s=a.near,l=Math.tan(a.fovy*.5),c=a.aspectRatio*l,d=2*(t.x-r.x)/r.width-1,h=2*(r.height-t.y-r.y)/r.height-1,f=d*s*c,p=h*s*l,u=a.getPixelDimensions(r.width,r.height,1,1,scratchPerspPixelSize),m=u.x*n*.5,g=u.y*i*.5,_=scratchPerspPickingFrustum;return _.top=p+g,_.bottom=p-g,_.right=f+m,_.left=f-m,_.near=s,_.far=a.far,_.computeCullingVolume(o.positionWC,o.directionWC,o.upWC)}function getPickCullingVolume(e,t,n,i,r){const o=e.camera.frustum;return o instanceof OrthographicFrustum||o instanceof OrthographicOffCenterFrustum?getPickOrthographicCullingVolume(e,t,n,i,r):getPickPerspectiveCullingVolume(e,t,n,i,r)}let scratchRectangleWidth=3,scratchRectangleHeight=3,scratchRectangle$1=new BoundingRectangle(0,0,scratchRectangleWidth,scratchRectangleHeight);const scratchPosition$1=new Cartesian2,scratchColorZero=new Color(0,0,0,0);Picking.prototype.pick=function(e,t,n,i){Check.defined("windowPosition",t),scratchRectangleWidth=defaultValue(n,3),scratchRectangleHeight=defaultValue(i,scratchRectangleWidth);const{context:r,frameState:o,defaultView:a}=e,{viewport:s,pickFramebuffer:l}=a;e.view=a,s.x=0,s.y=0,s.width=r.drawingBufferWidth,s.height=r.drawingBufferHeight;let c=a.passState;c.viewport=BoundingRectangle.clone(s,c.viewport);const d=SceneTransforms.transformWindowToDrawingBuffer(e,t,scratchPosition$1);e.jobScheduler.disableThisFrame(),e.updateFrameState(),o.cullingVolume=getPickCullingVolume(e,d,scratchRectangleWidth,scratchRectangleHeight,s),o.invertClassification=!1,o.passes.pick=!0,o.tilesetPassState=pickTilesetPassState,r.uniformState.update(o),e.updateEnvironment(),scratchRectangle$1.x=d.x-(scratchRectangleWidth-1)*.5,scratchRectangle$1.y=e.drawingBufferHeight-d.y-(scratchRectangleHeight-1)*.5,scratchRectangle$1.width=scratchRectangleWidth,scratchRectangle$1.height=scratchRectangleHeight,c=l.begin(scratchRectangle$1,s),e.updateAndExecuteCommands(c,scratchColorZero),e.resolveFramebuffers(c);const h=l.end(scratchRectangle$1);return r.endFrame(),h};Picking.prototype.pickVoxelCoordinate=function(e,t,n,i){Check.defined("windowPosition",t),scratchRectangleWidth=defaultValue(n,3),scratchRectangleHeight=defaultValue(i,scratchRectangleWidth);const{context:r,frameState:o,defaultView:a}=e,{viewport:s,pickFramebuffer:l}=a;e.view=a,s.x=0,s.y=0,s.width=r.drawingBufferWidth,s.height=r.drawingBufferHeight;let c=a.passState;c.viewport=BoundingRectangle.clone(s,c.viewport);const d=SceneTransforms.transformWindowToDrawingBuffer(e,t,scratchPosition$1);e.jobScheduler.disableThisFrame(),e.updateFrameState(),o.cullingVolume=getPickCullingVolume(e,d,scratchRectangleWidth,scratchRectangleHeight,s),o.invertClassification=!1,o.passes.pickVoxel=!0,o.tilesetPassState=pickTilesetPassState,r.uniformState.update(o),e.updateEnvironment(),scratchRectangle$1.x=d.x-(scratchRectangleWidth-1)*.5,scratchRectangle$1.y=e.drawingBufferHeight-d.y-(scratchRectangleHeight-1)*.5,scratchRectangle$1.width=scratchRectangleWidth,scratchRectangle$1.height=scratchRectangleHeight,c=l.begin(scratchRectangle$1,s),e.updateAndExecuteCommands(c,scratchColorZero),e.resolveFramebuffers(c);const h=l.readVoxelInfo(scratchRectangle$1);return r.endFrame(),h};function renderTranslucentDepthForPick(e,t){const{defaultView:n,context:i,frameState:r,environmentState:o}=e,{viewport:a,pickDepthFramebuffer:s}=n;e.view=n,a.x=0,a.y=0,a.width=i.drawingBufferWidth,a.height=i.drawingBufferHeight;let l=n.passState;l.viewport=BoundingRectangle.clone(a,l.viewport),e.clearPasses(r.passes),r.passes.pick=!0,r.passes.depth=!0,r.cullingVolume=getPickCullingVolume(e,t,1,1,a),r.tilesetPassState=pickTilesetPassState,e.updateEnvironment(),o.renderTranslucentDepthForPick=!0,l=s.update(i,t,a),e.updateAndExecuteCommands(l,scratchColorZero),e.resolveFramebuffers(l),i.endFrame()}const scratchPerspectiveFrustum$1=new PerspectiveFrustum,scratchPerspectiveOffCenterFrustum$1=new PerspectiveOffCenterFrustum,scratchOrthographicFrustum$1=new OrthographicFrustum,scratchOrthographicOffCenterFrustum$1=new OrthographicOffCenterFrustum;Picking.prototype.pickPositionWorldCoordinates=function(e,t,n){if(!e.useDepthPicking)return;if(Check.defined("windowPosition",t),!e.context.depthTexture)throw new DeveloperError("Picking from the depth buffer is not supported. Check pickPositionSupported.");const i=t.toString();if(this._pickPositionCacheDirty)this._pickPositionCache={},this._pickPositionCacheDirty=!1;else if(this._pickPositionCache.hasOwnProperty(i))return Cartesian3.clone(this._pickPositionCache[i],n);const{context:r,frameState:o,camera:a,defaultView:s}=e,{uniformState:l}=r;e.view=s;const c=SceneTransforms.transformWindowToDrawingBuffer(e,t,scratchPosition$1);e.pickTranslucentDepth?renderTranslucentDepthForPick(e,c):(e.updateFrameState(),l.update(o),e.updateEnvironment()),c.y=e.drawingBufferHeight-c.y;let d;defined(a.frustum.fov)?d=a.frustum.clone(scratchPerspectiveFrustum$1):defined(a.frustum.infiniteProjectionMatrix)?d=a.frustum.clone(scratchPerspectiveOffCenterFrustum$1):defined(a.frustum.width)?d=a.frustum.clone(scratchOrthographicFrustum$1):d=a.frustum.clone(scratchOrthographicOffCenterFrustum$1);const h=s.frustumCommandsList,f=h.length;for(let p=0;p<f;++p){const m=this.getPickDepth(e,p).getDepth(r,c.x,c.y);if(defined(m)&&m>0&&m<1){const g=h[p];let _;return e.mode===SceneMode.SCENE2D?(_=a.position.z,a.position.z=_-g.near+1,d.far=Math.max(1,g.far-g.near),d.near=1,l.update(o),l.updateFrustum(d)):(d.near=g.near*(p!==0?e.opaqueFrustumNearOffset:1),d.far=g.far,l.updateFrustum(d)),n=SceneTransforms.drawingBufferToWorldCoordinates(e,c,m,n),e.mode===SceneMode.SCENE2D&&(a.position.z=_,l.update(o)),this._pickPositionCache[i]=Cartesian3.clone(n),n}}this._pickPositionCache[i]=void 0};const scratchPickPositionCartographic=new Cartographic;Picking.prototype.pickPosition=function(e,t,n){if(n=this.pickPositionWorldCoordinates(e,t,n),defined(n)&&e.mode!==SceneMode.SCENE3D){Cartesian3.fromElements(n.y,n.z,n.x,n);const i=e.mapProjection,r=i.ellipsoid,o=i.unproject(n,scratchPickPositionCartographic);r.cartographicToCartesian(o,n)}return n};function drillPick(e,t){let n,i;const r=[],o=[],a=[],s=[];defined(e)||(e=Number.MAX_VALUE);let l=t();for(;defined(l);){const c=l.object,d=l.position,h=l.exclude;if(defined(d)&&!defined(c)){r.push(l);break}if(!defined(c)||!defined(c.primitive)||!h&&(r.push(l),0>=--e))break;const f=c.primitive;let p=!1;typeof f.getGeometryInstanceAttributes=="function"&&defined(c.id)&&(i=f.getGeometryInstanceAttributes(c.id),defined(i)&&defined(i.show)&&(p=!0,i.show=ShowGeometryInstanceAttribute.toValue(!1,i.show),a.push(i))),c instanceof Cesium3DTileFeature&&(p=!0,c.show=!1,s.push(c)),p||(f.show=!1,o.push(f)),l=t()}for(n=0;n<o.length;++n)o[n].show=!0;for(n=0;n<a.length;++n)i=a[n],i.show=ShowGeometryInstanceAttribute.toValue(!0,i.show);for(n=0;n<s.length;++n)s[n].show=!0;return r}Picking.prototype.drillPick=function(e,t,n,i,r){const o=this;return drillPick(n,function(){const l=o.pick(e,t,i,r);if(defined(l))return{object:l,position:void 0,exclude:!1}}).map(function(l){return l.object})};const scratchRight=new Cartesian3,scratchUp=new Cartesian3;function MostDetailedRayPick(e,t,n){this.ray=e,this.width=t,this.tilesets=n,this.ready=!1;const i=this;this.promise=new Promise(r=>{i._completePick=()=>{r()}})}function updateOffscreenCameraFromRay(e,t,n,i){const r=t.direction,o=Cartesian3.mostOrthogonalAxis(r,scratchRight),a=Cartesian3.cross(r,o,scratchRight),s=Cartesian3.cross(r,a,scratchUp);return i.position=t.origin,i.direction=r,i.up=s,i.right=a,i.frustum.width=defaultValue(n,offscreenDefaultWidth),i.frustum.computeCullingVolume(i.positionWC,i.directionWC,i.upWC)}function updateMostDetailedRayPick(e,t,n){const i=t.frameState,{ray:r,width:o,tilesets:a}=n,s=e._pickOffscreenView.camera,l=updateOffscreenCameraFromRay(e,r,o,s),c=mostDetailedPreloadTilesetPassState;c.camera=s,c.cullingVolume=l;let d=!0;const h=a.length;for(let f=0;f<h;++f){const p=a[f];p.show&&t.primitives.contains(p)&&(p.updateForPass(i,c),d=d&&c.ready)}return d&&n._completePick(),d}Picking.prototype.updateMostDetailedRayPicks=function(e){const t=this._mostDetailedRayPicks;for(let n=0;n<t.length;++n)updateMostDetailedRayPick(this,e,t[n])&&t.splice(n--,1)};function getTilesets(e,t,n){for(let i=0;i<e.length;++i){const r=e.get(i);r.show&&(defined(r.isCesium3DTileset)?(!defined(t)||t.indexOf(r)===-1)&&n.push(r):r instanceof PrimitiveCollection&&getTilesets(r,t,n))}}function launchMostDetailedRayPick(e,t,n,i,r,o){const a=[];if(getTilesets(t.primitives,i,a),a.length===0)return Promise.resolve(o());const s=new MostDetailedRayPick(n,r,a);return e._mostDetailedRayPicks.push(s),s.promise.then(function(){return o()})}function isExcluded(e,t){return!defined(e)||!defined(t)||t.length===0?!1:t.indexOf(e)>-1||t.indexOf(e.primitive)>-1||t.indexOf(e.id)>-1}function getRayIntersection(e,t,n,i,r,o,a){const{context:s,frameState:l}=t,c=s.uniformState,d=e._pickOffscreenView;t.view=d,updateOffscreenCameraFromRay(e,n,r,d.camera),scratchRectangle$1=BoundingRectangle.clone(d.viewport,scratchRectangle$1);const h=d.pickFramebuffer.begin(scratchRectangle$1,d.viewport);t.jobScheduler.disableThisFrame(),t.updateFrameState(),l.invertClassification=!1,l.passes.pick=!0,l.passes.offscreen=!0,a?l.tilesetPassState=mostDetailedPickTilesetPassState:l.tilesetPassState=pickTilesetPassState,c.update(l),t.updateEnvironment(),t.updateAndExecuteCommands(h,scratchColorZero),t.resolveFramebuffers(h);let f;const p=d.pickFramebuffer.end(scratchRectangle$1);if(t.context.depthTexture){const u=d.frustumCommandsList.length;for(let m=0;m<u;++m){const _=e.getPickDepth(t,m).getDepth(s,0,0);if(defined(_)&&_>0&&_<1){const C=d.frustumCommandsList[m],A=C.near*(m!==0?t.opaqueFrustumNearOffset:1),S=C.far,v=A+_*(S-A);f=Ray.getPoint(n,v);break}}}if(t.view=t.defaultView,s.endFrame(),defined(p)||defined(f))return{object:p,position:f,exclude:!defined(f)&&o||isExcluded(p,i)}}function getRayIntersections(e,t,n,i,r,o,a,s){return drillPick(i,function(){return getRayIntersection(e,t,n,r,o,a,s)})}function pickFromRay(e,t,n,i,r,o,a){const s=getRayIntersections(e,t,n,1,i,r,o,a);if(s.length>0)return s[0]}function drillPickFromRay(e,t,n,i,r,o,a,s){return getRayIntersections(e,t,n,i,r,o,a,s)}function deferPromiseUntilPostRender(e,t){return new Promise((n,i)=>{t.then(function(r){const o=e.postRender.addEventListener(function(){o(),n(r)});e.requestRender()}).catch(function(r){i(r)})})}Picking.prototype.pickFromRay=function(e,t,n,i){if(Check.defined("ray",t),e.mode!==SceneMode.SCENE3D)throw new DeveloperError("Ray intersections are only supported in 3D mode.");return pickFromRay(this,e,t,n,i,!1,!1)};Picking.prototype.drillPickFromRay=function(e,t,n,i,r){if(Check.defined("ray",t),e.mode!==SceneMode.SCENE3D)throw new DeveloperError("Ray intersections are only supported in 3D mode.");return drillPickFromRay(this,e,t,n,i,r,!1,!1)};Picking.prototype.pickFromRayMostDetailed=function(e,t,n,i){if(Check.defined("ray",t),e.mode!==SceneMode.SCENE3D)throw new DeveloperError("Ray intersections are only supported in 3D mode.");const r=this;return t=Ray.clone(t),n=defined(n)?n.slice():n,deferPromiseUntilPostRender(e,launchMostDetailedRayPick(r,e,t,n,i,function(){return pickFromRay(r,e,t,n,i,!1,!0)}))};Picking.prototype.drillPickFromRayMostDetailed=function(e,t,n,i,r){if(Check.defined("ray",t),e.mode!==SceneMode.SCENE3D)throw new DeveloperError("Ray intersections are only supported in 3D mode.");const o=this;return t=Ray.clone(t),i=defined(i)?i.slice():i,deferPromiseUntilPostRender(e,launchMostDetailedRayPick(o,e,t,i,r,function(){return drillPickFromRay(o,e,t,n,i,r,!1,!0)}))};const scratchSurfacePosition=new Cartesian3,scratchSurfaceNormal$1=new Cartesian3,scratchSurfaceRay=new Ray,scratchCartographic$1=new Cartographic;function getRayForSampleHeight(e,t){const n=e.ellipsoid,i=ApproximateTerrainHeights._defaultMaxTerrainHeight,r=n.geodeticSurfaceNormalCartographic(t,scratchSurfaceNormal$1),o=Cartographic.toCartesian(t,n,scratchSurfacePosition),a=scratchSurfaceRay;a.origin=o,a.direction=r;const s=new Ray;return Ray.getPoint(a,i,s.origin),Cartesian3.negate(r,s.direction),s}function getRayForClampToHeight(e,t){const n=e.ellipsoid,i=Cartographic.fromCartesian(t,n,scratchCartographic$1);return getRayForSampleHeight(e,i)}function getHeightFromCartesian(e,t){const n=e.ellipsoid;return Cartographic.fromCartesian(t,n,scratchCartographic$1).height}function sampleHeightMostDetailed(e,t,n,i,r){const o=getRayForSampleHeight(t,n);return launchMostDetailedRayPick(e,t,o,i,r,function(){const a=pickFromRay(e,t,o,i,r,!0,!0);if(defined(a))return getHeightFromCartesian(t,a.position)})}function clampToHeightMostDetailed(e,t,n,i,r,o){const a=getRayForClampToHeight(t,n);return launchMostDetailedRayPick(e,t,a,i,r,function(){const s=pickFromRay(e,t,a,i,r,!0,!0);if(defined(s))return Cartesian3.clone(s.position,o)})}Picking.prototype.sampleHeight=function(e,t,n,i){if(Check.defined("position",t),e.mode!==SceneMode.SCENE3D)throw new DeveloperError("sampleHeight is only supported in 3D mode.");if(!e.sampleHeightSupported)throw new DeveloperError("sampleHeight requires depth texture support. Check sampleHeightSupported.");const r=getRayForSampleHeight(e,t),o=pickFromRay(this,e,r,n,i,!0,!1);if(defined(o))return getHeightFromCartesian(e,o.position)};Picking.prototype.clampToHeight=function(e,t,n,i,r){if(Check.defined("cartesian",t),e.mode!==SceneMode.SCENE3D)throw new DeveloperError("clampToHeight is only supported in 3D mode.");if(!e.clampToHeightSupported)throw new DeveloperError("clampToHeight requires depth texture support. Check clampToHeightSupported.");const o=getRayForClampToHeight(e,t),a=pickFromRay(this,e,o,n,i,!0,!1);if(defined(a))return Cartesian3.clone(a.position,r)};Picking.prototype.sampleHeightMostDetailed=function(e,t,n,i){if(Check.defined("positions",t),e.mode!==SceneMode.SCENE3D)throw new DeveloperError("sampleHeightMostDetailed is only supported in 3D mode.");if(!e.sampleHeightSupported)throw new DeveloperError("sampleHeightMostDetailed requires depth texture support. Check sampleHeightSupported.");n=defined(n)?n.slice():n;const r=t.length,o=new Array(r);for(let a=0;a<r;++a)o[a]=sampleHeightMostDetailed(this,e,t[a],n,i);return deferPromiseUntilPostRender(e,Promise.all(o).then(function(a){const s=a.length;for(let l=0;l<s;++l)t[l].height=a[l];return t}))};Picking.prototype.clampToHeightMostDetailed=function(e,t,n,i){if(Check.defined("cartesians",t),e.mode!==SceneMode.SCENE3D)throw new DeveloperError("clampToHeightMostDetailed is only supported in 3D mode.");if(!e.clampToHeightSupported)throw new DeveloperError("clampToHeightMostDetailed requires depth texture support. Check clampToHeightSupported.");n=defined(n)?n.slice():n;const r=t.length,o=new Array(r);for(let a=0;a<r;++a)o[a]=clampToHeightMostDetailed(this,e,t[a],n,i,t[a]);return deferPromiseUntilPostRender(e,Promise.all(o).then(function(a){const s=a.length;for(let l=0;l<s;++l)t[l]=a[l];return t}))};Picking.prototype.destroy=function(){this._pickOffscreenView=this._pickOffscreenView&&this._pickOffscreenView.destroy()};const AcesTonemapping=`uniform sampler2D colorTexture;

in vec2 v_textureCoordinates;

#ifdef AUTO_EXPOSURE
uniform sampler2D autoExposure;
#endif

void main()
{
    vec4 fragmentColor = texture(colorTexture, v_textureCoordinates);
    vec3 color = fragmentColor.rgb;

#ifdef AUTO_EXPOSURE
    color /= texture(autoExposure, vec2(0.5)).r;
#endif
    color = czm_acesTonemapping(color);
    color = czm_inverseGamma(color);

    out_FragColor = vec4(color, fragmentColor.a);
}
`,AmbientOcclusionGenerate=`uniform sampler2D randomTexture;
uniform sampler2D depthTexture;
uniform float intensity;
uniform float bias;
uniform float lengthCap;
uniform float stepSize;
uniform float frustumLength;

in vec2 v_textureCoordinates;

vec4 clipToEye(vec2 uv, float depth)
{
    vec2 xy = vec2((uv.x * 2.0 - 1.0), ((1.0 - uv.y) * 2.0 - 1.0));
    vec4 posEC = czm_inverseProjection * vec4(xy, depth, 1.0);
    posEC = posEC / posEC.w;
    return posEC;
}

//Reconstruct Normal Without Edge Removation
vec3 getNormalXEdge(vec3 posInCamera, float depthU, float depthD, float depthL, float depthR, vec2 pixelSize)
{
    vec4 posInCameraUp = clipToEye(v_textureCoordinates - vec2(0.0, pixelSize.y), depthU);
    vec4 posInCameraDown = clipToEye(v_textureCoordinates + vec2(0.0, pixelSize.y), depthD);
    vec4 posInCameraLeft = clipToEye(v_textureCoordinates - vec2(pixelSize.x, 0.0), depthL);
    vec4 posInCameraRight = clipToEye(v_textureCoordinates + vec2(pixelSize.x, 0.0), depthR);

    vec3 up = posInCamera.xyz - posInCameraUp.xyz;
    vec3 down = posInCameraDown.xyz - posInCamera.xyz;
    vec3 left = posInCamera.xyz - posInCameraLeft.xyz;
    vec3 right = posInCameraRight.xyz - posInCamera.xyz;

    vec3 DX = length(left) < length(right) ? left : right;
    vec3 DY = length(up) < length(down) ? up : down;

    return normalize(cross(DY, DX));
}

void main(void)
{
    float depth = czm_readDepth(depthTexture, v_textureCoordinates);
    vec4 posInCamera = clipToEye(v_textureCoordinates, depth);

    if (posInCamera.z > frustumLength)
    {
        out_FragColor = vec4(1.0);
        return;
    }

    vec2 pixelSize = czm_pixelRatio / czm_viewport.zw;
    float depthU = czm_readDepth(depthTexture, v_textureCoordinates - vec2(0.0, pixelSize.y));
    float depthD = czm_readDepth(depthTexture, v_textureCoordinates + vec2(0.0, pixelSize.y));
    float depthL = czm_readDepth(depthTexture, v_textureCoordinates - vec2(pixelSize.x, 0.0));
    float depthR = czm_readDepth(depthTexture, v_textureCoordinates + vec2(pixelSize.x, 0.0));
    vec3 normalInCamera = getNormalXEdge(posInCamera.xyz, depthU, depthD, depthL, depthR, pixelSize);

    float ao = 0.0;
    vec2 sampleDirection = vec2(1.0, 0.0);
    float gapAngle = 90.0 * czm_radiansPerDegree;

    // RandomNoise
    float randomVal = texture(randomTexture, v_textureCoordinates / pixelSize / 255.0).x;

    //Loop for each direction
    for (int i = 0; i < 4; i++)
    {
        float newGapAngle = gapAngle * (float(i) + randomVal);
        float cosVal = cos(newGapAngle);
        float sinVal = sin(newGapAngle);

        //Rotate Sampling Direction
        vec2 rotatedSampleDirection = vec2(cosVal * sampleDirection.x - sinVal * sampleDirection.y, sinVal * sampleDirection.x + cosVal * sampleDirection.y);
        float localAO = 0.0;
        float localStepSize = stepSize;

        //Loop for each step
        for (int j = 0; j < 6; j++)
        {
            vec2 newCoords = v_textureCoordinates + rotatedSampleDirection * localStepSize * pixelSize;

            //Exception Handling
            if(newCoords.x > 1.0 || newCoords.y > 1.0 || newCoords.x < 0.0 || newCoords.y < 0.0)
            {
                break;
            }

            float stepDepthInfo = czm_readDepth(depthTexture, newCoords);
            vec4 stepPosInCamera = clipToEye(newCoords, stepDepthInfo);
            vec3 diffVec = stepPosInCamera.xyz - posInCamera.xyz;
            float len = length(diffVec);

            if (len > lengthCap)
            {
                break;
            }

            float dotVal = clamp(dot(normalInCamera, normalize(diffVec)), 0.0, 1.0 );
            float weight = len / lengthCap;
            weight = 1.0 - weight * weight;

            if (dotVal < bias)
            {
                dotVal = 0.0;
            }

            localAO = max(localAO, dotVal * weight);
            localStepSize += stepSize;
        }
        ao += localAO;
    }

    ao /= 4.0;
    ao = 1.0 - clamp(ao, 0.0, 1.0);
    ao = pow(ao, intensity);
    out_FragColor = vec4(vec3(ao), 1.0);
}
`,AmbientOcclusionModulate=`uniform sampler2D colorTexture;
uniform sampler2D ambientOcclusionTexture;
uniform bool ambientOcclusionOnly;
in vec2 v_textureCoordinates;

void main(void)
{
    vec4 color = texture(colorTexture, v_textureCoordinates);
    vec4 ao = texture(ambientOcclusionTexture, v_textureCoordinates);
    out_FragColor = ambientOcclusionOnly ? ao : ao * color;
}
`,BlackAndWhite=`uniform sampler2D colorTexture;
uniform float gradations;

in vec2 v_textureCoordinates;

void main(void)
{
    vec3 rgb = texture(colorTexture, v_textureCoordinates).rgb;
#ifdef CZM_SELECTED_FEATURE
    if (czm_selected()) {
        out_FragColor = vec4(rgb, 1.0);
        return;
    }
#endif
    float luminance = czm_luminance(rgb);
    float darkness = luminance * gradations;
    darkness = (darkness - fract(darkness)) / gradations;
    out_FragColor = vec4(vec3(darkness), 1.0);
}
`,BloomComposite=`uniform sampler2D colorTexture;
uniform sampler2D bloomTexture;
uniform bool glowOnly;

in vec2 v_textureCoordinates;

void main(void)
{
    vec4 color = texture(colorTexture, v_textureCoordinates);

#ifdef CZM_SELECTED_FEATURE
    if (czm_selected()) {
        out_FragColor = color;
        return;
    }
#endif

    vec4 bloom = texture(bloomTexture, v_textureCoordinates);
    out_FragColor = glowOnly ? bloom : bloom + color;
}
`,Brightness=`uniform sampler2D colorTexture;
uniform float brightness;

in vec2 v_textureCoordinates;

void main(void)
{
    vec3 rgb = texture(colorTexture, v_textureCoordinates).rgb;
    vec3 target = vec3(0.0);
    out_FragColor = vec4(mix(target, rgb, brightness), 1.0);
}
`,ContrastBias=`uniform sampler2D colorTexture;
uniform float contrast;
uniform float brightness;

in vec2 v_textureCoordinates;

void main(void)
{
    vec3 sceneColor = texture(colorTexture, v_textureCoordinates).xyz;
    sceneColor = czm_RGBToHSB(sceneColor);
    sceneColor.z += brightness;
    sceneColor = czm_HSBToRGB(sceneColor);

    float factor = (259.0 * (contrast + 255.0)) / (255.0 * (259.0 - contrast));
    sceneColor = factor * (sceneColor - vec3(0.5)) + vec3(0.5);
    out_FragColor = vec4(sceneColor, 1.0);
}
`,DepthOfField=`uniform sampler2D colorTexture;
uniform sampler2D blurTexture;
uniform sampler2D depthTexture;
uniform float focalDistance;

in vec2 v_textureCoordinates;

vec4 toEye(vec2 uv, float depth)
{
   vec2 xy = vec2((uv.x * 2.0 - 1.0), ((1.0 - uv.y) * 2.0 - 1.0));
   vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);
   posInCamera = posInCamera / posInCamera.w;
   return posInCamera;
}

float computeDepthBlur(float depth)
{
    float f;
    if (depth < focalDistance)
    {
        f = (focalDistance - depth) / (focalDistance - czm_currentFrustum.x);
    }
    else
    {
        f = (depth - focalDistance) / (czm_currentFrustum.y - focalDistance);
        f = pow(f, 0.1);
    }
    f *= f;
    f = clamp(f, 0.0, 1.0);
    return pow(f, 0.5);
}

void main(void)
{
    float depth = czm_readDepth(depthTexture, v_textureCoordinates);
    vec4 posInCamera = toEye(v_textureCoordinates, depth);
    float d = computeDepthBlur(-posInCamera.z);
    out_FragColor = mix(texture(colorTexture, v_textureCoordinates), texture(blurTexture, v_textureCoordinates), d);
}
`,DepthView=`uniform sampler2D depthTexture;

in vec2 v_textureCoordinates;

void main(void)
{
    float depth = czm_readDepth(depthTexture, v_textureCoordinates);
    out_FragColor = vec4(vec3(depth), 1.0);
}
`,EdgeDetection=`uniform sampler2D depthTexture;
uniform float length;
uniform vec4 color;

in vec2 v_textureCoordinates;

void main(void)
{
    float directions[3];
    directions[0] = -1.0;
    directions[1] = 0.0;
    directions[2] = 1.0;

    float scalars[3];
    scalars[0] = 3.0;
    scalars[1] = 10.0;
    scalars[2] = 3.0;

    float padx = czm_pixelRatio / czm_viewport.z;
    float pady = czm_pixelRatio / czm_viewport.w;

#ifdef CZM_SELECTED_FEATURE
    bool selected = false;
    for (int i = 0; i < 3; ++i)
    {
        float dir = directions[i];
        selected = selected || czm_selected(vec2(-padx, dir * pady));
        selected = selected || czm_selected(vec2(padx, dir * pady));
        selected = selected || czm_selected(vec2(dir * padx, -pady));
        selected = selected || czm_selected(vec2(dir * padx, pady));
        if (selected)
        {
            break;
        }
    }
    if (!selected)
    {
        out_FragColor = vec4(color.rgb, 0.0);
        return;
    }
#endif

    float horizEdge = 0.0;
    float vertEdge = 0.0;

    for (int i = 0; i < 3; ++i)
    {
        float dir = directions[i];
        float scale = scalars[i];

        horizEdge -= texture(depthTexture, v_textureCoordinates + vec2(-padx, dir * pady)).x * scale;
        horizEdge += texture(depthTexture, v_textureCoordinates + vec2(padx, dir * pady)).x * scale;

        vertEdge -= texture(depthTexture, v_textureCoordinates + vec2(dir * padx, -pady)).x * scale;
        vertEdge += texture(depthTexture, v_textureCoordinates + vec2(dir * padx, pady)).x * scale;
    }

    float len = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);
    out_FragColor = vec4(color.rgb, len > length ? color.a : 0.0);
}
`,FilmicTonemapping=`uniform sampler2D colorTexture;

in vec2 v_textureCoordinates;

#ifdef AUTO_EXPOSURE
uniform sampler2D autoExposure;
#endif

// See slides 142 and 143:
//     http://www.gdcvault.com/play/1012459/Uncharted_2__HDR_Lighting

void main()
{
    vec4 fragmentColor = texture(colorTexture, v_textureCoordinates);
    vec3 color = fragmentColor.rgb;

#ifdef AUTO_EXPOSURE
    float exposure = texture(autoExposure, vec2(0.5)).r;
    color /= exposure;
#endif

	const float A = 0.22; // shoulder strength
	const float B = 0.30; // linear strength
	const float C = 0.10; // linear angle
	const float D = 0.20; // toe strength
	const float E = 0.01; // toe numerator
	const float F = 0.30; // toe denominator

	const float white = 11.2; // linear white point value

	vec3 c = ((color * (A * color + C * B) + D * E) / (color * ( A * color + B) + D * F)) - E / F;
	float w = ((white * (A * white + C * B) + D * E) / (white * ( A * white + B) + D * F)) - E / F;

	c = czm_inverseGamma(c / w);
	out_FragColor = vec4(c, fragmentColor.a);
}
`,FXAA=`in vec2 v_textureCoordinates;

uniform sampler2D colorTexture;

const float fxaaQualitySubpix = 0.5;
const float fxaaQualityEdgeThreshold = 0.125;
const float fxaaQualityEdgeThresholdMin = 0.0833;

void main()
{
    vec2 fxaaQualityRcpFrame = vec2(1.0) / czm_viewport.zw;
    vec4 color = FxaaPixelShader(
        v_textureCoordinates,
        colorTexture,
        fxaaQualityRcpFrame,
        fxaaQualitySubpix,
        fxaaQualityEdgeThreshold,
        fxaaQualityEdgeThresholdMin);
    float alpha = texture(colorTexture, v_textureCoordinates).a;
    out_FragColor = vec4(color.rgb, alpha);
}
`,GaussianBlur1D=`#define SAMPLES 8

uniform float delta;
uniform float sigma;
uniform float direction; // 0.0 for x direction, 1.0 for y direction

uniform sampler2D colorTexture;

#ifdef USE_STEP_SIZE
uniform float stepSize;
#else
uniform vec2 step;
#endif

in vec2 v_textureCoordinates;

//  Incremental Computation of the Gaussian:
//  https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch40.html

void main()
{
    vec2 st = v_textureCoordinates;
    vec2 dir = vec2(1.0 - direction, direction);

#ifdef USE_STEP_SIZE
    vec2 step = vec2(stepSize * (czm_pixelRatio / czm_viewport.zw));
#else
    vec2 step = step;
#endif

    vec3 g;
    g.x = 1.0 / (sqrt(czm_twoPi) * sigma);
    g.y = exp((-0.5 * delta * delta) / (sigma * sigma));
    g.z = g.y * g.y;

    vec4 result = texture(colorTexture, st) * g.x;
    for (int i = 1; i < SAMPLES; ++i)
    {
        g.xy *= g.yz;

        vec2 offset = float(i) * dir * step;
        result += texture(colorTexture, st - offset) * g.x;
        result += texture(colorTexture, st + offset) * g.x;
    }

    out_FragColor = result;
}
`,LensFlare=`uniform sampler2D colorTexture;
uniform sampler2D dirtTexture;
uniform sampler2D starTexture;
uniform vec2 dirtTextureDimensions;
uniform float distortion;
uniform float ghostDispersal;
uniform float haloWidth;
uniform float dirtAmount;
uniform float earthRadius;
uniform float intensity;

in vec2 v_textureCoordinates;

// whether it is in space or not
// 6500000.0 is empirical value
#define DISTANCE_TO_SPACE 6500000.0

// return ndc from world coordinate biased earthRadius
vec4 getNDCFromWC(vec3 WC, float earthRadius)
{
    vec4 positionEC = czm_view * vec4(WC, 1.0);
    positionEC = vec4(positionEC.x + earthRadius, positionEC.y, positionEC.z, 1.0);
    vec4 positionWC = czm_eyeToWindowCoordinates(positionEC);
    return czm_viewportOrthographic * vec4(positionWC.xy, -positionWC.z, 1.0);
}

// Check if current pixel is included Earth
// if then mask it gradually
float isInEarth(vec2 texcoord, vec2 sceneSize)
{
    vec2 NDC = texcoord * 2.0 - 1.0;
    vec4 earthPosSC = getNDCFromWC(vec3(0.0), 0.0);
    vec4 earthPosSCEdge = getNDCFromWC(vec3(0.0), earthRadius * 1.5);
    NDC.xy -= earthPosSC.xy;

    float X = abs(NDC.x) * sceneSize.x;
    float Y = abs(NDC.y) * sceneSize.y;

    return clamp(0.0, 1.0, max(sqrt(X * X + Y * Y) / max(abs(earthPosSCEdge.x * sceneSize.x), 1.0) - 0.8 , 0.0));
}

// For Chromatic effect
vec4 textureDistorted(sampler2D tex, vec2 texcoord, vec2 direction, vec3 distortion, bool isSpace)
{
    vec2 sceneSize = czm_viewport.zw;
    vec3 color;
    if(isSpace)
    {
        color.r = isInEarth(texcoord + direction * distortion.r, sceneSize) * texture(tex, texcoord + direction * distortion.r).r;
        color.g = isInEarth(texcoord + direction * distortion.g, sceneSize) * texture(tex, texcoord + direction * distortion.g).g;
        color.b = isInEarth(texcoord + direction * distortion.b, sceneSize) * texture(tex, texcoord + direction * distortion.b).b;
    }
    else
    {
        color.r = texture(tex, texcoord + direction * distortion.r).r;
        color.g = texture(tex, texcoord + direction * distortion.g).g;
        color.b = texture(tex, texcoord + direction * distortion.b).b;
    }
    return vec4(clamp(color, 0.0, 1.0), 0.0);
}

void main(void)
{
    vec4 originalColor = texture(colorTexture, v_textureCoordinates);
    vec3 rgb = originalColor.rgb;
    bool isSpace = length(czm_viewerPositionWC.xyz) > DISTANCE_TO_SPACE;

    // Sun position
    vec4 sunPos = czm_morphTime == 1.0 ? vec4(czm_sunPositionWC, 1.0) : vec4(czm_sunPositionColumbusView.zxy, 1.0);
    vec4 sunPositionEC = czm_view * sunPos;
    vec4 sunPositionWC = czm_eyeToWindowCoordinates(sunPositionEC);
    sunPos = czm_viewportOrthographic * vec4(sunPositionWC.xy, -sunPositionWC.z, 1.0);

    // If sun is not in the screen space, use original color.
    if(!isSpace || !((sunPos.x >= -1.1 && sunPos.x <= 1.1) && (sunPos.y >= -1.1 && sunPos.y <= 1.1)))
    {
        // Lens flare is disabled when not in space until #5932 is fixed.
        //    https://github.com/CesiumGS/cesium/issues/5932
        out_FragColor = originalColor;
        return;
    }

    vec2 texcoord = vec2(1.0) - v_textureCoordinates;
    vec2 pixelSize = czm_pixelRatio / czm_viewport.zw;
    vec2 invPixelSize = 1.0 / pixelSize;
    vec3 distortionVec = pixelSize.x * vec3(-distortion, 0.0, distortion);

    // ghost vector to image centre:
    vec2 ghostVec = (vec2(0.5) - texcoord) * ghostDispersal;
    vec3 direction = normalize(vec3(ghostVec, 0.0));

    // sample ghosts:
    vec4 result = vec4(0.0);
    vec4 ghost = vec4(0.0);
    for (int i = 0; i < 4; ++i)
    {
        vec2 offset = fract(texcoord + ghostVec * float(i));
        // Only bright spots from the centre of the source image
        ghost += textureDistorted(colorTexture, offset, direction.xy, distortionVec, isSpace);
    }
    result += ghost;

    // sample halo
    vec2 haloVec = normalize(ghostVec) * haloWidth;
    float weightForHalo = length(vec2(0.5) - fract(texcoord + haloVec)) / length(vec2(0.5));
    weightForHalo = pow(1.0 - weightForHalo, 5.0);

    result += textureDistorted(colorTexture, texcoord + haloVec, direction.xy, distortionVec, isSpace) * weightForHalo * 1.5;

    // dirt on lens
    vec2 dirtTexCoords = (v_textureCoordinates * invPixelSize) / dirtTextureDimensions;
    if (dirtTexCoords.x > 1.0)
    {
        dirtTexCoords.x = mod(floor(dirtTexCoords.x), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.x) :  fract(dirtTexCoords.x);
    }
    if (dirtTexCoords.y > 1.0)
    {
        dirtTexCoords.y = mod(floor(dirtTexCoords.y), 2.0) == 1.0 ? 1.0 - fract(dirtTexCoords.y) :  fract(dirtTexCoords.y);
    }
    result += dirtAmount * texture(dirtTexture, dirtTexCoords);

    // Rotating starburst texture's coordinate
    // dot(czm_view[0].xyz, vec3(0.0, 0.0, 1.0)) + dot(czm_view[1].xyz, vec3(0.0, 1.0, 0.0))
    float camrot = czm_view[0].z + czm_view[1].y;
    float cosValue = cos(camrot);
    float sinValue = sin(camrot);
    mat3 rotation = mat3(
        cosValue, -sinValue, 0.0,
        sinValue, cosValue, 0.0,
        0.0, 0.0, 1.0
    );

    vec3 st1 = vec3(v_textureCoordinates * 2.0 - vec2(1.0), 1.0);
    vec3 st2 = vec3((rotation * st1).xy, 1.0);
    vec3 st3 = st2 * 0.5 + vec3(0.5);
    vec2 lensStarTexcoord = st3.xy;
    float weightForLensFlare = length(vec3(sunPos.xy, 0.0));
    float oneMinusWeightForLensFlare = max(1.0 - weightForLensFlare, 0.0);

    if (!isSpace)
    {
        result *= oneMinusWeightForLensFlare * intensity * 0.2;
    }
    else
    {
        result *= oneMinusWeightForLensFlare * intensity;
        result *= texture(starTexture, lensStarTexcoord) * pow(weightForLensFlare, 1.0) * max((1.0 - length(vec3(st1.xy, 0.0))), 0.0) * 2.0;
    }

    result += texture(colorTexture, v_textureCoordinates);

    out_FragColor = result;
}
`,ModifiedReinhardTonemapping=`uniform sampler2D colorTexture;
uniform vec3 white;

in vec2 v_textureCoordinates;

#ifdef AUTO_EXPOSURE
uniform sampler2D autoExposure;
#endif

// See equation 4:
//    http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf

void main()
{
    vec4 fragmentColor = texture(colorTexture, v_textureCoordinates);
    vec3 color = fragmentColor.rgb;
#ifdef AUTO_EXPOSURE
    float exposure = texture(autoExposure, vec2(0.5)).r;
    color /= exposure;
#endif
    color = (color * (1.0 + color / white)) / (1.0 + color);
    color = czm_inverseGamma(color);
    out_FragColor = vec4(color, fragmentColor.a);
}
`,NightVision=`uniform sampler2D colorTexture;

in vec2 v_textureCoordinates;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);
}

void main(void)
{
    float noiseValue = rand(v_textureCoordinates + sin(czm_frameNumber)) * 0.1;
    vec3 rgb = texture(colorTexture, v_textureCoordinates).rgb;
    vec3 green = vec3(0.0, 1.0, 0.0);
    out_FragColor = vec4((noiseValue + rgb) * green, 1.0);
}
`,ReinhardTonemapping=`uniform sampler2D colorTexture;

in vec2 v_textureCoordinates;

#ifdef AUTO_EXPOSURE
uniform sampler2D autoExposure;
#endif

// See equation 3:
//    http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf

void main()
{
    vec4 fragmentColor = texture(colorTexture, v_textureCoordinates);
    vec3 color = fragmentColor.rgb;
#ifdef AUTO_EXPOSURE
    float exposure = texture(autoExposure, vec2(0.5)).r;
    color /= exposure;
#endif
    color = color / (1.0 + color);
    color = czm_inverseGamma(color);
    out_FragColor = vec4(color, fragmentColor.a);
}
`,Silhouette=`uniform sampler2D colorTexture;
uniform sampler2D silhouetteTexture;

in vec2 v_textureCoordinates;

void main(void)
{
    vec4 silhouetteColor = texture(silhouetteTexture, v_textureCoordinates);
    vec4 color = texture(colorTexture, v_textureCoordinates);
    out_FragColor = mix(color, silhouetteColor, silhouetteColor.a);
}
`;function AutoExposure(){this._uniformMap=void 0,this._command=void 0,this._colorTexture=void 0,this._depthTexture=void 0,this._ready=!1,this._name="czm_autoexposure",this._logDepthChanged=void 0,this._useLogDepth=void 0,this._framebuffers=void 0,this._previousLuminance=new FramebufferManager,this._commands=void 0,this._clearCommand=void 0,this._minMaxLuminance=new Cartesian2,this.enabled=!0,this._enabled=!0,this.minimumLuminance=.1,this.maximumLuminance=10}Object.defineProperties(AutoExposure.prototype,{ready:{get:function(){return this._ready}},name:{get:function(){return this._name}},outputTexture:{get:function(){const e=this._framebuffers;if(defined(e))return e[e.length-1].getColorTexture(0)}}});function destroyFramebuffers(e){const t=e._framebuffers;if(!defined(t))return;const n=t.length;for(let i=0;i<n;++i)t[i].destroy();e._framebuffers=void 0,e._previousLuminance.destroy(),e._previousLuminance=void 0}function createFramebuffers$1(e,t){destroyFramebuffers(e);let n=e._width,i=e._height;const r=t.halfFloatingPointTexture?PixelDatatype.HALF_FLOAT:PixelDatatype.FLOAT,o=Math.ceil(Math.log(Math.max(n,i))/Math.log(3)),a=new Array(o);for(let l=0;l<o;++l)n=Math.max(Math.ceil(n/3),1),i=Math.max(Math.ceil(i/3),1),a[l]=new FramebufferManager,a[l].update(t,n,i,1,r);const s=a[o-1].getColorTexture(0);e._previousLuminance.update(t,s.width,s.height,1,r),e._framebuffers=a}function destroyCommands(e){const t=e._commands;if(!defined(t))return;const n=t.length;for(let i=0;i<n;++i)t[i].shaderProgram.destroy();e._commands=void 0}function createUniformMap$2(e,t){let n;if(t===0)n={colorTexture:function(){return e._colorTexture},colorTextureDimensions:function(){return e._colorTexture.dimensions}};else{const i=e._framebuffers[t-1].getColorTexture(0);n={colorTexture:function(){return i},colorTextureDimensions:function(){return i.dimensions}}}return n.minMaxLuminance=function(){return e._minMaxLuminance},n.previousLuminance=function(){return e._previousLuminance.getColorTexture(0)},n}function getShaderSource(e,t){let n=`uniform sampler2D colorTexture; 
in vec2 v_textureCoordinates; 
float sampleTexture(vec2 offset) { 
`;return e===0?n+=`    vec4 color = texture(colorTexture, v_textureCoordinates + offset); 
    return czm_luminance(color.rgb); 
`:n+=`    return texture(colorTexture, v_textureCoordinates + offset).r; 
`,n+=`}

`,n+=`uniform vec2 colorTextureDimensions; 
uniform vec2 minMaxLuminance; 
uniform sampler2D previousLuminance; 
void main() { 
    float color = 0.0; 
    float xStep = 1.0 / colorTextureDimensions.x; 
    float yStep = 1.0 / colorTextureDimensions.y; 
    int count = 0; 
    for (int i = 0; i < 3; ++i) { 
        for (int j = 0; j < 3; ++j) { 
            vec2 offset; 
            offset.x = -xStep + float(i) * xStep; 
            offset.y = -yStep + float(j) * yStep; 
            if (offset.x < 0.0 || offset.x > 1.0 || offset.y < 0.0 || offset.y > 1.0) { 
                continue; 
            } 
            color += sampleTexture(offset); 
            ++count; 
        } 
    } 
    if (count > 0) { 
        color /= float(count); 
    } 
`,e===t-1&&(n+=`    float previous = texture(previousLuminance, vec2(0.5)).r; 
    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); 
    color = previous + (color - previous) / (60.0 * 1.5); 
    color = clamp(color, minMaxLuminance.x, minMaxLuminance.y); 
`),n+=`    out_FragColor = vec4(color); 
} 
`,n}function createCommands(e,t){destroyCommands(e);const n=e._framebuffers,i=n.length,r=new Array(i);for(let o=0;o<i;++o)r[o]=t.createViewportQuadCommand(getShaderSource(o,i),{framebuffer:n[o].framebuffer,uniformMap:createUniformMap$2(e,o)});e._commands=r}AutoExposure.prototype.clear=function(e){const t=this._framebuffers;if(!defined(t))return;let n=this._clearCommand;defined(n)||(n=this._clearCommand=new ClearCommand({color:new Color(0,0,0,0),framebuffer:void 0}));const i=t.length;for(let r=0;r<i;++r)t[r].clear(e,n)};AutoExposure.prototype.update=function(e){const t=e.drawingBufferWidth,n=e.drawingBufferHeight;(t!==this._width||n!==this._height)&&(this._width=t,this._height=n,createFramebuffers$1(this,e),createCommands(this,e),this._ready||(this._ready=!0)),this._minMaxLuminance.x=this.minimumLuminance,this._minMaxLuminance.y=this.maximumLuminance;const i=this._framebuffers,r=i[i.length-1];i[i.length-1]=this._previousLuminance,this._commands[this._commands.length-1].framebuffer=this._previousLuminance.framebuffer,this._previousLuminance=r};AutoExposure.prototype.execute=function(e,t){this._colorTexture=t;const n=this._commands;if(!defined(n))return;const i=n.length;for(let r=0;r<i;++r)n[r].execute(e)};AutoExposure.prototype.isDestroyed=function(){return!1};AutoExposure.prototype.destroy=function(){return destroyFramebuffers(this),destroyCommands(this),destroyObject(this)};const PostProcessStageSampleMode={NEAREST:0,LINEAR:1},PostProcessStageSampleMode$1=PostProcessStageSampleMode;function PostProcessStage(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.fragmentShader,n=defaultValue(e.textureScale,1),i=defaultValue(e.pixelFormat,PixelFormat.RGBA);if(Check.typeOf.string("options.fragmentShader",t),Check.typeOf.number.greaterThan("options.textureScale",n,0),Check.typeOf.number.lessThanOrEquals("options.textureScale",n,1),!PixelFormat.isColorFormat(i))throw new DeveloperError("options.pixelFormat must be a color format.");this._fragmentShader=t,this._uniforms=e.uniforms,this._textureScale=n,this._forcePowerOfTwo=defaultValue(e.forcePowerOfTwo,!1),this._sampleMode=defaultValue(e.sampleMode,PostProcessStageSampleMode$1.NEAREST),this._pixelFormat=i,this._pixelDatatype=defaultValue(e.pixelDatatype,PixelDatatype.UNSIGNED_BYTE),this._clearColor=defaultValue(e.clearColor,Color.BLACK),this._uniformMap=void 0,this._command=void 0,this._colorTexture=void 0,this._depthTexture=void 0,this._idTexture=void 0,this._actualUniforms={},this._dirtyUniforms=[],this._texturesToRelease=[],this._texturesToCreate=[],this._texturePromise=void 0;const r=new PassState;r.scissorTest={enabled:!0,rectangle:defined(e.scissorRectangle)?BoundingRectangle.clone(e.scissorRectangle):new BoundingRectangle},this._passState=r,this._ready=!1;let o=e.name;defined(o)||(o=createGuid()),this._name=o,this._logDepthChanged=void 0,this._useLogDepth=void 0,this._selectedIdTexture=void 0,this._selected=void 0,this._selectedShadow=void 0,this._parentSelected=void 0,this._parentSelectedShadow=void 0,this._combinedSelected=void 0,this._combinedSelectedShadow=void 0,this._selectedLength=0,this._parentSelectedLength=0,this._selectedDirty=!0,this._textureCache=void 0,this._index=void 0,this.enabled=!0,this._enabled=!0}Object.defineProperties(PostProcessStage.prototype,{ready:{get:function(){return this._ready}},name:{get:function(){return this._name}},fragmentShader:{get:function(){return this._fragmentShader}},uniforms:{get:function(){return this._uniforms}},textureScale:{get:function(){return this._textureScale}},forcePowerOfTwo:{get:function(){return this._forcePowerOfTwo}},sampleMode:{get:function(){return this._sampleMode}},pixelFormat:{get:function(){return this._pixelFormat}},pixelDatatype:{get:function(){return this._pixelDatatype}},clearColor:{get:function(){return this._clearColor}},scissorRectangle:{get:function(){return this._passState.scissorTest.rectangle}},outputTexture:{get:function(){if(defined(this._textureCache)){const e=this._textureCache.getFramebuffer(this._name);if(defined(e))return e.getColorTexture(0)}}},selected:{get:function(){return this._selected},set:function(e){this._selected=e}},parentSelected:{get:function(){return this._parentSelected},set:function(e){this._parentSelected=e}}});const depthTextureRegex=/uniform\s+sampler2D\s+depthTexture/g;PostProcessStage.prototype._isSupported=function(e){return!depthTextureRegex.test(this._fragmentShader)||e.depthTexture};function getUniformValueGetterAndSetter(e,t,n){const i=t[n];return(typeof i=="string"||i instanceof HTMLCanvasElement||i instanceof HTMLImageElement||i instanceof HTMLVideoElement||i instanceof ImageData)&&e._dirtyUniforms.push(n),{get:function(){return t[n]},set:function(r){const o=t[n];t[n]=r;const a=e._actualUniforms,s=a[n];defined(s)&&s!==o&&s instanceof Texture&&!defined(e._textureCache.getStageByName(n))&&(e._texturesToRelease.push(s),delete a[n],delete a[`${n}Dimensions`]),o instanceof Texture&&e._texturesToRelease.push(o),typeof r=="string"||r instanceof HTMLCanvasElement||r instanceof HTMLImageElement||r instanceof HTMLVideoElement||r instanceof ImageData?e._dirtyUniforms.push(n):a[n]=r}}}function getUniformMapFunction(e,t){return function(){const n=e._actualUniforms[t];return typeof n=="function"?n():n}}function getUniformMapDimensionsFunction(e,t){return function(){const n=e[t]();if(defined(n))return n.dimensions}}function createUniformMap$1(e){if(defined(e._uniformMap))return;const t={},n={},i=e._uniforms,r=e._actualUniforms;for(const o in i)if(i.hasOwnProperty(o)){typeof i[o]!="function"?(t[o]=getUniformMapFunction(e,o),n[o]=getUniformValueGetterAndSetter(e,i,o)):(t[o]=i[o],n[o]=i[o]),r[o]=i[o];const a=t[o]();(typeof a=="string"||a instanceof Texture||a instanceof HTMLImageElement||a instanceof HTMLCanvasElement||a instanceof HTMLVideoElement)&&(t[`${o}Dimensions`]=getUniformMapDimensionsFunction(t,o))}e._uniforms={},Object.defineProperties(e._uniforms,n),e._uniformMap=combine$2(t,{colorTexture:function(){return e._colorTexture},colorTextureDimensions:function(){return e._colorTexture.dimensions},depthTexture:function(){return e._depthTexture},depthTextureDimensions:function(){return e._depthTexture.dimensions},czm_idTexture:function(){return e._idTexture},czm_selectedIdTexture:function(){return e._selectedIdTexture},czm_selectedIdTextureStep:function(){return 1/e._selectedIdTexture.width}})}function createDrawCommand(e,t){if(defined(e._command)&&!e._logDepthChanged&&!e._selectedDirty)return;let n=e._fragmentShader;if(defined(e._selectedIdTexture)){const r=e._selectedIdTexture.width;n=n.replace(/in\s+vec2\s+v_textureCoordinates;/g,""),n=`#define CZM_SELECTED_FEATURE 
uniform sampler2D czm_idTexture; 
uniform sampler2D czm_selectedIdTexture; 
uniform float czm_selectedIdTextureStep; 
in vec2 v_textureCoordinates; 
bool czm_selected(vec2 offset) 
{ 
    bool selected = false;
    vec4 id = texture(czm_idTexture, v_textureCoordinates + offset); 
    for (int i = 0; i < ${r}; ++i) 
    { 
        vec4 selectedId = texture(czm_selectedIdTexture, vec2((float(i) + 0.5) * czm_selectedIdTextureStep, 0.5)); 
        if (all(equal(id, selectedId))) 
        { 
            return true; 
        } 
    } 
    return false; 
} 

bool czm_selected() 
{ 
    return czm_selected(vec2(0.0)); 
} 

${n}`}const i=new ShaderSource({defines:[e._useLogDepth?"LOG_DEPTH":""],sources:[n]});e._command=t.createViewportQuadCommand(i,{uniformMap:e._uniformMap,owner:e})}function createSampler(e){const t=e._sampleMode;let n,i;t===PostProcessStageSampleMode$1.LINEAR?(n=TextureMinificationFilter.LINEAR,i=TextureMagnificationFilter.LINEAR):(n=TextureMinificationFilter.NEAREST,i=TextureMagnificationFilter.NEAREST);const r=e._sampler;(!defined(r)||r.minificationFilter!==n||r.magnificationFilter!==i)&&(e._sampler=new Sampler({wrapS:TextureWrap.CLAMP_TO_EDGE,wrapT:TextureWrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:i}))}function createLoadImageFunction(e,t){return function(n){e._texturesToCreate.push({name:t,source:n})}}function createStageOutputTextureFunction(e,t){return function(){return e._textureCache.getOutputTexture(t)}}function updateUniformTextures(e,t){let n,i,r;const o=e._texturesToRelease;let a=o.length;for(n=0;n<a;++n)i=o[n],i=i&&i.destroy();o.length=0;const s=e._texturesToCreate;for(a=s.length,n=0;n<a;++n){const h=s[n];r=h.name;const f=h.source;e._actualUniforms[r]=new Texture({context:t,source:f})}s.length=0;const l=e._dirtyUniforms;if(l.length===0&&!defined(e._texturePromise)){e._ready=!0;return}if(l.length===0||defined(e._texturePromise))return;a=l.length;const c=e._uniforms,d=[];for(n=0;n<a;++n){r=l[n];const h=c[r],f=e._textureCache.getStageByName(h);if(defined(f))e._actualUniforms[r]=createStageOutputTextureFunction(e,h);else if(typeof h=="string"){const p=new Resource({url:h});d.push(p.fetchImage().then(createLoadImageFunction(e,r)))}else e._texturesToCreate.push({name:r,source:h})}l.length=0,d.length>0?(e._ready=!1,e._texturePromise=Promise.all(d).then(function(){e._ready=!0,e._texturePromise=void 0})):e._ready=!0}function releaseResources$1(e){defined(e._command)&&(e._command.shaderProgram=e._command.shaderProgram&&e._command.shaderProgram.destroy(),e._command=void 0),e._selectedIdTexture=e._selectedIdTexture&&e._selectedIdTexture.destroy();const t=e._textureCache;if(!defined(t))return;const n=e._uniforms,i=e._actualUniforms;for(const r in i)i.hasOwnProperty(r)&&i[r]instanceof Texture&&(defined(t.getStageByName(n[r]))||i[r].destroy(),e._dirtyUniforms.push(r))}function isSelectedTextureDirty$1(e){let t=defined(e._selected)?e._selected.length:0;const n=defined(e._parentSelected)?e._parentSelected:0;let i=e._selected!==e._selectedShadow||t!==e._selectedLength;if(i=i||e._parentSelected!==e._parentSelectedShadow||n!==e._parentSelectedLength,defined(e._selected)&&defined(e._parentSelected)?e._combinedSelected=e._selected.concat(e._parentSelected):defined(e._parentSelected)?e._combinedSelected=e._parentSelected:e._combinedSelected=e._selected,!i&&defined(e._combinedSelected)){if(!defined(e._combinedSelectedShadow))return!0;t=e._combinedSelected.length;for(let r=0;r<t;++r)if(e._combinedSelected[r]!==e._combinedSelectedShadow[r])return!0}return i}function createSelectedTexture(e,t){if(!e._selectedDirty)return;e._selectedIdTexture=e._selectedIdTexture&&e._selectedIdTexture.destroy(),e._selectedIdTexture=void 0;const n=e._combinedSelected;if(!defined(n))return;let i,r,o=0;const a=n.length;for(i=0;i<a;++i)r=n[i],defined(r.pickIds)?o+=r.pickIds.length:defined(r.pickId)&&++o;if(a===0||o===0){const d=new Uint8Array(4);d[0]=255,d[1]=255,d[2]=255,d[3]=255,e._selectedIdTexture=new Texture({context:t,pixelFormat:PixelFormat.RGBA,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,source:{arrayBufferView:d,width:1,height:1},sampler:Sampler.NEAREST});return}let s,l=0;const c=new Uint8Array(o*4);for(i=0;i<a;++i)if(r=n[i],defined(r.pickIds)){const d=r.pickIds,h=d.length;for(let f=0;f<h;++f)s=d[f].color,c[l]=Color.floatToByte(s.red),c[l+1]=Color.floatToByte(s.green),c[l+2]=Color.floatToByte(s.blue),c[l+3]=Color.floatToByte(s.alpha),l+=4}else defined(r.pickId)&&(s=r.pickId.color,c[l]=Color.floatToByte(s.red),c[l+1]=Color.floatToByte(s.green),c[l+2]=Color.floatToByte(s.blue),c[l+3]=Color.floatToByte(s.alpha),l+=4);e._selectedIdTexture=new Texture({context:t,pixelFormat:PixelFormat.RGBA,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,source:{arrayBufferView:c,width:o,height:1},sampler:Sampler.NEAREST})}PostProcessStage.prototype.update=function(e,t){if(this.enabled!==this._enabled&&!this.enabled&&releaseResources$1(this),this._enabled=this.enabled,!this._enabled||(this._logDepthChanged=t!==this._useLogDepth,this._useLogDepth=t,this._selectedDirty=isSelectedTextureDirty$1(this),this._selectedShadow=this._selected,this._parentSelectedShadow=this._parentSelected,this._combinedSelectedShadow=this._combinedSelected,this._selectedLength=defined(this._selected)?this._selected.length:0,this._parentSelectedLength=defined(this._parentSelected)?this._parentSelected.length:0,createSelectedTexture(this,e),createUniformMap$1(this),updateUniformTextures(this,e),createDrawCommand(this,e),createSampler(this),this._selectedDirty=!1,!this._ready))return;const n=this._textureCache.getFramebuffer(this._name);if(this._command.framebuffer=n,!defined(n))return;const i=n.getColorTexture(0);let r;(i.width!==e.drawingBufferWidth||i.height!==e.drawingBufferHeight)&&(r=this._renderState,(!defined(r)||i.width!==r.viewport.width||i.height!==r.viewport.height)&&(this._renderState=RenderState.fromCache({viewport:new BoundingRectangle(0,0,i.width,i.height)}))),this._command.renderState=r};PostProcessStage.prototype.execute=function(e,t,n,i){if(!defined(this._command)||!defined(this._command.framebuffer)||!this._ready||!this._enabled)return;this._colorTexture=t,this._depthTexture=n,this._idTexture=i,Sampler.equals(this._colorTexture.sampler,this._sampler)||(this._colorTexture.sampler=this._sampler);const r=this.scissorRectangle.width>0&&this.scissorRectangle.height>0?this._passState:void 0;defined(r)&&(r.context=e),this._command.execute(e,r)};PostProcessStage.prototype.isDestroyed=function(){return!1};PostProcessStage.prototype.destroy=function(){return releaseResources$1(this),destroyObject(this)};function PostProcessStageComposite(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),Check.defined("options.stages",e.stages),Check.typeOf.number.greaterThan("options.stages.length",e.stages.length,0),this._stages=e.stages,this._inputPreviousStageTexture=defaultValue(e.inputPreviousStageTexture,!0);let t=e.name;defined(t)||(t=createGuid()),this._name=t,this._uniforms=e.uniforms,this._textureCache=void 0,this._index=void 0,this._selected=void 0,this._selectedShadow=void 0,this._parentSelected=void 0,this._parentSelectedShadow=void 0,this._combinedSelected=void 0,this._combinedSelectedShadow=void 0,this._selectedLength=0,this._parentSelectedLength=0,this._selectedDirty=!0}Object.defineProperties(PostProcessStageComposite.prototype,{ready:{get:function(){const e=this._stages,t=e.length;for(let n=0;n<t;++n)if(!e[n].ready)return!1;return!0}},name:{get:function(){return this._name}},enabled:{get:function(){return this._stages[0].enabled},set:function(e){const t=this._stages,n=t.length;for(let i=0;i<n;++i)t[i].enabled=e}},uniforms:{get:function(){return this._uniforms}},inputPreviousStageTexture:{get:function(){return this._inputPreviousStageTexture}},length:{get:function(){return this._stages.length}},selected:{get:function(){return this._selected},set:function(e){this._selected=e}},parentSelected:{get:function(){return this._parentSelected},set:function(e){this._parentSelected=e}}});PostProcessStageComposite.prototype._isSupported=function(e){const t=this._stages,n=t.length;for(let i=0;i<n;++i)if(!t[i]._isSupported(e))return!1;return!0};PostProcessStageComposite.prototype.get=function(e){return Check.typeOf.number.greaterThanOrEquals("index",e,0),Check.typeOf.number.lessThan("index",e,this.length),this._stages[e]};function isSelectedTextureDirty(e){let t=defined(e._selected)?e._selected.length:0;const n=defined(e._parentSelected)?e._parentSelected:0;let i=e._selected!==e._selectedShadow||t!==e._selectedLength;if(i=i||e._parentSelected!==e._parentSelectedShadow||n!==e._parentSelectedLength,defined(e._selected)&&defined(e._parentSelected)?e._combinedSelected=e._selected.concat(e._parentSelected):defined(e._parentSelected)?e._combinedSelected=e._parentSelected:e._combinedSelected=e._selected,!i&&defined(e._combinedSelected)){if(!defined(e._combinedSelectedShadow))return!0;t=e._combinedSelected.length;for(let r=0;r<t;++r)if(e._combinedSelected[r]!==e._combinedSelectedShadow[r])return!0}return i}PostProcessStageComposite.prototype.update=function(e,t){this._selectedDirty=isSelectedTextureDirty(this),this._selectedShadow=this._selected,this._parentSelectedShadow=this._parentSelected,this._combinedSelectedShadow=this._combinedSelected,this._selectedLength=defined(this._selected)?this._selected.length:0,this._parentSelectedLength=defined(this._parentSelected)?this._parentSelected.length:0;const n=this._stages,i=n.length;for(let r=0;r<i;++r){const o=n[r];this._selectedDirty&&(o.parentSelected=this._combinedSelected),o.update(e,t)}};PostProcessStageComposite.prototype.isDestroyed=function(){return!1};PostProcessStageComposite.prototype.destroy=function(){const e=this._stages,t=e.length;for(let n=0;n<t;++n)e[n].destroy();return destroyObject(this)};const PostProcessStageLibrary={};function createBlur(e){const r=`#define USE_STEP_SIZE
${GaussianBlur1D}`,o=new PostProcessStage({name:`${e}_x_direction`,fragmentShader:r,uniforms:{delta:1,sigma:2,stepSize:1,direction:0},sampleMode:PostProcessStageSampleMode$1.LINEAR}),a=new PostProcessStage({name:`${e}_y_direction`,fragmentShader:r,uniforms:{delta:1,sigma:2,stepSize:1,direction:1},sampleMode:PostProcessStageSampleMode$1.LINEAR}),s={};return Object.defineProperties(s,{delta:{get:function(){return o.uniforms.delta},set:function(l){const c=o.uniforms,d=a.uniforms;c.delta=d.delta=l}},sigma:{get:function(){return o.uniforms.sigma},set:function(l){const c=o.uniforms,d=a.uniforms;c.sigma=d.sigma=l}},stepSize:{get:function(){return o.uniforms.stepSize},set:function(l){const c=o.uniforms,d=a.uniforms;c.stepSize=d.stepSize=l}}}),new PostProcessStageComposite({name:e,stages:[o,a],uniforms:s})}PostProcessStageLibrary.createBlurStage=function(){return createBlur("czm_blur")};PostProcessStageLibrary.createDepthOfFieldStage=function(){const e=createBlur("czm_depth_of_field_blur"),t=new PostProcessStage({name:"czm_depth_of_field_composite",fragmentShader:DepthOfField,uniforms:{focalDistance:5,blurTexture:e.name}}),n={};return Object.defineProperties(n,{focalDistance:{get:function(){return t.uniforms.focalDistance},set:function(i){t.uniforms.focalDistance=i}},delta:{get:function(){return e.uniforms.delta},set:function(i){e.uniforms.delta=i}},sigma:{get:function(){return e.uniforms.sigma},set:function(i){e.uniforms.sigma=i}},stepSize:{get:function(){return e.uniforms.stepSize},set:function(i){e.uniforms.stepSize=i}}}),new PostProcessStageComposite({name:"czm_depth_of_field",stages:[e,t],inputPreviousStageTexture:!1,uniforms:n})};PostProcessStageLibrary.isDepthOfFieldSupported=function(e){return e.context.depthTexture};PostProcessStageLibrary.createEdgeDetectionStage=function(){const e=createGuid();return new PostProcessStage({name:`czm_edge_detection_${e}`,fragmentShader:EdgeDetection,uniforms:{length:.25,color:Color.clone(Color.BLACK)}})};PostProcessStageLibrary.isEdgeDetectionSupported=function(e){return e.context.depthTexture};function getSilhouetteEdgeDetection(e){if(!defined(e))return PostProcessStageLibrary.createEdgeDetectionStage();const t=new PostProcessStageComposite({name:"czm_edge_detection_multiple",stages:e,inputPreviousStageTexture:!1}),n={};let i="",r="";for(let s=0;s<e.length;++s)i+=`uniform sampler2D edgeTexture${s}; 
`,r+=`        vec4 edge${s} = texture(edgeTexture${s}, v_textureCoordinates); 
        if (edge${s}.a > 0.0) 
        { 
            color = edge${s}; 
            break; 
        } 
`,n[`edgeTexture${s}`]=e[s].name;const o=`${i}in vec2 v_textureCoordinates; 
void main() { 
    vec4 color = vec4(0.0); 
    for (int i = 0; i < ${e.length}; i++) 
    { 
${r}    } 
    out_FragColor = color; 
} 
`,a=new PostProcessStage({name:"czm_edge_detection_combine",fragmentShader:o,uniforms:n});return new PostProcessStageComposite({name:"czm_edge_detection_composite",stages:[t,a]})}PostProcessStageLibrary.createSilhouetteStage=function(e){const t=getSilhouetteEdgeDetection(e),n=new PostProcessStage({name:"czm_silhouette_color_edges",fragmentShader:Silhouette,uniforms:{silhouetteTexture:t.name}});return new PostProcessStageComposite({name:"czm_silhouette",stages:[t,n],inputPreviousStageTexture:!1,uniforms:t.uniforms})};PostProcessStageLibrary.isSilhouetteSupported=function(e){return e.context.depthTexture};PostProcessStageLibrary.createBloomStage=function(){const e=new PostProcessStage({name:"czm_bloom_contrast_bias",fragmentShader:ContrastBias,uniforms:{contrast:128,brightness:-.3}}),t=createBlur("czm_bloom_blur"),n=new PostProcessStageComposite({name:"czm_bloom_contrast_bias_blur",stages:[e,t]}),i=new PostProcessStage({name:"czm_bloom_generate_composite",fragmentShader:BloomComposite,uniforms:{glowOnly:!1,bloomTexture:n.name}}),r={};return Object.defineProperties(r,{glowOnly:{get:function(){return i.uniforms.glowOnly},set:function(o){i.uniforms.glowOnly=o}},contrast:{get:function(){return e.uniforms.contrast},set:function(o){e.uniforms.contrast=o}},brightness:{get:function(){return e.uniforms.brightness},set:function(o){e.uniforms.brightness=o}},delta:{get:function(){return t.uniforms.delta},set:function(o){t.uniforms.delta=o}},sigma:{get:function(){return t.uniforms.sigma},set:function(o){t.uniforms.sigma=o}},stepSize:{get:function(){return t.uniforms.stepSize},set:function(o){t.uniforms.stepSize=o}}}),new PostProcessStageComposite({name:"czm_bloom",stages:[n,i],inputPreviousStageTexture:!1,uniforms:r})};PostProcessStageLibrary.createAmbientOcclusionStage=function(){const e=new PostProcessStage({name:"czm_ambient_occlusion_generate",fragmentShader:AmbientOcclusionGenerate,uniforms:{intensity:3,bias:.1,lengthCap:.26,stepSize:1.95,frustumLength:1e3,randomTexture:void 0}}),t=createBlur("czm_ambient_occlusion_blur");t.uniforms.stepSize=.86;const n=new PostProcessStageComposite({name:"czm_ambient_occlusion_generate_blur",stages:[e,t]}),i=new PostProcessStage({name:"czm_ambient_occlusion_composite",fragmentShader:AmbientOcclusionModulate,uniforms:{ambientOcclusionOnly:!1,ambientOcclusionTexture:n.name}}),r={};return Object.defineProperties(r,{intensity:{get:function(){return e.uniforms.intensity},set:function(o){e.uniforms.intensity=o}},bias:{get:function(){return e.uniforms.bias},set:function(o){e.uniforms.bias=o}},lengthCap:{get:function(){return e.uniforms.lengthCap},set:function(o){e.uniforms.lengthCap=o}},stepSize:{get:function(){return e.uniforms.stepSize},set:function(o){e.uniforms.stepSize=o}},frustumLength:{get:function(){return e.uniforms.frustumLength},set:function(o){e.uniforms.frustumLength=o}},randomTexture:{get:function(){return e.uniforms.randomTexture},set:function(o){e.uniforms.randomTexture=o}},delta:{get:function(){return t.uniforms.delta},set:function(o){t.uniforms.delta=o}},sigma:{get:function(){return t.uniforms.sigma},set:function(o){t.uniforms.sigma=o}},blurStepSize:{get:function(){return t.uniforms.stepSize},set:function(o){t.uniforms.stepSize=o}},ambientOcclusionOnly:{get:function(){return i.uniforms.ambientOcclusionOnly},set:function(o){i.uniforms.ambientOcclusionOnly=o}}}),new PostProcessStageComposite({name:"czm_ambient_occlusion",stages:[n,i],inputPreviousStageTexture:!1,uniforms:r})};PostProcessStageLibrary.isAmbientOcclusionSupported=function(e){return e.context.depthTexture};const fxaaFS=`#define FXAA_QUALITY_PRESET 39 
${FXAA3_11}
${FXAA}`;PostProcessStageLibrary.createFXAAStage=function(){return new PostProcessStage({name:"czm_FXAA",fragmentShader:fxaaFS,sampleMode:PostProcessStageSampleMode$1.LINEAR})};PostProcessStageLibrary.createAcesTonemappingStage=function(e){let t=e?`#define AUTO_EXPOSURE
`:"";return t+=AcesTonemapping,new PostProcessStage({name:"czm_aces",fragmentShader:t,uniforms:{autoExposure:void 0}})};PostProcessStageLibrary.createFilmicTonemappingStage=function(e){let t=e?`#define AUTO_EXPOSURE
`:"";return t+=FilmicTonemapping,new PostProcessStage({name:"czm_filmic",fragmentShader:t,uniforms:{autoExposure:void 0}})};PostProcessStageLibrary.createReinhardTonemappingStage=function(e){let t=e?`#define AUTO_EXPOSURE
`:"";return t+=ReinhardTonemapping,new PostProcessStage({name:"czm_reinhard",fragmentShader:t,uniforms:{autoExposure:void 0}})};PostProcessStageLibrary.createModifiedReinhardTonemappingStage=function(e){let t=e?`#define AUTO_EXPOSURE
`:"";return t+=ModifiedReinhardTonemapping,new PostProcessStage({name:"czm_modified_reinhard",fragmentShader:t,uniforms:{white:Color.WHITE,autoExposure:void 0}})};PostProcessStageLibrary.createAutoExposureStage=function(){return new AutoExposure};PostProcessStageLibrary.createBlackAndWhiteStage=function(){return new PostProcessStage({name:"czm_black_and_white",fragmentShader:BlackAndWhite,uniforms:{gradations:5}})};PostProcessStageLibrary.createBrightnessStage=function(){return new PostProcessStage({name:"czm_brightness",fragmentShader:Brightness,uniforms:{brightness:.5}})};PostProcessStageLibrary.createNightVisionStage=function(){return new PostProcessStage({name:"czm_night_vision",fragmentShader:NightVision})};PostProcessStageLibrary.createDepthViewStage=function(){return new PostProcessStage({name:"czm_depth_view",fragmentShader:DepthView})};PostProcessStageLibrary.createLensFlareStage=function(){return new PostProcessStage({name:"czm_lens_flare",fragmentShader:LensFlare,uniforms:{dirtTexture:buildModuleUrl("Assets/Textures/LensFlare/DirtMask.jpg"),starTexture:buildModuleUrl("Assets/Textures/LensFlare/StarBurst.jpg"),intensity:2,distortion:10,ghostDispersal:.4,haloWidth:.4,dirtAmount:.4,earthRadius:Ellipsoid.WGS84.maximumRadius}})};const PostProcessStageLibrary$1=PostProcessStageLibrary;function PostProcessStageTextureCache(e){this._collection=e,this._framebuffers=[],this._stageNameToFramebuffer={},this._width=void 0,this._height=void 0,this._updateDependencies=!1}function getLastStageName(e){for(;defined(e.length);)e=e.get(e.length-1);return e.name}function getStageDependencies(e,t,n,i,r){if(!i.enabled||!i._isSupported(t))return r;const o=n[i.name]={};if(defined(r)){const s=e.getStageByName(r);o[getLastStageName(s)]=!0}const a=i.uniforms;if(defined(a)){const s=Object.getOwnPropertyNames(a),l=s.length;for(let c=0;c<l;++c){const d=a[s[c]];if(typeof d=="string"){const h=e.getStageByName(d);defined(h)&&(o[getLastStageName(h)]=!0)}}}return i.name}function getCompositeDependencies(e,t,n,i,r){if(defined(i.enabled)&&!i.enabled||defined(i._isSupported)&&!i._isSupported(t))return r;const o=r,a=!defined(i.inputPreviousStageTexture)||i.inputPreviousStageTexture;let s=r;const l=i.length;for(let h=0;h<l;++h){const f=i.get(h);defined(f.length)?s=getCompositeDependencies(e,t,n,f,r):s=getStageDependencies(e,t,n,f,r),a&&(r=s)}let c,d;if(a)for(c=1;c<l;++c)d=getLastStageName(i.get(c)),defined(n[d])||(n[d]={}),n[d][o]=!0;else for(c=1;c<l;++c){d=getLastStageName(i.get(c));const h=n[d];for(let f=0;f<c;++f)h[getLastStageName(i.get(f))]=!0}return s}function getDependencies(e,t){const n={};if(defined(e.ambientOcclusion)){const i=e.ambientOcclusion,r=e.bloom,o=e._tonemapping,a=e.fxaa;let s=getCompositeDependencies(e,t,n,i,void 0);s=getCompositeDependencies(e,t,n,r,s),s=getStageDependencies(e,t,n,o,s),s=getCompositeDependencies(e,t,n,e,s),getStageDependencies(e,t,n,a,s)}else getCompositeDependencies(e,t,n,e,void 0);return n}function getFramebuffer(e,t,n){const r=e._collection.getStageByName(t),o=r._textureScale,a=r._forcePowerOfTwo,s=r._pixelFormat,l=r._pixelDatatype,c=r._clearColor;let d,h;const f=e._framebuffers,p=f.length;for(d=0;d<p;++d){if(h=f[d],o!==h.textureScale||a!==h.forcePowerOfTwo||s!==h.pixelFormat||l!==h.pixelDatatype||!Color.equals(c,h.clearColor))continue;const u=h.stages,m=u.length;let g=!1;for(let _=0;_<m;++_)if(n[u[_]]){g=!0;break}if(!g)break}return defined(h)&&d<p?(h.stages.push(t),h):(h={textureScale:o,forcePowerOfTwo:a,pixelFormat:s,pixelDatatype:l,clearColor:c,stages:[t],buffer:new FramebufferManager({pixelFormat:s,pixelDatatype:l}),clear:void 0},f.push(h),h)}function createFramebuffers(e,t){const n=getDependencies(e._collection,t);for(const i in n)n.hasOwnProperty(i)&&(e._stageNameToFramebuffer[i]=getFramebuffer(e,i,n[i]))}function releaseResources(e){const t=e._framebuffers,n=t.length;for(let i=0;i<n;++i)t[i].buffer.destroy()}function updateFramebuffers(e,t){const n=e._width,i=e._height,r=e._framebuffers,o=r.length;for(let a=0;a<o;++a){const s=r[a],l=s.textureScale;let c=Math.ceil(n*l),d=Math.ceil(i*l),h=Math.min(c,d);s.forcePowerOfTwo&&(CesiumMath.isPowerOfTwo(h)||(h=CesiumMath.nextPowerOfTwo(h)),c=h,d=h),s.buffer.update(t,c,d),s.clear=new ClearCommand({color:s.clearColor,framebuffer:s.buffer.framebuffer})}}PostProcessStageTextureCache.prototype.updateDependencies=function(){this._updateDependencies=!0};PostProcessStageTextureCache.prototype.update=function(e){const t=this._collection,n=this._updateDependencies,i=defined(t.ambientOcclusion)&&t.ambientOcclusion.enabled&&t.ambientOcclusion._isSupported(e),r=defined(t.bloom)&&t.bloom.enabled&&t.bloom._isSupported(e),o=defined(t._tonemapping)&&t._tonemapping.enabled&&t._tonemapping._isSupported(e),a=defined(t.fxaa)&&t.fxaa.enabled&&t.fxaa._isSupported(e),s=!defined(t._activeStages)||t._activeStages.length>0||i||r||o||a;if((n||!s&&this._framebuffers.length>0)&&(releaseResources(this),this._framebuffers.length=0,this._stageNameToFramebuffer={},this._width=void 0,this._height=void 0),!n&&!s)return;this._framebuffers.length===0&&createFramebuffers(this,e);const l=e.drawingBufferWidth,c=e.drawingBufferHeight,d=this._width!==l||this._height!==c;!n&&!d||(this._width=l,this._height=c,this._updateDependencies=!1,releaseResources(this),updateFramebuffers(this,e))};PostProcessStageTextureCache.prototype.clear=function(e){const t=this._framebuffers;for(let n=0;n<t.length;++n)t[n].clear.execute(e)};PostProcessStageTextureCache.prototype.getStageByName=function(e){return this._collection.getStageByName(e)};PostProcessStageTextureCache.prototype.getOutputTexture=function(e){return this._collection.getOutputTexture(e)};PostProcessStageTextureCache.prototype.getFramebuffer=function(e){const t=this._stageNameToFramebuffer[e];if(defined(t))return t.buffer.framebuffer};PostProcessStageTextureCache.prototype.isDestroyed=function(){return!1};PostProcessStageTextureCache.prototype.destroy=function(){return releaseResources(this),destroyObject(this)};const Tonemapper={REINHARD:0,MODIFIED_REINHARD:1,FILMIC:2,ACES:3,validate:function(e){return e===Tonemapper.REINHARD||e===Tonemapper.MODIFIED_REINHARD||e===Tonemapper.FILMIC||e===Tonemapper.ACES}},Tonemapper$1=Object.freeze(Tonemapper),stackScratch=[];function PostProcessStageCollection(){const e=PostProcessStageLibrary$1.createFXAAStage(),t=PostProcessStageLibrary$1.createAmbientOcclusionStage(),n=PostProcessStageLibrary$1.createBloomStage();this._autoExposureEnabled=!1,this._autoExposure=PostProcessStageLibrary$1.createAutoExposureStage(),this._tonemapping=void 0,this._tonemapper=void 0,this.tonemapper=Tonemapper$1.ACES;const i=this._tonemapping;e.enabled=!1,t.enabled=!1,n.enabled=!1,i.enabled=!1;const r=new PostProcessStageTextureCache(this),o={},a=stackScratch;for(a.push(e,t,n,i);a.length>0;){const l=a.pop();o[l.name]=l,l._textureCache=r;const c=l.length;if(defined(c))for(let d=0;d<c;++d)a.push(l.get(d))}this._stages=[],this._activeStages=[],this._previousActiveStages=[],this._randomTexture=void 0;const s=this;t.uniforms.randomTexture=function(){return s._randomTexture},this._ao=t,this._bloom=n,this._fxaa=e,this._aoEnabled=void 0,this._bloomEnabled=void 0,this._tonemappingEnabled=void 0,this._fxaaEnabled=void 0,this._activeStagesChanged=!1,this._stagesRemoved=!1,this._textureCacheDirty=!1,this._stageNames=o,this._textureCache=r}Object.defineProperties(PostProcessStageCollection.prototype,{ready:{get:function(){let e=!1;const t=this._stages,n=t.length;for(let s=n-1;s>=0;--s){const l=t[s];e=e||l.ready&&l.enabled}const i=this._fxaa,r=this._ao,o=this._bloom,a=this._tonemapping;return e=e||i.ready&&i.enabled,e=e||r.ready&&r.enabled,e=e||o.ready&&o.enabled,e=e||a.ready&&a.enabled,e}},fxaa:{get:function(){return this._fxaa}},ambientOcclusion:{get:function(){return this._ao}},bloom:{get:function(){return this._bloom}},length:{get:function(){return removeStages(this),this._stages.length}},outputTexture:{get:function(){const e=this._fxaa;if(e.enabled&&e.ready)return this.getOutputTexture(e.name);const t=this._stages,n=t.length;for(let a=n-1;a>=0;--a){const s=t[a];if(defined(s)&&s.ready&&s.enabled)return this.getOutputTexture(s.name)}const i=this._tonemapping;if(i.enabled&&i.ready)return this.getOutputTexture(i.name);const r=this._bloom;if(r.enabled&&r.ready)return this.getOutputTexture(r.name);const o=this._ao;if(o.enabled&&o.ready)return this.getOutputTexture(o.name)}},hasSelected:{get:function(){const e=this._stages.slice();for(;e.length>0;){const t=e.pop();if(!defined(t))continue;if(defined(t.selected))return!0;const n=t.length;if(defined(n))for(let i=0;i<n;++i)e.push(t.get(i))}return!1}},tonemapper:{get:function(){return this._tonemapper},set:function(e){if(this._tonemapper===e)return;if(!Tonemapper$1.validate(e))throw new DeveloperError("tonemapper was set to an invalid value.");defined(this._tonemapping)&&(delete this._stageNames[this._tonemapping.name],this._tonemapping.destroy());const t=this._autoExposureEnabled;let n;switch(e){case Tonemapper$1.REINHARD:n=PostProcessStageLibrary$1.createReinhardTonemappingStage(t);break;case Tonemapper$1.MODIFIED_REINHARD:n=PostProcessStageLibrary$1.createModifiedReinhardTonemappingStage(t);break;case Tonemapper$1.FILMIC:n=PostProcessStageLibrary$1.createFilmicTonemappingStage(t);break;default:n=PostProcessStageLibrary$1.createAcesTonemappingStage(t);break}if(t){const i=this._autoExposure;n.uniforms.autoExposure=function(){return i.outputTexture}}this._tonemapper=e,this._tonemapping=n,defined(this._stageNames)&&(this._stageNames[n.name]=n,n._textureCache=this._textureCache),this._textureCacheDirty=!0}}});function removeStages(e){if(!e._stagesRemoved)return;e._stagesRemoved=!1;const t=[],n=e._stages,i=n.length;for(let r=0,o=0;r<i;++r){const a=n[r];a&&(a._index=o++,t.push(a))}e._stages=t}PostProcessStageCollection.prototype.add=function(e){Check.typeOf.object("stage",e);const t=this._stageNames,n=stackScratch;for(n.push(e);n.length>0;){const r=n.pop();if(defined(t[r.name]))throw new DeveloperError(`${r.name} has already been added to the collection or does not have a unique name.`);t[r.name]=r,r._textureCache=this._textureCache;const o=r.length;if(defined(o))for(let a=0;a<o;++a)n.push(r.get(a))}const i=this._stages;return e._index=i.length,i.push(e),this._textureCacheDirty=!0,e};PostProcessStageCollection.prototype.remove=function(e){if(!this.contains(e))return!1;const t=this._stageNames,n=stackScratch;for(n.push(e);n.length>0;){const i=n.pop();delete t[i.name];const r=i.length;if(defined(r))for(let o=0;o<r;++o)n.push(i.get(o))}return this._stages[e._index]=void 0,this._stagesRemoved=!0,this._textureCacheDirty=!0,e._index=void 0,e._textureCache=void 0,e.destroy(),!0};PostProcessStageCollection.prototype.contains=function(e){return defined(e)&&defined(e._index)&&e._textureCache===this._textureCache};PostProcessStageCollection.prototype.get=function(e){removeStages(this);const t=this._stages,n=t.length;return Check.typeOf.number.greaterThanOrEquals("stages length",n,0),Check.typeOf.number.greaterThanOrEquals("index",e,0),Check.typeOf.number.lessThan("index",e,n),t[e]};PostProcessStageCollection.prototype.removeAll=function(){const e=this._stages,t=e.length;for(let n=0;n<t;++n)this.remove(e[n]);e.length=0};PostProcessStageCollection.prototype.getStageByName=function(e){return this._stageNames[e]};PostProcessStageCollection.prototype.update=function(e,t,n){removeStages(this);const i=this._activeStages,r=this._activeStages=this._previousActiveStages;this._previousActiveStages=i;const o=this._stages;let a=r.length=o.length,s,l,c=0;for(s=0;s<a;++s)l=o[s],l.ready&&l.enabled&&l._isSupported(e)&&(r[c++]=l);r.length=c;let d=c!==i.length;if(!d){for(s=0;s<c;++s)if(r[s]!==i[s]){d=!0;break}}const h=this._ao,f=this._bloom,p=this._autoExposure,u=this._tonemapping,m=this._fxaa;u.enabled=n;const g=h.enabled&&h._isSupported(e),_=f.enabled&&f._isSupported(e),C=u.enabled&&u._isSupported(e),A=m.enabled&&m._isSupported(e);if((d||this._textureCacheDirty||g!==this._aoEnabled||_!==this._bloomEnabled||C!==this._tonemappingEnabled||A!==this._fxaaEnabled)&&(this._textureCache.updateDependencies(),this._aoEnabled=g,this._bloomEnabled=_,this._tonemappingEnabled=C,this._fxaaEnabled=A,this._textureCacheDirty=!1),defined(this._randomTexture)&&!g&&(this._randomTexture.destroy(),this._randomTexture=void 0),!defined(this._randomTexture)&&g){a=256*256*3;const S=new Uint8Array(a);for(s=0;s<a;s+=3)S[s]=Math.floor(Math.random()*255);this._randomTexture=new Texture({context:e,pixelFormat:PixelFormat.RGB,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,source:{arrayBufferView:S,width:256,height:256},sampler:new Sampler({wrapS:TextureWrap.REPEAT,wrapT:TextureWrap.REPEAT,minificationFilter:TextureMinificationFilter.NEAREST,magnificationFilter:TextureMagnificationFilter.NEAREST})})}for(this._textureCache.update(e),m.update(e,t),h.update(e,t),f.update(e,t),u.update(e,t),this._autoExposureEnabled&&p.update(e,t),a=o.length,s=0;s<a;++s)o[s].update(e,t);for(c=0,s=0;s<a;++s)l=o[s],l.ready&&l.enabled&&l._isSupported(e)&&c++;d=c!==r.length,d&&this.update(e,t,n)};PostProcessStageCollection.prototype.clear=function(e){this._textureCache.clear(e),this._autoExposureEnabled&&this._autoExposure.clear(e)};function getOutputTexture(e){for(;defined(e.length);)e=e.get(e.length-1);return e.outputTexture}PostProcessStageCollection.prototype.getOutputTexture=function(e){const t=this.getStageByName(e);if(defined(t))return getOutputTexture(t)};function execute(e,t,n,i,r){if(defined(e.execute)){e.execute(t,n,i,r);return}const o=e.length;let a;if(e.inputPreviousStageTexture)for(execute(e.get(0),t,n,i,r),a=1;a<o;++a)execute(e.get(a),t,getOutputTexture(e.get(a-1)),i,r);else for(a=0;a<o;++a)execute(e.get(a),t,n,i,r)}PostProcessStageCollection.prototype.execute=function(e,t,n,i){const r=this._activeStages,o=r.length,a=this._fxaa,s=this._ao,l=this._bloom,c=this._autoExposure,d=this._tonemapping,h=s.enabled&&s._isSupported(e),f=l.enabled&&l._isSupported(e),p=this._autoExposureEnabled,u=d.enabled&&d._isSupported(e),m=a.enabled&&a._isSupported(e);if(!m&&!h&&!f&&!u&&o===0)return;let g=t;h&&s.ready&&(execute(s,e,g,n,i),g=getOutputTexture(s)),f&&l.ready&&(execute(l,e,g,n,i),g=getOutputTexture(l)),p&&c.ready&&execute(c,e,g,n,i),u&&d.ready&&(execute(d,e,g,n,i),g=getOutputTexture(d));let _=g;if(o>0){execute(r[0],e,g,n,i);for(let C=1;C<o;++C)execute(r[C],e,getOutputTexture(r[C-1]),n,i);_=getOutputTexture(r[o-1])}m&&a.ready&&execute(a,e,_,n,i)};PostProcessStageCollection.prototype.copy=function(e,t){if(!defined(this._copyColorCommand)){const n=this;this._copyColorCommand=e.createViewportQuadCommand(PassThrough,{uniformMap:{colorTexture:function(){return n.outputTexture}},owner:this})}this._copyColorCommand.framebuffer=t,this._copyColorCommand.execute(e)};PostProcessStageCollection.prototype.isDestroyed=function(){return!1};PostProcessStageCollection.prototype.destroy=function(){return this._fxaa.destroy(),this._ao.destroy(),this._bloom.destroy(),this._autoExposure.destroy(),this._tonemapping.destroy(),this.removeAll(),this._textureCache=this._textureCache&&this._textureCache.destroy(),destroyObject(this)};function SceneTransitioner(e){Check.typeOf.object("scene",e),this._scene=e,this._currentTweens=[],this._morphHandler=void 0,this._morphCancelled=!1,this._completeMorph=void 0,this._morphToOrthographic=!1}SceneTransitioner.prototype.completeMorph=function(){defined(this._completeMorph)&&this._completeMorph()};SceneTransitioner.prototype.morphTo2D=function(e,t){defined(this._completeMorph)&&this._completeMorph();const n=this._scene;this._previousMode=n.mode,this._morphToOrthographic=n.camera.frustum instanceof OrthographicFrustum,!(this._previousMode===SceneMode.SCENE2D||this._previousMode===SceneMode.MORPHING)&&(this._scene.morphStart.raiseEvent(this,this._previousMode,SceneMode.SCENE2D,!0),n._mode=SceneMode.MORPHING,n.camera._setTransform(Matrix4.IDENTITY),this._previousMode===SceneMode.COLUMBUS_VIEW?morphFromColumbusViewTo2D(this,e):morphFrom3DTo2D(this,e,t),e===0&&defined(this._completeMorph)&&this._completeMorph())};const scratchToCVPosition=new Cartesian3,scratchToCVDirection=new Cartesian3,scratchToCVUp=new Cartesian3,scratchToCVPosition2D=new Cartesian3,scratchToCVDirection2D=new Cartesian3,scratchToCVUp2D=new Cartesian3,scratchToCVSurfacePosition=new Cartesian3,scratchToCVCartographic=new Cartographic,scratchToCVToENU=new Matrix4,scratchToCVFrustumPerspective=new PerspectiveFrustum,scratchToCVFrustumOrthographic=new OrthographicFrustum,scratchToCVCamera={position:void 0,direction:void 0,up:void 0,position2D:void 0,direction2D:void 0,up2D:void 0,frustum:void 0};SceneTransitioner.prototype.morphToColumbusView=function(e,t){defined(this._completeMorph)&&this._completeMorph();const n=this._scene;if(this._previousMode=n.mode,this._previousMode===SceneMode.COLUMBUS_VIEW||this._previousMode===SceneMode.MORPHING)return;this._scene.morphStart.raiseEvent(this,this._previousMode,SceneMode.COLUMBUS_VIEW,!0),n.camera._setTransform(Matrix4.IDENTITY);let i=scratchToCVPosition;const r=scratchToCVDirection,o=scratchToCVUp;if(e>0)i.x=0,i.y=-1,i.z=1,i=Cartesian3.multiplyByScalar(Cartesian3.normalize(i,i),5*t.maximumRadius,i),Cartesian3.negate(Cartesian3.normalize(i,r),r),Cartesian3.cross(Cartesian3.UNIT_X,r,o);else{const c=n.camera;if(this._previousMode===SceneMode.SCENE2D)Cartesian3.clone(c.position,i),i.z=c.frustum.right-c.frustum.left,Cartesian3.negate(Cartesian3.UNIT_Z,r),Cartesian3.clone(Cartesian3.UNIT_Y,o);else{Cartesian3.clone(c.positionWC,i),Cartesian3.clone(c.directionWC,r),Cartesian3.clone(c.upWC,o);const d=t.scaleToGeodeticSurface(i,scratchToCVSurfacePosition),h=Transforms.eastNorthUpToFixedFrame(d,t,scratchToCVToENU);Matrix4.inverseTransformation(h,h),n.mapProjection.project(t.cartesianToCartographic(i,scratchToCVCartographic),i),Matrix4.multiplyByPointAsVector(h,r,r),Matrix4.multiplyByPointAsVector(h,o,o)}}let a;this._morphToOrthographic?(a=scratchToCVFrustumOrthographic,a.width=n.camera.frustum.right-n.camera.frustum.left,a.aspectRatio=n.drawingBufferWidth/n.drawingBufferHeight):(a=scratchToCVFrustumPerspective,a.aspectRatio=n.drawingBufferWidth/n.drawingBufferHeight,a.fov=CesiumMath.toRadians(60));const s=scratchToCVCamera;s.position=i,s.direction=r,s.up=o,s.frustum=a;const l=completeColumbusViewCallback(s);createMorphHandler(this,l),this._previousMode===SceneMode.SCENE2D?morphFrom2DToColumbusView(this,e,s,l):(s.position2D=Matrix4.multiplyByPoint(Camera.TRANSFORM_2D,i,scratchToCVPosition2D),s.direction2D=Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D,r,scratchToCVDirection2D),s.up2D=Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D,o,scratchToCVUp2D),n._mode=SceneMode.MORPHING,morphFrom3DToColumbusView(this,e,s,l)),e===0&&defined(this._completeMorph)&&this._completeMorph()};const scratchCVTo3DCamera={position:new Cartesian3,direction:new Cartesian3,up:new Cartesian3,frustum:void 0},scratch2DTo3DFrustumPersp=new PerspectiveFrustum;SceneTransitioner.prototype.morphTo3D=function(e,t){defined(this._completeMorph)&&this._completeMorph();const n=this._scene;if(this._previousMode=n.mode,!(this._previousMode===SceneMode.SCENE3D||this._previousMode===SceneMode.MORPHING)){if(this._scene.morphStart.raiseEvent(this,this._previousMode,SceneMode.SCENE3D,!0),n._mode=SceneMode.MORPHING,n.camera._setTransform(Matrix4.IDENTITY),this._previousMode===SceneMode.SCENE2D)morphFrom2DTo3D(this,e,t);else{let i;e>0?(i=scratchCVTo3DCamera,Cartesian3.fromDegrees(0,0,5*t.maximumRadius,t,i.position),Cartesian3.negate(i.position,i.direction),Cartesian3.normalize(i.direction,i.direction),Cartesian3.clone(Cartesian3.UNIT_Z,i.up)):i=getColumbusViewTo3DCamera(this,t);let r;const o=n.camera;o.frustum instanceof OrthographicFrustum?r=o.frustum.clone():(r=scratch2DTo3DFrustumPersp,r.aspectRatio=n.drawingBufferWidth/n.drawingBufferHeight,r.fov=CesiumMath.toRadians(60)),i.frustum=r;const a=complete3DCallback(i);createMorphHandler(this,a),morphFromColumbusViewTo3D(this,e,i,a)}e===0&&defined(this._completeMorph)&&this._completeMorph()}};SceneTransitioner.prototype.isDestroyed=function(){return!1};SceneTransitioner.prototype.destroy=function(){return destroyMorphHandler(this),destroyObject(this)};function createMorphHandler(e,t){if(e._scene.completeMorphOnUserInput){e._morphHandler=new ScreenSpaceEventHandler(e._scene.canvas);const n=function(){e._morphCancelled=!0,e._scene.camera.cancelFlight(),t(e)};e._completeMorph=n,e._morphHandler.setInputAction(n,ScreenSpaceEventType.LEFT_DOWN),e._morphHandler.setInputAction(n,ScreenSpaceEventType.MIDDLE_DOWN),e._morphHandler.setInputAction(n,ScreenSpaceEventType.RIGHT_DOWN),e._morphHandler.setInputAction(n,ScreenSpaceEventType.WHEEL)}}function destroyMorphHandler(e){const t=e._currentTweens;for(let n=0;n<t.length;++n)t[n].cancelTween();e._currentTweens.length=0,e._morphHandler=e._morphHandler&&e._morphHandler.destroy()}const scratchCVTo3DCartographic=new Cartographic,scratchCVTo3DSurfacePoint=new Cartesian3,scratchCVTo3DFromENU=new Matrix4;function getColumbusViewTo3DCamera(e,t){const n=e._scene,i=n.camera,r=scratchCVTo3DCamera,o=r.position,a=r.direction,s=r.up,l=n.mapProjection.unproject(i.position,scratchCVTo3DCartographic);t.cartographicToCartesian(l,o);const c=t.scaleToGeodeticSurface(o,scratchCVTo3DSurfacePoint),d=Transforms.eastNorthUpToFixedFrame(c,t,scratchCVTo3DFromENU);return Matrix4.multiplyByPointAsVector(d,i.direction,a),Matrix4.multiplyByPointAsVector(d,i.up,s),r}const scratchCVTo3DStartPos=new Cartesian3,scratchCVTo3DStartDir=new Cartesian3,scratchCVTo3DStartUp=new Cartesian3,scratchCVTo3DEndPos=new Cartesian3,scratchCVTo3DEndDir=new Cartesian3,scratchCVTo3DEndUp=new Cartesian3;function morphFromColumbusViewTo3D(e,t,n,i){t*=.5;const r=e._scene,o=r.camera,a=Cartesian3.clone(o.position,scratchCVTo3DStartPos),s=Cartesian3.clone(o.direction,scratchCVTo3DStartDir),l=Cartesian3.clone(o.up,scratchCVTo3DStartUp),c=Matrix4.multiplyByPoint(Camera.TRANSFORM_2D_INVERSE,n.position,scratchCVTo3DEndPos),d=Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D_INVERSE,n.direction,scratchCVTo3DEndDir),h=Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D_INVERSE,n.up,scratchCVTo3DEndUp);function f(u){columbusViewMorph(a,c,u.time,o.position),columbusViewMorph(s,d,u.time,o.direction),columbusViewMorph(l,h,u.time,o.up),Cartesian3.cross(o.direction,o.up,o.right),Cartesian3.normalize(o.right,o.right)}const p=r.tweens.add({duration:t,easingFunction:EasingFunction$1.QUARTIC_OUT,startObject:{time:0},stopObject:{time:1},update:f,complete:function(){addMorphTimeAnimations(e,r,0,1,t,i)}});e._currentTweens.push(p)}const scratch2DTo3DFrustumOrtho=new OrthographicFrustum,scratch3DToCVStartPos=new Cartesian3,scratch3DToCVStartDir=new Cartesian3,scratch3DToCVStartUp=new Cartesian3,scratch3DToCVEndPos=new Cartesian3,scratch3DToCVEndDir=new Cartesian3,scratch3DToCVEndUp=new Cartesian3;function morphFrom2DTo3D(e,t,n){t/=3;const i=e._scene,r=i.camera;let o;t>0?(o=scratchCVTo3DCamera,Cartesian3.fromDegrees(0,0,5*n.maximumRadius,n,o.position),Cartesian3.negate(o.position,o.direction),Cartesian3.normalize(o.direction,o.direction),Cartesian3.clone(Cartesian3.UNIT_Z,o.up)):(r.position.z=r.frustum.right-r.frustum.left,o=getColumbusViewTo3DCamera(e,n));let a;e._morphToOrthographic?(a=scratch2DTo3DFrustumOrtho,a.aspectRatio=i.drawingBufferWidth/i.drawingBufferHeight,a.width=r.frustum.right-r.frustum.left):(a=scratch2DTo3DFrustumPersp,a.aspectRatio=i.drawingBufferWidth/i.drawingBufferHeight,a.fov=CesiumMath.toRadians(60)),o.frustum=a;const s=complete3DCallback(o);createMorphHandler(e,s);let l;e._morphToOrthographic?l=function(){morphFromColumbusViewTo3D(e,t,o,s)}:l=function(){morphOrthographicToPerspective(e,t,o,function(){morphFromColumbusViewTo3D(e,t,o,s)})},t>0?(i._mode=SceneMode.SCENE2D,r.flyTo({duration:t,destination:Cartesian3.fromDegrees(0,0,5*n.maximumRadius,n,scratch3DToCVEndPos),complete:function(){i._mode=SceneMode.MORPHING,l()}})):l()}function columbusViewMorph(e,t,n,i){return Cartesian3.lerp(e,t,n,i)}function morphPerspectiveToOrthographic(e,t,n,i,r){const o=e._scene,a=o.camera;if(a.frustum instanceof OrthographicFrustum)return;const s=a.frustum.fov,l=CesiumMath.RADIANS_PER_DEGREE*.5,c=n.position.z*Math.tan(s*.5);a.frustum.far=c/Math.tan(l*.5)+1e7;function d(f){a.frustum.fov=CesiumMath.lerp(s,l,f.time);const p=c/Math.tan(a.frustum.fov*.5);i(a,p)}const h=o.tweens.add({duration:t,easingFunction:EasingFunction$1.QUARTIC_OUT,startObject:{time:0},stopObject:{time:1},update:d,complete:function(){a.frustum=n.frustum.clone(),r(e)}});e._currentTweens.push(h)}const scratchCVTo2DStartPos=new Cartesian3,scratchCVTo2DStartDir=new Cartesian3,scratchCVTo2DStartUp=new Cartesian3,scratchCVTo2DEndPos=new Cartesian3,scratchCVTo2DEndDir=new Cartesian3,scratchCVTo2DEndUp=new Cartesian3,scratchCVTo2DFrustum=new OrthographicOffCenterFrustum,scratchCVTo2DRay=new Ray,scratchCVTo2DPickPos=new Cartesian3,scratchCVTo2DCamera={position:void 0,direction:void 0,up:void 0,frustum:void 0};function morphFromColumbusViewTo2D(e,t){t*=.5;const n=e._scene,i=n.camera,r=Cartesian3.clone(i.position,scratchCVTo2DStartPos),o=Cartesian3.clone(i.direction,scratchCVTo2DStartDir),a=Cartesian3.clone(i.up,scratchCVTo2DStartUp),s=Cartesian3.negate(Cartesian3.UNIT_Z,scratchCVTo2DEndDir),l=Cartesian3.clone(Cartesian3.UNIT_Y,scratchCVTo2DEndUp),c=scratchCVTo2DEndPos;if(t>0)Cartesian3.clone(Cartesian3.ZERO,scratchCVTo2DEndPos),c.z=5*n.ellipsoid.maximumRadius;else{Cartesian3.clone(r,scratchCVTo2DEndPos);const g=scratchCVTo2DRay;Matrix4.multiplyByPoint(Camera.TRANSFORM_2D,r,g.origin),Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D,o,g.direction);const _=n.globe;if(defined(_)){const C=_.pickWorldCoordinates(g,n,!0,scratchCVTo2DPickPos);defined(C)&&(Matrix4.multiplyByPoint(Camera.TRANSFORM_2D_INVERSE,C,c),c.z+=Cartesian3.distance(r,c))}}const d=scratchCVTo2DFrustum;d.right=c.z*.5,d.left=-d.right,d.top=d.right*(n.drawingBufferHeight/n.drawingBufferWidth),d.bottom=-d.top;const h=scratchCVTo2DCamera;h.position=c,h.direction=s,h.up=l,h.frustum=d;const f=complete2DCallback(h);createMorphHandler(e,f);function p(g){columbusViewMorph(r,c,g.time,i.position),columbusViewMorph(o,s,g.time,i.direction),columbusViewMorph(a,l,g.time,i.up),Cartesian3.cross(i.direction,i.up,i.right),Cartesian3.normalize(i.right,i.right),i._adjustOrthographicFrustum(!0)}function u(g,_){g.position.z=_}const m=n.tweens.add({duration:t,easingFunction:EasingFunction$1.QUARTIC_OUT,startObject:{time:0},stopObject:{time:1},update:p,complete:function(){morphPerspectiveToOrthographic(e,t,h,u,f)}});e._currentTweens.push(m)}const scratch3DTo2DCartographic=new Cartographic,scratch3DTo2DCamera={position:new Cartesian3,direction:new Cartesian3,up:new Cartesian3,position2D:new Cartesian3,direction2D:new Cartesian3,up2D:new Cartesian3,frustum:new OrthographicOffCenterFrustum},scratch3DTo2DEndCamera={position:new Cartesian3,direction:new Cartesian3,up:new Cartesian3,frustum:void 0},scratch3DTo2DPickPosition=new Cartesian3,scratch3DTo2DRay=new Ray,scratch3DTo2DToENU=new Matrix4,scratch3DTo2DSurfacePoint=new Cartesian3;function morphFrom3DTo2D(e,t,n){t*=.5;const i=e._scene,r=i.camera,o=scratch3DTo2DCamera;if(t>0)Cartesian3.clone(Cartesian3.ZERO,o.position),o.position.z=5*n.maximumRadius,Cartesian3.negate(Cartesian3.UNIT_Z,o.direction),Cartesian3.clone(Cartesian3.UNIT_Y,o.up);else{n.cartesianToCartographic(r.positionWC,scratch3DTo2DCartographic),i.mapProjection.project(scratch3DTo2DCartographic,o.position),Cartesian3.negate(Cartesian3.UNIT_Z,o.direction),Cartesian3.clone(Cartesian3.UNIT_Y,o.up);const h=scratch3DTo2DRay;Cartesian3.clone(o.position2D,h.origin);const f=Cartesian3.clone(r.directionWC,h.direction),p=n.scaleToGeodeticSurface(r.positionWC,scratch3DTo2DSurfacePoint),u=Transforms.eastNorthUpToFixedFrame(p,n,scratch3DTo2DToENU);Matrix4.inverseTransformation(u,u),Matrix4.multiplyByPointAsVector(u,f,f),Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D,f,f);const m=i.globe;if(defined(m)){const g=m.pickWorldCoordinates(h,i,!0,scratch3DTo2DPickPosition);if(defined(g)){const _=Cartesian3.distance(o.position2D,g);g.x+=_,Cartesian3.clone(g,o.position2D)}}}function a(h,f){h.position.x=f}Matrix4.multiplyByPoint(Camera.TRANSFORM_2D,o.position,o.position2D),Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D,o.direction,o.direction2D),Matrix4.multiplyByPointAsVector(Camera.TRANSFORM_2D,o.up,o.up2D);const s=o.frustum;s.right=o.position.z*.5,s.left=-s.right,s.top=s.right*(i.drawingBufferHeight/i.drawingBufferWidth),s.bottom=-s.top;const l=scratch3DTo2DEndCamera;Matrix4.multiplyByPoint(Camera.TRANSFORM_2D_INVERSE,o.position2D,l.position),Cartesian3.clone(o.direction,l.direction),Cartesian3.clone(o.up,l.up),l.frustum=s;const c=complete2DCallback(l);createMorphHandler(e,c);function d(){morphPerspectiveToOrthographic(e,t,o,a,c)}morphFrom3DToColumbusView(e,t,o,d)}function morphOrthographicToPerspective(e,t,n,i){const r=e._scene,o=r.camera,a=o.frustum.right-o.frustum.left;o.frustum=n.frustum.clone();const s=o.frustum.fov,l=CesiumMath.RADIANS_PER_DEGREE*.5,c=a*Math.tan(s*.5);o.frustum.far=c/Math.tan(l*.5)+1e7,o.frustum.fov=l;function d(f){o.frustum.fov=CesiumMath.lerp(l,s,f.time),o.position.z=c/Math.tan(o.frustum.fov*.5)}const h=r.tweens.add({duration:t,easingFunction:EasingFunction$1.QUARTIC_OUT,startObject:{time:0},stopObject:{time:1},update:d,complete:function(){i(e)}});e._currentTweens.push(h)}function morphFrom2DToColumbusView(e,t,n,i){t*=.5;const r=e._scene,o=r.camera,a=Cartesian3.clone(n.position,scratch3DToCVEndPos),s=Cartesian3.clone(n.direction,scratch3DToCVEndDir),l=Cartesian3.clone(n.up,scratch3DToCVEndUp);r._mode=SceneMode.MORPHING;function c(){o.frustum=n.frustum.clone();const d=Cartesian3.clone(o.position,scratch3DToCVStartPos),h=Cartesian3.clone(o.direction,scratch3DToCVStartDir),f=Cartesian3.clone(o.up,scratch3DToCVStartUp);d.z=a.z;function p(m){columbusViewMorph(d,a,m.time,o.position),columbusViewMorph(h,s,m.time,o.direction),columbusViewMorph(f,l,m.time,o.up),Cartesian3.cross(o.direction,o.up,o.right),Cartesian3.normalize(o.right,o.right)}const u=r.tweens.add({duration:t,easingFunction:EasingFunction$1.QUARTIC_OUT,startObject:{time:0},stopObject:{time:1},update:p,complete:function(){i(e)}});e._currentTweens.push(u)}e._morphToOrthographic?c():morphOrthographicToPerspective(e,0,n,c)}function morphFrom3DToColumbusView(e,t,n,i){const r=e._scene,o=r.camera,a=Cartesian3.clone(o.position,scratch3DToCVStartPos),s=Cartesian3.clone(o.direction,scratch3DToCVStartDir),l=Cartesian3.clone(o.up,scratch3DToCVStartUp),c=Cartesian3.clone(n.position2D,scratch3DToCVEndPos),d=Cartesian3.clone(n.direction2D,scratch3DToCVEndDir),h=Cartesian3.clone(n.up2D,scratch3DToCVEndUp);function f(u){columbusViewMorph(a,c,u.time,o.position),columbusViewMorph(s,d,u.time,o.direction),columbusViewMorph(l,h,u.time,o.up),Cartesian3.cross(o.direction,o.up,o.right),Cartesian3.normalize(o.right,o.right),o._adjustOrthographicFrustum(!0)}const p=r.tweens.add({duration:t,easingFunction:EasingFunction$1.QUARTIC_OUT,startObject:{time:0},stopObject:{time:1},update:f,complete:function(){addMorphTimeAnimations(e,r,1,0,t,i)}});e._currentTweens.push(p)}function addMorphTimeAnimations(e,t,n,i,r,o){const a={object:t,property:"morphTime",startValue:n,stopValue:i,duration:r,easingFunction:EasingFunction$1.QUARTIC_OUT};defined(o)&&(a.complete=function(){o(e)});const s=t.tweens.addProperty(a);e._currentTweens.push(s)}function complete3DCallback(e){return function(t){const n=t._scene;n._mode=SceneMode.SCENE3D,n.morphTime=SceneMode.getMorphTime(SceneMode.SCENE3D),destroyMorphHandler(t);const i=n.camera;(t._previousMode!==SceneMode.MORPHING||t._morphCancelled)&&(t._morphCancelled=!1,Cartesian3.clone(e.position,i.position),Cartesian3.clone(e.direction,i.direction),Cartesian3.clone(e.up,i.up),Cartesian3.cross(i.direction,i.up,i.right),Cartesian3.normalize(i.right,i.right),i.frustum=e.frustum.clone());const r=i.frustum;n.frameState.useLogDepth&&(r.near=.1,r.far=1e10);const o=defined(t._completeMorph);t._completeMorph=void 0,n.camera.update(n.mode),t._scene.morphComplete.raiseEvent(t,t._previousMode,SceneMode.SCENE3D,o)}}function complete2DCallback(e){return function(t){const n=t._scene;n._mode=SceneMode.SCENE2D,n.morphTime=SceneMode.getMorphTime(SceneMode.SCENE2D),destroyMorphHandler(t);const i=n.camera;Cartesian3.clone(e.position,i.position),i.position.z=n.ellipsoid.maximumRadius*2,Cartesian3.clone(e.direction,i.direction),Cartesian3.clone(e.up,i.up),Cartesian3.cross(i.direction,i.up,i.right),Cartesian3.normalize(i.right,i.right),i.frustum=e.frustum.clone();const r=defined(t._completeMorph);t._completeMorph=void 0,n.camera.update(n.mode),t._scene.morphComplete.raiseEvent(t,t._previousMode,SceneMode.SCENE2D,r)}}function completeColumbusViewCallback(e){return function(t){const n=t._scene;n._mode=SceneMode.COLUMBUS_VIEW,n.morphTime=SceneMode.getMorphTime(SceneMode.COLUMBUS_VIEW),destroyMorphHandler(t);const i=n.camera;(t._previousModeMode!==SceneMode.MORPHING||t._morphCancelled)&&(t._morphCancelled=!1,Cartesian3.clone(e.position,i.position),Cartesian3.clone(e.direction,i.direction),Cartesian3.clone(e.up,i.up),Cartesian3.cross(i.direction,i.up,i.right),Cartesian3.normalize(i.right,i.right));const r=i.frustum;n.frameState.useLogDepth&&(r.near=.1,r.far=1e10);const o=defined(t._completeMorph);t._completeMorph=void 0,n.camera.update(n.mode),t._scene.morphComplete.raiseEvent(t,t._previousMode,SceneMode.COLUMBUS_VIEW,o)}}const CameraEventType={LEFT_DRAG:0,RIGHT_DRAG:1,MIDDLE_DRAG:2,WHEEL:3,PINCH:4},CameraEventType$1=Object.freeze(CameraEventType);function getKey(e,t){let n=e;return defined(t)&&(n+=`+${t}`),n}function clonePinchMovement(e,t){Cartesian2.clone(e.distance.startPosition,t.distance.startPosition),Cartesian2.clone(e.distance.endPosition,t.distance.endPosition),Cartesian2.clone(e.angleAndHeight.startPosition,t.angleAndHeight.startPosition),Cartesian2.clone(e.angleAndHeight.endPosition,t.angleAndHeight.endPosition)}function listenToPinch(e,t,n){const i=getKey(CameraEventType$1.PINCH,t),r=e._update,o=e._isDown,a=e._eventStartPosition,s=e._pressTime,l=e._releaseTime;r[i]=!0,o[i]=!1,a[i]=new Cartesian2;let c=e._movement[i];defined(c)||(c=e._movement[i]={}),c.distance={startPosition:new Cartesian2,endPosition:new Cartesian2},c.angleAndHeight={startPosition:new Cartesian2,endPosition:new Cartesian2},c.prevAngle=0,e._eventHandler.setInputAction(function(d){e._buttonsDown++,o[i]=!0,s[i]=new Date,Cartesian2.lerp(d.position1,d.position2,.5,a[i])},ScreenSpaceEventType.PINCH_START,t),e._eventHandler.setInputAction(function(){e._buttonsDown=Math.max(e._buttonsDown-1,0),o[i]=!1,l[i]=new Date},ScreenSpaceEventType.PINCH_END,t),e._eventHandler.setInputAction(function(d){if(o[i]){r[i]?(clonePinchMovement(d,c),r[i]=!1,c.prevAngle=c.angleAndHeight.startPosition.x):(Cartesian2.clone(d.distance.endPosition,c.distance.endPosition),Cartesian2.clone(d.angleAndHeight.endPosition,c.angleAndHeight.endPosition));let h=c.angleAndHeight.endPosition.x;const f=c.prevAngle,p=Math.PI*2;for(;h>=f+Math.PI;)h-=p;for(;h<f-Math.PI;)h+=p;c.angleAndHeight.endPosition.x=-h*n.clientWidth/12,c.angleAndHeight.startPosition.x=-f*n.clientWidth/12}},ScreenSpaceEventType.PINCH_MOVE,t)}function listenToWheel(e,t){const n=getKey(CameraEventType$1.WHEEL,t),i=e._pressTime,r=e._releaseTime,o=e._update;o[n]=!0;let a=e._movement[n];defined(a)||(a=e._movement[n]={});let s=e._lastMovement[n];defined(s)||(s=e._lastMovement[n]={startPosition:new Cartesian2,endPosition:new Cartesian2,valid:!1}),a.startPosition=new Cartesian2,Cartesian2.clone(Cartesian2.ZERO,a.startPosition),a.endPosition=new Cartesian2,e._eventHandler.setInputAction(function(l){const c=7.5*CesiumMath.toRadians(l);i[n]=r[n]=new Date,a.endPosition.x=0,a.endPosition.y=c,Cartesian2.clone(a.endPosition,s.endPosition),s.valid=!0,o[n]=!1},ScreenSpaceEventType.WHEEL,t)}function listenMouseButtonDownUp(e,t,n){const i=getKey(n,t),r=e._isDown,o=e._eventStartPosition,a=e._pressTime,s=e._releaseTime;r[i]=!1,o[i]=new Cartesian2;let l=e._lastMovement[i];defined(l)||(l=e._lastMovement[i]={startPosition:new Cartesian2,endPosition:new Cartesian2,valid:!1});let c,d;n===CameraEventType$1.LEFT_DRAG?(c=ScreenSpaceEventType.LEFT_DOWN,d=ScreenSpaceEventType.LEFT_UP):n===CameraEventType$1.RIGHT_DRAG?(c=ScreenSpaceEventType.RIGHT_DOWN,d=ScreenSpaceEventType.RIGHT_UP):n===CameraEventType$1.MIDDLE_DRAG&&(c=ScreenSpaceEventType.MIDDLE_DOWN,d=ScreenSpaceEventType.MIDDLE_UP),e._eventHandler.setInputAction(function(h){e._buttonsDown++,l.valid=!1,r[i]=!0,a[i]=new Date,Cartesian2.clone(h.position,o[i])},c,t),e._eventHandler.setInputAction(function(){e._buttonsDown=Math.max(e._buttonsDown-1,0),r[i]=!1,s[i]=new Date},d,t)}function cloneMouseMovement(e,t){Cartesian2.clone(e.startPosition,t.startPosition),Cartesian2.clone(e.endPosition,t.endPosition)}function listenMouseMove(e,t){const n=e._update,i=e._movement,r=e._lastMovement,o=e._isDown;for(const a in CameraEventType$1)if(CameraEventType$1.hasOwnProperty(a)){const s=CameraEventType$1[a];if(defined(s)){const l=getKey(s,t);n[l]=!0,defined(e._lastMovement[l])||(e._lastMovement[l]={startPosition:new Cartesian2,endPosition:new Cartesian2,valid:!1}),defined(e._movement[l])||(e._movement[l]={startPosition:new Cartesian2,endPosition:new Cartesian2})}}e._eventHandler.setInputAction(function(a){for(const s in CameraEventType$1)if(CameraEventType$1.hasOwnProperty(s)){const l=CameraEventType$1[s];if(defined(l)){const c=getKey(l,t);o[c]&&(n[c]?(cloneMouseMovement(i[c],r[c]),r[c].valid=!0,cloneMouseMovement(a,i[c]),n[c]=!1):Cartesian2.clone(a.endPosition,i[c].endPosition))}}Cartesian2.clone(a.endPosition,e._currentMousePosition)},ScreenSpaceEventType.MOUSE_MOVE,t)}function CameraEventAggregator(e){if(!defined(e))throw new DeveloperError("canvas is required.");this._eventHandler=new ScreenSpaceEventHandler(e),this._update={},this._movement={},this._lastMovement={},this._isDown={},this._eventStartPosition={},this._pressTime={},this._releaseTime={},this._buttonsDown=0,this._currentMousePosition=new Cartesian2,listenToWheel(this,void 0),listenToPinch(this,void 0,e),listenMouseButtonDownUp(this,void 0,CameraEventType$1.LEFT_DRAG),listenMouseButtonDownUp(this,void 0,CameraEventType$1.RIGHT_DRAG),listenMouseButtonDownUp(this,void 0,CameraEventType$1.MIDDLE_DRAG),listenMouseMove(this,void 0);for(const t in KeyboardEventModifier)if(KeyboardEventModifier.hasOwnProperty(t)){const n=KeyboardEventModifier[t];defined(n)&&(listenToWheel(this,n),listenToPinch(this,n,e),listenMouseButtonDownUp(this,n,CameraEventType$1.LEFT_DRAG),listenMouseButtonDownUp(this,n,CameraEventType$1.RIGHT_DRAG),listenMouseButtonDownUp(this,n,CameraEventType$1.MIDDLE_DRAG),listenMouseMove(this,n))}}Object.defineProperties(CameraEventAggregator.prototype,{currentMousePosition:{get:function(){return this._currentMousePosition}},anyButtonDown:{get:function(){const e=!this._update[getKey(CameraEventType$1.WHEEL)]||!this._update[getKey(CameraEventType$1.WHEEL,KeyboardEventModifier.SHIFT)]||!this._update[getKey(CameraEventType$1.WHEEL,KeyboardEventModifier.CTRL)]||!this._update[getKey(CameraEventType$1.WHEEL,KeyboardEventModifier.ALT)];return this._buttonsDown>0||e}}});CameraEventAggregator.prototype.isMoving=function(e,t){if(!defined(e))throw new DeveloperError("type is required.");const n=getKey(e,t);return!this._update[n]};CameraEventAggregator.prototype.getMovement=function(e,t){if(!defined(e))throw new DeveloperError("type is required.");const n=getKey(e,t);return this._movement[n]};CameraEventAggregator.prototype.getLastMovement=function(e,t){if(!defined(e))throw new DeveloperError("type is required.");const n=getKey(e,t),i=this._lastMovement[n];if(i.valid)return i};CameraEventAggregator.prototype.isButtonDown=function(e,t){if(!defined(e))throw new DeveloperError("type is required.");const n=getKey(e,t);return this._isDown[n]};CameraEventAggregator.prototype.getStartMousePosition=function(e,t){if(!defined(e))throw new DeveloperError("type is required.");if(e===CameraEventType$1.WHEEL)return this._currentMousePosition;const n=getKey(e,t);return this._eventStartPosition[n]};CameraEventAggregator.prototype.getButtonPressTime=function(e,t){if(!defined(e))throw new DeveloperError("type is required.");const n=getKey(e,t);return this._pressTime[n]};CameraEventAggregator.prototype.getButtonReleaseTime=function(e,t){if(!defined(e))throw new DeveloperError("type is required.");const n=getKey(e,t);return this._releaseTime[n]};CameraEventAggregator.prototype.reset=function(){for(const e in this._update)this._update.hasOwnProperty(e)&&(this._update[e]=!0)};CameraEventAggregator.prototype.isDestroyed=function(){return!1};CameraEventAggregator.prototype.destroy=function(){return this._eventHandler=this._eventHandler&&this._eventHandler.destroy(),destroyObject(this)};function Tween(e,t,n,i,r,o,a,s,l,c){this._tweens=e,this._tweenjs=t,this._startObject=clone(n),this._stopObject=clone(i),this._duration=r,this._delay=o,this._easingFunction=a,this._update=s,this._complete=l,this.cancel=c,this.needsStart=!0}Object.defineProperties(Tween.prototype,{startObject:{get:function(){return this._startObject}},stopObject:{get:function(){return this._stopObject}},duration:{get:function(){return this._duration}},delay:{get:function(){return this._delay}},easingFunction:{get:function(){return this._easingFunction}},update:{get:function(){return this._update}},complete:{get:function(){return this._complete}},tweenjs:{get:function(){return this._tweenjs}}});Tween.prototype.cancelTween=function(){this._tweens.remove(this)};function TweenCollection(){this._tweens=[]}Object.defineProperties(TweenCollection.prototype,{length:{get:function(){return this._tweens.length}}});TweenCollection.prototype.add=function(e){if(e=defaultValue(e,defaultValue.EMPTY_OBJECT),!defined(e.startObject)||!defined(e.stopObject))throw new DeveloperError("options.startObject and options.stopObject are required.");if(!defined(e.duration)||e.duration<0)throw new DeveloperError("options.duration is required and must be positive.");if(e.duration===0)return defined(e.complete)&&e.complete(),new Tween(this);const t=e.duration/TimeConstants.SECONDS_PER_MILLISECOND,n=defaultValue(e.delay,0),i=n/TimeConstants.SECONDS_PER_MILLISECOND,r=defaultValue(e.easingFunction,EasingFunction$1.LINEAR_NONE),o=e.startObject,a=new Tween$1(o);a.to(clone(e.stopObject),t),a.delay(i),a.easing(r),defined(e.update)&&a.onUpdate(function(){e.update(o)}),a.onComplete(defaultValue(e.complete,null)),a.repeat(defaultValue(e._repeat,0));const s=new Tween(this,a,e.startObject,e.stopObject,e.duration,n,r,e.update,e.complete,e.cancel);return this._tweens.push(s),s};TweenCollection.prototype.addProperty=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.object,n=e.property,i=e.startValue,r=e.stopValue;if(!defined(t)||!defined(e.property))throw new DeveloperError("options.object and options.property are required.");if(!defined(t[n]))throw new DeveloperError("options.object must have the specified property.");if(!defined(i)||!defined(r))throw new DeveloperError("options.startValue and options.stopValue are required.");function o(a){t[n]=a.value}return this.add({startObject:{value:i},stopObject:{value:r},duration:defaultValue(e.duration,3),delay:e.delay,easingFunction:e.easingFunction,update:o,complete:e.complete,cancel:e.cancel,_repeat:e._repeat})};TweenCollection.prototype.addAlpha=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.material;if(!defined(t))throw new DeveloperError("options.material is required.");const n=[];for(const r in t.uniforms)t.uniforms.hasOwnProperty(r)&&defined(t.uniforms[r])&&defined(t.uniforms[r].alpha)&&n.push(r);if(n.length===0)throw new DeveloperError("material has no properties with alpha components.");function i(r){const o=n.length;for(let a=0;a<o;++a)t.uniforms[n[a]].alpha=r.alpha}return this.add({startObject:{alpha:defaultValue(e.startValue,0)},stopObject:{alpha:defaultValue(e.stopValue,1)},duration:defaultValue(e.duration,3),delay:e.delay,easingFunction:e.easingFunction,update:i,complete:e.complete,cancel:e.cancel})};TweenCollection.prototype.addOffsetIncrement=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.material;if(!defined(t))throw new DeveloperError("material is required.");if(!defined(t.uniforms.offset))throw new DeveloperError("material.uniforms must have an offset property.");const n=t.uniforms;return this.addProperty({object:n,property:"offset",startValue:n.offset,stopValue:n.offset+1,duration:e.duration,delay:e.delay,easingFunction:e.easingFunction,update:e.update,cancel:e.cancel,_repeat:1/0})};TweenCollection.prototype.remove=function(e){if(!defined(e))return!1;const t=this._tweens.indexOf(e);return t!==-1?(e.tweenjs.stop(),defined(e.cancel)&&e.cancel(),this._tweens.splice(t,1),!0):!1};TweenCollection.prototype.removeAll=function(){const e=this._tweens;for(let t=0;t<e.length;++t){const n=e[t];n.tweenjs.stop(),defined(n.cancel)&&n.cancel()}e.length=0};TweenCollection.prototype.contains=function(e){return defined(e)&&this._tweens.indexOf(e)!==-1};TweenCollection.prototype.get=function(e){if(!defined(e))throw new DeveloperError("index is required.");return this._tweens[e]};TweenCollection.prototype.update=function(e){const t=this._tweens;let n=0;for(e=defined(e)?e/TimeConstants.SECONDS_PER_MILLISECOND:getTimestamp();n<t.length;){const i=t[n],r=i.tweenjs;i.needsStart?(i.needsStart=!1,r.start(e)):r.update(e)?n++:(r.stop(),t.splice(n,1))}};function ScreenSpaceCameraController(e){if(!defined(e))throw new DeveloperError("scene is required.");this.enableInputs=!0,this.enableTranslate=!0,this.enableZoom=!0,this.enableRotate=!0,this.enableTilt=!0,this.enableLook=!0,this.inertiaSpin=.9,this.inertiaTranslate=.9,this.inertiaZoom=.8,this.maximumMovementRatio=.1,this.bounceAnimationTime=3,this.minimumZoomDistance=1,this.maximumZoomDistance=Number.POSITIVE_INFINITY,this.translateEventTypes=CameraEventType$1.LEFT_DRAG,this.zoomEventTypes=[CameraEventType$1.RIGHT_DRAG,CameraEventType$1.WHEEL,CameraEventType$1.PINCH],this.rotateEventTypes=CameraEventType$1.LEFT_DRAG,this.tiltEventTypes=[CameraEventType$1.MIDDLE_DRAG,CameraEventType$1.PINCH,{eventType:CameraEventType$1.LEFT_DRAG,modifier:KeyboardEventModifier.CTRL},{eventType:CameraEventType$1.RIGHT_DRAG,modifier:KeyboardEventModifier.CTRL}],this.lookEventTypes={eventType:CameraEventType$1.LEFT_DRAG,modifier:KeyboardEventModifier.SHIFT};const t=defaultValue(e.ellipsoid,Ellipsoid.default);this.minimumPickingTerrainHeight=Ellipsoid.WGS84.equals(t)?15e4:t.minimumRadius*.025,this._minimumPickingTerrainHeight=this.minimumPickingTerrainHeight,this.minimumPickingTerrainDistanceWithInertia=Ellipsoid.WGS84.equals(t)?4e3:t.minimumRadius*63e-5,this.minimumCollisionTerrainHeight=Ellipsoid.WGS84.equals(t)?15e3:t.minimumRadius*.0025,this._minimumCollisionTerrainHeight=this.minimumCollisionTerrainHeight,this.minimumTrackBallHeight=Ellipsoid.WGS84.equals(t)?75e5:t.minimumRadius*1.175,this._minimumTrackBallHeight=this.minimumTrackBallHeight,this.enableCollisionDetection=!0,this._scene=e,this._globe=void 0,this._ellipsoid=t,this._lastGlobeHeight=0,this._aggregator=new CameraEventAggregator(e.canvas),this._lastInertiaSpinMovement=void 0,this._lastInertiaZoomMovement=void 0,this._lastInertiaTranslateMovement=void 0,this._lastInertiaTiltMovement=void 0,this._inertiaDisablers={_lastInertiaZoomMovement:["_lastInertiaSpinMovement","_lastInertiaTranslateMovement","_lastInertiaTiltMovement"],_lastInertiaTiltMovement:["_lastInertiaSpinMovement","_lastInertiaTranslateMovement"]},this._tweens=new TweenCollection,this._tween=void 0,this._horizontalRotationAxis=void 0,this._tiltCenterMousePosition=new Cartesian2(-1,-1),this._tiltCenter=new Cartesian3,this._rotateMousePosition=new Cartesian2(-1,-1),this._rotateStartPosition=new Cartesian3,this._strafeStartPosition=new Cartesian3,this._strafeMousePosition=new Cartesian2,this._strafeEndMousePosition=new Cartesian2,this._zoomMouseStart=new Cartesian2(-1,-1),this._zoomWorldPosition=new Cartesian3,this._useZoomWorldPosition=!1,this._panLastMousePosition=new Cartesian2,this._panLastWorldPosition=new Cartesian3,this._tiltCVOffMap=!1,this._looking=!1,this._rotating=!1,this._strafing=!1,this._zoomingOnVector=!1,this._zoomingUnderground=!1,this._rotatingZoom=!1,this._adjustedHeightForTerrain=!1,this._cameraUnderground=!1;const n=e.mapProjection;this._maxCoord=n.project(new Cartographic(Math.PI,CesiumMath.PI_OVER_TWO)),this._zoomFactor=5,this._rotateFactor=void 0,this._rotateRateRangeAdjustment=void 0,this._maximumRotateRate=1.77,this._minimumRotateRate=1/5e3,this._minimumZoomRate=20,this._maximumZoomRate=5906376272e3,this._minimumUndergroundPickDistance=2e3,this._maximumUndergroundPickDistance=1e4}function decay(e,t){if(e<0)return 0;const n=(1-t)*25;return Math.exp(-n*e)}function sameMousePosition(e){return Cartesian2.equalsEpsilon(e.startPosition,e.endPosition,CesiumMath.EPSILON14)}const inertiaMaxClickTimeThreshold=.4;function maintainInertia(e,t,n,i,r,o,a){let s=o[a];defined(s)||(s=o[a]={startPosition:new Cartesian2,endPosition:new Cartesian2,motion:new Cartesian2,inertiaEnabled:!0});const l=e.getButtonPressTime(t,n),c=e.getButtonReleaseTime(t,n),d=l&&c&&(c.getTime()-l.getTime())/1e3,f=c&&(new Date().getTime()-c.getTime())/1e3;if(l&&c&&d<inertiaMaxClickTimeThreshold){const p=decay(f,i),u=e.getLastMovement(t,n);if(!defined(u)||sameMousePosition(u)||!s.inertiaEnabled||(s.motion.x=(u.endPosition.x-u.startPosition.x)*.5,s.motion.y=(u.endPosition.y-u.startPosition.y)*.5,s.startPosition=Cartesian2.clone(u.startPosition,s.startPosition),s.endPosition=Cartesian2.multiplyByScalar(s.motion,p,s.endPosition),s.endPosition=Cartesian2.add(s.startPosition,s.endPosition,s.endPosition),isNaN(s.endPosition.x)||isNaN(s.endPosition.y)||Cartesian2.distance(s.startPosition,s.endPosition)<.5))return;if(!e.isButtonDown(t,n)){const m=e.getStartMousePosition(t,n);r(o,m,s)}}}function activateInertia(e,t){if(defined(t)){let n=e[t];defined(n)&&(n.inertiaEnabled=!0);const i=e._inertiaDisablers[t];if(defined(i)){const r=i.length;for(let o=0;o<r;++o)n=e[i[o]],defined(n)&&(n.inertiaEnabled=!1)}}}const scratchEventTypeArray=[];function reactToInput(e,t,n,i,r,o){if(!defined(n))return;const a=e._aggregator;Array.isArray(n)||(scratchEventTypeArray[0]=n,n=scratchEventTypeArray);const s=n.length;for(let l=0;l<s;++l){const c=n[l],d=defined(c.eventType)?c.eventType:c,h=c.modifier,f=a.isMoving(d,h)&&a.getMovement(d,h),p=a.getStartMousePosition(d,h);e.enableInputs&&t&&(f?(i(e,p,f),activateInertia(e,o)):r<1&&maintainInertia(a,d,h,r,i,e,o))}}const scratchZoomPickRay=new Ray,scratchPickCartesian$1=new Cartesian3,scratchZoomOffset=new Cartesian2,scratchZoomDirection=new Cartesian3,scratchCenterPixel=new Cartesian2,scratchCenterPosition=new Cartesian3,scratchPositionNormal=new Cartesian3,scratchPickNormal=new Cartesian3,scratchZoomAxis=new Cartesian3,scratchCameraPositionNormal=new Cartesian3,scratchTargetNormal=new Cartesian3,scratchCameraPosition=new Cartesian3,scratchCameraUpNormal=new Cartesian3,scratchCameraRightNormal=new Cartesian3,scratchForwardNormal=new Cartesian3,scratchPositionToTarget=new Cartesian3,scratchPositionToTargetNormal=new Cartesian3,scratchPan=new Cartesian3,scratchCenterMovement=new Cartesian3,scratchCenter$1=new Cartesian3,scratchCartesian=new Cartesian3,scratchCartesianTwo=new Cartesian3,scratchCartesianThree=new Cartesian3,scratchZoomViewOptions={orientation:new HeadingPitchRoll};function handleZoom(e,t,n,i,r,o){let a=1;defined(o)&&(a=CesiumMath.clamp(Math.abs(o),.25,1));const s=n.endPosition.y-n.startPosition.y,c=s>0?e.minimumZoomDistance*a:0,d=e.maximumZoomDistance,h=r-c;let f=i*h;f=CesiumMath.clamp(f,e._minimumZoomRate,e._maximumZoomRate);let p=s/e._scene.canvas.clientHeight;p=Math.min(p,e.maximumMovementRatio);let u=f*p;if(e.enableCollisionDetection||e.minimumZoomDistance===0||!defined(e._globe)){if(u>0&&Math.abs(r-c)<1||u<0&&Math.abs(r-d)<1)return;r-u<c?u=r-c-1:r-u>d&&(u=r-d)}const m=e._scene,g=m.camera,_=m.mode,C=scratchZoomViewOptions.orientation;if(C.heading=g.heading,C.pitch=g.pitch,C.roll=g.roll,g.frustum instanceof OrthographicFrustum){Math.abs(u)>0&&(g.zoomIn(u),g._adjustOrthographicFrustum(!0));return}const A=defaultValue(n.inertiaEnabled,Cartesian2.equals(t,e._zoomMouseStart));let S=e._zoomingOnVector,v=e._rotatingZoom,b;if(A||(e._zoomMouseStart=Cartesian2.clone(t,e._zoomMouseStart),defined(e._globe)&&_===SceneMode.SCENE2D?(b=g.getPickRay(t,scratchZoomPickRay).origin,b=Cartesian3.fromElements(b.y,b.z,b.x)):defined(e._globe)&&(b=pickPosition(e,t,scratchPickCartesian$1)),defined(b)?(e._useZoomWorldPosition=!0,e._zoomWorldPosition=Cartesian3.clone(b,e._zoomWorldPosition)):e._useZoomWorldPosition=!1,S=e._zoomingOnVector=!1,v=e._rotatingZoom=!1,e._zoomingUnderground=e._cameraUnderground),!e._useZoomWorldPosition){g.zoomIn(u);return}let D=_===SceneMode.COLUMBUS_VIEW;if(g.positionCartographic.height<2e6&&(v=!0),!A||v){if(_===SceneMode.SCENE2D){const I=e._zoomWorldPosition,L=g.position;if(!Cartesian3.equals(I,L)&&g.positionCartographic.height<e._maxCoord.x*2){const N=g.position.x,y=Cartesian3.subtract(I,L,scratchZoomDirection);Cartesian3.normalize(y,y);const x=Cartesian3.distance(I,L)*u/(g.getMagnitude()*.5);g.move(y,x*.5),(g.position.x<0&&N>0||g.position.x>0&&N<0)&&(b=g.getPickRay(t,scratchZoomPickRay).origin,b=Cartesian3.fromElements(b.y,b.z,b.x),e._zoomWorldPosition=Cartesian3.clone(b,e._zoomWorldPosition))}}else if(_===SceneMode.SCENE3D){const I=Cartesian3.normalize(g.position,scratchCameraPositionNormal);if(e._cameraUnderground||e._zoomingUnderground||g.positionCartographic.height<3e3&&Math.abs(Cartesian3.dot(g.direction,I))<.6)D=!0;else{const L=m.canvas,N=scratchCenterPixel;N.x=L.clientWidth/2,N.y=L.clientHeight/2;const y=pickPosition(e,N,scratchCenterPosition);if(!defined(y))D=!0;else if(g.positionCartographic.height<1e6)if(Cartesian3.dot(g.direction,I)>=-.5)D=!0;else{const x=scratchCameraPosition;Cartesian3.clone(g.position,x);const T=e._zoomWorldPosition;let E=scratchTargetNormal;if(E=Cartesian3.normalize(T,E),Cartesian3.dot(E,I)<0)return;const P=scratchCenter$1,M=scratchForwardNormal;Cartesian3.clone(g.direction,M),Cartesian3.add(x,Cartesian3.multiplyByScalar(M,1e3,scratchCartesian),P);const O=scratchPositionToTarget,V=scratchPositionToTargetNormal;Cartesian3.subtract(T,x,O),Cartesian3.normalize(O,V);const R=Cartesian3.dot(I,V);if(R>=0){e._zoomMouseStart.x=-1;return}const w=Math.acos(-R),U=Cartesian3.magnitude(x),k=Cartesian3.magnitude(T),H=U-u,F=Cartesian3.magnitude(O),G=Math.asin(CesiumMath.clamp(F/k*Math.sin(w),-1,1)),B=Math.asin(CesiumMath.clamp(H/k*Math.sin(w),-1,1)),W=G-B+w,Y=scratchCameraUpNormal;Cartesian3.normalize(x,Y);let z=scratchCameraRightNormal;z=Cartesian3.cross(V,Y,z),z=Cartesian3.normalize(z,z),Cartesian3.normalize(Cartesian3.cross(Y,z,scratchCartesian),M),Cartesian3.multiplyByScalar(Cartesian3.normalize(P,scratchCartesian),Cartesian3.magnitude(P)-u,P),Cartesian3.normalize(x,x),Cartesian3.multiplyByScalar(x,H,x);const X=scratchPan;Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(Y,Math.cos(W)-1,scratchCartesianTwo),Cartesian3.multiplyByScalar(M,Math.sin(W),scratchCartesianThree),scratchCartesian),H,X),Cartesian3.add(x,X,x),Cartesian3.normalize(P,Y),Cartesian3.normalize(Cartesian3.cross(Y,z,scratchCartesian),M);const q=scratchCenterMovement;Cartesian3.multiplyByScalar(Cartesian3.add(Cartesian3.multiplyByScalar(Y,Math.cos(W)-1,scratchCartesianTwo),Cartesian3.multiplyByScalar(M,Math.sin(W),scratchCartesianThree),scratchCartesian),Cartesian3.magnitude(P),q),Cartesian3.add(P,q,P),Cartesian3.clone(x,g.position),Cartesian3.normalize(Cartesian3.subtract(P,x,scratchCartesian),g.direction),Cartesian3.clone(g.direction,g.direction),Cartesian3.cross(g.direction,g.up,g.right),Cartesian3.cross(g.right,g.direction,g.up),g.setView(scratchZoomViewOptions);return}else{const x=Cartesian3.normalize(y,scratchPositionNormal),T=Cartesian3.normalize(e._zoomWorldPosition,scratchPickNormal),E=Cartesian3.dot(T,x);if(E>0&&E<1){const P=CesiumMath.acosClamped(E),M=Cartesian3.cross(T,x,scratchZoomAxis),O=Math.abs(P)>CesiumMath.toRadians(20)?g.positionCartographic.height*.75:g.positionCartographic.height-u,V=u/O;g.rotate(M,P*V)}}}}e._rotatingZoom=!D}if(!A&&D||S){let I;const L=SceneTransforms.worldToWindowCoordinates(m,e._zoomWorldPosition,scratchZoomOffset);_!==SceneMode.COLUMBUS_VIEW&&Cartesian2.equals(t,e._zoomMouseStart)&&defined(L)?I=g.getPickRay(L,scratchZoomPickRay):I=g.getPickRay(t,scratchZoomPickRay);const N=I.direction;(_===SceneMode.COLUMBUS_VIEW||_===SceneMode.SCENE2D)&&Cartesian3.fromElements(N.y,N.z,N.x,N),g.move(N,u),e._zoomingOnVector=!0}else g.zoomIn(u);e._cameraUnderground||g.setView(scratchZoomViewOptions)}const translate2DStart=new Ray,translate2DEnd=new Ray,scratchTranslateP0=new Cartesian3;function translate2D(e,t,n){const r=e._scene.camera;let o=r.getPickRay(n.startPosition,translate2DStart).origin,a=r.getPickRay(n.endPosition,translate2DEnd).origin;o=Cartesian3.fromElements(o.y,o.z,o.x,o),a=Cartesian3.fromElements(a.y,a.z,a.x,a);const s=Cartesian3.subtract(o,a,scratchTranslateP0),l=Cartesian3.magnitude(s);l>0&&(Cartesian3.normalize(s,s),r.move(s,l))}function zoom2D(e,t,n){defined(n.distance)&&(n=n.distance);const r=e._scene.camera;handleZoom(e,t,n,e._zoomFactor,r.getMagnitude())}const twist2DStart=new Cartesian2,twist2DEnd=new Cartesian2;function twist2D(e,t,n){if(defined(n.angleAndHeight)){singleAxisTwist2D(e,t,n.angleAndHeight);return}const i=e._scene,r=i.camera,o=i.canvas,a=o.clientWidth,s=o.clientHeight;let l=twist2DStart;l.x=2/a*n.startPosition.x-1,l.y=2/s*(s-n.startPosition.y)-1,l=Cartesian2.normalize(l,l);let c=twist2DEnd;c.x=2/a*n.endPosition.x-1,c.y=2/s*(s-n.endPosition.y)-1,c=Cartesian2.normalize(c,c);let d=CesiumMath.acosClamped(l.x);l.y<0&&(d=CesiumMath.TWO_PI-d);let h=CesiumMath.acosClamped(c.x);c.y<0&&(h=CesiumMath.TWO_PI-h);const f=h-d;r.twistRight(f)}function singleAxisTwist2D(e,t,n){let i=e._rotateFactor*e._rotateRateRangeAdjustment;i>e._maximumRotateRate&&(i=e._maximumRotateRate),i<e._minimumRotateRate&&(i=e._minimumRotateRate);const r=e._scene,o=r.camera,a=r.canvas;let s=(n.endPosition.x-n.startPosition.x)/a.clientWidth;s=Math.min(s,e.maximumMovementRatio);const l=i*s*Math.PI*4;o.twistRight(l)}function update2D(e){const t=e._scene.mapMode2D===MapMode2D$1.ROTATE;Matrix4.equals(Matrix4.IDENTITY,e._scene.camera.transform)?(reactToInput(e,e.enableTranslate,e.translateEventTypes,translate2D,e.inertiaTranslate,"_lastInertiaTranslateMovement"),reactToInput(e,e.enableZoom,e.zoomEventTypes,zoom2D,e.inertiaZoom,"_lastInertiaZoomMovement"),t&&reactToInput(e,e.enableRotate,e.tiltEventTypes,twist2D,e.inertiaSpin,"_lastInertiaTiltMovement")):(reactToInput(e,e.enableZoom,e.zoomEventTypes,zoom2D,e.inertiaZoom,"_lastInertiaZoomMovement"),t&&reactToInput(e,e.enableRotate,e.translateEventTypes,twist2D,e.inertiaSpin,"_lastInertiaSpinMovement"))}const pickGlobeScratchRay=new Ray,scratchDepthIntersection=new Cartesian3,scratchRayIntersection=new Cartesian3;function pickPosition(e,t,n){const i=e._scene,r=e._globe,o=i.camera;let a;if(i.pickPositionSupported&&(a=i.pickPositionWorldCoordinates(t,scratchDepthIntersection)),!defined(r))return Cartesian3.clone(a,n);const s=!e._cameraUnderground,l=o.getPickRay(t,pickGlobeScratchRay),c=r.pickWorldCoordinates(l,i,s,scratchRayIntersection),d=defined(a)?Cartesian3.distance(a,o.positionWC):Number.POSITIVE_INFINITY,h=defined(c)?Cartesian3.distance(c,o.positionWC):Number.POSITIVE_INFINITY;return d<h?Cartesian3.clone(a,n):Cartesian3.clone(c,n)}const scratchDistanceCartographic=new Cartographic;function getDistanceFromSurface(e){const t=e._ellipsoid,n=e._scene,i=n.camera,r=n.mode;let o=0;if(r===SceneMode.SCENE3D){const l=t.cartesianToCartographic(i.position,scratchDistanceCartographic);defined(l)&&(o=l.height)}else o=i.position.z;const a=defaultValue(e._scene.globeHeight,0);return Math.abs(a-o)}const scratchSurfaceNormal=new Cartesian3;function getZoomDistanceUnderground(e,t){const n=t.origin,i=t.direction,r=getDistanceFromSurface(e),o=Cartesian3.normalize(n,scratchSurfaceNormal);let a=Math.abs(Cartesian3.dot(o,i));return a=Math.max(a,.5)*2,r*a}function getTiltCenterUnderground(e,t,n,i){let r=Cartesian3.distance(t.origin,n);const o=getDistanceFromSurface(e),a=CesiumMath.clamp(o*5,e._minimumUndergroundPickDistance,e._maximumUndergroundPickDistance);return r>a&&(r=Math.min(r,o/5),r=Math.max(r,100)),Ray.getPoint(t,r,i)}function getStrafeStartPositionUnderground(e,t,n,i){let r;return defined(n)?(r=Cartesian3.distance(t.origin,n),r>e._maximumUndergroundPickDistance&&(r=getDistanceFromSurface(e))):r=getDistanceFromSurface(e),Ray.getPoint(t,r,i)}const scratchInertialDelta=new Cartesian2;function continueStrafing(e,t){const n=t.endPosition,i=Cartesian2.subtract(t.endPosition,t.startPosition,scratchInertialDelta),r=e._strafeEndMousePosition;Cartesian2.add(r,i,r),t.endPosition=r,strafe(e,t,e._strafeStartPosition),t.endPosition=n}const translateCVStartRay=new Ray,translateCVEndRay=new Ray,translateCVStartPos=new Cartesian3,translateCVEndPos=new Cartesian3,translateCVDifference=new Cartesian3,translateCVOrigin=new Cartesian3,translateCVPlane=new Plane(Cartesian3.UNIT_X,0),translateCVStartMouse=new Cartesian2,translateCVEndMouse=new Cartesian2;function translateCV(e,t,n){if(Cartesian3.equals(t,e._translateMousePosition)||(e._looking=!1),Cartesian3.equals(t,e._strafeMousePosition)||(e._strafing=!1),e._looking){look3D(e,t,n);return}if(e._strafing){continueStrafing(e,n);return}const r=e._scene.camera,o=e._cameraUnderground,a=Cartesian2.clone(n.startPosition,translateCVStartMouse),s=Cartesian2.clone(n.endPosition,translateCVEndMouse);let l=r.getPickRay(a,translateCVStartRay);const c=Cartesian3.clone(Cartesian3.ZERO,translateCVOrigin),d=Cartesian3.UNIT_X;let h;if(r.position.z<e._minimumPickingTerrainHeight&&(h=pickPosition(e,a,translateCVStartPos),defined(h)&&(c.x=h.x)),o||c.x>r.position.z&&defined(h)){let A=h;o&&(A=getStrafeStartPositionUnderground(e,l,h,translateCVStartPos)),Cartesian2.clone(t,e._strafeMousePosition),Cartesian2.clone(t,e._strafeEndMousePosition),Cartesian3.clone(A,e._strafeStartPosition),e._strafing=!0,strafe(e,n,e._strafeStartPosition);return}const f=Plane.fromPointNormal(c,d,translateCVPlane);l=r.getPickRay(a,translateCVStartRay);const p=IntersectionTests.rayPlane(l,f,translateCVStartPos),u=r.getPickRay(s,translateCVEndRay),m=IntersectionTests.rayPlane(u,f,translateCVEndPos);if(!defined(p)||!defined(m)){e._looking=!0,look3D(e,t,n),Cartesian2.clone(t,e._translateMousePosition);return}const g=Cartesian3.subtract(p,m,translateCVDifference),_=g.x;g.x=g.y,g.y=g.z,g.z=_;const C=Cartesian3.magnitude(g);C>CesiumMath.EPSILON6&&(Cartesian3.normalize(g,g),r.move(g,C))}const rotateCVWindowPos=new Cartesian2,rotateCVWindowRay=new Ray,rotateCVCenter=new Cartesian3,rotateCVVerticalCenter=new Cartesian3,rotateCVTransform=new Matrix4,rotateCVVerticalTransform=new Matrix4,rotateCVOrigin=new Cartesian3,rotateCVPlane=new Plane(Cartesian3.UNIT_X,0),rotateCVCartesian3=new Cartesian3,rotateCVCart=new Cartographic,rotateCVOldTransform=new Matrix4,rotateCVQuaternion=new Quaternion,rotateCVMatrix=new Matrix3,tilt3DCartesian3=new Cartesian3;function rotateCV(e,t,n){if(defined(n.angleAndHeight)&&(n=n.angleAndHeight),Cartesian2.equals(t,e._tiltCenterMousePosition)||(e._tiltCVOffMap=!1,e._looking=!1),e._looking){look3D(e,t,n);return}const r=e._scene.camera;e._tiltCVOffMap||!e.onMap()||Math.abs(r.position.z)>e._minimumPickingTerrainHeight?(e._tiltCVOffMap=!0,rotateCVOnPlane(e,t,n)):rotateCVOnTerrain(e,t,n)}function rotateCVOnPlane(e,t,n){const i=e._scene,r=i.camera,o=i.canvas,a=rotateCVWindowPos;a.x=o.clientWidth/2,a.y=o.clientHeight/2;const s=r.getPickRay(a,rotateCVWindowRay),l=Cartesian3.UNIT_X,c=s.origin,d=s.direction;let h;const f=Cartesian3.dot(l,d);if(Math.abs(f)>CesiumMath.EPSILON6&&(h=-Cartesian3.dot(l,c)/f),!defined(h)||h<=0){e._looking=!0,look3D(e,t,n),Cartesian2.clone(t,e._tiltCenterMousePosition);return}const p=Cartesian3.multiplyByScalar(d,h,rotateCVCenter);Cartesian3.add(c,p,p);const u=i.mapProjection,m=u.ellipsoid;Cartesian3.fromElements(p.y,p.z,p.x,p);const g=u.unproject(p,rotateCVCart);m.cartographicToCartesian(g,p);const _=Transforms.eastNorthUpToFixedFrame(p,m,rotateCVTransform),C=e._globe,A=e._ellipsoid;e._globe=void 0,e._ellipsoid=Ellipsoid.UNIT_SPHERE,e._rotateFactor=1,e._rotateRateRangeAdjustment=1;const S=Matrix4.clone(r.transform,rotateCVOldTransform);r._setTransform(_),rotate3D(e,t,n,Cartesian3.UNIT_Z),r._setTransform(S),e._globe=C,e._ellipsoid=A;const v=A.maximumRadius;e._rotateFactor=1/v,e._rotateRateRangeAdjustment=v}function rotateCVOnTerrain(e,t,n){const i=e._scene,r=i.camera,o=e._cameraUnderground;let a,s;const l=Cartesian3.UNIT_X;if(Cartesian2.equals(t,e._tiltCenterMousePosition))a=Cartesian3.clone(e._tiltCenter,rotateCVCenter);else{if(r.position.z<e._minimumPickingTerrainHeight&&(a=pickPosition(e,t,rotateCVCenter)),!defined(a)){s=r.getPickRay(t,rotateCVWindowRay);const y=s.origin,x=s.direction;let T;const E=Cartesian3.dot(l,x);if(Math.abs(E)>CesiumMath.EPSILON6&&(T=-Cartesian3.dot(l,y)/E),!defined(T)||T<=0){e._looking=!0,look3D(e,t,n),Cartesian2.clone(t,e._tiltCenterMousePosition);return}a=Cartesian3.multiplyByScalar(x,T,rotateCVCenter),Cartesian3.add(y,a,a)}o&&(defined(s)||(s=r.getPickRay(t,rotateCVWindowRay)),getTiltCenterUnderground(e,s,a,a)),Cartesian2.clone(t,e._tiltCenterMousePosition),Cartesian3.clone(a,e._tiltCenter)}const c=i.canvas,d=rotateCVWindowPos;d.x=c.clientWidth/2,d.y=e._tiltCenterMousePosition.y,s=r.getPickRay(d,rotateCVWindowRay);const h=Cartesian3.clone(Cartesian3.ZERO,rotateCVOrigin);h.x=a.x;const f=Plane.fromPointNormal(h,l,rotateCVPlane),p=IntersectionTests.rayPlane(s,f,rotateCVVerticalCenter),u=r._projection,m=u.ellipsoid;Cartesian3.fromElements(a.y,a.z,a.x,a);let g=u.unproject(a,rotateCVCart);m.cartographicToCartesian(g,a);const _=Transforms.eastNorthUpToFixedFrame(a,m,rotateCVTransform);let C;defined(p)?(Cartesian3.fromElements(p.y,p.z,p.x,p),g=u.unproject(p,rotateCVCart),m.cartographicToCartesian(g,p),C=Transforms.eastNorthUpToFixedFrame(p,m,rotateCVVerticalTransform)):C=_;const A=e._globe,S=e._ellipsoid;e._globe=void 0,e._ellipsoid=Ellipsoid.UNIT_SPHERE,e._rotateFactor=1,e._rotateRateRangeAdjustment=1;let v=Cartesian3.UNIT_Z;const b=Matrix4.clone(r.transform,rotateCVOldTransform);r._setTransform(_);const D=Cartesian3.cross(Cartesian3.UNIT_Z,Cartesian3.normalize(r.position,rotateCVCartesian3),rotateCVCartesian3),I=Cartesian3.dot(r.right,D);if(rotate3D(e,t,n,v,!1,!0),r._setTransform(C),I<0){const y=n.startPosition.y-n.endPosition.y;(o&&y<0||!o&&y>0)&&(v=void 0);const x=r.constrainedAxis;r.constrainedAxis=void 0,rotate3D(e,t,n,v,!0,!1),r.constrainedAxis=x}else rotate3D(e,t,n,v,!0,!1);if(defined(r.constrainedAxis)){const y=Cartesian3.cross(r.direction,r.constrainedAxis,tilt3DCartesian3);Cartesian3.equalsEpsilon(y,Cartesian3.ZERO,CesiumMath.EPSILON6)||(Cartesian3.dot(y,r.right)<0&&Cartesian3.negate(y,y),Cartesian3.cross(y,r.direction,r.up),Cartesian3.cross(r.direction,r.up,r.right),Cartesian3.normalize(r.up,r.up),Cartesian3.normalize(r.right,r.right))}r._setTransform(b),e._globe=A,e._ellipsoid=S;const L=S.maximumRadius;e._rotateFactor=1/L,e._rotateRateRangeAdjustment=L;const N=Cartesian3.clone(r.positionWC,rotateCVCartesian3);if(e.enableCollisionDetection&&adjustHeightForTerrain(e,!0),!Cartesian3.equals(r.positionWC,N)){r._setTransform(C),r.worldToCameraCoordinatesPoint(N,N);const y=Cartesian3.magnitudeSquared(N);Cartesian3.magnitudeSquared(r.position)>y&&(Cartesian3.normalize(r.position,r.position),Cartesian3.multiplyByScalar(r.position,Math.sqrt(y),r.position));const x=Cartesian3.angleBetween(N,r.position),T=Cartesian3.cross(N,r.position,N);Cartesian3.normalize(T,T);const E=Quaternion.fromAxisAngle(T,x,rotateCVQuaternion),P=Matrix3.fromQuaternion(E,rotateCVMatrix);Matrix3.multiplyByVector(P,r.direction,r.direction),Matrix3.multiplyByVector(P,r.up,r.up),Cartesian3.cross(r.direction,r.up,r.right),Cartesian3.cross(r.right,r.direction,r.up),r._setTransform(b)}}const zoomCVWindowPos=new Cartesian2,zoomCVWindowRay=new Ray,zoomCVIntersection=new Cartesian3;function zoomCV(e,t,n){defined(n.distance)&&(n=n.distance);const i=e._scene,r=i.camera,o=i.canvas,a=e._cameraUnderground;let s;a?s=t:(s=zoomCVWindowPos,s.x=o.clientWidth/2,s.y=o.clientHeight/2);const l=r.getPickRay(s,zoomCVWindowRay),c=l.origin,d=l.direction,h=r.position.z;let f;h<e._minimumPickingTerrainHeight&&(f=pickPosition(e,s,zoomCVIntersection));let p;if(defined(f)&&(p=Cartesian3.distance(c,f)),a){const u=getZoomDistanceUnderground(e,l);defined(p)?p=Math.min(p,u):p=u}if(!defined(p)){const u=Cartesian3.UNIT_X;p=-Cartesian3.dot(u,c)/Cartesian3.dot(u,d)}handleZoom(e,t,n,e._zoomFactor,p)}function updateCV(e){const n=e._scene.camera;if(!Matrix4.equals(Matrix4.IDENTITY,n.transform))reactToInput(e,e.enableRotate,e.rotateEventTypes,rotate3D,e.inertiaSpin,"_lastInertiaSpinMovement"),reactToInput(e,e.enableZoom,e.zoomEventTypes,zoom3D,e.inertiaZoom,"_lastInertiaZoomMovement");else{const i=e._tweens;if(e._aggregator.anyButtonDown&&i.removeAll(),reactToInput(e,e.enableTilt,e.tiltEventTypes,rotateCV,e.inertiaSpin,"_lastInertiaTiltMovement"),reactToInput(e,e.enableTranslate,e.translateEventTypes,translateCV,e.inertiaTranslate,"_lastInertiaTranslateMovement"),reactToInput(e,e.enableZoom,e.zoomEventTypes,zoomCV,e.inertiaZoom,"_lastInertiaZoomMovement"),reactToInput(e,e.enableLook,e.lookEventTypes,look3D),!e._aggregator.anyButtonDown&&!i.contains(e._tween)){const r=n.createCorrectPositionTween(e.bounceAnimationTime);defined(r)&&(e._tween=i.add(r))}i.update()}}const scratchStrafeRay=new Ray,scratchStrafePlane=new Plane(Cartesian3.UNIT_X,0),scratchStrafeIntersection=new Cartesian3,scratchStrafeDirection=new Cartesian3;function strafe(e,t,n){const i=e._scene,r=i.camera,o=r.getPickRay(t.endPosition,scratchStrafeRay);let a=Cartesian3.clone(r.direction,scratchStrafeDirection);i.mode===SceneMode.COLUMBUS_VIEW&&Cartesian3.fromElements(a.z,a.x,a.y,a);const s=Plane.fromPointNormal(n,a,scratchStrafePlane),l=IntersectionTests.rayPlane(o,s,scratchStrafeIntersection);defined(l)&&(a=Cartesian3.subtract(n,l,a),i.mode===SceneMode.COLUMBUS_VIEW&&Cartesian3.fromElements(a.y,a.z,a.x,a),Cartesian3.add(r.position,a,r.position))}const spin3DPick=new Cartesian3,scratchCartographic=new Cartographic,scratchRadii=new Cartesian3,scratchEllipsoid=new Ellipsoid,scratchLookUp=new Cartesian3,scratchNormal$1=new Cartesian3,scratchMousePosition=new Cartesian3;function spin3D(e,t,n){const r=e._scene.camera,o=e._cameraUnderground;let a=e._ellipsoid;if(!Matrix4.equals(r.transform,Matrix4.IDENTITY)){rotate3D(e,t,n);return}let s,l;const c=a.geodeticSurfaceNormal(r.position,scratchLookUp);if(Cartesian2.equals(t,e._rotateMousePosition)){if(e._looking)look3D(e,t,n,c);else if(e._rotating)rotate3D(e,t,n);else if(e._strafing)continueStrafing(e,n);else{if(Cartesian3.magnitude(r.position)<Cartesian3.magnitude(e._rotateStartPosition))return;s=Cartesian3.magnitude(e._rotateStartPosition),l=scratchRadii,l.x=l.y=l.z=s,a=Ellipsoid.fromCartesian3(l,scratchEllipsoid),pan3D(e,t,n,a)}return}e._looking=!1,e._rotating=!1,e._strafing=!1;const d=a.cartesianToCartographic(r.positionWC,scratchCartographic).height,h=e._globe;if(defined(h)&&d<e._minimumPickingTerrainHeight){const f=pickPosition(e,n.startPosition,scratchMousePosition);if(defined(f)){let p=!1;const u=r.getPickRay(n.startPosition,pickGlobeScratchRay);if(o)p=!0,getStrafeStartPositionUnderground(e,u,f,f);else{const m=a.geodeticSurfaceNormal(f,scratchNormal$1);Math.abs(Cartesian3.dot(u.direction,m))<.05?p=!0:p=Cartesian3.magnitude(r.position)<Cartesian3.magnitude(f)}p?(Cartesian2.clone(t,e._strafeEndMousePosition),Cartesian3.clone(f,e._strafeStartPosition),e._strafing=!0,strafe(e,n,e._strafeStartPosition)):(s=Cartesian3.magnitude(f),l=scratchRadii,l.x=l.y=l.z=s,a=Ellipsoid.fromCartesian3(l,scratchEllipsoid),pan3D(e,t,n,a),Cartesian3.clone(f,e._rotateStartPosition))}else e._looking=!0,look3D(e,t,n,c)}else defined(r.pickEllipsoid(n.startPosition,e._ellipsoid,spin3DPick))?(pan3D(e,t,n,e._ellipsoid),Cartesian3.clone(spin3DPick,e._rotateStartPosition)):d>e._minimumTrackBallHeight?(e._rotating=!0,rotate3D(e,t,n)):(e._looking=!0,look3D(e,t,n,c));Cartesian2.clone(t,e._rotateMousePosition)}function rotate3D(e,t,n,i,r,o){r=defaultValue(r,!1),o=defaultValue(o,!1);const a=e._scene,s=a.camera,l=a.canvas,c=s.constrainedAxis;defined(i)&&(s.constrainedAxis=i);const d=Cartesian3.magnitude(s.position);let h=e._rotateFactor*(d-e._rotateRateRangeAdjustment);h>e._maximumRotateRate&&(h=e._maximumRotateRate),h<e._minimumRotateRate&&(h=e._minimumRotateRate);let f=(n.startPosition.x-n.endPosition.x)/l.clientWidth,p=(n.startPosition.y-n.endPosition.y)/l.clientHeight;f=Math.min(f,e.maximumMovementRatio),p=Math.min(p,e.maximumMovementRatio);const u=h*f*Math.PI*2,m=h*p*Math.PI;r||s.rotateRight(u),o||s.rotateUp(m),s.constrainedAxis=c}const pan3DP0=Cartesian4.clone(Cartesian4.UNIT_W),pan3DP1=Cartesian4.clone(Cartesian4.UNIT_W),pan3DTemp0=new Cartesian3,pan3DTemp1=new Cartesian3,pan3DTemp2=new Cartesian3,pan3DTemp3=new Cartesian3,pan3DStartMousePosition=new Cartesian2,pan3DEndMousePosition=new Cartesian2,pan3DDiffMousePosition=new Cartesian2,pan3DPixelDimensions=new Cartesian2,panRay=new Ray;function pan3D(e,t,n,i){const r=e._scene,o=r.camera,a=Cartesian2.clone(n.startPosition,pan3DStartMousePosition),s=Cartesian2.clone(n.endPosition,pan3DEndMousePosition),l=i.cartesianToCartographic(o.positionWC,scratchCartographic).height;let c,d;if(!n.inertiaEnabled&&l<e._minimumPickingTerrainHeight&&(c=Cartesian3.clone(e._panLastWorldPosition,pan3DP0),!defined(e._globe)&&!Cartesian2.equalsEpsilon(a,e._panLastMousePosition)&&(c=pickPosition(e,a,pan3DP0)),!defined(e._globe)&&defined(c))){const h=Cartesian3.subtract(c,o.positionWC,pan3DTemp1),f=Cartesian3.multiplyByScalar(o.directionWC,Cartesian3.dot(o.directionWC,h),pan3DTemp1),p=Cartesian3.magnitude(f),u=o.frustum.getPixelDimensions(r.drawingBufferWidth,r.drawingBufferHeight,p,r.pixelRatio,pan3DPixelDimensions),m=Cartesian2.subtract(s,a,pan3DDiffMousePosition),g=Cartesian3.multiplyByScalar(o.rightWC,m.x*u.x,pan3DTemp1),_=Cartesian3.normalize(o.positionWC,scratchCameraPositionNormal),C=o.getPickRay(s,panRay).direction,A=Cartesian3.subtract(C,Cartesian3.projectVector(C,o.rightWC,pan3DTemp2),pan3DTemp2),S=Cartesian3.angleBetween(A,o.directionWC);let v=1;defined(o.frustum.fov)&&(v=Math.max(Math.tan(S),.1));let b=Math.abs(Cartesian3.dot(o.directionWC,_));const D=-m.y*u.y*2/Math.sqrt(v)*(1-b),I=Cartesian3.multiplyByScalar(C,D,pan3DTemp2);b=Math.abs(Cartesian3.dot(o.upWC,_));const L=Cartesian3.multiplyByScalar(o.upWC,-m.y*(1-b)*u.y,pan3DTemp3);d=Cartesian3.add(c,g,pan3DP1),d=Cartesian3.add(d,I,d),d=Cartesian3.add(d,L,d),Cartesian3.clone(d,e._panLastWorldPosition),Cartesian2.clone(s,e._panLastMousePosition)}if((!defined(c)||!defined(d))&&(c=o.pickEllipsoid(a,i,pan3DP0),d=o.pickEllipsoid(s,i,pan3DP1)),!defined(c)||!defined(d)){e._rotating=!0,rotate3D(e,t,n);return}if(c=o.worldToCameraCoordinates(c,c),d=o.worldToCameraCoordinates(d,d),defined(o.constrainedAxis)){const h=o.constrainedAxis,f=Cartesian3.mostOrthogonalAxis(h,pan3DTemp0);Cartesian3.cross(f,h,f),Cartesian3.normalize(f,f);const p=Cartesian3.cross(h,f,pan3DTemp1),u=Cartesian3.magnitude(c),m=Cartesian3.dot(h,c),g=Math.acos(m/u),_=Cartesian3.multiplyByScalar(h,m,pan3DTemp2);Cartesian3.subtract(c,_,_),Cartesian3.normalize(_,_);const C=Cartesian3.magnitude(d),A=Cartesian3.dot(h,d),S=Math.acos(A/C),v=Cartesian3.multiplyByScalar(h,A,pan3DTemp3);Cartesian3.subtract(d,v,v),Cartesian3.normalize(v,v);let b=Math.acos(Cartesian3.dot(_,f));Cartesian3.dot(_,p)<0&&(b=CesiumMath.TWO_PI-b);let D=Math.acos(Cartesian3.dot(v,f));Cartesian3.dot(v,p)<0&&(D=CesiumMath.TWO_PI-D);const I=b-D;let L;Cartesian3.equalsEpsilon(h,o.position,CesiumMath.EPSILON2)?L=o.right:L=Cartesian3.cross(h,o.position,pan3DTemp0);const N=Cartesian3.cross(h,L,pan3DTemp0),y=Cartesian3.dot(N,Cartesian3.subtract(c,h,pan3DTemp1)),x=Cartesian3.dot(N,Cartesian3.subtract(d,h,pan3DTemp1));let T;y>0&&x>0?T=S-g:y>0&&x<=0?Cartesian3.dot(o.position,h)>0?T=-g-S:T=g+S:T=g-S,o.rotateRight(I),o.rotateUp(T)}else{Cartesian3.normalize(c,c),Cartesian3.normalize(d,d);const h=Cartesian3.dot(c,d),f=Cartesian3.cross(c,d,pan3DTemp0);if(h<1&&!Cartesian3.equalsEpsilon(f,Cartesian3.ZERO,CesiumMath.EPSILON14)){const p=Math.acos(h);o.rotate(f,p)}}}const zoom3DUnitPosition=new Cartesian3,zoom3DCartographic=new Cartographic;let preIntersectionDistance=0;function zoom3D(e,t,n){defined(n.distance)&&(n=n.distance);const i=n.inertiaEnabled,r=e._ellipsoid,o=e._scene,a=o.camera,s=o.canvas,l=e._cameraUnderground;let c;l?c=t:(c=zoomCVWindowPos,c.x=s.clientWidth/2,c.y=s.clientHeight/2);const d=a.getPickRay(c,zoomCVWindowRay);let h;const f=r.cartesianToCartographic(a.position,zoom3DCartographic).height,p=Math.abs(preIntersectionDistance)<e.minimumPickingTerrainDistanceWithInertia;(i?p:f<e._minimumPickingTerrainHeight)&&(h=pickPosition(e,c,zoomCVIntersection));let m;if(defined(h)&&(m=Cartesian3.distance(d.origin,h),preIntersectionDistance=m),l){const _=getZoomDistanceUnderground(e,d);defined(m)?m=Math.min(m,_):m=_}defined(m)||(m=f);const g=Cartesian3.normalize(a.position,zoom3DUnitPosition);handleZoom(e,t,n,e._zoomFactor,m,Cartesian3.dot(g,a.direction))}const tilt3DWindowPos=new Cartesian2,tilt3DRay=new Ray,tilt3DCenter=new Cartesian3,tilt3DVerticalCenter=new Cartesian3,tilt3DTransform=new Matrix4,tilt3DVerticalTransform=new Matrix4,tilt3DOldTransform=new Matrix4,tilt3DQuaternion=new Quaternion,tilt3DMatrix=new Matrix3,tilt3DCart=new Cartographic,tilt3DLookUp=new Cartesian3;function tilt3D(e,t,n){const r=e._scene.camera;if(!Matrix4.equals(r.transform,Matrix4.IDENTITY))return;if(defined(n.angleAndHeight)&&(n=n.angleAndHeight),Cartesian2.equals(t,e._tiltCenterMousePosition)||(e._tiltOnEllipsoid=!1,e._looking=!1),e._looking){const s=e._ellipsoid.geodeticSurfaceNormal(r.position,tilt3DLookUp);look3D(e,t,n,s);return}const a=e._ellipsoid.cartesianToCartographic(r.position,tilt3DCart);e._tiltOnEllipsoid||a.height>e._minimumCollisionTerrainHeight?(e._tiltOnEllipsoid=!0,tilt3DOnEllipsoid(e,t,n)):tilt3DOnTerrain(e,t,n)}const tilt3DOnEllipsoidCartographic=new Cartographic;function tilt3DOnEllipsoid(e,t,n){const i=e._ellipsoid,r=e._scene,o=r.camera,a=e.minimumZoomDistance*.25,s=i.cartesianToCartographic(o.positionWC,tilt3DOnEllipsoidCartographic).height;if(s-a-1<CesiumMath.EPSILON3&&n.endPosition.y-n.startPosition.y<0)return;const l=r.canvas,c=tilt3DWindowPos;c.x=l.clientWidth/2,c.y=l.clientHeight/2;const d=o.getPickRay(c,tilt3DRay);let h;const f=IntersectionTests.rayEllipsoid(d,i);if(defined(f))h=Ray.getPoint(d,f.start,tilt3DCenter);else if(s>e._minimumTrackBallHeight){const C=IntersectionTests.grazingAltitudeLocation(d,i);if(!defined(C))return;const A=i.cartesianToCartographic(C,tilt3DCart);A.height=0,h=i.cartographicToCartesian(A,tilt3DCenter)}else{e._looking=!0;const C=e._ellipsoid.geodeticSurfaceNormal(o.position,tilt3DLookUp);look3D(e,t,n,C),Cartesian2.clone(t,e._tiltCenterMousePosition);return}const p=Transforms.eastNorthUpToFixedFrame(h,i,tilt3DTransform),u=e._globe,m=e._ellipsoid;e._globe=void 0,e._ellipsoid=Ellipsoid.UNIT_SPHERE,e._rotateFactor=1,e._rotateRateRangeAdjustment=1;const g=Matrix4.clone(o.transform,tilt3DOldTransform);o._setTransform(p),rotate3D(e,t,n,Cartesian3.UNIT_Z),o._setTransform(g),e._globe=u,e._ellipsoid=m;const _=m.maximumRadius;e._rotateFactor=1/_,e._rotateRateRangeAdjustment=_}function tilt3DOnTerrain(e,t,n){const i=e._ellipsoid,r=e._scene,o=r.camera,a=e._cameraUnderground;let s,l,c;if(Cartesian2.equals(t,e._tiltCenterMousePosition))s=Cartesian3.clone(e._tiltCenter,tilt3DCenter);else{if(s=pickPosition(e,t,tilt3DCenter),!defined(s)){if(l=o.getPickRay(t,tilt3DRay),c=IntersectionTests.rayEllipsoid(l,i),!defined(c)){if(i.cartesianToCartographic(o.position,tilt3DCart).height<=e._minimumTrackBallHeight){e._looking=!0;const x=e._ellipsoid.geodeticSurfaceNormal(o.position,tilt3DLookUp);look3D(e,t,n,x),Cartesian2.clone(t,e._tiltCenterMousePosition)}return}s=Ray.getPoint(l,c.start,tilt3DCenter)}a&&(defined(l)||(l=o.getPickRay(t,tilt3DRay)),getTiltCenterUnderground(e,l,s,s)),Cartesian2.clone(t,e._tiltCenterMousePosition),Cartesian3.clone(s,e._tiltCenter)}const d=r.canvas,h=tilt3DWindowPos;h.x=d.clientWidth/2,h.y=e._tiltCenterMousePosition.y,l=o.getPickRay(h,tilt3DRay);const f=Cartesian3.magnitude(s),p=Cartesian3.fromElements(f,f,f,scratchRadii),u=Ellipsoid.fromCartesian3(p,scratchEllipsoid);if(c=IntersectionTests.rayEllipsoid(l,u),!defined(c))return;const m=Cartesian3.magnitude(l.origin)>f?c.start:c.stop,g=Ray.getPoint(l,m,tilt3DVerticalCenter),_=Transforms.eastNorthUpToFixedFrame(s,i,tilt3DTransform),C=Transforms.eastNorthUpToFixedFrame(g,u,tilt3DVerticalTransform),A=e._globe,S=e._ellipsoid;e._globe=void 0,e._ellipsoid=Ellipsoid.UNIT_SPHERE,e._rotateFactor=1,e._rotateRateRangeAdjustment=1;let v=Cartesian3.UNIT_Z;const b=Matrix4.clone(o.transform,tilt3DOldTransform);o._setTransform(C);const D=Cartesian3.cross(g,o.positionWC,tilt3DCartesian3);if(Cartesian3.dot(o.rightWC,D)<0){const y=n.startPosition.y-n.endPosition.y;(a&&y<0||!a&&y>0)&&(v=void 0);const x=o.constrainedAxis;o.constrainedAxis=void 0,rotate3D(e,t,n,v,!0,!1),o.constrainedAxis=x}else rotate3D(e,t,n,v,!0,!1);if(o._setTransform(_),rotate3D(e,t,n,v,!1,!0),defined(o.constrainedAxis)){const y=Cartesian3.cross(o.direction,o.constrainedAxis,tilt3DCartesian3);Cartesian3.equalsEpsilon(y,Cartesian3.ZERO,CesiumMath.EPSILON6)||(Cartesian3.dot(y,o.right)<0&&Cartesian3.negate(y,y),Cartesian3.cross(y,o.direction,o.up),Cartesian3.cross(o.direction,o.up,o.right),Cartesian3.normalize(o.up,o.up),Cartesian3.normalize(o.right,o.right))}o._setTransform(b),e._globe=A,e._ellipsoid=S;const L=S.maximumRadius;e._rotateFactor=1/L,e._rotateRateRangeAdjustment=L;const N=Cartesian3.clone(o.positionWC,tilt3DCartesian3);if(e.enableCollisionDetection&&adjustHeightForTerrain(e,!0),!Cartesian3.equals(o.positionWC,N)){o._setTransform(C),o.worldToCameraCoordinatesPoint(N,N);const y=Cartesian3.magnitudeSquared(N);Cartesian3.magnitudeSquared(o.position)>y&&(Cartesian3.normalize(o.position,o.position),Cartesian3.multiplyByScalar(o.position,Math.sqrt(y),o.position));const x=Cartesian3.angleBetween(N,o.position),T=Cartesian3.cross(N,o.position,N);Cartesian3.normalize(T,T);const E=Quaternion.fromAxisAngle(T,x,tilt3DQuaternion),P=Matrix3.fromQuaternion(E,tilt3DMatrix);Matrix3.multiplyByVector(P,o.direction,o.direction),Matrix3.multiplyByVector(P,o.up,o.up),Cartesian3.cross(o.direction,o.up,o.right),Cartesian3.cross(o.right,o.direction,o.up),o._setTransform(b)}}const look3DStartPos=new Cartesian2,look3DEndPos=new Cartesian2,look3DStartRay=new Ray,look3DEndRay=new Ray,look3DNegativeRot=new Cartesian3,look3DTan=new Cartesian3;function look3D(e,t,n,i){const o=e._scene.camera,a=look3DStartPos;a.x=n.startPosition.x,a.y=0;const s=look3DEndPos;s.x=n.endPosition.x,s.y=0;let l=o.getPickRay(a,look3DStartRay),c=o.getPickRay(s,look3DEndRay),d=0,h,f;o.frustum instanceof OrthographicFrustum?(h=l.origin,f=c.origin,Cartesian3.add(o.direction,h,h),Cartesian3.add(o.direction,f,f),Cartesian3.subtract(h,o.position,h),Cartesian3.subtract(f,o.position,f),Cartesian3.normalize(h,h),Cartesian3.normalize(f,f)):(h=l.direction,f=c.direction);let p=Cartesian3.dot(h,f);p<1&&(d=Math.acos(p)),d=n.startPosition.x>n.endPosition.x?-d:d;const u=e._horizontalRotationAxis;if(defined(i)?o.look(i,-d):defined(u)?o.look(u,-d):o.lookLeft(d),a.x=0,a.y=n.startPosition.y,s.x=0,s.y=n.endPosition.y,l=o.getPickRay(a,look3DStartRay),c=o.getPickRay(s,look3DEndRay),d=0,o.frustum instanceof OrthographicFrustum?(h=l.origin,f=c.origin,Cartesian3.add(o.direction,h,h),Cartesian3.add(o.direction,f,f),Cartesian3.subtract(h,o.position,h),Cartesian3.subtract(f,o.position,f),Cartesian3.normalize(h,h),Cartesian3.normalize(f,f)):(h=l.direction,f=c.direction),p=Cartesian3.dot(h,f),p<1&&(d=Math.acos(p)),d=n.startPosition.y>n.endPosition.y?-d:d,i=defaultValue(i,u),defined(i)){const m=o.direction,g=Cartesian3.negate(i,look3DNegativeRot),_=Cartesian3.equalsEpsilon(m,i,CesiumMath.EPSILON2),C=Cartesian3.equalsEpsilon(m,g,CesiumMath.EPSILON2);if(!_&&!C){p=Cartesian3.dot(m,i);let A=CesiumMath.acosClamped(p);d>0&&d>A&&(d=A-CesiumMath.EPSILON4),p=Cartesian3.dot(m,g),A=CesiumMath.acosClamped(p),d<0&&-d>A&&(d=-A+CesiumMath.EPSILON4);const S=Cartesian3.cross(i,m,look3DTan);o.look(S,d)}else(_&&d<0||C&&d>0)&&o.look(o.right,-d)}else o.lookUp(d)}function update3D(e){reactToInput(e,e.enableRotate,e.rotateEventTypes,spin3D,e.inertiaSpin,"_lastInertiaSpinMovement"),reactToInput(e,e.enableZoom,e.zoomEventTypes,zoom3D,e.inertiaZoom,"_lastInertiaZoomMovement"),reactToInput(e,e.enableTilt,e.tiltEventTypes,tilt3D,e.inertiaSpin,"_lastInertiaTiltMovement"),reactToInput(e,e.enableLook,e.lookEventTypes,look3D)}const scratchAdjustHeightTransform=new Matrix4,scratchAdjustHeightCartographic=new Cartographic;function adjustHeightForTerrain(e,t){e._adjustedHeightForTerrain=!0;const n=e._scene,i=n.mode;if(i===SceneMode.SCENE2D||i===SceneMode.MORPHING)return;const r=n.camera,o=defaultValue(n.ellipsoid,Ellipsoid.WGS84),a=n.mapProjection;let s,l;Matrix4.equals(r.transform,Matrix4.IDENTITY)||(s=Matrix4.clone(r.transform,scratchAdjustHeightTransform),l=Cartesian3.magnitude(r.position),r._setTransform(Matrix4.IDENTITY));const c=scratchAdjustHeightCartographic;i===SceneMode.SCENE3D?o.cartesianToCartographic(r.position,c):a.unproject(r.position,c);let d=!1;if(c.height<e._minimumCollisionTerrainHeight){const h=e._scene.globeHeight;if(defined(h)){const f=h+e.minimumZoomDistance,p=h-e._lastGlobeHeight,u=p/e._lastGlobeHeight;c.height<f&&(t||Math.abs(u)<=.1)&&(c.height=f,i===SceneMode.SCENE3D?o.cartographicToCartesian(c,r.position):a.project(c,r.position),d=!0),t||Math.abs(u)<=.1?e._lastGlobeHeight=h:e._lastGlobeHeight+=p*.1}}defined(s)&&(r._setTransform(s),d&&(Cartesian3.normalize(r.position,r.position),Cartesian3.negate(r.position,r.direction),Cartesian3.multiplyByScalar(r.position,Math.max(l,e.minimumZoomDistance),r.position),Cartesian3.normalize(r.direction,r.direction),Cartesian3.cross(r.direction,r.up,r.right),Cartesian3.cross(r.right,r.direction,r.up)))}ScreenSpaceCameraController.prototype.onMap=function(){const e=this._scene,t=e.mode,n=e.camera;return t===SceneMode.COLUMBUS_VIEW?Math.abs(n.position.x)-this._maxCoord.x<0&&Math.abs(n.position.y)-this._maxCoord.y<0:!0};const scratchPreviousPosition=new Cartesian3,scratchPreviousDirection=new Cartesian3;ScreenSpaceCameraController.prototype.update=function(){const e=this._scene,{camera:t,globe:n,mode:i}=e;Matrix4.equals(t.transform,Matrix4.IDENTITY)?(this._globe=n,this._ellipsoid=defaultValue(e.ellipsoid,Ellipsoid.default)):(this._globe=void 0,this._ellipsoid=Ellipsoid.UNIT_SPHERE);const{verticalExaggeration:r,verticalExaggerationRelativeHeight:o}=e;this._minimumCollisionTerrainHeight=VerticalExaggeration.getHeight(this.minimumCollisionTerrainHeight,r,o),this._minimumPickingTerrainHeight=VerticalExaggeration.getHeight(this.minimumPickingTerrainHeight,r,o),this._minimumTrackBallHeight=VerticalExaggeration.getHeight(this.minimumTrackBallHeight,r,o),this._cameraUnderground=e.cameraUnderground&&defined(this._globe);const a=this._ellipsoid.maximumRadius;this._rotateFactor=1/a,this._rotateRateRangeAdjustment=a,this._adjustedHeightForTerrain=!1;const s=Cartesian3.clone(t.positionWC,scratchPreviousPosition),l=Cartesian3.clone(t.directionWC,scratchPreviousDirection);if(i===SceneMode.SCENE2D?update2D(this):i===SceneMode.COLUMBUS_VIEW?(this._horizontalRotationAxis=Cartesian3.UNIT_Z,updateCV(this)):i===SceneMode.SCENE3D&&(this._horizontalRotationAxis=void 0,update3D(this)),this.enableCollisionDetection&&!this._adjustedHeightForTerrain){const c=!Cartesian3.equals(s,t.positionWC)||!Cartesian3.equals(l,t.directionWC);adjustHeightForTerrain(this,c)}this._aggregator.reset()};ScreenSpaceCameraController.prototype.isDestroyed=function(){return!1};ScreenSpaceCameraController.prototype.destroy=function(){return this._tweens.removeAll(),this._aggregator=this._aggregator&&this._aggregator.destroy(),destroyObject(this)};const AdditiveBlend=`uniform sampler2D colorTexture;
uniform sampler2D colorTexture2;

uniform vec2 center;
uniform float radius;

in vec2 v_textureCoordinates;

void main()
{
    vec4 color0 = texture(colorTexture, v_textureCoordinates);
    vec4 color1 = texture(colorTexture2, v_textureCoordinates);

    float x = length(gl_FragCoord.xy - center) / radius;
    float t = smoothstep(0.5, 0.8, x);
    out_FragColor = mix(color0 + color1, color1, t);
}
`,BrightPass=`uniform sampler2D colorTexture;

uniform float avgLuminance;
uniform float threshold;
uniform float offset;

in vec2 v_textureCoordinates;

float key(float avg)
{
    float guess = 1.5 - (1.5 / (avg * 0.1 + 1.0));
    return max(0.0, guess) + 0.1;
}

// See section 9. "The bright-pass filter" of Realtime HDR Rendering
// http://www.cg.tuwien.ac.at/research/publications/2007/Luksch_2007_RHR/Luksch_2007_RHR-RealtimeHDR%20.pdf

void main()
{
    vec4 color = texture(colorTexture, v_textureCoordinates);
    vec3 xyz = czm_RGBToXYZ(color.rgb);
    float luminance = xyz.r;

    float scaledLum = key(avgLuminance) * luminance / avgLuminance;
    float brightLum = max(scaledLum - threshold, 0.0);
    float brightness = brightLum / (offset + brightLum);

    xyz.r = brightness;
    out_FragColor = vec4(czm_XYZToRGB(xyz), 1.0);
}
`;function SunPostProcess(){this._sceneFramebuffer=new SceneFramebuffer;const e=.125,t=new Array(6);t[0]=new PostProcessStage({fragmentShader:PassThrough,textureScale:e,forcePowerOfTwo:!0,sampleMode:PostProcessStageSampleMode$1.LINEAR});const n=t[1]=new PostProcessStage({fragmentShader:BrightPass,uniforms:{avgLuminance:.5,threshold:.25,offset:.1},textureScale:e,forcePowerOfTwo:!0}),i=this;this._delta=1,this._sigma=2,this._blurStep=new Cartesian2,t[2]=new PostProcessStage({fragmentShader:GaussianBlur1D,uniforms:{step:function(){return i._blurStep.x=i._blurStep.y=1/n.outputTexture.width,i._blurStep},delta:function(){return i._delta},sigma:function(){return i._sigma},direction:0},textureScale:e,forcePowerOfTwo:!0}),t[3]=new PostProcessStage({fragmentShader:GaussianBlur1D,uniforms:{step:function(){return i._blurStep.x=i._blurStep.y=1/n.outputTexture.width,i._blurStep},delta:function(){return i._delta},sigma:function(){return i._sigma},direction:1},textureScale:e,forcePowerOfTwo:!0}),t[4]=new PostProcessStage({fragmentShader:PassThrough,sampleMode:PostProcessStageSampleMode$1.LINEAR}),this._uCenter=new Cartesian2,this._uRadius=void 0,t[5]=new PostProcessStage({fragmentShader:AdditiveBlend,uniforms:{center:function(){return i._uCenter},radius:function(){return i._uRadius},colorTexture2:function(){return i._sceneFramebuffer.framebuffer.getColorTexture(0)}}}),this._stages=new PostProcessStageComposite({stages:t});const r=new PostProcessStageTextureCache(this),o=t.length;for(let a=0;a<o;++a)t[a]._textureCache=r;this._textureCache=r,this.length=t.length}SunPostProcess.prototype.get=function(e){return this._stages.get(e)};SunPostProcess.prototype.getStageByName=function(e){const t=this._stages.length;for(let n=0;n<t;++n){const i=this._stages.get(n);if(i.name===e)return i}};const sunPositionECScratch=new Cartesian4,sunPositionWCScratch=new Cartesian2,sizeScratch=new Cartesian2,postProcessMatrix4Scratch=new Matrix4;function updateSunPosition(e,t,n){const i=t.uniformState,r=i.sunPositionWC,o=i.view,a=i.viewProjection,s=i.projection;let l=Matrix4.computeViewportTransformation(n,0,1,postProcessMatrix4Scratch);const c=Matrix4.multiplyByPoint(o,r,sunPositionECScratch);let d=Transforms.pointToGLWindowCoordinates(a,l,r,sunPositionWCScratch);c.x+=CesiumMath.SOLAR_RADIUS;const h=Transforms.pointToGLWindowCoordinates(s,l,c,c),f=Cartesian2.magnitude(Cartesian2.subtract(h,d,h))*30*2,p=sizeScratch;p.x=f,p.y=f,e._uCenter=Cartesian2.clone(d,e._uCenter),e._uRadius=Math.max(p.x,p.y)*.15;const u=t.drawingBufferWidth,m=t.drawingBufferHeight,g=e._stages,_=g.get(0),C=_.outputTexture.width,A=_.outputTexture.height,S=new BoundingRectangle;S.width=C,S.height=A,l=Matrix4.computeViewportTransformation(S,0,1,postProcessMatrix4Scratch),d=Transforms.pointToGLWindowCoordinates(a,l,r,sunPositionWCScratch),p.x*=C/u,p.y*=A/m;const v=_.scissorRectangle;v.x=Math.max(d.x-p.x*.5,0),v.y=Math.max(d.y-p.y*.5,0),v.width=Math.min(p.x,u),v.height=Math.min(p.y,m);for(let b=1;b<4;++b)BoundingRectangle.clone(v,g.get(b).scissorRectangle)}SunPostProcess.prototype.clear=function(e,t,n){this._sceneFramebuffer.clear(e,t,n),this._textureCache.clear(e)};SunPostProcess.prototype.update=function(e){const t=e.context,n=e.viewport,i=this._sceneFramebuffer;i.update(t,n);const r=i.framebuffer;return this._textureCache.update(t),this._stages.update(t,!1),updateSunPosition(this,t,n),r};SunPostProcess.prototype.execute=function(e){const t=this._sceneFramebuffer.framebuffer.getColorTexture(0),n=this._stages,i=n.length;n.get(0).execute(e,t);for(let r=1;r<i;++r)n.get(r).execute(e,n.get(r-1).outputTexture)};SunPostProcess.prototype.copy=function(e,t){if(!defined(this._copyColorCommand)){const n=this;this._copyColorCommand=e.createViewportQuadCommand(PassThrough,{uniformMap:{colorTexture:function(){return n._stages.get(n._stages.length-1).outputTexture}},owner:this})}this._copyColorCommand.framebuffer=t,this._copyColorCommand.execute(e)};SunPostProcess.prototype.isDestroyed=function(){return!1};SunPostProcess.prototype.destroy=function(){return this._textureCache.destroy(),this._stages.destroy(),destroyObject(this)};function DebugInspector(){this._cachedShowFrustumsShaders={}}function getAttributeLocations(e){const t={},n=e.vertexAttributes;for(const i in n)n.hasOwnProperty(i)&&(t[i]=n[i].index);return t}function createDebugShowFrustumsShaderProgram(e,t){const n=e.context,i=t,r=i.fragmentShaderSource.clone(),o=[];r.sources=r.sources.map(function(d){d=ShaderSource.replaceMain(d,"czm_Debug_main");const h=/out_FragData_(\d+)/g;let f;for(;(f=h.exec(d))!==null;)o.indexOf(f[1])===-1&&o.push(f[1]);return d});const a=o.length;let s="";s+=`uniform vec3 debugShowCommandsColor;
`,s+=`uniform vec3 debugShowFrustumsColor;
`,s+=`void main() 
{ 
    czm_Debug_main(); 
`;let l;if(a>0)for(l=0;l<a;++l)s+=`    out_FragData_${o[l]}.rgb *= debugShowCommandsColor;
`,s+=`    out_FragData_${o[l]}.rgb *= debugShowFrustumsColor;
`;else s+=`    out_FragColor.rgb *= debugShowCommandsColor;
`,s+=`    out_FragColor.rgb *= debugShowFrustumsColor;
`;s+="}",r.sources.push(s);const c=getAttributeLocations(i);return ShaderProgram.fromCache({context:n,vertexShaderSource:i.vertexShaderSource,fragmentShaderSource:r,attributeLocations:c})}const scratchFrustumColor=new Color;function createDebugShowFrustumsUniformMap(e,t){let n;return defined(t.uniformMap)?n=t.uniformMap:n={},defined(n.debugShowCommandsColor)||defined(n.debugShowFrustumsColor)||(n.debugShowCommandsColor=function(){return e.debugShowCommands?(defined(t._debugColor)||(t._debugColor=Color.fromRandom()),t._debugColor):Color.WHITE},n.debugShowFrustumsColor=function(){return e.debugShowFrustums?(scratchFrustumColor.red=t.debugOverlappingFrustums&1?1:0,scratchFrustumColor.green=t.debugOverlappingFrustums&2?1:0,scratchFrustumColor.blue=t.debugOverlappingFrustums&4?1:0,scratchFrustumColor.alpha=1,scratchFrustumColor):Color.WHITE}),n}const scratchShowFrustumCommand=new DrawCommand;DebugInspector.prototype.executeDebugShowFrustumsCommand=function(e,t,n){const i=t.shaderProgram.id;let r=this._cachedShowFrustumsShaders[i];defined(r)||(r=createDebugShowFrustumsShaderProgram(e,t.shaderProgram),this._cachedShowFrustumsShaders[i]=r);const o=DrawCommand.shallowClone(t,scratchShowFrustumCommand);o.shaderProgram=r,o.uniformMap=createDebugShowFrustumsUniformMap(e,t),o.execute(e.context,n)};function VoxelCell(e,t,n){this._primitive=e,this._tileIndex=t,this._sampleIndex=n,this._metadata={},this._orientedBoundingBox=new OrientedBoundingBox}VoxelCell.fromKeyframeNode=function(e,t,n,i){Check.typeOf.object("primitive",e),Check.typeOf.number("tileIndex",t),Check.typeOf.number("sampleIndex",n),Check.typeOf.object("keyframeNode",i);const r=new VoxelCell(e,t,n),{spatialNode:o,metadata:a}=i;return r._metadata=getMetadataForSample(e,a,n),r._orientedBoundingBox=getOrientedBoundingBox(e,o,n,r._orientedBoundingBox),r};function getMetadataForSample(e,t,n){if(!defined(t))return;const{names:i,types:r}=e.provider,o={};for(let a=0;a<i.length;a++){const s=i[a],l=MetadataType.getComponentCount(r[a]),c=t[a].slice(n*l,(n+1)*l);o[s]=c}return o}const tileCoordinateScratch=new Cartesian3,tileUvScratch=new Cartesian3;function getOrientedBoundingBox(e,t,n,i){const r=t.dimensions,o=r.x*r.y,a=Math.floor(n/o),s=n-a*o,l=Math.floor(s/r.x),c=s-l*r.x,d=Cartesian3.fromElements(c,l,a,tileCoordinateScratch),h=Cartesian3.divideComponents(Cartesian3.subtract(d,e._paddingBefore,tileCoordinateScratch),e.dimensions,tileUvScratch);return e._shape.computeOrientedBoundingBoxForSample(t,e.dimensions,h,i)}Object.defineProperties(VoxelCell.prototype,{metadata:{get:function(){return this._metadata}},primitive:{get:function(){return this._primitive}},sampleIndex:{get:function(){return this._sampleIndex}},tileIndex:{get:function(){return this._tileIndex}},orientedBoundingBox:{get:function(){return this._orientedBoundingBox.clone()}}});VoxelCell.prototype.hasProperty=function(e){return defined(this._metadata[e])};VoxelCell.prototype.getNames=function(){return Object.keys(this._metadata)};VoxelCell.prototype.getProperty=function(e){return this._metadata[e]};const VoxelUtils=`struct Ray {
    vec3 pos;
    vec3 dir;
    vec3 rawDir;
};

#if defined(JITTER)
/**
 * Generate a pseudo-random value for a given 2D screen coordinate.
 * Similar to https://www.shadertoy.com/view/4djSRW with a modified hashscale.
 */
float hash(vec2 p)
{
    vec3 p3 = fract(vec3(p.xyx) * 50.0);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.x + p3.y) * p3.z);
}
#endif

float minComponent(in vec3 v) {
    return min(min(v.x, v.y), v.z);
}

float maxComponent(in vec3 v) {
    return max(max(v.x, v.y), v.z);
}

struct PointJacobianT {
    vec3 point;
    mat3 jacobianT;
};
`,VoxelFS=`// See Intersection.glsl for the definition of intersectScene
// See IntersectionUtils.glsl for the definition of nextIntersection
// See convertUvToBox.glsl, convertUvToCylinder.glsl, or convertUvToEllipsoid.glsl
// for the definition of convertUvToShapeUvSpace. The appropriate function is 
// selected based on the VoxelPrimitive shape type, and added to the shader in
// Scene/VoxelRenderResources.js.
// See Octree.glsl for the definitions of TraversalData, SampleData,
// traverseOctreeFromBeginning, and traverseOctreeFromExisting
// See Megatexture.glsl for the definition of accumulatePropertiesFromMegatexture

#define STEP_COUNT_MAX 1000 // Harcoded value because GLSL doesn't like variable length loops
#if defined(PICKING_VOXEL)
    #define ALPHA_ACCUM_MAX 0.1
#else
    #define ALPHA_ACCUM_MAX 0.98 // Must be > 0.0 and <= 1.0
#endif

uniform mat3 u_transformDirectionViewToLocal;
uniform vec3 u_cameraPositionUv;
uniform float u_stepSize;

#if defined(PICKING)
    uniform vec4 u_pickColor;
#endif

vec3 getSampleSize(in int level) {
    vec3 sampleCount = exp2(float(level)) * vec3(u_dimensions);
    vec3 sampleSizeUv = 1.0 / sampleCount;
    return scaleShapeUvToShapeSpace(sampleSizeUv);
}

#define MINIMUM_STEP_SCALAR (0.02)
#define SHIFT_FRACTION (0.001)

/**
 * Given a coordinate within a tile, and sample spacings along a ray through
 * the coordinate, find the distance to the points where the ray entered and
 * exited the voxel cell, along with the surface normals at those points.
 * The surface normals are returned in shape space coordinates.
 */
RayShapeIntersection getVoxelIntersection(in vec3 tileUv, in vec3 sampleSizeAlongRay) {
    vec3 voxelCoord = tileUv * vec3(u_dimensions);
    vec3 directions = sign(sampleSizeAlongRay);
    vec3 positiveDirections = max(directions, 0.0);
    vec3 entryCoord = mix(ceil(voxelCoord), floor(voxelCoord), positiveDirections);
    vec3 exitCoord = entryCoord + directions;

    vec3 distanceFromEntry = -abs((entryCoord - voxelCoord) * sampleSizeAlongRay);
    float lastEntry = maxComponent(distanceFromEntry);
    bvec3 isLastEntry = equal(distanceFromEntry, vec3(lastEntry));
    vec3 entryNormal = -1.0 * vec3(isLastEntry) * directions;
    vec4 entry = vec4(entryNormal, lastEntry);

    vec3 distanceToExit = abs((exitCoord - voxelCoord) * sampleSizeAlongRay);
    float firstExit = minComponent(distanceToExit);
    bvec3 isFirstExit = equal(distanceToExit, vec3(firstExit));
    vec3 exitNormal = vec3(isFirstExit) * directions;
    vec4 exit = vec4(exitNormal, firstExit);

    return RayShapeIntersection(entry, exit);
}

vec4 getStepSize(in SampleData sampleData, in Ray viewRay, in RayShapeIntersection shapeIntersection, in mat3 jacobianT, in float currentT) {
    // The Jacobian is computed in a space where the shape spans [-1, 1].
    // But the ray is marched in a space where the shape fills [0, 1].
    // So we need to scale the Jacobian by 2.
    vec3 gradient = 2.0 * viewRay.rawDir * jacobianT;
    vec3 sampleSizeAlongRay = getSampleSize(sampleData.tileCoords.w) / gradient;

    RayShapeIntersection voxelIntersection = getVoxelIntersection(sampleData.tileUv, sampleSizeAlongRay);

    // Transform normal from shape space to Cartesian space
    vec3 voxelNormal = normalize(jacobianT * voxelIntersection.entry.xyz);
    // Compare with the shape intersection, to choose the appropriate normal
    vec4 voxelEntry = vec4(voxelNormal, currentT + voxelIntersection.entry.w);
    vec4 entry = intersectionMax(shapeIntersection.entry, voxelEntry);

    float fixedStep = minComponent(abs(sampleSizeAlongRay)) * u_stepSize;
    float shift = fixedStep * SHIFT_FRACTION;
    float dt = voxelIntersection.exit.w + shift;
    if ((currentT + dt) > shapeIntersection.exit.w) {
        // Stop at end of shape
        dt = shapeIntersection.exit.w - currentT + shift;
    }
    float stepSize = clamp(dt, fixedStep * MINIMUM_STEP_SCALAR, fixedStep + shift);

    return vec4(entry.xyz, stepSize);
}

vec2 packIntToVec2(int value) {
    float shifted = float(value) / 255.0;
    float lowBits = fract(shifted);
    float highBits = floor(shifted) / 255.0;
    return vec2(highBits, lowBits);
}

vec2 packFloatToVec2(float value) {
    float lowBits = fract(value);
    float highBits = floor(value) / 255.0;
    return vec2(highBits, lowBits);
}

int getSampleIndex(in vec3 tileUv) {
    ivec3 voxelDimensions = u_dimensions;
    vec3 sampleCoordinate = tileUv * vec3(voxelDimensions);
    // tileUv = 1.0 is a valid coordinate but sampleIndex = voxelDimensions is not.
    // (tileUv = 1.0 corresponds to the last sample, at index = voxelDimensions - 1).
    // Clamp to [0, voxelDimensions - 0.5) to avoid numerical error before flooring
    vec3 maxCoordinate = vec3(voxelDimensions) - vec3(0.5);
    sampleCoordinate = clamp(sampleCoordinate, vec3(0.0), maxCoordinate);
    ivec3 sampleIndex = ivec3(floor(sampleCoordinate));
    #if defined(PADDING)
        voxelDimensions += u_paddingBefore + u_paddingAfter;
        sampleIndex += u_paddingBefore;
    #endif
    // Convert to a 1D index for lookup in a 1D data array
    return sampleIndex.x + voxelDimensions.x * (sampleIndex.y + voxelDimensions.y * sampleIndex.z);
}

void main()
{
    vec4 fragCoord = gl_FragCoord;
    vec2 screenCoord = (fragCoord.xy - czm_viewport.xy) / czm_viewport.zw; // [0,1]
    vec3 eyeDirection = normalize(czm_windowToEyeCoordinates(fragCoord).xyz);
    vec3 viewDirWorld = normalize(czm_inverseViewRotation * eyeDirection); // normalize again just in case
    vec3 viewDirUv = normalize(u_transformDirectionViewToLocal * eyeDirection); // normalize again just in case
    vec3 viewPosUv = u_cameraPositionUv;
    #if defined(SHAPE_ELLIPSOID)
        // viewDirUv has been scaled to a space where the ellipsoid is a sphere.
        // Undo this scaling to get the raw direction.
        vec3 rawDir = viewDirUv * u_ellipsoidRadiiUv;
        Ray viewRayUv = Ray(viewPosUv, viewDirUv, rawDir);
    #else
        Ray viewRayUv = Ray(viewPosUv, viewDirUv, viewDirUv);
    #endif

    Intersections ix;
    RayShapeIntersection shapeIntersection = intersectScene(screenCoord, viewRayUv, ix);

    // Exit early if the scene was completely missed.
    if (shapeIntersection.entry.w == NO_HIT) {
        discard;
    }

    float currentT = shapeIntersection.entry.w;
    float endT = shapeIntersection.exit.w;
    vec3 positionUv = viewPosUv + currentT * viewDirUv;
    PointJacobianT pointJacobian = convertUvToShapeUvSpaceDerivative(positionUv);

    // Traverse the tree from the start position
    TraversalData traversalData;
    SampleData sampleDatas[SAMPLE_COUNT];
    traverseOctreeFromBeginning(pointJacobian.point, traversalData, sampleDatas);
    vec4 step = getStepSize(sampleDatas[0], viewRayUv, shapeIntersection, pointJacobian.jacobianT, currentT);

    #if defined(JITTER)
        float noise = hash(screenCoord); // [0,1]
        currentT += noise * step.w;
        positionUv += noise * step.w * viewDirUv;
    #endif

    FragmentInput fragmentInput;
    #if defined(STATISTICS)
        setStatistics(fragmentInput.metadata.statistics);
    #endif

    vec4 colorAccum = vec4(0.0);

    for (int stepCount = 0; stepCount < STEP_COUNT_MAX; ++stepCount) {
        // Read properties from the megatexture based on the traversal state
        Properties properties = accumulatePropertiesFromMegatexture(sampleDatas);

        // Prepare the custom shader inputs
        copyPropertiesToMetadata(properties, fragmentInput.metadata);
        fragmentInput.voxel.positionUv = positionUv;
        fragmentInput.voxel.positionShapeUv = pointJacobian.point;
        fragmentInput.voxel.positionUvLocal = sampleDatas[0].tileUv;
        fragmentInput.voxel.viewDirUv = viewDirUv;
        fragmentInput.voxel.viewDirWorld = viewDirWorld;
        fragmentInput.voxel.surfaceNormal = step.xyz;
        fragmentInput.voxel.travelDistance = step.w;
        fragmentInput.voxel.stepCount = stepCount;
        fragmentInput.voxel.tileIndex = sampleDatas[0].megatextureIndex;
        fragmentInput.voxel.sampleIndex = getSampleIndex(sampleDatas[0].tileUv);

        // Run the custom shader
        czm_modelMaterial materialOutput;
        fragmentMain(fragmentInput, materialOutput);

        // Sanitize the custom shader output
        vec4 color = vec4(materialOutput.diffuse, materialOutput.alpha);
        color.rgb = max(color.rgb, vec3(0.0));
        color.a = clamp(color.a, 0.0, 1.0);

        // Pre-multiplied alpha blend
        colorAccum += (1.0 - colorAccum.a) * vec4(color.rgb * color.a, color.a);

        // Stop traversing if the alpha has been fully saturated
        if (colorAccum.a > ALPHA_ACCUM_MAX) {
            colorAccum.a = ALPHA_ACCUM_MAX;
            break;
        }

        if (step.w == 0.0) {
            // Shape is infinitely thin. The ray may have hit the edge of a
            // foreground voxel. Step ahead slightly to check for more voxels
            step.w == 0.00001;
        }

        // Keep raymarching
        currentT += step.w;
        positionUv = viewPosUv + currentT * viewDirUv;

        // Check if there's more intersections.
        if (currentT > endT) {
            #if (INTERSECTION_COUNT == 1)
                break;
            #else
                shapeIntersection = nextIntersection(ix);
                if (shapeIntersection.entry.w == NO_HIT) {
                    break;
                } else {
                    // Found another intersection. Resume raymarching there
                    currentT = shapeIntersection.entry.w;
                    endT = shapeIntersection.exit.w;
                    positionUv = viewPosUv + currentT * viewDirUv;
                }
            #endif
        }

        // Traverse the tree from the current ray position.
        // This is similar to traverseOctreeFromBeginning but is faster when the ray is in the same tile as the previous step.
        pointJacobian = convertUvToShapeUvSpaceDerivative(positionUv);
        traverseOctreeFromExisting(pointJacobian.point, traversalData, sampleDatas);
        step = getStepSize(sampleDatas[0], viewRayUv, shapeIntersection, pointJacobian.jacobianT, currentT);
    }

    // Convert the alpha from [0,ALPHA_ACCUM_MAX] to [0,1]
    colorAccum.a /= ALPHA_ACCUM_MAX;

    #if defined(PICKING)
        // If alpha is 0.0 there is nothing to pick
        if (colorAccum.a == 0.0) {
            discard;
        }
        out_FragColor = u_pickColor;
    #elif defined(PICKING_VOXEL)
        // If alpha is 0.0 there is nothing to pick
        if (colorAccum.a == 0.0) {
            discard;
        }
        vec2 megatextureId = packIntToVec2(sampleDatas[0].megatextureIndex);
        vec2 sampleIndex = packIntToVec2(getSampleIndex(sampleDatas[0].tileUv));
        out_FragColor = vec4(megatextureId, sampleIndex);
    #else
        out_FragColor = colorAccum;
    #endif
}
`,VoxelVS=`in vec2 position;

uniform vec4 u_ndcSpaceAxisAlignedBoundingBox;

void main() {
    vec2 aabbMin = u_ndcSpaceAxisAlignedBoundingBox.xy;
    vec2 aabbMax = u_ndcSpaceAxisAlignedBoundingBox.zw;
    vec2 translation = 0.5 * (aabbMax + aabbMin);
    vec2 scale = 0.5 * (aabbMax - aabbMin);
    gl_Position = vec4(position * scale + translation, 0.0, 1.0);
}
`,IntersectionUtils=`/* Intersection defines
#define INTERSECTION_COUNT ###
*/

#define NO_HIT (-czm_infinity)
#define INF_HIT (czm_infinity * 0.5)

struct RayShapeIntersection {
    vec4 entry;
    vec4 exit;
};

vec4 intersectionMin(in vec4 intersect0, in vec4 intersect1)
{
    if (intersect0.w == NO_HIT) {
        return intersect1;
    } else if (intersect1.w == NO_HIT) {
        return intersect0;
    }
    return (intersect0.w <= intersect1.w) ? intersect0 : intersect1;
}

vec4 intersectionMax(in vec4 intersect0, in vec4 intersect1)
{
    return (intersect0.w >= intersect1.w) ? intersect0 : intersect1;
}

RayShapeIntersection intersectIntersections(in Ray ray, in RayShapeIntersection intersect0, in RayShapeIntersection intersect1)
{
    bool missed = (intersect0.entry.w == NO_HIT) ||
        (intersect1.entry.w == NO_HIT) ||
        (intersect0.exit.w < intersect1.entry.w) ||
        (intersect0.entry.w > intersect1.exit.w);
    if (missed) {
        vec4 miss = vec4(normalize(ray.dir), NO_HIT);
        return RayShapeIntersection(miss, miss);
    }

    vec4 entry = intersectionMax(intersect0.entry, intersect1.entry);
    vec4 exit = intersectionMin(intersect0.exit, intersect1.exit);

    return RayShapeIntersection(entry, exit);
}

struct Intersections {
    // Don't access these member variables directly - call the functions instead.

    // Store an array of ray-surface intersections. Each intersection is composed of:
    //  .xyz for the surface normal at the intersection point
    //  .w for the T value
    // The scale of the normal encodes the shape intersection type:
    //  length(intersection.xyz) = 1: positive shape entry
    //  length(intersection.xyz) = 2: positive shape exit
    //  length(intersection.xyz) = 3: negative shape entry
    //  length(intersection.xyz) = 4: negative shape exit
    // INTERSECTION_COUNT is the number of ray-*shape* (volume) intersections,
    // so we need twice as many to track ray-*surface* intersections
    vec4 intersections[INTERSECTION_COUNT * 2];

    #if (INTERSECTION_COUNT > 1)
        // Maintain state for future nextIntersection calls
        int index;
        int surroundCount;
        bool surroundIsPositive;
    #endif
};

RayShapeIntersection getFirstIntersection(in Intersections ix) 
{
    return RayShapeIntersection(ix.intersections[0], ix.intersections[1]);
}

vec4 encodeIntersectionType(vec4 intersection, int index, bool entry)
{
    float scale = float(index > 0) * 2.0 + float(!entry) + 1.0;
    return vec4(intersection.xyz * scale, intersection.w);
}

// Use defines instead of real functions because WebGL1 cannot access array with non-constant index.
#define setIntersection(/*inout Intersections*/ ix, /*int*/ index, /*float*/ t, /*bool*/ positive, /*bool*/ enter) (ix).intersections[(index)] = vec4(0.0, float(!positive) * 2.0 + float(!enter) + 1.0, 0.0, (t))
#define setIntersectionPair(/*inout Intersections*/ ix, /*int*/ index, /*vec2*/ entryExit) (ix).intersections[(index) * 2 + 0] = vec4(0.0, float((index) > 0) * 2.0 + 1.0, 0.0, (entryExit).x); (ix).intersections[(index) * 2 + 1] = vec4(0.0, float((index) > 0) * 2.0 + 2.0, 0.0, (entryExit).y)
#define setSurfaceIntersection(/*inout Intersections*/ ix, /*int*/ index, /*vec4*/ intersection, /*bool*/ positive, /*bool*/ enter) (ix).intersections[(index)] = encodeIntersectionType((intersection), int(!positive), (enter))
#define setShapeIntersection(/*inout Intersections*/ ix, /*int*/ index, /*RayShapeIntersection*/ intersection) (ix).intersections[(index) * 2 + 0] = encodeIntersectionType((intersection).entry, (index), true); (ix).intersections[(index) * 2 + 1] = encodeIntersectionType((intersection).exit, (index), false)

#if (INTERSECTION_COUNT > 1)
void initializeIntersections(inout Intersections ix) {
    // Sort the intersections from min T to max T with bubble sort.
    // Note: If this sorting function changes, some of the intersection test may
    // need to be updated. Search for "bubble sort" to find those areas.
    const int sortPasses = INTERSECTION_COUNT * 2 - 1;
    for (int n = sortPasses; n > 0; --n) {
        for (int i = 0; i < sortPasses; ++i) {
            // The loop should be: for (i = 0; i < n; ++i) {...} but WebGL1 cannot
            // loop with non-constant condition, so it has to break early instead
            if (i >= n) { break; }

            vec4 intersect0 = ix.intersections[i + 0];
            vec4 intersect1 = ix.intersections[i + 1];

            bool inOrder = intersect0.w <= intersect1.w;

            ix.intersections[i + 0] = inOrder ? intersect0 : intersect1;
            ix.intersections[i + 1] = inOrder ? intersect1 : intersect0;
        }
    }

    // Prepare initial state for nextIntersection
    ix.index = 0;
    ix.surroundCount = 0;
    ix.surroundIsPositive = false;
}
#endif

#if (INTERSECTION_COUNT > 1)
RayShapeIntersection nextIntersection(inout Intersections ix) {
    vec4 surfaceIntersection = vec4(0.0, 0.0, 0.0, NO_HIT);
    RayShapeIntersection shapeIntersection = RayShapeIntersection(surfaceIntersection, surfaceIntersection);

    const int passCount = INTERSECTION_COUNT * 2;

    if (ix.index == passCount) {
        return shapeIntersection;
    }

    for (int i = 0; i < passCount; ++i) {
        // The loop should be: for (i = ix.index; i < passCount; ++i) {...} but WebGL1 cannot
        // loop with non-constant condition, so it has to continue instead.
        if (i < ix.index) {
            continue;
        }

        ix.index = i + 1;

        surfaceIntersection = ix.intersections[i];
        int intersectionType = int(length(surfaceIntersection.xyz) - 0.5);
        bool currShapeIsPositive = intersectionType < 2;
        bool enter = intMod(intersectionType, 2) == 0;

        ix.surroundCount += enter ? +1 : -1;
        ix.surroundIsPositive = currShapeIsPositive ? enter : ix.surroundIsPositive;

        // entering positive or exiting negative
        if (ix.surroundCount == 1 && ix.surroundIsPositive && enter == currShapeIsPositive) {
            shapeIntersection.entry = surfaceIntersection;
        }

        // exiting positive or entering negative after being inside positive
        bool exitPositive = !enter && currShapeIsPositive && ix.surroundCount == 0;
        bool enterNegativeFromPositive = enter && !currShapeIsPositive && ix.surroundCount == 2 && ix.surroundIsPositive;
        if (exitPositive || enterNegativeFromPositive) {
            shapeIntersection.exit = surfaceIntersection;

            // entry and exit have been found, so the loop can stop
            if (exitPositive) {
                // After exiting positive shape there is nothing left to intersect, so jump to the end index.
                ix.index = passCount;
            }
            break;
        }
    }

    return shapeIntersection;
}
#endif

// NOTE: initializeIntersections, nextIntersection aren't even declared unless INTERSECTION_COUNT > 1
`,IntersectDepth=`// See IntersectionUtils.glsl for the definitions of Ray, Intersections,
// setIntersectionPair, INF_HIT, NO_HIT

/* intersectDepth defines (set in Scene/VoxelRenderResources.js)
#define DEPTH_INTERSECTION_INDEX ###
*/

uniform mat4 u_transformPositionViewToUv;

void intersectDepth(in vec2 screenCoord, in Ray ray, inout Intersections ix) {
    float logDepthOrDepth = czm_unpackDepth(texture(czm_globeDepthTexture, screenCoord));
    if (logDepthOrDepth != 0.0) {
        // Calculate how far the ray must travel before it hits the depth buffer.
        vec4 eyeCoordinateDepth = czm_screenToEyeCoordinates(screenCoord, logDepthOrDepth);
        eyeCoordinateDepth /= eyeCoordinateDepth.w;
        vec3 depthPositionUv = vec3(u_transformPositionViewToUv * eyeCoordinateDepth);
        float t = dot(depthPositionUv - ray.pos, ray.dir);
        setIntersectionPair(ix, DEPTH_INTERSECTION_INDEX, vec2(t, +INF_HIT));
    } else {
        // There's no depth at this location.
        setIntersectionPair(ix, DEPTH_INTERSECTION_INDEX, vec2(NO_HIT));
    }
}
`,IntersectClippingPlanes=`// See IntersectionUtils.glsl for the definitions of Ray, Intersections, INF_HIT,
// NO_HIT, setShapeIntersection

/* Clipping plane defines (set in Scene/VoxelRenderResources.js)
#define CLIPPING_PLANES_UNION
#define CLIPPING_PLANES_COUNT
#define CLIPPING_PLANES_INTERSECTION_INDEX
*/

uniform sampler2D u_clippingPlanesTexture;
uniform mat4 u_clippingPlanesMatrix;

// Plane is in Hessian Normal Form
vec4 intersectPlane(in Ray ray, in vec4 plane) {
    vec3 n = plane.xyz; // normal
    float w = plane.w; // -dot(pointOnPlane, normal)

    float a = dot(ray.pos, n);
    float b = dot(ray.dir, n);
    float t = -(w + a) / b;

    return vec4(n, t);
}

void intersectClippingPlanes(in Ray ray, inout Intersections ix) {
    vec4 backSide = vec4(-ray.dir, -INF_HIT);
    vec4 farSide = vec4(ray.dir, +INF_HIT);
    RayShapeIntersection clippingVolume;

    #if (CLIPPING_PLANES_COUNT == 1)
        // Union and intersection are the same when there's one clipping plane, and the code
        // is more simplified.
        vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, 0, u_clippingPlanesMatrix);
        vec4 intersection = intersectPlane(ray, planeUv);
        bool reflects = dot(ray.dir, intersection.xyz) < 0.0;
        clippingVolume.entry = reflects ? backSide : intersection;
        clippingVolume.exit = reflects ? intersection : farSide;
        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX, clippingVolume);
    #elif defined(CLIPPING_PLANES_UNION)
        vec4 firstTransmission = vec4(ray.dir, +INF_HIT);
        vec4 lastReflection = vec4(-ray.dir, -INF_HIT);
        for (int i = 0; i < CLIPPING_PLANES_COUNT; i++) {
            vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, i, u_clippingPlanesMatrix);
            vec4 intersection = intersectPlane(ray, planeUv);
            if (dot(ray.dir, planeUv.xyz) > 0.0) {
                firstTransmission = intersection.w <= firstTransmission.w ? intersection : firstTransmission;
            } else {
                lastReflection = intersection.w >= lastReflection.w ? intersection : lastReflection;
            }
        }
        clippingVolume.entry = backSide;
        clippingVolume.exit = lastReflection;
        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX + 0, clippingVolume);
        clippingVolume.entry = firstTransmission;
        clippingVolume.exit = farSide;
        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX + 1, clippingVolume);
    #else // intersection
        vec4 lastTransmission = vec4(ray.dir, -INF_HIT);
        vec4 firstReflection = vec4(-ray.dir, +INF_HIT);
        for (int i = 0; i < CLIPPING_PLANES_COUNT; i++) {
            vec4 planeUv = getClippingPlane(u_clippingPlanesTexture, i, u_clippingPlanesMatrix);
            vec4 intersection = intersectPlane(ray, planeUv);
            if (dot(ray.dir, planeUv.xyz) > 0.0) {
                lastTransmission = intersection.w > lastTransmission.w ? intersection : lastTransmission;
            } else {
                firstReflection = intersection.w < firstReflection.w ? intersection: firstReflection;
            }
        }
        if (lastTransmission.w < firstReflection.w) {
            clippingVolume.entry = lastTransmission;
            clippingVolume.exit = firstReflection;
        } else {
            clippingVolume.entry = vec4(-ray.dir, NO_HIT);
            clippingVolume.exit = vec4(ray.dir, NO_HIT);
        }
        setShapeIntersection(ix, CLIPPING_PLANES_INTERSECTION_INDEX, clippingVolume);
    #endif
}
`,IntersectLongitude=`// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, INF_HIT,
// RayShapeIntersection

vec4 intersectLongitude(in Ray ray, in float angle, in bool positiveNormal) {
    float normalSign = positiveNormal ? 1.0 : -1.0;
    vec2 planeNormal = vec2(-sin(angle), cos(angle)) * normalSign;

    vec2 position = ray.pos.xy;
    vec2 direction = ray.dir.xy;
    float approachRate = dot(direction, planeNormal);
    float distance = -dot(position, planeNormal);

    float t = (approachRate == 0.0)
        ? NO_HIT
        : distance / approachRate;

    return vec4(planeNormal, 0.0, t);
}

RayShapeIntersection intersectHalfSpace(in Ray ray, in float angle, in bool positiveNormal)
{
    vec4 intersection = intersectLongitude(ray, angle, positiveNormal);
    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);

    bool hitFront = (intersection.w > 0.0) == (dot(ray.pos.xy, intersection.xy) > 0.0);
    if (!hitFront) {
        return RayShapeIntersection(intersection, farSide);
    } else {
        return RayShapeIntersection(-1.0 * farSide, intersection);
    }
}

void intersectFlippedWedge(in Ray ray, in vec2 minMaxAngle, out RayShapeIntersection intersections[2])
{
    intersections[0] = intersectHalfSpace(ray, minMaxAngle.x, false);
    intersections[1] = intersectHalfSpace(ray, minMaxAngle.y, true);
}

bool hitPositiveHalfPlane(in Ray ray, in vec4 intersection, in bool positiveNormal) {
    float normalSign = positiveNormal ? 1.0 : -1.0;
    vec2 planeDirection = vec2(intersection.y, -intersection.x) * normalSign;
    vec2 hit = ray.pos.xy + intersection.w * ray.dir.xy;
    return dot(hit, planeDirection) > 0.0;
}

void intersectHalfPlane(in Ray ray, in float angle, out RayShapeIntersection intersections[2]) {
    vec4 intersection = intersectLongitude(ray, angle, true);
    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);

    if (hitPositiveHalfPlane(ray, intersection, true)) {
        intersections[0].entry = -1.0 * farSide;
        intersections[0].exit = vec4(-1.0 * intersection.xy, 0.0, intersection.w);
        intersections[1].entry = intersection;
        intersections[1].exit = farSide;
    } else {
        vec4 miss = vec4(normalize(ray.dir), NO_HIT);
        intersections[0].entry = -1.0 * farSide;
        intersections[0].exit = farSide;
        intersections[1].entry = miss;
        intersections[1].exit = miss;
    }
}

RayShapeIntersection intersectRegularWedge(in Ray ray, in vec2 minMaxAngle)
{
    // Note: works for maxAngle > minAngle + pi, where the "regular wedge"
    // is actually a negative volume.
    // Compute intersections with the two planes.
    // Normals will point toward the "outside" (negative space)
    vec4 intersect1 = intersectLongitude(ray, minMaxAngle.x, false);
    vec4 intersect2 = intersectLongitude(ray, minMaxAngle.y, true);

    // Choose intersection with smallest T as the "first", the other as "last"
    // Note: first or last could be in the "shadow" wedge, beyond the tip
    bool inOrder = intersect1.w <= intersect2.w;
    vec4 first = inOrder ? intersect1 : intersect2;
    vec4 last = inOrder ? intersect2 : intersect1;

    bool firstIsAhead = first.w >= 0.0;
    bool startedInsideFirst = dot(ray.pos.xy, first.xy) < 0.0;
    bool exitFromInside = firstIsAhead == startedInsideFirst;
    bool lastIsAhead = last.w > 0.0;
    bool startedOutsideLast = dot(ray.pos.xy, last.xy) >= 0.0;
    bool enterFromOutside = lastIsAhead == startedOutsideLast;

    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);
    vec4 miss = vec4(normalize(ray.dir), NO_HIT);

    if (exitFromInside && enterFromOutside) {
        // Ray crosses both faces of negative wedge, exiting then entering the positive shape
        return RayShapeIntersection(first, last);
    } else if (!exitFromInside && enterFromOutside) {
        // Ray starts inside wedge. last is in shadow wedge, and first is actually the entry
        return RayShapeIntersection(-1.0 * farSide, first);
    } else if (exitFromInside && !enterFromOutside) {
        // First intersection was in the shadow wedge, so last is actually the exit
        return RayShapeIntersection(last, farSide);
    } else { // !exitFromInside && !enterFromOutside
        // Both intersections were in the shadow wedge
        return RayShapeIntersection(miss, miss);
    }
}
`,IntersectBox=`// See IntersectionUtils.glsl for the definitions of Ray, RayShapeIntersection,
// NO_HIT, Intersections

/* Box defines (set in Scene/VoxelBoxShape.js)
#define BOX_INTERSECTION_INDEX ### // always 0
*/

uniform vec3 u_renderMinBounds;
uniform vec3 u_renderMaxBounds;

RayShapeIntersection intersectBox(in Ray ray, in vec3 minBound, in vec3 maxBound)
{
    // Consider the box as the intersection of the space between 3 pairs of parallel planes
    // Compute the distance along the ray to each plane
    vec3 t0 = (minBound - ray.pos) / ray.dir;
    vec3 t1 = (maxBound - ray.pos) / ray.dir;

    // Identify candidate entries/exits based on distance from ray.pos
    vec3 entries = min(t0, t1);
    vec3 exits = max(t0, t1);

    vec3 directions = sign(ray.dir);

    // The actual intersection points are the furthest entry and the closest exit
    float lastEntry = maxComponent(entries);
    bvec3 isLastEntry = equal(entries, vec3(lastEntry));
    vec3 entryNormal = -1.0 * vec3(isLastEntry) * directions;
    vec4 entry = vec4(entryNormal, lastEntry);

    float firstExit = minComponent(exits);
    bvec3 isFirstExit = equal(exits, vec3(firstExit));
    vec3 exitNormal = vec3(isLastEntry) * directions;
    vec4 exit = vec4(exitNormal, firstExit);

    if (entry.w > exit.w) {
        entry.w = NO_HIT;
        exit.w = NO_HIT;
    }

    return RayShapeIntersection(entry, exit);
}

void intersectShape(in Ray ray, inout Intersections ix)
{
    RayShapeIntersection intersection = intersectBox(ray, u_renderMinBounds, u_renderMaxBounds);
    setShapeIntersection(ix, BOX_INTERSECTION_INDEX, intersection);
}
`,IntersectCylinder=`// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, Intersections,
// RayShapeIntersection, setSurfaceIntersection, setShapeIntersection,
// intersectIntersections
// See IntersectLongitude.glsl for the definitions of intersectHalfPlane,
// intersectFlippedWedge, intersectRegularWedge

/* Cylinder defines (set in Scene/VoxelCylinderShape.js)
#define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN
#define CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT
#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE
#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF
#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF
#define CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO

#define CYLINDER_INTERSECTION_INDEX_RADIUS_MAX
#define CYLINDER_INTERSECTION_INDEX_RADIUS_MIN
#define CYLINDER_INTERSECTION_INDEX_ANGLE
*/

// Cylinder uniforms
uniform vec2 u_cylinderRenderRadiusMinMax;
uniform vec2 u_cylinderRenderHeightMinMax;
#if defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE)
    uniform vec2 u_cylinderRenderAngleMinMax;
#endif

/**
 * Find the intersection of a ray with the volume defined by two planes of constant z
 */
RayShapeIntersection intersectHeightBounds(in Ray ray, in vec2 minMaxHeight, in bool convex)
{
    float zPosition = ray.pos.z;
    float zDirection = ray.dir.z;

    float tmin = (minMaxHeight.x - zPosition) / zDirection;
    float tmax = (minMaxHeight.y - zPosition) / zDirection;

    // Normals point outside the volume
    float signFlip = convex ? 1.0 : -1.0;
    vec4 intersectMin = vec4(0.0, 0.0, -1.0 * signFlip, tmin);
    vec4 intersectMax = vec4(0.0, 0.0, 1.0 * signFlip, tmax);

    bool topEntry = zDirection < 0.0;
    vec4 entry = topEntry ? intersectMax : intersectMin;
    vec4 exit = topEntry ? intersectMin : intersectMax;

    return RayShapeIntersection(entry, exit);
}

/**
 * Find the intersection of a ray with a right cylindrical surface of a given radius
 * about the z-axis.
 */
RayShapeIntersection intersectCylinder(in Ray ray, in float radius, in bool convex)
{
    vec2 position = ray.pos.xy;
    vec2 direction = ray.dir.xy;

    float a = dot(direction, direction);
    float b = dot(position, direction);
    float c = dot(position, position) - radius * radius;
    float determinant = b * b - a * c;

    if (determinant < 0.0) {
        vec4 miss = vec4(normalize(ray.dir), NO_HIT);
        return RayShapeIntersection(miss, miss);
    }

    determinant = sqrt(determinant);
    float t1 = (-b - determinant) / a;
    float t2 = (-b + determinant) / a;
    float signFlip = convex ? 1.0 : -1.0;
    vec4 intersect1 = vec4(normalize(position + t1 * direction) * signFlip, 0.0, t1);
    vec4 intersect2 = vec4(normalize(position + t2 * direction) * signFlip, 0.0, t2);

    return RayShapeIntersection(intersect1, intersect2);
}

/**
 * Find the intersection of a ray with a right cylindrical solid of given
 * radius and height bounds. NOTE: The shape is assumed to be convex.
 */
RayShapeIntersection intersectBoundedCylinder(in Ray ray, in float radius, in vec2 minMaxHeight)
{
    RayShapeIntersection cylinderIntersection = intersectCylinder(ray, radius, true);
    RayShapeIntersection heightBoundsIntersection = intersectHeightBounds(ray, minMaxHeight, true);
    return intersectIntersections(ray, cylinderIntersection, heightBoundsIntersection);
}

void intersectShape(Ray ray, inout Intersections ix)
{
    // Position is converted from [0,1] to [-1,+1] because shape intersections assume unit space is [-1,+1].
    // Direction is scaled as well to be in sync with position.
    ray.pos = ray.pos * 2.0 - 1.0;
    ray.dir *= 2.0;

    RayShapeIntersection outerIntersect = intersectBoundedCylinder(ray, u_cylinderRenderRadiusMinMax.y, u_cylinderRenderHeightMinMax);

    setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_RADIUS_MAX, outerIntersect);

    if (outerIntersect.entry.w == NO_HIT) {
        return;
    }

    #if defined(CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT)
        // When the cylinder is perfectly thin it's necessary to sandwich the
        // inner cylinder intersection inside the outer cylinder intersection.

        // Without this special case,
        // [outerMin, outerMax, innerMin, innerMax] will bubble sort to
        // [outerMin, innerMin, outerMax, innerMax] which will cause the back
        // side of the cylinder to be invisible because it will think the ray
        // is still inside the inner (negative) cylinder after exiting the
        // outer (positive) cylinder.

        // With this special case,
        // [outerMin, innerMin, innerMax, outerMax] will bubble sort to
        // [outerMin, innerMin, innerMax, outerMax] which will work correctly.

        // Note: If initializeIntersections() changes its sorting function
        // from bubble sort to something else, this code may need to change.
        RayShapeIntersection innerIntersect = intersectCylinder(ray, 1.0, false);
        setSurfaceIntersection(ix, 0, outerIntersect.entry, true, true);  // positive, enter
        setSurfaceIntersection(ix, 1, innerIntersect.entry, false, true); // negative, enter
        setSurfaceIntersection(ix, 2, innerIntersect.exit, false, false); // negative, exit
        setSurfaceIntersection(ix, 3, outerIntersect.exit, true, false);  // positive, exit
    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN)
        RayShapeIntersection innerIntersect = intersectCylinder(ray, u_cylinderRenderRadiusMinMax.x, false);
        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_RADIUS_MIN, innerIntersect);
    #endif

    #if defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF)
        RayShapeIntersection wedgeIntersect = intersectRegularWedge(ray, u_cylinderRenderAngleMinMax);
        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE, wedgeIntersect);
    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF)
        RayShapeIntersection wedgeIntersects[2];
        intersectFlippedWedge(ray, u_cylinderRenderAngleMinMax, wedgeIntersects);
        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]);
        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]);
    #elif defined(CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO)
        RayShapeIntersection wedgeIntersects[2];
        intersectHalfPlane(ray, u_cylinderRenderAngleMinMax.x, wedgeIntersects);
        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 0, wedgeIntersects[0]);
        setShapeIntersection(ix, CYLINDER_INTERSECTION_INDEX_ANGLE + 1, wedgeIntersects[1]);
    #endif
}
`,IntersectEllipsoid=`// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT, INF_HIT, Intersections,
// RayShapeIntersection, setSurfaceIntersection, setShapeIntersection
// See IntersectLongitude.glsl for the definitions of intersectHalfPlane,
// intersectFlippedWedge, intersectRegularWedge

/* Ellipsoid defines (set in Scene/VoxelEllipsoidShape.js)
#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE
#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO
#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF
#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF
#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF
#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF
#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF
#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF
#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF
#define ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF
#define ELLIPSOID_INTERSECTION_INDEX_LONGITUDE
#define ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX
#define ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN
#define ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX
#define ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN
*/

#if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE)
    uniform vec2 u_ellipsoidRenderLongitudeMinMax;
#endif
uniform float u_eccentricitySquared;
uniform vec2 u_ellipsoidRenderLatitudeSinMinMax;
uniform vec2 u_clipMinMaxHeight;

RayShapeIntersection intersectZPlane(in Ray ray, in float z) {
    float t = -ray.pos.z / ray.dir.z;

    bool startsOutside = sign(ray.pos.z) == sign(z);
    bool entry = (t >= 0.0) != startsOutside;

    vec4 intersect = vec4(0.0, 0.0, z, t);
    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);

    if (entry) {
        return RayShapeIntersection(intersect, farSide);
    } else {
        return RayShapeIntersection(-1.0 * farSide, intersect);
    }
}

RayShapeIntersection intersectHeight(in Ray ray, in float relativeHeight, in bool convex)
{
    // Scale the ray by the ellipsoid axes to make it a unit sphere
    // Note: approximating ellipsoid + height as an ellipsoid
    vec3 radiiCorrection = u_ellipsoidRadiiUv / (u_ellipsoidRadiiUv + relativeHeight);
    vec3 position = ray.pos * radiiCorrection;
    vec3 direction = ray.dir * radiiCorrection;

    float a = dot(direction, direction); // ~ 1.0 (or maybe 4.0 if ray is scaled)
    float b = dot(direction, position); // roughly inside [-1.0, 1.0] when zoomed in
    float c = dot(position, position) - 1.0; // ~ 0.0 when zoomed in.
    float determinant = b * b - a * c; // ~ b * b when zoomed in

    if (determinant < 0.0) {
        vec4 miss = vec4(normalize(direction), NO_HIT);
        return RayShapeIntersection(miss, miss);
    }

    determinant = sqrt(determinant);

    // Compute larger root using standard formula
    float signB = b < 0.0 ? -1.0 : 1.0;
    // The other root may suffer from subtractive cancellation in the standard formula.
    // Compute it from the first root instead.
    float t1 = (-b - signB * determinant) / a;
    float t2 = c / (a * t1);
    float tmin = min(t1, t2);
    float tmax = max(t1, t2);

    float directionScale = convex ? 1.0 : -1.0;
    vec3 d1 = directionScale * normalize(position + tmin * direction);
    vec3 d2 = directionScale * normalize(position + tmax * direction);

    return RayShapeIntersection(vec4(d1, tmin), vec4(d2, tmax));
}

/**
 * Given a circular cone around the z-axis, with apex at the origin,
 * find the parametric distance(s) along a ray where that ray intersects
 * the cone.
 * The cone opening angle is described by the squared cosine of
 * its half-angle (the angle between the Z-axis and the surface)
 */
vec2 intersectDoubleEndedCone(in Ray ray, in float cosSqrHalfAngle)
{
    vec3 o = ray.pos;
    vec3 d = ray.dir;
    float sinSqrHalfAngle = 1.0 - cosSqrHalfAngle;

    float aSin = d.z * d.z * sinSqrHalfAngle;
    float aCos = -dot(d.xy, d.xy) * cosSqrHalfAngle;
    float a = aSin + aCos;

    float bSin = d.z * o.z * sinSqrHalfAngle;
    float bCos = -dot(o.xy, d.xy) * cosSqrHalfAngle;
    float b = bSin + bCos;

    float cSin = o.z * o.z * sinSqrHalfAngle;
    float cCos = -dot(o.xy, o.xy) * cosSqrHalfAngle;
    float c = cSin + cCos;
    // determinant = b * b - a * c. But bSin * bSin = aSin * cSin.
    // Avoid subtractive cancellation by expanding to eliminate these terms
    float determinant = 2.0 * bSin * bCos + bCos * bCos - aSin * cCos - aCos * cSin - aCos * cCos;

    if (determinant < 0.0) {
        return vec2(NO_HIT);
    } else if (a == 0.0) {
        // Ray is parallel to cone surface
        return (b == 0.0)
            ? vec2(NO_HIT) // Ray is on cone surface
            : vec2(-0.5 * c / b, NO_HIT);
    }

    determinant = sqrt(determinant);

    // Compute larger root using standard formula
    float signB = b < 0.0 ? -1.0 : 1.0;
    float t1 = (-b - signB * determinant) / a;
    // The other root may suffer from subtractive cancellation in the standard formula.
    // Compute it from the first root instead.
    float t2 = c / (a * t1);
    float tmin = min(t1, t2);
    float tmax = max(t1, t2);
    return vec2(tmin, tmax);
}

/**
 * Given a point on a conical surface, find the surface normal at that point.
 */
vec3 getConeNormal(in vec3 p, in bool convex) {
    // Start with radial component pointing toward z-axis
    vec2 radial = -abs(p.z) * normalize(p.xy);
    // Z component points toward opening of cone
    float zSign = (p.z < 0.0) ? -1.0 : 1.0;
    float z = length(p.xy) * zSign;
    // Flip normal if shape is convex
    float flip = (convex) ? -1.0 : 1.0;
    return normalize(vec3(radial, z) * flip);
}

/**
 * Compute the shift between the ellipsoid origin and the apex of a cone of latitude
 */
float getLatitudeConeShift(in float sinLatitude) {
    // Find prime vertical radius of curvature: 
    // the distance along the ellipsoid normal to the intersection with the z-axis
    float x2 = u_eccentricitySquared * sinLatitude * sinLatitude;
    float primeVerticalRadius = inversesqrt(1.0 - x2);

    // Compute a shift from the origin to the intersection of the cone with the z-axis
    return primeVerticalRadius * u_eccentricitySquared * sinLatitude;
}

void intersectFlippedCone(in Ray ray, in float cosHalfAngle, out RayShapeIntersection intersections[2]) {
    // Undo the scaling from ellipsoid to sphere
    ray.pos = ray.pos * u_ellipsoidRadiiUv;
    ray.dir = ray.dir * u_ellipsoidRadiiUv;
    // Shift the ray to account for the latitude cone not being centered at the Earth center
    ray.pos.z += getLatitudeConeShift(cosHalfAngle);

    float cosSqrHalfAngle = cosHalfAngle * cosHalfAngle;
    vec2 intersect = intersectDoubleEndedCone(ray, cosSqrHalfAngle);

    vec4 miss = vec4(normalize(ray.dir), NO_HIT);
    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);

    // Initialize output with no intersections
    intersections[0].entry = -1.0 * farSide;
    intersections[0].exit = farSide;
    intersections[1].entry = miss;
    intersections[1].exit = miss;

    if (intersect.x == NO_HIT) {
        return;
    }

    // Find the points of intersection
    float tmin = intersect.x;
    float tmax = intersect.y;
    vec3 p0 = ray.pos + tmin * ray.dir;
    vec3 p1 = ray.pos + tmax * ray.dir;

    vec4 intersect0 = vec4(getConeNormal(p0, true), tmin);
    vec4 intersect1 = vec4(getConeNormal(p1, true), tmax);

    bool p0InShadowCone = sign(p0.z) != sign(cosHalfAngle);
    bool p1InShadowCone = sign(p1.z) != sign(cosHalfAngle);

    if (p0InShadowCone && p1InShadowCone) {
        // no valid intersections
    } else if (p0InShadowCone) {
        intersections[0].exit = intersect1;
    } else if (p1InShadowCone) {
        intersections[0].entry = intersect0;
    } else {
        intersections[0].exit = intersect0;
        intersections[1].entry = intersect1;
        intersections[1].exit = farSide;
    }
}

RayShapeIntersection intersectRegularCone(in Ray ray, in float cosHalfAngle, in bool convex) {
    // Undo the scaling from ellipsoid to sphere
    ray.pos = ray.pos * u_ellipsoidRadiiUv;
    ray.dir = ray.dir * u_ellipsoidRadiiUv;
    // Shift the ray to account for the latitude cone not being centered at the Earth center
    ray.pos.z += getLatitudeConeShift(cosHalfAngle);

    float cosSqrHalfAngle = cosHalfAngle * cosHalfAngle;
    vec2 intersect = intersectDoubleEndedCone(ray, cosSqrHalfAngle);

    vec4 miss = vec4(normalize(ray.dir), NO_HIT);
    vec4 farSide = vec4(normalize(ray.dir), INF_HIT);

    if (intersect.x == NO_HIT) {
        return RayShapeIntersection(miss, miss);
    }

    // Find the points of intersection
    float tmin = intersect.x;
    float tmax = intersect.y;
    vec3 p0 = ray.pos + tmin * ray.dir;
    vec3 p1 = ray.pos + tmax * ray.dir;

    vec4 intersect0 = vec4(getConeNormal(p0, convex), tmin);
    vec4 intersect1 = vec4(getConeNormal(p1, convex), tmax);

    bool p0InShadowCone = sign(p0.z) != sign(cosHalfAngle);
    bool p1InShadowCone = sign(p1.z) != sign(cosHalfAngle);

    if (p0InShadowCone && p1InShadowCone) {
        return RayShapeIntersection(miss, miss);
    } else if (p0InShadowCone) {
        return RayShapeIntersection(intersect1, farSide);
    } else if (p1InShadowCone) {
        return RayShapeIntersection(-1.0 * farSide, intersect0);
    } else {
        return RayShapeIntersection(intersect0, intersect1);
    }
}

void intersectShape(in Ray ray, inout Intersections ix) {
    // Position is converted from [0,1] to [-1,+1] because shape intersections assume unit space is [-1,+1].
    // Direction is scaled as well to be in sync with position.
    ray.pos = ray.pos * 2.0 - 1.0;
    ray.dir *= 2.0;

    // Outer ellipsoid
    RayShapeIntersection outerIntersect = intersectHeight(ray, u_clipMinMaxHeight.y, true);
    setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX, outerIntersect);

    // Exit early if the outer ellipsoid was missed.
    if (outerIntersect.entry.w == NO_HIT) {
        return;
    }

    // Inner ellipsoid
    RayShapeIntersection innerIntersect = intersectHeight(ray, u_clipMinMaxHeight.x, false);

    if (innerIntersect.entry.w == NO_HIT) {
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN, innerIntersect);
    } else {
        // When the ellipsoid is large and thin it's possible for floating point math
        // to cause the ray to intersect the inner ellipsoid before the outer ellipsoid. 
        // To prevent this from happening, clamp innerIntersect to outerIntersect and
        // sandwich the inner ellipsoid intersection inside the outer ellipsoid intersection.

        // Without this special case,
        // [outerMin, outerMax, innerMin, innerMax] will bubble sort to
        // [outerMin, innerMin, outerMax, innerMax] which will cause the back
        // side of the ellipsoid to be invisible because it will think the ray
        // is still inside the inner (negative) ellipsoid after exiting the
        // outer (positive) ellipsoid.

        // With this special case,
        // [outerMin, innerMin, innerMax, outerMax] will bubble sort to
        // [outerMin, innerMin, innerMax, outerMax] which will work correctly.

        // Note: If initializeIntersections() changes its sorting function
        // from bubble sort to something else, this code may need to change.
        innerIntersect.entry.w = max(innerIntersect.entry.w, outerIntersect.entry.w);
        innerIntersect.exit.w = min(innerIntersect.exit.w, outerIntersect.exit.w);
        setSurfaceIntersection(ix, 0, outerIntersect.entry, true, true);  // positive, enter
        setSurfaceIntersection(ix, 1, innerIntersect.entry, false, true); // negative, enter
        setSurfaceIntersection(ix, 2, innerIntersect.exit, false, false); // negative, exit
        setSurfaceIntersection(ix, 3, outerIntersect.exit, true, false);  // positive, exit
    }

    // Bottom cone
    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF)
        RayShapeIntersection bottomConeIntersection = intersectRegularCone(ray, u_ellipsoidRenderLatitudeSinMinMax.x, false);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN, bottomConeIntersection);
    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF)
        RayShapeIntersection bottomConeIntersection = intersectZPlane(ray, -1.0);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN, bottomConeIntersection);
    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF)
        RayShapeIntersection bottomConeIntersections[2];
        intersectFlippedCone(ray, u_ellipsoidRenderLatitudeSinMinMax.x, bottomConeIntersections);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN + 0, bottomConeIntersections[0]);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN + 1, bottomConeIntersections[1]);
    #endif

    // Top cone
    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF)
        RayShapeIntersection topConeIntersections[2];
        intersectFlippedCone(ray, u_ellipsoidRenderLatitudeSinMinMax.y, topConeIntersections);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX + 0, topConeIntersections[0]);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX + 1, topConeIntersections[1]);
    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF)
        RayShapeIntersection topConeIntersection = intersectZPlane(ray, 1.0);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX, topConeIntersection);
    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF)
        RayShapeIntersection topConeIntersection = intersectRegularCone(ray, u_ellipsoidRenderLatitudeSinMinMax.y, false);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX, topConeIntersection);
    #endif

    // Wedge
    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO)
        RayShapeIntersection wedgeIntersects[2];
        intersectHalfPlane(ray, u_ellipsoidRenderLongitudeMinMax.x, wedgeIntersects);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 0, wedgeIntersects[0]);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 1, wedgeIntersects[1]);
    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF)
        RayShapeIntersection wedgeIntersect = intersectRegularWedge(ray, u_ellipsoidRenderLongitudeMinMax);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE, wedgeIntersect);
    #elif defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF)
        RayShapeIntersection wedgeIntersects[2];
        intersectFlippedWedge(ray, u_ellipsoidRenderLongitudeMinMax, wedgeIntersects);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 0, wedgeIntersects[0]);
        setShapeIntersection(ix, ELLIPSOID_INTERSECTION_INDEX_LONGITUDE + 1, wedgeIntersects[1]);
    #endif
}
`,Intersection=`// Main intersection function for Voxel scenes.
// See IntersectBox.glsl, IntersectCylinder.glsl, or IntersectEllipsoid.glsl
// for the definition of intersectShape. The appropriate function is selected
// based on the VoxelPrimitive shape type, and added to the shader in
// Scene/VoxelRenderResources.js.
// See also IntersectClippingPlane.glsl and IntersectDepth.glsl.
// See IntersectionUtils.glsl for the definitions of Ray, NO_HIT,
// getFirstIntersection, initializeIntersections, nextIntersection.

/* Intersection defines (set in Scene/VoxelRenderResources.js)
#define INTERSECTION_COUNT ###
*/

RayShapeIntersection intersectScene(in vec2 screenCoord, in Ray ray, out Intersections ix) {
    // Do a ray-shape intersection to find the exact starting and ending points.
    intersectShape(ray, ix);

    // Exit early if the positive shape was completely missed or behind the ray.
    RayShapeIntersection intersection = getFirstIntersection(ix);
    if (intersection.entry.w == NO_HIT) {
        // Positive shape was completely missed - so exit early.
        return intersection;
    }

    // Clipping planes
    #if defined(CLIPPING_PLANES)
        intersectClippingPlanes(ray, ix);
    #endif

    // Depth
    #if defined(DEPTH_TEST)
        intersectDepth(screenCoord, ray, ix);
    #endif

    // Find the first intersection that's in front of the ray
    #if (INTERSECTION_COUNT > 1)
        initializeIntersections(ix);
        for (int i = 0; i < INTERSECTION_COUNT; ++i) {
            intersection = nextIntersection(ix);
            if (intersection.exit.w > 0.0) {
                // Set start to 0.0 when ray is inside the shape.
                intersection.entry.w = max(intersection.entry.w, 0.0);
                break;
            }
        }
    #else
        // Set start to 0.0 when ray is inside the shape.
        intersection.entry.w = max(intersection.entry.w, 0.0);
    #endif

    return intersection;
}
`,convertUvToBox=`/* Box defines (set in Scene/VoxelBoxShape.js)
#define BOX_HAS_SHAPE_BOUNDS
*/

#if defined(BOX_HAS_SHAPE_BOUNDS)
    uniform vec3 u_boxUvToShapeUvScale;
    uniform vec3 u_boxUvToShapeUvTranslate;
#endif

PointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) {
    // For BOX, UV space = shape space, so we can use positionUv as-is,
    // and the Jacobian is the identity matrix, except that a step of 1
    // only spans half the shape space [-1, 1], so the identity is scaled.
    return PointJacobianT(positionUv, mat3(0.5));
}

vec3 convertShapeToShapeUvSpace(in vec3 positionShape) {
#if defined(BOX_HAS_SHAPE_BOUNDS)
    return positionShape * u_boxUvToShapeUvScale + u_boxUvToShapeUvTranslate;
#else
    return positionShape;
#endif
}

PointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) {
    PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv);
    pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point);
    return pointJacobian;
}

vec3 convertShapeUvToUvSpace(in vec3 shapeUv) {
#if defined(BOX_HAS_SHAPE_BOUNDS)
    return (shapeUv - u_boxUvToShapeUvTranslate) / u_boxUvToShapeUvScale;
#else
    return shapeUv;
#endif
}

vec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {
#if defined(BOX_HAS_SHAPE_BOUNDS)
    return shapeUv / u_boxUvToShapeUvScale;
#else
    return shapeUv;
#endif
}`,convertUvToCylinder=`/* Cylinder defines (set in Scene/VoxelCylinderShape.js)
#define CYLINDER_HAS_SHAPE_BOUNDS_RADIUS
#define CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT
#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE
#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY
#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY
#define CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED
*/

#if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS)
    uniform vec2 u_cylinderUvToShapeUvRadius; // x = scale, y = offset
#endif
#if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT)
    uniform vec2 u_cylinderUvToShapeUvHeight; // x = scale, y = offset
#endif
#if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE)
    uniform vec2 u_cylinderUvToShapeUvAngle; // x = scale, y = offset
#endif
#if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY)
    uniform vec2 u_cylinderShapeUvAngleMinMax;
#endif
#if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY) || defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED)
    uniform float u_cylinderShapeUvAngleRangeZeroMid;
#endif

PointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) {
    // Convert from Cartesian UV space [0, 1] to Cartesian local space [-1, 1]
    vec3 position = positionUv * 2.0 - 1.0;

    float radius = length(position.xy); // [0, 1]
    vec3 radial = normalize(vec3(position.xy, 0.0));

    // Shape space height is defined within [0, 1]
    float height = positionUv.z; // [0, 1]
    vec3 z = vec3(0.0, 0.0, 1.0);

    float angle = atan(position.y, position.x);
    vec3 east = normalize(vec3(-position.y, position.x, 0.0));

    vec3 point = vec3(radius, height, angle);
    mat3 jacobianT = mat3(radial, z, east / length(position.xy));
    return PointJacobianT(point, jacobianT);
}

vec3 convertShapeToShapeUvSpace(in vec3 positionShape) {
    float radius = positionShape.x;
    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS)
        radius = radius * u_cylinderUvToShapeUvRadius.x + u_cylinderUvToShapeUvRadius.y;
    #endif

    float height = positionShape.y;
    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT)
        height = height * u_cylinderUvToShapeUvHeight.x + u_cylinderUvToShapeUvHeight.y;
    #endif

    float angle = (positionShape.z + czm_pi) / czm_twoPi;
    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE)
        #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED)
            // Comparing against u_cylinderShapeUvAngleMinMax has precision problems. u_cylinderShapeUvAngleRangeZeroMid is more conservative.
            angle += float(angle < u_cylinderShapeUvAngleRangeZeroMid);
        #endif

        // Avoid flickering from reading voxels from both sides of the -pi/+pi discontinuity.
        #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY)
            angle = angle > u_cylinderShapeUvAngleRangeZeroMid ? u_cylinderShapeUvAngleMinMax.x : angle;
        #elif defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY)
            angle = angle < u_cylinderShapeUvAngleRangeZeroMid ? u_cylinderShapeUvAngleMinMax.y : angle;
        #endif

        angle = angle * u_cylinderUvToShapeUvAngle.x + u_cylinderUvToShapeUvAngle.y;
    #endif

    return vec3(radius, height, angle);
}

PointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) {
    PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv);
    pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point);
    return pointJacobian;
}

vec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {
    float radius = shapeUv.x;
    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_RADIUS)
        radius /= u_cylinderUvToShapeUvRadius.x;
    #endif

    float height = shapeUv.y;
    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT)
        height /= u_cylinderUvToShapeUvHeight.x;
    #endif

    float angle = shapeUv.z * czm_twoPi;
    #if defined(CYLINDER_HAS_SHAPE_BOUNDS_ANGLE)
        angle /= u_cylinderUvToShapeUvAngle.x;
    #endif

    return vec3(radius, height, angle);
}
`,convertUvToEllipsoid=`/* Ellipsoid defines (set in Scene/VoxelEllipsoidShape.js)
#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY
#define ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY
#define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE
#define ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED
#define ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE
*/

uniform vec3 u_ellipsoidRadiiUv; // [0,1]
uniform vec2 u_evoluteScale; // (radiiUv.x ^ 2 - radiiUv.z ^ 2) * vec2(1.0, -1.0) / radiiUv;
uniform vec3 u_ellipsoidInverseRadiiSquaredUv;
#if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY) || defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY) || defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED)
    uniform vec3 u_ellipsoidShapeUvLongitudeMinMaxMid;
#endif
#if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)
    uniform vec2 u_ellipsoidUvToShapeUvLongitude; // x = scale, y = offset
#endif
#if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)
    uniform vec2 u_ellipsoidUvToShapeUvLatitude; // x = scale, y = offset
#endif
uniform float u_ellipsoidInverseHeightDifferenceUv;

// robust iterative solution without trig functions
// https://github.com/0xfaded/ellipse_demo/issues/1
// https://stackoverflow.com/questions/22959698/distance-from-given-point-to-given-ellipse
// Extended to return radius of curvature along with the point
vec3 nearestPointAndRadiusOnEllipse(vec2 pos, vec2 radii) {
    vec2 p = abs(pos);
    vec2 inverseRadii = 1.0 / radii;

    // We describe the ellipse parametrically: v = radii * vec2(cos(t), sin(t))
    // but store the cos and sin of t in a vec2 for efficiency.
    // Initial guess: t = pi/4
    vec2 tTrigs = vec2(0.7071067811865476);
    // Initial guess of point on ellipsoid
    vec2 v = radii * tTrigs;
    // Center of curvature of the ellipse at v
    vec2 evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs;

    const int iterations = 3;
    for (int i = 0; i < iterations; ++i) {
        // Find the (approximate) intersection of p - evolute with the ellipsoid.
        vec2 q = normalize(p - evolute) * length(v - evolute);
        // Update the estimate of t.
        tTrigs = (q + evolute) * inverseRadii;
        tTrigs = normalize(clamp(tTrigs, 0.0, 1.0));
        v = radii * tTrigs;
        evolute = u_evoluteScale * tTrigs * tTrigs * tTrigs;
    }

    return vec3(v * sign(pos), length(v - evolute));
}

PointJacobianT convertUvToShapeSpaceDerivative(in vec3 positionUv) {
    // Convert from UV space [0, 1] to local space [-1, 1]
    vec3 position = positionUv * 2.0 - 1.0;
    // Undo the scaling from ellipsoid to sphere
    position = position * u_ellipsoidRadiiUv;

    float longitude = atan(position.y, position.x);
    vec3 east = normalize(vec3(-position.y, position.x, 0.0));

    // Convert the 3D position to a 2D position relative to the ellipse (radii.x, radii.z)
    // (assume radii.y == radii.x) and find the nearest point on the ellipse and its normal
    float distanceFromZAxis = length(position.xy);
    vec2 posEllipse = vec2(distanceFromZAxis, position.z);
    vec3 surfacePointAndRadius = nearestPointAndRadiusOnEllipse(posEllipse, u_ellipsoidRadiiUv.xz);
    vec2 surfacePoint = surfacePointAndRadius.xy;

    vec2 normal2d = normalize(surfacePoint * u_ellipsoidInverseRadiiSquaredUv.xz);
    float latitude = atan(normal2d.y, normal2d.x);
    vec3 north = vec3(-normal2d.y * normalize(position.xy), abs(normal2d.x));

    float heightSign = length(posEllipse) < length(surfacePoint) ? -1.0 : 1.0;
    float height = heightSign * length(posEllipse - surfacePoint);
    vec3 up = normalize(cross(east, north));

    vec3 point = vec3(longitude, latitude, height);
    mat3 jacobianT = mat3(east / distanceFromZAxis, north / (surfacePointAndRadius.z + height), up);
    return PointJacobianT(point, jacobianT);
}

vec3 convertShapeToShapeUvSpace(in vec3 positionShape) {
    // Longitude: shift & scale to [0, 1]
    float longitude = (positionShape.x + czm_pi) / czm_twoPi;

    // Correct the angle when max < min
    // Technically this should compare against min longitude - but it has precision problems so compare against the middle of empty space.
    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED)
        longitude += float(longitude < u_ellipsoidShapeUvLongitudeMinMaxMid.z);
    #endif

    // Avoid flickering from reading voxels from both sides of the -pi/+pi discontinuity.
    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY)
        longitude = longitude > u_ellipsoidShapeUvLongitudeMinMaxMid.z ? u_ellipsoidShapeUvLongitudeMinMaxMid.x : longitude;
    #endif
    #if defined(ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY)
        longitude = longitude < u_ellipsoidShapeUvLongitudeMinMaxMid.z ? u_ellipsoidShapeUvLongitudeMinMaxMid.y : longitude;
    #endif

    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)
        longitude = longitude * u_ellipsoidUvToShapeUvLongitude.x + u_ellipsoidUvToShapeUvLongitude.y;
    #endif

    // Latitude: shift and scale to [0, 1]
    float latitude = (positionShape.y + czm_piOverTwo) / czm_pi;
    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)
        latitude = latitude * u_ellipsoidUvToShapeUvLatitude.x + u_ellipsoidUvToShapeUvLatitude.y;
    #endif

    // Height: scale to the range [0, 1]
    float height = 1.0 + positionShape.z * u_ellipsoidInverseHeightDifferenceUv;

    return vec3(longitude, latitude, height);
}

PointJacobianT convertUvToShapeUvSpaceDerivative(in vec3 positionUv) {
    PointJacobianT pointJacobian = convertUvToShapeSpaceDerivative(positionUv);
    pointJacobian.point = convertShapeToShapeUvSpace(pointJacobian.point);
    return pointJacobian;
}

vec3 scaleShapeUvToShapeSpace(in vec3 shapeUv) {
    // Convert from [0, 1] to radians [-pi, pi]
    float longitude = shapeUv.x * czm_twoPi;
    #if defined (ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE)
        longitude /= u_ellipsoidUvToShapeUvLongitude.x;
    #endif

    // Convert from [0, 1] to radians [-pi/2, pi/2]
    float latitude = shapeUv.y * czm_pi;
    #if defined(ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE)
        latitude /= u_ellipsoidUvToShapeUvLatitude.x;
    #endif
    
    float height = shapeUv.z / u_ellipsoidInverseHeightDifferenceUv;

    return vec3(longitude, latitude, height);
}
`,Octree=`// These octree flags must be in sync with GpuOctreeFlag in VoxelTraversal.js
#define OCTREE_FLAG_INTERNAL 0
#define OCTREE_FLAG_LEAF 1
#define OCTREE_FLAG_PACKED_LEAF_FROM_PARENT 2

#define OCTREE_MAX_LEVELS 32 // Harcoded value because GLSL doesn't like variable length loops

uniform sampler2D u_octreeInternalNodeTexture;
uniform vec2 u_octreeInternalNodeTexelSizeUv;
uniform int u_octreeInternalNodeTilesPerRow;
#if (SAMPLE_COUNT > 1)
uniform sampler2D u_octreeLeafNodeTexture;
uniform vec2 u_octreeLeafNodeTexelSizeUv;
uniform int u_octreeLeafNodeTilesPerRow;
#endif

struct OctreeNodeData {
    int data;
    int flag;
};

struct TraversalData {
    ivec4 octreeCoords;
    int parentOctreeIndex;
};

struct SampleData {
    int megatextureIndex;
    ivec4 tileCoords;
    vec3 tileUv;
    #if (SAMPLE_COUNT > 1)
        float weight;
    #endif
};

// Integer mod: For WebGL1 only
int intMod(in int a, in int b) {
    return a - (b * (a / b));
}
int normU8_toInt(in float value) {
    return int(value * 255.0);
}
int normU8x2_toInt(in vec2 value) {
    return int(value.x * 255.0) + 256 * int(value.y * 255.0);
}
float normU8x2_toFloat(in vec2 value) {
    return float(normU8x2_toInt(value)) / 65535.0;
}

OctreeNodeData getOctreeNodeData(in vec2 octreeUv) {
    vec4 texData = texture(u_octreeInternalNodeTexture, octreeUv);

    OctreeNodeData data;
    data.data = normU8x2_toInt(texData.xy);
    data.flag = normU8x2_toInt(texData.zw);
    return data;
}

OctreeNodeData getOctreeChildData(in int parentOctreeIndex, in ivec3 childCoord) {
    int childIndex = childCoord.z * 4 + childCoord.y * 2 + childCoord.x;
    int octreeCoordX = intMod(parentOctreeIndex, u_octreeInternalNodeTilesPerRow) * 9 + 1 + childIndex;
    int octreeCoordY = parentOctreeIndex / u_octreeInternalNodeTilesPerRow;
    vec2 octreeUv = u_octreeInternalNodeTexelSizeUv * vec2(float(octreeCoordX) + 0.5, float(octreeCoordY) + 0.5);
    return getOctreeNodeData(octreeUv);
}

int getOctreeParentIndex(in int octreeIndex) {
    int octreeCoordX = intMod(octreeIndex, u_octreeInternalNodeTilesPerRow) * 9;
    int octreeCoordY = octreeIndex / u_octreeInternalNodeTilesPerRow;
    vec2 octreeUv = u_octreeInternalNodeTexelSizeUv * vec2(float(octreeCoordX) + 0.5, float(octreeCoordY) + 0.5);
    vec4 parentData = texture(u_octreeInternalNodeTexture, octreeUv);
    int parentOctreeIndex = normU8x2_toInt(parentData.xy);
    return parentOctreeIndex;
}

/**
* Convert a position in the uv-space of the tileset bounding shape
* into the uv-space of a tile within the tileset
*/
vec3 getTileUv(in vec3 shapePosition, in ivec4 octreeCoords) {
	// PERFORMANCE_IDEA: use bit-shifting (only in WebGL2)
    float dimAtLevel = exp2(float(octreeCoords.w));
    return shapePosition * dimAtLevel - vec3(octreeCoords.xyz);
}

vec3 getClampedTileUv(in vec3 shapePosition, in ivec4 octreeCoords) {
    vec3 tileUv = getTileUv(shapePosition, octreeCoords);
    return clamp(tileUv, vec3(0.0), vec3(1.0));
}

void getOctreeLeafSampleData(in OctreeNodeData data, in ivec4 octreeCoords, out SampleData sampleData) {
    sampleData.megatextureIndex = data.data;
    sampleData.tileCoords = (data.flag == OCTREE_FLAG_PACKED_LEAF_FROM_PARENT)
        ? ivec4(octreeCoords.xyz / 2, octreeCoords.w - 1)
        : octreeCoords;
}

#if (SAMPLE_COUNT > 1)
void getOctreeLeafSampleDatas(in OctreeNodeData data, in ivec4 octreeCoords, out SampleData sampleDatas[SAMPLE_COUNT]) {
    int leafIndex = data.data;
    int leafNodeTexelCount = 2;
    // Adding 0.5 moves to the center of the texel
    float leafCoordXStart = float(intMod(leafIndex, u_octreeLeafNodeTilesPerRow) * leafNodeTexelCount) + 0.5;
    float leafCoordY = float(leafIndex / u_octreeLeafNodeTilesPerRow) + 0.5;

    // Get an interpolation weight and a flag to determine whether to read the parent texture
    vec2 leafUv0 = u_octreeLeafNodeTexelSizeUv * vec2(leafCoordXStart + 0.0, leafCoordY);
    vec4 leafData0 = texture(u_octreeLeafNodeTexture, leafUv0);
    float lerp = normU8x2_toFloat(leafData0.xy);
    sampleDatas[0].weight = 1.0 - lerp;
    sampleDatas[1].weight = lerp;
    // TODO: this looks wrong? Should be comparing to OCTREE_FLAG_PACKED_LEAF_FROM_PARENT
    sampleDatas[0].tileCoords = (normU8_toInt(leafData0.z) == 1)
        ? ivec4(octreeCoords.xyz / 2, octreeCoords.w - 1)
        : octreeCoords;
    sampleDatas[1].tileCoords = (normU8_toInt(leafData0.w) == 1)
        ? ivec4(octreeCoords.xyz / 2, octreeCoords.w - 1)
        : octreeCoords;

    // Get megatexture indices for both samples
    vec2 leafUv1 = u_octreeLeafNodeTexelSizeUv * vec2(leafCoordXStart + 1.0, leafCoordY);
    vec4 leafData1 = texture(u_octreeLeafNodeTexture, leafUv1);
    sampleDatas[0].megatextureIndex = normU8x2_toInt(leafData1.xy);
    sampleDatas[1].megatextureIndex = normU8x2_toInt(leafData1.zw);
}
#endif

OctreeNodeData traverseOctreeDownwards(in vec3 shapePosition, inout TraversalData traversalData) {
    float sizeAtLevel = exp2(-1.0 * float(traversalData.octreeCoords.w));
    vec3 start = vec3(traversalData.octreeCoords.xyz) * sizeAtLevel;
    vec3 end = start + vec3(sizeAtLevel);
    OctreeNodeData childData;

    for (int i = 0; i < OCTREE_MAX_LEVELS; ++i) {
        // Find out which octree child contains the position
        // 0 if before center, 1 if after
        vec3 center = 0.5 * (start + end);
        vec3 childCoord = step(center, shapePosition);

        // Get octree coords for the next level down
        ivec4 octreeCoords = traversalData.octreeCoords;
        traversalData.octreeCoords = ivec4(octreeCoords.xyz * 2 + ivec3(childCoord), octreeCoords.w + 1);

        childData = getOctreeChildData(traversalData.parentOctreeIndex, ivec3(childCoord));

        if (childData.flag != OCTREE_FLAG_INTERNAL) {
            // leaf tile - stop traversing
            break;
        }

        // interior tile - keep going deeper
        start = mix(start, center, childCoord);
        end = mix(center, end, childCoord);
        traversalData.parentOctreeIndex = childData.data;
    }

    return childData;
}

/**
* Transform a given position to an octree tile coordinate and a position within that tile,
* and find the corresponding megatexture index and texture coordinates
*/
void traverseOctreeFromBeginning(in vec3 shapePosition, out TraversalData traversalData, out SampleData sampleDatas[SAMPLE_COUNT]) {
    traversalData.octreeCoords = ivec4(0);
    traversalData.parentOctreeIndex = 0;

    OctreeNodeData nodeData = getOctreeNodeData(vec2(0.0));
    if (nodeData.flag != OCTREE_FLAG_LEAF) {
        nodeData = traverseOctreeDownwards(shapePosition, traversalData);
    }

    #if (SAMPLE_COUNT == 1)
        getOctreeLeafSampleData(nodeData, traversalData.octreeCoords, sampleDatas[0]);
        sampleDatas[0].tileUv = getClampedTileUv(shapePosition, sampleDatas[0].tileCoords);
    #else
        getOctreeLeafSampleDatas(nodeData, traversalData.octreeCoords, sampleDatas);
        sampleDatas[0].tileUv = getClampedTileUv(shapePosition, sampleDatas[0].tileCoords);
        sampleDatas[1].tileUv = getClampedTileUv(shapePosition, sampleDatas[1].tileCoords);
    #endif
}

bool inRange(in vec3 v, in vec3 minVal, in vec3 maxVal) {
    return clamp(v, minVal, maxVal) == v;
}

bool insideTile(in vec3 shapePosition, in ivec4 octreeCoords) {
    vec3 tileUv = getTileUv(shapePosition, octreeCoords);
	bool inside = inRange(tileUv, vec3(0.0), vec3(1.0));
	// Assume (!) the position is always inside the root tile.
	return inside || octreeCoords.w == 0;
}

void traverseOctreeFromExisting(in vec3 shapePosition, inout TraversalData traversalData, inout SampleData sampleDatas[SAMPLE_COUNT]) {
    if (insideTile(shapePosition, traversalData.octreeCoords)) {
        for (int i = 0; i < SAMPLE_COUNT; i++) {
            sampleDatas[0].tileUv = getClampedTileUv(shapePosition, sampleDatas[0].tileCoords);
        }
        return;
    }

    // Go up tree until we find a parent tile containing shapePosition
    for (int i = 0; i < OCTREE_MAX_LEVELS; ++i) {
        traversalData.octreeCoords.xyz /= 2;
        traversalData.octreeCoords.w -= 1;

        if (insideTile(shapePosition, traversalData.octreeCoords)) {
            break;
        }

        traversalData.parentOctreeIndex = getOctreeParentIndex(traversalData.parentOctreeIndex);
    }

    // Go down tree
    OctreeNodeData nodeData = traverseOctreeDownwards(shapePosition, traversalData);

    #if (SAMPLE_COUNT == 1)
        getOctreeLeafSampleData(nodeData, traversalData.octreeCoords, sampleDatas[0]);
        sampleDatas[0].tileUv = getClampedTileUv(shapePosition, sampleDatas[0].tileCoords);
    #else
        getOctreeLeafSampleDatas(nodeData, traversalData.octreeCoords, sampleDatas);
        sampleDatas[0].tileUv = getClampedTileUv(shapePosition, sampleDatas[0].tileCoords);
        sampleDatas[1].tileUv = getClampedTileUv(shapePosition, sampleDatas[1].tileCoords);
    #endif
}
`,Megatexture$1=`// See Octree.glsl for the definitions of SampleData and intMod

/* Megatexture defines (set in Scene/VoxelRenderResources.js)
#define SAMPLE_COUNT ###
#define NEAREST_SAMPLING
#define PADDING
*/

uniform ivec2 u_megatextureSliceDimensions; // number of slices per tile, in two dimensions
uniform ivec2 u_megatextureTileDimensions; // number of tiles per megatexture, in two dimensions
uniform vec2 u_megatextureVoxelSizeUv;
uniform vec2 u_megatextureSliceSizeUv;
uniform vec2 u_megatextureTileSizeUv;

uniform ivec3 u_dimensions; // does not include padding
#if defined(PADDING)
    uniform ivec3 u_paddingBefore;
    uniform ivec3 u_paddingAfter;
#endif

// Integer min, max, clamp: For WebGL1 only
int intMin(int a, int b) {
    return a <= b ? a : b;
}
int intMax(int a, int b) {
    return a >= b ? a : b;
}
int intClamp(int v, int minVal, int maxVal) {
    return intMin(intMax(v, minVal), maxVal);
}

vec2 index1DTo2DTexcoord(int index, ivec2 dimensions, vec2 uvScale)
{
    int indexX = intMod(index, dimensions.x);
    int indexY = index / dimensions.x;
    return vec2(indexX, indexY) * uvScale;
}

/*
    How is 3D data stored in a 2D megatexture?

    In this example there is only one loaded tile and it has 2x2x2 voxels (8 voxels total).
    The data is sliced by Z. The data at Z = 0 is placed in texels (0,0), (0,1), (1,0), (1,1) and
    the data at Z = 1 is placed in texels (2,0), (2,1), (3,0), (3,1).
    Note that there could be empty space in the megatexture because it's a power of two.

      0   1   2   3
    +---+---+---+---+
    |   |   |   |   | 3
    +---+---+---+---+
    |   |   |   |   | 2
    +-------+-------+
    |010|110|011|111| 1
    |--- ---|--- ---|
    |000|100|001|101| 0
    +-------+-------+

    When doing linear interpolation the megatexture needs to be sampled twice: once for
    the Z slice above the voxel coordinate and once for the slice below. The two slices
    are interpolated with fract(coord.z - 0.5). For example, a Z coordinate of 1.0 is
    halfway between two Z slices so the interpolation factor is 0.5. Below is a side view
    of the 3D voxel grid with voxel coordinates on the left side.

    2 +---+
      |001|
    1 +-z-+
      |000|
    0 +---+

    When doing nearest neighbor the megatexture only needs to be sampled once at the closest Z slice.
*/

Properties getPropertiesFromMegatexture(in SampleData sampleData) {
    int tileIndex = sampleData.megatextureIndex;
    vec3 voxelCoord = sampleData.tileUv * vec3(u_dimensions);
    ivec3 voxelDimensions = u_dimensions;

    #if defined(PADDING)
        voxelDimensions += u_paddingBefore + u_paddingAfter;
        voxelCoord += vec3(u_paddingBefore);
    #endif

    #if defined(NEAREST_SAMPLING)
        // Round to the center of the nearest voxel
        voxelCoord = floor(voxelCoord) + vec3(0.5);
    #endif

    // Tile location
    vec2 tileUvOffset = index1DTo2DTexcoord(tileIndex, u_megatextureTileDimensions, u_megatextureTileSizeUv);

    // Slice location
    float slice = voxelCoord.z - 0.5;
    int sliceIndex = int(floor(slice));
    int sliceIndex0 = intClamp(sliceIndex, 0, voxelDimensions.z - 1);
    vec2 sliceUvOffset0 = index1DTo2DTexcoord(sliceIndex0, u_megatextureSliceDimensions, u_megatextureSliceSizeUv);

    // Voxel location
    vec2 voxelUvOffset = clamp(voxelCoord.xy, vec2(0.5), vec2(voxelDimensions.xy) - vec2(0.5)) * u_megatextureVoxelSizeUv;

    // Final location in the megatexture
    vec2 uv0 = tileUvOffset + sliceUvOffset0 + voxelUvOffset;

    #if defined(NEAREST_SAMPLING)
        return getPropertiesFromMegatextureAtUv(uv0);
    #else
        float sliceLerp = fract(slice);
        int sliceIndex1 = intMin(sliceIndex + 1, voxelDimensions.z - 1);
        vec2 sliceUvOffset1 = index1DTo2DTexcoord(sliceIndex1, u_megatextureSliceDimensions, u_megatextureSliceSizeUv);
        vec2 uv1 = tileUvOffset + sliceUvOffset1 + voxelUvOffset;
        Properties properties0 = getPropertiesFromMegatextureAtUv(uv0);
        Properties properties1 = getPropertiesFromMegatextureAtUv(uv1);
        return mixProperties(properties0, properties1, sliceLerp);
    #endif
}

// Convert an array of sample datas to a final weighted properties.
Properties accumulatePropertiesFromMegatexture(in SampleData sampleDatas[SAMPLE_COUNT]) {
    #if (SAMPLE_COUNT == 1)
        return getPropertiesFromMegatexture(sampleDatas[0]);
    #else
        // When more than one sample is taken the accumulator needs to start at 0
        Properties properties = clearProperties();
        for (int i = 0; i < SAMPLE_COUNT; ++i) {
            float weight = sampleDatas[i].weight;

            // Avoid reading the megatexture when the weight is 0 as it can be costly.
            if (weight > 0.0) {
                Properties tempProperties = getPropertiesFromMegatexture(sampleDatas[i]);
                tempProperties = scaleProperties(tempProperties, weight);
                properties = sumProperties(properties, tempProperties);
            }
        }
        return properties;
    #endif
}
`;function VoxelRenderResources(e){const t=new ShaderBuilder;this.shaderBuilder=t;const n=e._customShader,i=combine$2(e._uniformMap,n.uniformMap);e._uniformMap=i;const r=n.uniforms;for(const f in r)if(r.hasOwnProperty(f)){const p=r[f];t.addUniform(p.type,f,ShaderDestination.FRAGMENT)}t.addUniform("sampler2D","u_megatextureTextures[METADATA_COUNT]",ShaderDestination.FRAGMENT),this.uniformMap=i;const o=e._clippingPlanes,a=defined(o)&&o.enabled?o.length:0;this.clippingPlanes=o,this.clippingPlanesLength=a,t.addVertexLines([VoxelVS]),t.addFragmentLines([n.fragmentShaderText,"#line 0",Octree,VoxelUtils,IntersectionUtils,Megatexture$1]),a>0&&(t.addDefine("CLIPPING_PLANES",void 0,ShaderDestination.FRAGMENT),t.addDefine("CLIPPING_PLANES_COUNT",a,ShaderDestination.FRAGMENT),o.unionClippingRegions&&t.addDefine("CLIPPING_PLANES_UNION",void 0,ShaderDestination.FRAGMENT),t.addFragmentLines([IntersectClippingPlanes])),e._depthTest&&(t.addDefine("DEPTH_TEST",void 0,ShaderDestination.FRAGMENT),t.addFragmentLines([IntersectDepth]));const s=e._provider.shape;s==="BOX"?t.addFragmentLines([convertUvToBox,IntersectBox,Intersection]):s==="CYLINDER"?t.addFragmentLines([convertUvToCylinder,IntersectLongitude,IntersectCylinder,Intersection]):s==="ELLIPSOID"&&(t.addDefine("SHAPE_ELLIPSOID",void 0,ShaderDestination.FRAGMENT),t.addFragmentLines([convertUvToEllipsoid,IntersectLongitude,IntersectEllipsoid,Intersection])),t.addFragmentLines([VoxelFS]);const l=e._shape,c=l.shaderDefines;for(const f in c)if(c.hasOwnProperty(f)){let p=c[f];defined(p)&&(p=p===!0?void 0:p,t.addDefine(f,p,ShaderDestination.FRAGMENT))}let d=l.shaderMaximumIntersectionsLength;a>0&&(t.addDefine("CLIPPING_PLANES_INTERSECTION_INDEX",d,ShaderDestination.FRAGMENT),a===1?d+=1:o.unionClippingRegions?d+=2:d+=1),e._depthTest&&(t.addDefine("DEPTH_INTERSECTION_INDEX",d,ShaderDestination.FRAGMENT),d+=1),t.addDefine("INTERSECTION_COUNT",d,ShaderDestination.FRAGMENT),(!Cartesian3.equals(e.paddingBefore,Cartesian3.ZERO)||!Cartesian3.equals(e.paddingAfter,Cartesian3.ZERO))&&t.addDefine("PADDING",void 0,ShaderDestination.FRAGMENT),e._useLogDepth&&t.addDefine("LOG_DEPTH_READ_ONLY",void 0,ShaderDestination.FRAGMENT),e._jitter&&t.addDefine("JITTER",void 0,ShaderDestination.FRAGMENT),e._nearestSampling&&t.addDefine("NEAREST_SAMPLING",void 0,ShaderDestination.FRAGMENT);const h=e._traversal;t.addDefine("SAMPLE_COUNT",`${h._sampleCount}`,ShaderDestination.FRAGMENT)}function processVoxelProperties(e,t){const{shaderBuilder:n}=e,{names:i,types:r,componentTypes:o,minimumValues:a,maximumValues:s}=t._provider,l=r.length,c=defined(a)&&defined(s);n.addDefine("METADATA_COUNT",l,ShaderDestination.FRAGMENT),c&&n.addDefine("STATISTICS",void 0,ShaderDestination.FRAGMENT);for(let I=0;I<l;I++){const L=i[I],N=r[I],y=`PropertyStatistics_${L}`,x=`PropertyStatistics_${L}`;n.addStruct(y,x,ShaderDestination.FRAGMENT);const T=getGlslType(N);n.addStructField(y,T,"min"),n.addStructField(y,T,"max")}const d="Statistics",h="Statistics",f="statistics";n.addStruct(d,h,ShaderDestination.FRAGMENT);for(let I=0;I<l;I++){const L=i[I],N=`PropertyStatistics_${L}`,y=L;n.addStructField(d,N,y)}const p="Metadata",u="Metadata",m="metadata";n.addStruct(p,u,ShaderDestination.FRAGMENT),n.addStructField(p,h,f);for(let I=0;I<l;I++){const L=i[I],N=r[I],y=getGlslType(N);n.addStructField(p,y,L)}for(let I=0;I<l;I++){const L=i[I],N=r[I],y=getGlslPartialDerivativeType(N),x=`VoxelProperty_${L}`,T=`VoxelProperty_${L}`;n.addStruct(x,T,ShaderDestination.FRAGMENT),n.addStructField(x,y,"partialDerivativeLocal"),n.addStructField(x,y,"partialDerivativeWorld"),n.addStructField(x,y,"partialDerivativeView"),n.addStructField(x,y,"partialDerivativeValid")}const g="Voxel",_="Voxel",C="voxel";n.addStruct(g,_,ShaderDestination.FRAGMENT);for(let I=0;I<l;I++){const L=i[I],N=`VoxelProperty_${L}`;n.addStructField(g,N,L)}n.addStructField(g,"vec3","positionEC"),n.addStructField(g,"vec3","positionUv"),n.addStructField(g,"vec3","positionShapeUv"),n.addStructField(g,"vec3","positionUvLocal"),n.addStructField(g,"vec3","viewDirUv"),n.addStructField(g,"vec3","viewDirWorld"),n.addStructField(g,"vec3","surfaceNormal"),n.addStructField(g,"float","travelDistance"),n.addStructField(g,"int","stepCount"),n.addStructField(g,"int","tileIndex"),n.addStructField(g,"int","sampleIndex");const A="FragmentInput";n.addStruct(A,"FragmentInput",ShaderDestination.FRAGMENT),n.addStructField(A,u,m),n.addStructField(A,_,C);const v="Properties",b="Properties",D="properties";n.addStruct(v,b,ShaderDestination.FRAGMENT);for(let I=0;I<l;I++){const L=i[I],N=r[I],y=getGlslType(N);n.addStructField(v,y,L)}{const I="clearProperties";n.addFunction(I,`${b} clearProperties()`,ShaderDestination.FRAGMENT),n.addFunctionLines(I,[`${b} ${D};`]);for(let L=0;L<l;L++){const N=i[L],y=r[L];o[L];const x=getGlslType(y);n.addFunctionLines(I,[`${D}.${N} = ${x}(0.0);`])}n.addFunctionLines(I,[`return ${D};`])}{const I="sumProperties";n.addFunction(I,`${b} sumProperties(${b} propertiesA, ${b} propertiesB)`,ShaderDestination.FRAGMENT),n.addFunctionLines(I,[`${b} ${D};`]);for(let L=0;L<l;L++){const N=i[L];n.addFunctionLines(I,[`${D}.${N} = propertiesA.${N} + propertiesB.${N};`])}n.addFunctionLines(I,[`return ${D};`])}{const I="scaleProperties";n.addFunction(I,`${b} scaleProperties(${b} ${D}, float scale)`,ShaderDestination.FRAGMENT),n.addFunctionLines(I,[`${b} scaledProperties = ${D};`]);for(let L=0;L<l;L++){const N=i[L];n.addFunctionLines(I,[`scaledProperties.${N} *= scale;`])}n.addFunctionLines(I,["return scaledProperties;"])}{const I="mixProperties";n.addFunction(I,`${b} mixProperties(${b} propertiesA, ${b} propertiesB, float mixFactor)`,ShaderDestination.FRAGMENT),n.addFunctionLines(I,[`${b} ${D};`]);for(let L=0;L<l;L++){const N=i[L];n.addFunctionLines(I,[`${D}.${N} = mix(propertiesA.${N}, propertiesB.${N}, mixFactor);`])}n.addFunctionLines(I,[`return ${D};`])}{const I="copyPropertiesToMetadata";n.addFunction(I,`void copyPropertiesToMetadata(in ${b} ${D}, inout ${u} ${m})`,ShaderDestination.FRAGMENT);for(let L=0;L<l;L++){const N=i[L];n.addFunctionLines(I,[`${m}.${N} = ${D}.${N};`])}}if(c){const I="setStatistics";n.addFunction(I,`void setStatistics(inout ${h} ${f})`,ShaderDestination.FRAGMENT);for(let L=0;L<l;L++){const N=i[L],y=r[L],x=MetadataType.getComponentCount(y);for(let T=0;T<x;T++){const E=getGlslField(y,T),P=a[L][T],M=s[L][T];n.addFunctionLines(I,[`${f}.${N}.min${E} = ${getGlslNumberAsFloat(P)};`,`${f}.${N}.max${E} = ${getGlslNumberAsFloat(M)};`])}}}{const I="getPropertiesFromMegatextureAtUv";n.addFunction(I,`${b} getPropertiesFromMegatextureAtUv(vec2 texcoord)`,ShaderDestination.FRAGMENT),n.addFunctionLines(I,[`${b} ${D};`]);for(let L=0;L<l;L++){const N=i[L],y=r[L];o[L];const x=getGlslTextureSwizzle(y);n.addFunctionLines(I,[`properties.${N} = texture(u_megatextureTextures[${L}], texcoord)${x};`])}n.addFunctionLines(I,[`return ${D};`])}}function getGlslType(e){if(e===MetadataType.SCALAR)return"float";if(e===MetadataType.VEC2)return"vec2";if(e===MetadataType.VEC3)return"vec3";if(e===MetadataType.VEC4)return"vec4"}function getGlslTextureSwizzle(e){if(e===MetadataType.SCALAR)return".r";if(e===MetadataType.VEC2)return".ra";if(e===MetadataType.VEC3)return".rgb";if(e===MetadataType.VEC4)return""}function getGlslPartialDerivativeType(e){if(e===MetadataType.SCALAR)return"vec3";if(e===MetadataType.VEC2)return"mat2";if(e===MetadataType.VEC3)return"mat3";if(e===MetadataType.VEC4)return"mat4"}function getGlslNumberAsFloat(e){let t=e.toString();return t.indexOf(".")===-1&&(t=`${e}.0`),t}function getGlslField(e,t){return e===MetadataType.SCALAR?"":`[${t}]`}function buildVoxelDrawCommands(e,t){const n=new VoxelRenderResources(e);processVoxelProperties(n,e);const{shaderBuilder:i,clippingPlanes:r,clippingPlanesLength:o}=n;if(o>0){const _="getClippingPlane",C=getClippingFunction(r,t),A=0,S=C.indexOf(")")+1,v=C.indexOf("{",S)+1,b=C.indexOf("}",v),D=C.slice(A,S),I=C.slice(v,b);i.addFunction(_,D,ShaderDestination.FRAGMENT),i.addFunctionLines(_,[I])}const a=i.clone();a.addDefine("PICKING",void 0,ShaderDestination.FRAGMENT);const s=i.clone();s.addDefine("PICKING_VOXEL",void 0,ShaderDestination.FRAGMENT);const l=i.buildShaderProgram(t),c=a.buildShaderProgram(t),d=s.buildShaderProgram(t),h=RenderState.fromCache({cull:{enabled:!0,face:CullFace.BACK},depthTest:{enabled:!1},depthMask:!1,blending:BlendingState.PRE_MULTIPLIED_ALPHA_BLEND}),f=t.getViewportQuadVertexArray(),p=e._depthTest,u=new DrawCommand({vertexArray:f,primitiveType:PrimitiveType.TRIANGLES,renderState:h,shaderProgram:l,uniformMap:n.uniformMap,modelMatrix:e._compoundModelMatrix,pass:Pass.VOXELS,executeInClosestFrustum:!0,owner:this,cull:p,occlude:p}),m=DrawCommand.shallowClone(u,new DrawCommand);m.shaderProgram=c,m.pickOnly=!0;const g=DrawCommand.shallowClone(u,new DrawCommand);if(g.shaderProgram=d,g.pickOnly=!0,defined(e._drawCommand)){const _=e._drawCommand;_.shaderProgram=_.shaderProgram&&_.shaderProgram.destroy()}if(defined(e._drawCommandPick)){const _=e._drawCommandPick;_.shaderProgram=_.shaderProgram&&_.shaderProgram.destroy()}if(defined(e._drawCommandPickVoxel)){const _=e._drawCommandPickVoxel;_.shaderProgram=_.shaderProgram&&_.shaderProgram.destroy()}e._drawCommand=u,e._drawCommandPick=m,e._drawCommandPickVoxel=g}function VoxelBoxShape(){this.orientedBoundingBox=new OrientedBoundingBox,this.boundingSphere=new BoundingSphere,this.boundTransform=new Matrix4,this.shapeTransform=new Matrix4,this._minBounds=Cartesian3.clone(VoxelBoxShape.DefaultMinBounds,new Cartesian3),this._maxBounds=Cartesian3.clone(VoxelBoxShape.DefaultMaxBounds,new Cartesian3),this.shaderUniforms={renderMinBounds:new Cartesian3,renderMaxBounds:new Cartesian3,boxUvToShapeUvScale:new Cartesian3,boxUvToShapeUvTranslate:new Cartesian3},this.shaderDefines={BOX_INTERSECTION_INDEX:void 0,BOX_HAS_SHAPE_BOUNDS:void 0},this.shaderMaximumIntersectionsLength=0}const scratchCenter=new Cartesian3,scratchScale$5=new Cartesian3,scratchRotation$3=new Matrix3,scratchClipMinBounds$1=new Cartesian3,scratchClipMaxBounds$1=new Cartesian3,scratchRenderMinBounds$1=new Cartesian3,scratchRenderMaxBounds$1=new Cartesian3,transformLocalToUv=Matrix4.fromRotationTranslation(Matrix3.fromUniformScale(.5,new Matrix3),new Cartesian3(.5,.5,.5),new Matrix4);VoxelBoxShape.prototype.update=function(e,t,n,i,r){i=defaultValue(i,VoxelBoxShape.DefaultMinBounds),r=defaultValue(r,VoxelBoxShape.DefaultMaxBounds),Check.typeOf.object("modelMatrix",e),Check.typeOf.object("minBounds",t),Check.typeOf.object("maxBounds",n);const o=VoxelBoxShape.DefaultMinBounds,a=VoxelBoxShape.DefaultMaxBounds;t=this._minBounds=Cartesian3.clamp(t,o,a,this._minBounds),n=this._maxBounds=Cartesian3.clamp(n,o,a,this._maxBounds),i=Cartesian3.clamp(i,o,a,scratchClipMinBounds$1),r=Cartesian3.clamp(r,o,a,scratchClipMaxBounds$1);const s=Cartesian3.clamp(t,i,r,scratchRenderMinBounds$1),l=Cartesian3.clamp(n,i,r,scratchRenderMaxBounds$1),c=Matrix4.getScale(e,scratchScale$5);if(s.x>l.x||s.y>l.y||s.z>l.z||(s.x===l.x)+(s.y===l.y)+(s.z===l.z)>=2||i.x>r.x||i.y>r.y||i.z>r.z||c.x===0||c.y===0||c.z===0)return!1;this.shapeTransform=Matrix4.clone(e,this.shapeTransform),this.orientedBoundingBox=getBoxChunkObb(s,l,this.shapeTransform,this.orientedBoundingBox),this.boundTransform=Matrix4.fromRotationTranslation(this.orientedBoundingBox.halfAxes,this.orientedBoundingBox.center,this.boundTransform),this.boundingSphere=BoundingSphere.fromOrientedBoundingBox(this.orientedBoundingBox,this.boundingSphere);const{shaderUniforms:d,shaderDefines:h}=this;for(const u in h)h.hasOwnProperty(u)&&(h[u]=void 0);const f=!Cartesian3.equals(t,o)||!Cartesian3.equals(n,a);let p=0;if(h.BOX_INTERSECTION_INDEX=p,p+=1,d.renderMinBounds=Matrix4.multiplyByPoint(transformLocalToUv,s,d.renderMinBounds),d.renderMaxBounds=Matrix4.multiplyByPoint(transformLocalToUv,l,d.renderMaxBounds),f){h.BOX_HAS_SHAPE_BOUNDS=!0;const u=t,m=n;d.boxUvToShapeUvScale=Cartesian3.fromElements(2/(u.x===m.x?1:m.x-u.x),2/(u.y===m.y?1:m.y-u.y),2/(u.z===m.z?1:m.z-u.z),d.boxUvToShapeUvScale),d.boxUvToShapeUvTranslate=Cartesian3.fromElements(-d.boxUvToShapeUvScale.x*(u.x*.5+.5),-d.boxUvToShapeUvScale.y*(u.y*.5+.5),-d.boxUvToShapeUvScale.z*(u.z*.5+.5),d.boxUvToShapeUvTranslate)}return this.shaderMaximumIntersectionsLength=p,!0};const scratchTileMinBounds$2=new Cartesian3,scratchTileMaxBounds$2=new Cartesian3;VoxelBoxShape.prototype.computeOrientedBoundingBoxForTile=function(e,t,n,i,r){Check.typeOf.number("tileLevel",e),Check.typeOf.number("tileX",t),Check.typeOf.number("tileY",n),Check.typeOf.number("tileZ",i),Check.typeOf.object("result",r);const o=this._minBounds,a=this._maxBounds,s=1/Math.pow(2,e),l=Cartesian3.fromElements(CesiumMath.lerp(o.x,a.x,s*t),CesiumMath.lerp(o.y,a.y,s*n),CesiumMath.lerp(o.z,a.z,s*i),scratchTileMinBounds$2),c=Cartesian3.fromElements(CesiumMath.lerp(o.x,a.x,s*(t+1)),CesiumMath.lerp(o.y,a.y,s*(n+1)),CesiumMath.lerp(o.z,a.z,s*(i+1)),scratchTileMaxBounds$2);return getBoxChunkObb(l,c,this.shapeTransform,r)};const sampleSizeScratch$2=new Cartesian3;VoxelBoxShape.prototype.computeOrientedBoundingBoxForSample=function(e,t,n,i){Check.typeOf.object("spatialNode",e),Check.typeOf.object("tileDimensions",t),Check.typeOf.object("tileUv",n),Check.typeOf.object("result",i);const r=1/Math.pow(2,e.level),o=Cartesian3.divideComponents(Cartesian3.ONE,t,sampleSizeScratch$2),a=Cartesian3.multiplyByScalar(o,r,sampleSizeScratch$2),s=Cartesian3.multiplyByScalar(Cartesian3.fromElements(e.x+n.x,e.y+n.y,e.z+n.z,scratchTileMinBounds$2),r,scratchTileMinBounds$2),l=Cartesian3.add(s,a,scratchTileMaxBounds$2),c=this._minBounds,d=this._maxBounds,h=Cartesian3.fromElements(CesiumMath.lerp(c.x,d.x,s.x),CesiumMath.lerp(c.y,d.y,s.y),CesiumMath.lerp(c.z,d.z,s.z),scratchTileMinBounds$2),f=Cartesian3.fromElements(CesiumMath.lerp(c.x,d.x,l.x),CesiumMath.lerp(c.y,d.y,l.y),CesiumMath.lerp(c.z,d.z,l.z),scratchTileMaxBounds$2);return getBoxChunkObb(h,f,this.shapeTransform,i)};VoxelBoxShape.DefaultMinBounds=Object.freeze(new Cartesian3(-1,-1,-1));VoxelBoxShape.DefaultMaxBounds=Object.freeze(new Cartesian3(1,1,1));function getBoxChunkObb(e,t,n,i){const r=VoxelBoxShape.DefaultMinBounds,o=VoxelBoxShape.DefaultMaxBounds;if(Cartesian3.equals(e,r)&&Cartesian3.equals(t,o))i.center=Matrix4.getTranslation(n,i.center),i.halfAxes=Matrix4.getMatrix3(n,i.halfAxes);else{let s=Matrix4.getScale(n,scratchScale$5);const l=Cartesian3.midpoint(e,t,scratchCenter);i.center=Matrix4.multiplyByPoint(n,l,i.center),s=Cartesian3.fromElements(s.x*.5*(t.x-e.x),s.y*.5*(t.y-e.y),s.z*.5*(t.z-e.z),scratchScale$5);const c=Matrix4.getRotation(n,scratchRotation$3);i.halfAxes=Matrix3.setScale(c,s,i.halfAxes)}return i}function VoxelCylinderShape(){this.orientedBoundingBox=new OrientedBoundingBox,this.boundingSphere=new BoundingSphere,this.boundTransform=new Matrix4,this.shapeTransform=new Matrix4,this._minimumRadius=VoxelCylinderShape.DefaultMinBounds.x,this._maximumRadius=VoxelCylinderShape.DefaultMaxBounds.x,this._minimumHeight=VoxelCylinderShape.DefaultMinBounds.y,this._maximumHeight=VoxelCylinderShape.DefaultMaxBounds.y,this._minimumAngle=VoxelCylinderShape.DefaultMinBounds.z,this._maximumAngle=VoxelCylinderShape.DefaultMaxBounds.z,this.shaderUniforms={cylinderRenderHeightMinMax:new Cartesian2,cylinderRenderRadiusMinMax:new Cartesian2,cylinderRenderAngleMinMax:new Cartesian2,cylinderUvToShapeUvRadius:new Cartesian2,cylinderUvToShapeUvHeight:new Cartesian2,cylinderUvToShapeUvAngle:new Cartesian2,cylinderShapeUvAngleMinMax:new Cartesian2,cylinderShapeUvAngleRangeZeroMid:0},this.shaderDefines={CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN:void 0,CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT:void 0,CYLINDER_HAS_RENDER_BOUNDS_ANGLE:void 0,CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO:void 0,CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF:void 0,CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF:void 0,CYLINDER_HAS_SHAPE_BOUNDS_RADIUS:void 0,CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT:void 0,CYLINDER_HAS_SHAPE_BOUNDS_ANGLE:void 0,CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY:void 0,CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY:void 0,CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED:void 0,CYLINDER_INTERSECTION_INDEX_RADIUS_MAX:void 0,CYLINDER_INTERSECTION_INDEX_RADIUS_MIN:void 0,CYLINDER_INTERSECTION_INDEX_ANGLE:void 0},this.shaderMaximumIntersectionsLength=0}const scratchScale$4=new Cartesian3;VoxelCylinderShape.prototype.update=function(e,t,n,i,r){i=defaultValue(i,VoxelCylinderShape.DefaultMinBounds),r=defaultValue(r,VoxelCylinderShape.DefaultMaxBounds),Check.typeOf.object("modelMatrix",e),Check.typeOf.object("minBounds",t),Check.typeOf.object("maxBounds",n);const o=VoxelCylinderShape.DefaultMinBounds.x,a=VoxelCylinderShape.DefaultMaxBounds.x,s=VoxelCylinderShape.DefaultMinBounds.y,l=VoxelCylinderShape.DefaultMaxBounds.y,c=VoxelCylinderShape.DefaultMinBounds.z,d=VoxelCylinderShape.DefaultMaxBounds.z,h=d-c,f=.5*h,p=CesiumMath.EPSILON10,u=CesiumMath.EPSILON3,m=CesiumMath.EPSILON10,g=CesiumMath.clamp(t.x,o,a),_=CesiumMath.clamp(n.x,o,a),C=CesiumMath.clamp(i.x,o,a),A=CesiumMath.clamp(r.x,o,a),S=Math.max(g,C),v=Math.min(_,A),b=CesiumMath.clamp(t.y,s,l),D=CesiumMath.clamp(n.y,s,l),I=CesiumMath.clamp(i.y,s,l),L=CesiumMath.clamp(r.y,s,l),N=Math.max(b,I),y=Math.min(D,L),x=CesiumMath.negativePiToPi(t.z),T=CesiumMath.negativePiToPi(n.z),E=CesiumMath.negativePiToPi(i.z),P=CesiumMath.negativePiToPi(r.z),M=Math.max(x,E),O=Math.min(T,P),V=Matrix4.getScale(e,scratchScale$4);if(v===0||S>v||N>y||CesiumMath.equalsEpsilon(V.x,0,void 0,p)||CesiumMath.equalsEpsilon(V.y,0,void 0,p)||CesiumMath.equalsEpsilon(V.z,0,void 0,p))return!1;this._minimumRadius=g,this._maximumRadius=_,this._minimumHeight=b,this._maximumHeight=D,this._minimumAngle=x,this._maximumAngle=T,this.shapeTransform=Matrix4.clone(e,this.shapeTransform),this.orientedBoundingBox=getCylinderChunkObb(S,v,N,y,M,O,this.shapeTransform,this.orientedBoundingBox),this.boundTransform=Matrix4.fromRotationTranslation(this.orientedBoundingBox.halfAxes,this.orientedBoundingBox.center,this.boundTransform),this.boundingSphere=BoundingSphere.fromOrientedBoundingBox(this.orientedBoundingBox,this.boundingSphere);const U=g===o&&_===a,k=b===s&&D===l,H=T<x,F=T-x+H*h,G=F>f+m&&F<h-m,B=F<f-m,W=F>=f-m&&F<=f+m,Y=G||B||W,z=CesiumMath.equalsEpsilon(x,c,void 0,u),X=CesiumMath.equalsEpsilon(T,d,void 0,u),q=S===o,Q=O<M,Z=O-M+Q*h,K=Z>=f-m&&Z<h-m,J=Z>m&&Z<f-m,se=Z<=m,ae=K||J||se,{shaderUniforms:te,shaderDefines:ee}=this;for(const re in ee)ee.hasOwnProperty(re)&&(ee[re]=void 0);let ce=0;if(ee.CYLINDER_INTERSECTION_INDEX_RADIUS_MAX=ce,ce+=1,q||(ee.CYLINDER_HAS_RENDER_BOUNDS_RADIUS_MIN=!0,ee.CYLINDER_INTERSECTION_INDEX_RADIUS_MIN=ce,ce+=1),te.cylinderRenderRadiusMinMax=Cartesian2.fromElements(S,v,te.cylinderRenderRadiusMinMax),S===v&&(ee.CYLINDER_HAS_RENDER_BOUNDS_RADIUS_FLAT=!0),!U){ee.CYLINDER_HAS_SHAPE_BOUNDS_RADIUS=!0;const re=_-g;let ne=0,le=1;re!==0&&(ne=1/re,le=-g/re),te.cylinderUvToShapeUvRadius=Cartesian2.fromElements(ne,le,te.cylinderUvToShapeUvRadius)}if(!k){ee.CYLINDER_HAS_SHAPE_BOUNDS_HEIGHT=!0;const re=D-b;let ne=0,le=1;re!==0&&(ne=2/re,le=-(b+1)/re),te.cylinderUvToShapeUvHeight=Cartesian2.fromElements(ne,le,te.cylinderUvToShapeUvHeight)}if(te.cylinderRenderHeightMinMax=Cartesian2.fromElements(N,y,te.cylinderRenderHeightMinMax),H&&(ee.CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_MAX_REVERSED=!0),ae&&(ee.CYLINDER_HAS_RENDER_BOUNDS_ANGLE=!0,ee.CYLINDER_INTERSECTION_INDEX_ANGLE=ce,K?(ee.CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_UNDER_HALF=!0,ce+=1):J?(ee.CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_OVER_HALF=!0,ce+=2):se&&(ee.CYLINDER_HAS_RENDER_BOUNDS_ANGLE_RANGE_EQUAL_ZERO=!0,ce+=2),te.cylinderRenderAngleMinMax=Cartesian2.fromElements(M,O,te.cylinderRenderAngleMinMax)),Y){ee.CYLINDER_HAS_SHAPE_BOUNDS_ANGLE=!0,z&&(ee.CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MIN_DISCONTINUITY=!0),X&&(ee.CYLINDER_HAS_SHAPE_BOUNDS_ANGLE_MAX_DISCONTINUITY=!0);const re=(x-c)/h,ne=(T-c)/h,le=1-F/h;if(te.cylinderShapeUvAngleMinMax=Cartesian2.fromElements(re,ne,te.cylinderShapeUvAngleMinMax),te.cylinderShapeUvAngleRangeZeroMid=(ne+.5*le)%1,F<=m)te.cylinderUvToShapeUvAngle=Cartesian2.fromElements(0,1,te.cylinderUvToShapeUvAngle);else{const $=h/F,j=-(x-c)/F;te.cylinderUvToShapeUvAngle=Cartesian2.fromElements($,j,te.cylinderUvToShapeUvAngle)}}return this.shaderMaximumIntersectionsLength=ce,!0};VoxelCylinderShape.prototype.computeOrientedBoundingBoxForTile=function(e,t,n,i,r){Check.typeOf.number("tileLevel",e),Check.typeOf.number("tileX",t),Check.typeOf.number("tileY",n),Check.typeOf.number("tileZ",i),Check.typeOf.object("result",r);const o=this._minimumRadius,a=this._maximumRadius,s=this._minimumHeight,l=this._maximumHeight,c=this._minimumAngle,d=this._maximumAngle,h=1/Math.pow(2,e),f=CesiumMath.lerp(o,a,t*h),p=CesiumMath.lerp(o,a,(t+1)*h),u=CesiumMath.lerp(s,l,n*h),m=CesiumMath.lerp(s,l,(n+1)*h),g=CesiumMath.lerp(c,d,i*h),_=CesiumMath.lerp(c,d,(i+1)*h);return getCylinderChunkObb(f,p,u,m,g,_,this.shapeTransform,r)};const sampleSizeScratch$1=new Cartesian3,scratchTileMinBounds$1=new Cartesian3,scratchTileMaxBounds$1=new Cartesian3;VoxelCylinderShape.prototype.computeOrientedBoundingBoxForSample=function(e,t,n,i){Check.typeOf.object("spatialNode",e),Check.typeOf.object("tileDimensions",t),Check.typeOf.object("tileUv",n),Check.typeOf.object("result",i);const r=1/Math.pow(2,e.level),o=Cartesian3.divideComponents(Cartesian3.ONE,t,sampleSizeScratch$1),a=Cartesian3.multiplyByScalar(o,r,sampleSizeScratch$1),s=Cartesian3.multiplyByScalar(Cartesian3.fromElements(e.x+n.x,e.y+n.y,e.z+n.z,scratchTileMinBounds$1),r,scratchTileMinBounds$1),l=Cartesian3.add(s,a,scratchTileMaxBounds$1),c=this._minimumRadius,d=this._maximumRadius,h=this._minimumHeight,f=this._maximumHeight,p=this._minimumAngle,u=this._maximumAngle,m=CesiumMath.lerp(c,d,s.x),g=CesiumMath.lerp(c,d,l.x),_=CesiumMath.lerp(h,f,s.y),C=CesiumMath.lerp(h,f,l.y),A=CesiumMath.lerp(p,u,s.z),S=CesiumMath.lerp(p,u,l.z);return getCylinderChunkObb(m,g,_,C,A,S,this.shapeTransform,i)};VoxelCylinderShape.DefaultMinBounds=Object.freeze(new Cartesian3(0,-1,-CesiumMath.PI));VoxelCylinderShape.DefaultMaxBounds=Object.freeze(new Cartesian3(1,1,+CesiumMath.PI));const maxTestAngles=5,scratchTestAngles=new Array(maxTestAngles),scratchTranslation$1=new Cartesian3,scratchRotation$2=new Matrix3,scratchTranslationMatrix=new Matrix4,scratchRotationMatrix=new Matrix4,scratchScaleMatrix=new Matrix4,scratchMatrix=new Matrix4,scratchColumn0=new Cartesian3,scratchColumn1=new Cartesian3,scratchColumn2=new Cartesian3,scratchCorners=new Array(8);for(let e=0;e<8;e++)scratchCorners[e]=new Cartesian3;function orthogonal(e,t,n){return Math.abs(Cartesian4.dot(e,t))<n}function isValidOrientedBoundingBoxTransformation(e){const t=Matrix4.getColumn(e,0,scratchColumn0),n=Matrix4.getColumn(e,1,scratchColumn1),i=Matrix4.getColumn(e,2,scratchColumn2),r=CesiumMath.EPSILON4;return orthogonal(t,n,r)&&orthogonal(n,i,r)}function computeLooseOrientedBoundingBox(e,t){const n=scratchCorners;Cartesian3.fromElements(-.5,-.5,-.5,n[0]),Cartesian3.fromElements(-.5,-.5,.5,n[1]),Cartesian3.fromElements(-.5,.5,-.5,n[2]),Cartesian3.fromElements(-.5,.5,.5,n[3]),Cartesian3.fromElements(.5,-.5,-.5,n[4]),Cartesian3.fromElements(.5,-.5,.5,n[5]),Cartesian3.fromElements(.5,.5,-.5,n[6]),Cartesian3.fromElements(.5,.5,.5,n[7]);for(let i=0;i<8;++i)Matrix4.multiplyByPoint(e,n[i],n[i]);return OrientedBoundingBox.fromPoints(n,t)}function getCylinderChunkObb(e,t,n,i,r,o,a,s){const l=VoxelCylinderShape.DefaultMinBounds,c=VoxelCylinderShape.DefaultMaxBounds,d=l.x,h=c.x,f=l.y,p=c.y,u=l.z,m=c.z;if(e===d&&t===h&&n===f&&i===p&&r===u&&o===m)return s.center=Matrix4.getTranslation(a,s.center),s.halfAxes=Matrix4.getMatrix3(a,s.halfAxes),s;o<r&&(o+=CesiumMath.TWO_PI);const _=o-r,C=r+_*.5,A=scratchTestAngles;let S=0;A[S++]=r,A[S++]=o,A[S++]=C,_>CesiumMath.PI&&(A[S++]=C-CesiumMath.PI_OVER_TWO,A[S++]=C+CesiumMath.PI_OVER_TWO);let v=1,b=1,D=-1,I=-1;for(let H=0;H<S;++H){const F=A[H]-C,G=Math.cos(F),B=Math.sin(F),W=G*e,Y=B*e,z=G*t,X=B*t;v=Math.min(v,W),b=Math.min(b,Y),v=Math.min(v,z),b=Math.min(b,X),D=Math.max(D,W),I=Math.max(I,Y),D=Math.max(D,z),I=Math.max(I,X)}const L=D-v,N=I-b,y=i-n,x=(v+D)*.5,T=(b+I)*.5,E=(n+i)*.5,P=Cartesian3.fromElements(x,T,E,scratchTranslation$1),M=Matrix3.fromRotationZ(C,scratchRotation$2),O=Cartesian3.fromElements(L,N,y,scratchScale$4),V=Matrix4.fromScale(O,scratchScaleMatrix),R=Matrix4.fromRotation(M,scratchRotationMatrix),w=Matrix4.fromTranslation(P,scratchTranslationMatrix),U=Matrix4.multiplyTransformation(R,Matrix4.multiplyTransformation(w,V,scratchMatrix),scratchMatrix),k=Matrix4.multiplyTransformation(a,U,scratchMatrix);return isValidOrientedBoundingBoxTransformation(k)?OrientedBoundingBox.fromTransformation(k,s):computeLooseOrientedBoundingBox(k,s)}function VoxelEllipsoidShape(){this.orientedBoundingBox=new OrientedBoundingBox,this.boundingSphere=new BoundingSphere,this.boundTransform=new Matrix4,this.shapeTransform=new Matrix4,this._rectangle=new Rectangle,this._minimumHeight=VoxelEllipsoidShape.DefaultMinBounds.z,this._maximumHeight=VoxelEllipsoidShape.DefaultMaxBounds.z,this._ellipsoid=new Ellipsoid,this._translation=new Cartesian3,this._rotation=new Matrix3,this.shaderUniforms={ellipsoidRadiiUv:new Cartesian3,eccentricitySquared:0,evoluteScale:new Cartesian2,ellipsoidInverseRadiiSquaredUv:new Cartesian3,ellipsoidRenderLongitudeMinMax:new Cartesian2,ellipsoidShapeUvLongitudeMinMaxMid:new Cartesian3,ellipsoidUvToShapeUvLongitude:new Cartesian2,ellipsoidUvToShapeUvLatitude:new Cartesian2,ellipsoidRenderLatitudeSinMinMax:new Cartesian2,ellipsoidInverseHeightDifferenceUv:0,clipMinMaxHeight:new Cartesian2},this.shaderDefines={ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE:void 0,ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO:void 0,ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF:void 0,ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF:void 0,ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY:void 0,ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY:void 0,ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE:void 0,ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED:void 0,ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF:void 0,ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF:void 0,ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF:void 0,ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF:void 0,ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF:void 0,ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF:void 0,ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE:void 0,ELLIPSOID_INTERSECTION_INDEX_LONGITUDE:void 0,ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX:void 0,ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN:void 0,ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX:void 0,ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN:void 0},this.shaderMaximumIntersectionsLength=0}const scratchActualMinBounds=new Cartesian3,scratchShapeMinBounds=new Cartesian3,scratchShapeMaxBounds=new Cartesian3,scratchClipMinBounds=new Cartesian3,scratchClipMaxBounds=new Cartesian3,scratchRenderMinBounds=new Cartesian3,scratchRenderMaxBounds=new Cartesian3,scratchScale$3=new Cartesian3,scratchRotationScale=new Matrix3,scratchShapeOuterExtent=new Cartesian3,scratchRenderOuterExtent=new Cartesian3,scratchRenderRectangle=new Rectangle;VoxelEllipsoidShape.prototype.update=function(e,t,n,i,r){const{DefaultMinBounds:o,DefaultMaxBounds:a}=VoxelEllipsoidShape;i=defaultValue(i,o),r=defaultValue(r,a),Check.typeOf.object("modelMatrix",e),Check.typeOf.object("minBounds",t),Check.typeOf.object("maxBounds",n);const s=CesiumMath.EPSILON10,l=CesiumMath.EPSILON3,c=CesiumMath.EPSILON10,d=CesiumMath.EPSILON10,h=CesiumMath.EPSILON3,f=Matrix4.getScale(e,scratchScale$3),p=Cartesian3.clone(o,scratchActualMinBounds);p.z=-Cartesian3.minimumComponent(f);const u=Cartesian3.clamp(t,p,a,scratchShapeMinBounds),m=Cartesian3.clamp(n,p,a,scratchShapeMaxBounds),g=Cartesian3.clamp(i,p,a,scratchClipMinBounds),_=Cartesian3.clamp(r,p,a,scratchClipMaxBounds),C=Cartesian3.maximumByComponent(u,g,scratchRenderMinBounds),A=Cartesian3.minimumByComponent(m,_,scratchRenderMaxBounds),S=Cartesian3.add(f,Cartesian3.fromElements(m.z,m.z,m.z,scratchShapeOuterExtent),scratchShapeOuterExtent),v=Cartesian3.maximumComponent(S),b=Cartesian3.add(f,Cartesian3.fromElements(A.z,A.z,A.z,scratchRenderOuterExtent),scratchRenderOuterExtent);if(C.y>A.y||C.y===a.y||A.y===o.y||C.z>A.z||CesiumMath.equalsEpsilon(b,Cartesian3.ZERO,void 0,s))return!1;this._rectangle=Rectangle.fromRadians(u.x,u.y,m.x,m.y),this._translation=Matrix4.getTranslation(e,this._translation),this._rotation=Matrix4.getRotation(e,this._rotation),this._ellipsoid=Ellipsoid.fromCartesian3(f,this._ellipsoid),this._minimumHeight=u.z,this._maximumHeight=m.z;const D=Rectangle.fromRadians(C.x,C.y,A.x,A.y,scratchRenderRectangle);this.orientedBoundingBox=getEllipsoidChunkObb(D,C.z,A.z,this._ellipsoid,this._translation,this._rotation,this.orientedBoundingBox),this.shapeTransform=Matrix4.fromRotationTranslation(Matrix3.setScale(this._rotation,S,scratchRotationScale),this._translation,this.shapeTransform),this.boundTransform=Matrix4.fromRotationTranslation(this.orientedBoundingBox.halfAxes,this.orientedBoundingBox.center,this.boundTransform),this.boundingSphere=BoundingSphere.fromOrientedBoundingBox(this.orientedBoundingBox,this.boundingSphere);const I=a.x-o.x,L=.5*I,N=A.x<C.x,y=A.x-C.x+N*I,x=y<=c,T=y>=L-c&&y<I-c,E=y>c&&y<L-c,P=x||T||E,M=m.x<u.x,O=m.x-u.x+M*I,V=O>L+c&&O<I-c,R=O>=L-c&&O<=L+c,w=O<L-c,U=V||R||w,k=A.y<-h,H=A.y>=-h&&A.y<=+h,F=A.y>+h&&A.y<a.y-d,G=k||H||F,B=C.y>o.y+d&&C.y<-h,W=C.y>=-h&&C.y<=+h,Y=C.y>+h,z=B||W||Y,X=G||z,q=m.y-u.y,Q=m.y<-h,Z=m.y>=-h&&m.y<=+h,K=m.y>+h&&m.y<a.y-d,J=Q||Z||K,se=u.y>o.y+d&&u.y<-h,ae=u.y>=-h&&u.y<=+h,te=u.y>+h,ce=J||(se||ae||te),{shaderUniforms:re,shaderDefines:ne}=this;for(const de in ne)ne.hasOwnProperty(de)&&(ne[de]=void 0);re.ellipsoidRadiiUv=Cartesian3.divideByScalar(S,v,re.ellipsoidRadiiUv);const{x:le,z:$}=re.ellipsoidRadiiUv,j=$/le;re.eccentricitySquared=1-j*j,re.evoluteScale=Cartesian2.fromElements((le*le-$*$)/le,($*$-le*le)/$,re.evoluteScale),re.ellipsoidInverseRadiiSquaredUv=Cartesian3.divideComponents(Cartesian3.ONE,Cartesian3.multiplyComponents(re.ellipsoidRadiiUv,re.ellipsoidRadiiUv,re.ellipsoidInverseRadiiSquaredUv),re.ellipsoidInverseRadiiSquaredUv);let oe=0;ne.ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MAX=oe,oe+=1,ne.ELLIPSOID_INTERSECTION_INDEX_HEIGHT_MIN=oe,oe+=1,re.clipMinMaxHeight=Cartesian2.fromElements((C.z-m.z)/v,(A.z-m.z)/v,re.clipMinMaxHeight);const ie=(m.z-u.z)/v;if(re.ellipsoidInverseHeightDifferenceUv=1/ie,u.z===m.z&&(re.ellipsoidInverseHeightDifferenceUv=0),P&&(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE=!0,ne.ELLIPSOID_INTERSECTION_INDEX_LONGITUDE=oe,T?(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_UNDER_HALF=!0,oe+=1):E?(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_OVER_HALF=!0,oe+=2):x&&(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_RANGE_EQUAL_ZERO=!0,oe+=2),re.ellipsoidRenderLongitudeMinMax=Cartesian2.fromElements(C.x,A.x,re.ellipsoidRenderLongitudeMinMax)),U)if(ne.ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE=!0,m.x<u.x&&(ne.ELLIPSOID_HAS_SHAPE_BOUNDS_LONGITUDE_MIN_MAX_REVERSED=!0),O<=c)re.ellipsoidUvToShapeUvLongitude=Cartesian2.fromElements(0,1,re.ellipsoidUvToShapeUvLongitude);else{const ue=I/O,Ee=-(u.x-o.x)/O;re.ellipsoidUvToShapeUvLongitude=Cartesian2.fromElements(ue,Ee,re.ellipsoidUvToShapeUvLongitude)}if(P){const de=CesiumMath.equalsEpsilon(C.x,o.x,void 0,l),ue=CesiumMath.equalsEpsilon(A.x,a.x,void 0,l);de&&(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MIN_DISCONTINUITY=!0),ue&&(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LONGITUDE_MAX_DISCONTINUITY=!0);const Ee=(u.x-o.x)/I,Pe=(m.x-o.x)/I,De=(A.x-o.x)/I,Me=1-y/I,we=(De+.5*Me)%1;re.ellipsoidShapeUvLongitudeMinMaxMid=Cartesian3.fromElements(Ee,Pe,we,re.ellipsoidShapeUvLongitudeMinMaxMid)}if(X&&(z&&(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN=!0,ne.ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MIN=oe,B?(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_UNDER_HALF=!0,oe+=1):W?(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_EQUAL_HALF=!0,oe+=1):Y&&(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MIN_OVER_HALF=!0,oe+=2)),G&&(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX=!0,ne.ELLIPSOID_INTERSECTION_INDEX_LATITUDE_MAX=oe,k?(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_UNDER_HALF=!0,oe+=2):H?(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_EQUAL_HALF=!0,oe+=1):F&&(ne.ELLIPSOID_HAS_RENDER_BOUNDS_LATITUDE_MAX_OVER_HALF=!0,oe+=1)),re.ellipsoidRenderLatitudeSinMinMax=Cartesian2.fromElements(Math.sin(C.y),Math.sin(A.y),re.ellipsoidRenderLatitudeSinMinMax)),ce)if(ne.ELLIPSOID_HAS_SHAPE_BOUNDS_LATITUDE=!0,q<d)re.ellipsoidUvToShapeUvLatitude=Cartesian2.fromElements(0,1,re.ellipsoidUvToShapeUvLatitude);else{const ue=(a.y-o.y)/q,Ee=(o.y-u.y)/q;re.ellipsoidUvToShapeUvLatitude=Cartesian2.fromElements(ue,Ee,re.ellipsoidUvToShapeUvLatitude)}return this.shaderMaximumIntersectionsLength=oe,!0};const scratchRectangle=new Rectangle;VoxelEllipsoidShape.prototype.computeOrientedBoundingBoxForTile=function(e,t,n,i,r){Check.typeOf.number("tileLevel",e),Check.typeOf.number("tileX",t),Check.typeOf.number("tileY",n),Check.typeOf.number("tileZ",i),Check.typeOf.object("result",r);const o=1/Math.pow(2,e),a=t*o,s=(t+1)*o,l=n*o,c=(n+1)*o,d=i*o,h=(i+1)*o,f=Rectangle.subsection(this._rectangle,a,l,s,c,scratchRectangle),p=CesiumMath.lerp(this._minimumHeight,this._maximumHeight,d),u=CesiumMath.lerp(this._minimumHeight,this._maximumHeight,h);return getEllipsoidChunkObb(f,p,u,this._ellipsoid,this._translation,this._rotation,r)};const sampleSizeScratch=new Cartesian3,scratchTileMinBounds=new Cartesian3,scratchTileMaxBounds=new Cartesian3;VoxelEllipsoidShape.prototype.computeOrientedBoundingBoxForSample=function(e,t,n,i){Check.typeOf.object("spatialNode",e),Check.typeOf.object("tileDimensions",t),Check.typeOf.object("tileUv",n),Check.typeOf.object("result",i);const r=1/Math.pow(2,e.level),o=Cartesian3.divideComponents(Cartesian3.ONE,t,sampleSizeScratch),a=Cartesian3.multiplyByScalar(o,r,sampleSizeScratch),s=Cartesian3.multiplyByScalar(Cartesian3.fromElements(e.x+n.x,e.y+n.y,e.z+n.z,scratchTileMinBounds),r,scratchTileMinBounds),l=Cartesian3.add(s,a,scratchTileMaxBounds),c=Rectangle.subsection(this._rectangle,s.x,s.y,l.x,l.y,scratchRectangle),d=CesiumMath.lerp(this._minimumHeight,this._maximumHeight,s.z),h=CesiumMath.lerp(this._minimumHeight,this._maximumHeight,l.z);return getEllipsoidChunkObb(c,d,h,this._ellipsoid,this._translation,this._rotation,i)};function getEllipsoidChunkObb(e,t,n,i,r,o,a){return a=OrientedBoundingBox.fromRectangle(e,t,n,i,a),a.center=Cartesian3.add(a.center,r,a.center),a.halfAxes=Matrix3.multiply(a.halfAxes,o,a.halfAxes),a}VoxelEllipsoidShape.DefaultMinBounds=Object.freeze(new Cartesian3(-CesiumMath.PI,-CesiumMath.PI_OVER_TWO,-Ellipsoid.WGS84.minimumRadius));VoxelEllipsoidShape.DefaultMaxBounds=Object.freeze(new Cartesian3(CesiumMath.PI,CesiumMath.PI_OVER_TWO,10*Ellipsoid.WGS84.maximumRadius));const VoxelShapeType={BOX:"BOX",ELLIPSOID:"ELLIPSOID",CYLINDER:"CYLINDER"};VoxelShapeType.getMinBounds=function(e){switch(e){case VoxelShapeType.BOX:return VoxelBoxShape.DefaultMinBounds;case VoxelShapeType.ELLIPSOID:return VoxelEllipsoidShape.DefaultMinBounds;case VoxelShapeType.CYLINDER:return VoxelCylinderShape.DefaultMinBounds;default:throw new DeveloperError(`Invalid shape type ${e}`)}};VoxelShapeType.getMaxBounds=function(e){switch(e){case VoxelShapeType.BOX:return VoxelBoxShape.DefaultMaxBounds;case VoxelShapeType.ELLIPSOID:return VoxelEllipsoidShape.DefaultMaxBounds;case VoxelShapeType.CYLINDER:return VoxelCylinderShape.DefaultMaxBounds;default:throw new DeveloperError(`Invalid shape type ${e}`)}};VoxelShapeType.getShapeConstructor=function(e){switch(e){case VoxelShapeType.BOX:return VoxelBoxShape;case VoxelShapeType.ELLIPSOID:return VoxelEllipsoidShape;case VoxelShapeType.CYLINDER:return VoxelCylinderShape;default:throw new DeveloperError(`Invalid shape type ${e}`)}};const VoxelShapeType$1=Object.freeze(VoxelShapeType);function DoubleEndedPriorityQueue(e){Check.typeOf.object("options",e),Check.defined("options.comparator",e.comparator),defined(e.maximumLength)&&Check.typeOf.number.greaterThanOrEquals("options.maximumLength",e.maximumLength,0),this._comparator=e.comparator,this._maximumLength=e.maximumLength,this._array=defined(e.maximumLength)?new Array(e.maximumLength):[],this._length=0}Object.defineProperties(DoubleEndedPriorityQueue.prototype,{length:{get:function(){return this._length}},maximumLength:{get:function(){return this._maximumLength},set:function(e){if(defined(e)){for(Check.typeOf.number.greaterThanOrEquals("maximumLength",e,0);this._length>e;)this.removeMinimum();this._array.length=e}this._maximumLength=e}},internalArray:{get:function(){return this._array}},comparator:{get:function(){return this._comparator}}});DoubleEndedPriorityQueue.prototype.clone=function(){const e=this._maximumLength,t=this._comparator,n=this._array,i=this._length,r=new DoubleEndedPriorityQueue({comparator:t,maximumLength:e});r._length=i;for(let o=0;o<i;o++)r._array[o]=n[o];return r};DoubleEndedPriorityQueue.prototype.reset=function(){this._length=0;const e=this._maximumLength;if(defined(e))for(let t=0;t<e;t++)this._array[t]=void 0;else this._array.length=0};DoubleEndedPriorityQueue.prototype.resort=function(){const e=this._length;for(let t=0;t<e;t++)pushUp(this,t)};DoubleEndedPriorityQueue.prototype.insert=function(e){let t;const n=this._maximumLength;if(defined(n)){if(n===0)return;if(this._length===n){const r=this._array[0];if(this._comparator(e,r)<=0)return e;t=this.removeMinimum()}}const i=this._length;return this._array[i]=e,this._length++,pushUp(this,i),t};DoubleEndedPriorityQueue.prototype.removeMinimum=function(){const e=this._length;if(e===0)return;this._length--;const t=this._array[0];return e>=2&&(this._array[0]=this._array[e-1],pushDown(this,0)),this._array[e-1]=void 0,t};DoubleEndedPriorityQueue.prototype.removeMaximum=function(){const e=this._length;if(e===0)return;this._length--;let t;if(e<=2)t=this._array[e-1];else{const n=greaterThan(this,1,2)?1:2;t=this._array[n],this._array[n]=this._array[e-1],e>=4&&pushDown(this,n)}return this._array[e-1]=void 0,t};DoubleEndedPriorityQueue.prototype.getMinimum=function(){if(this._length!==0)return this._array[0]};DoubleEndedPriorityQueue.prototype.getMaximum=function(){const e=this._length;if(e!==0)return e<=2?this._array[e-1]:this._array[greaterThan(this,1,2)?1:2]};function swap(e,t,n){const i=e._array,r=i[t];i[t]=i[n],i[n]=r}function lessThan(e,t,n){return e._comparator(e._array[t],e._array[n])<0}function greaterThan(e,t,n){return e._comparator(e._array[t],e._array[n])>0}function pushUp(e,t){if(t===0)return;const n=Math.floor(CesiumMath.log2(t+1))%2===0,i=Math.floor((t-1)/2),r=lessThan(e,t,i);for(r!==n&&(swap(e,t,i),t=i);t>=3;){const o=Math.floor((t-3)/4);if(lessThan(e,t,o)!==r)break;swap(e,t,o),t=o}}function pushDown(e,t){const n=e._length,i=Math.floor(CesiumMath.log2(t+1))%2===0;let r;for(;(r=2*t+1)<n;){let o=r;const a=r+1;if(a<n){lessThan(e,a,o)===i&&(o=a);const s=2*r+1,l=Math.max(Math.min(n-s,4),0);for(let c=0;c<l;c++){const d=s+c;lessThan(e,d,o)===i&&(o=d)}}if(lessThan(e,o,t)===i&&(swap(e,o,t),o!==r&&o!==a)){const s=Math.floor((o-1)/2);greaterThan(e,o,s)===i&&swap(e,o,s)}t=o}}const LoadState=Object.freeze({UNLOADED:0,RECEIVING:1,RECEIVED:2,LOADED:3,FAILED:4,UNAVAILABLE:5});function KeyframeNode(e,t){this.spatialNode=e,this.keyframe=t,this.state=LoadState.UNLOADED,this.metadata=[],this.megatextureIndex=-1,this.priority=-Number.MAX_VALUE,this.highPriorityFrameNumber=-1}KeyframeNode.priorityComparator=function(e,t){return e.priority-t.priority};KeyframeNode.searchComparator=function(e,t){return e.keyframe-t.keyframe};KeyframeNode.LoadState=LoadState;function Megatexture(e,t,n,i,r){i===MetadataComponentType.UNSIGNED_SHORT&&(i=MetadataComponentType.FLOAT32);const o=e.floatingPointTexture;if(i===MetadataComponentType.FLOAT32&&!o)throw new RuntimeError("Floating point texture not supported");let a;i===MetadataComponentType.FLOAT32||i===MetadataComponentType.FLOAT64?a=PixelDatatype.FLOAT:i===MetadataComponentType.UINT8&&(a=PixelDatatype.UNSIGNED_BYTE);let s;n===1?s=e.webgl2?PixelFormat.RED:PixelFormat.LUMINANCE:n===2?s=e.webgl2?PixelFormat.RG:PixelFormat.LUMINANCE_ALPHA:n===3?s=PixelFormat.RGB:n===4&&(s=PixelFormat.RGBA);const l=512*1024*1024,c=128*1024*1024;r=Math.min(defaultValue(r,c),l);const d=ContextLimits.maximumTextureSize,h=MetadataComponentType.getSizeInBytes(i),f=Math.floor(r/(n*h)),p=Math.min(d,CesiumMath.previousPowerOfTwo(Math.floor(Math.sqrt(f)))),u=Math.ceil(Math.sqrt(t.x)),m=Math.ceil(t.z/u),g=u*t.x,_=m*t.y,C=Math.floor(p/g),A=Math.floor(p/_);if(C===0||A===0)throw new RuntimeError("Tileset is too large to fit into megatexture");this.channelCount=n,this.componentType=i,this.voxelCountPerTile=Cartesian3.clone(t,new Cartesian3),this.maximumTileCount=C*A,this.regionCountPerMegatexture=new Cartesian2(C,A),this.voxelCountPerRegion=new Cartesian2(g,_),this.sliceCountPerRegion=new Cartesian2(u,m),this.voxelSizeUv=new Cartesian2(1/p,1/p),this.sliceSizeUv=new Cartesian2(t.x/p,t.y/p),this.regionSizeUv=new Cartesian2(g/p,_/p),this.texture=new Texture({context:e,pixelFormat:s,pixelDatatype:a,flipY:!1,width:p,height:p,sampler:new Sampler({wrapS:TextureWrap.CLAMP_TO_EDGE,wrapT:TextureWrap.CLAMP_TO_EDGE,minificationFilter:TextureMinificationFilter.LINEAR,magnificationFilter:TextureMagnificationFilter.LINEAR})});const S=MetadataComponentType.toComponentDatatype(i);this.tileVoxelDataTemp=ComponentDatatype.createTypedArray(S,g*_*n),this.nodes=new Array(this.maximumTileCount);for(let v=0;v<this.maximumTileCount;v++)this.nodes[v]=new MegatextureNode(v);for(let v=0;v<this.maximumTileCount;v++){const b=this.nodes[v];b.previousNode=v>0?this.nodes[v-1]:void 0,b.nextNode=v<this.maximumTileCount-1?this.nodes[v+1]:void 0}this.occupiedList=void 0,this.emptyList=this.nodes[0],this.occupiedCount=0}function MegatextureNode(e){this.index=e,this.nextNode=void 0,this.previousNode=void 0}Megatexture.prototype.add=function(e){if(this.isFull())throw new DeveloperError("Trying to add when there are no empty spots");const t=this.emptyList;this.emptyList=this.emptyList.nextNode,defined(this.emptyList)&&(this.emptyList.previousNode=void 0),t.nextNode=this.occupiedList,defined(t.nextNode)&&(t.nextNode.previousNode=t),this.occupiedList=t;const n=t.index;return this.writeDataToTexture(n,e),this.occupiedCount++,n};Megatexture.prototype.remove=function(e){if(e<0||e>=this.maximumTileCount)throw new DeveloperError("Megatexture index out of bounds");const t=this.nodes[e];defined(t.previousNode)&&(t.previousNode.nextNode=t.nextNode),defined(t.nextNode)&&(t.nextNode.previousNode=t.previousNode),t.nextNode=this.emptyList,defined(t.nextNode)&&(t.nextNode.previousNode=t),t.previousNode=void 0,this.emptyList=t,this.occupiedCount--};Megatexture.prototype.isFull=function(){return this.emptyList===void 0};Megatexture.getApproximateTextureMemoryByteLength=function(e,t,n,i){i===MetadataComponentType.UNSIGNED_SHORT&&(i=MetadataComponentType.FLOAT32);const r=MetadataComponentType.getSizeInBytes(i),o=e*t.x*t.y*t.z,a=Math.ceil(Math.sqrt(t.x)),s=Math.ceil(t.z/a),l=a*t.x,c=s*t.y;let d=CesiumMath.previousPowerOfTwo(Math.floor(Math.sqrt(o)));for(;;){const f=Math.floor(d/l),p=Math.floor(d/c);if(f*p>=e)break;d*=2}return d*d*n*r};Megatexture.prototype.writeDataToTexture=function(e,t){const n=t.constructor===Uint16Array?new Float32Array(t):t,i=this.voxelCountPerTile,r=this.sliceCountPerRegion,o=this.voxelCountPerRegion,a=this.channelCount,s=this.tileVoxelDataTemp;for(let m=0;m<i.z;m++){const g=m%r.x*i.x,_=Math.floor(m/r.x)*i.y;for(let C=0;C<i.y;C++)for(let A=0;A<i.x;A++){const S=m*i.y*i.x+C*i.x+A,v=(_+C)*o.x+(g+A);for(let b=0;b<a;b++)s[v*a+b]=n[S*a+b]}}const l=this.regionCountPerMegatexture,c=o.x,d=o.y,h=e%l.x*o.x,f=Math.floor(e/l.x)*o.y,u={source:{arrayBufferView:s,width:c,height:d},xOffset:h,yOffset:f};this.texture.copyFrom(u)};Megatexture.prototype.isDestroyed=function(){return!1};Megatexture.prototype.destroy=function(){return this.texture=this.texture&&this.texture.destroy(),destroyObject(this)};function SpatialNode(e,t,n,i,r,o,a){this.children=void 0,this.parent=r,this.level=e,this.x=t,this.y=n,this.z=i,this.dimensions=Cartesian3.clone(a),this.keyframeNodes=[],this.renderableKeyframeNodes=[],this.renderableKeyframeNodeLerp=0,this.renderableKeyframeNodePrevious=void 0,this.renderableKeyframeNodeNext=void 0,this.orientedBoundingBox=new OrientedBoundingBox,this.approximateVoxelSize=0,this.screenSpaceError=0,this.visitedFrameNumber=-1,this.computeBoundingVolumes(o)}const scratchObbHalfScale=new Cartesian3;SpatialNode.prototype.computeBoundingVolumes=function(e){this.orientedBoundingBox=e.computeOrientedBoundingBoxForTile(this.level,this.x,this.y,this.z,this.orientedBoundingBox);const t=Matrix3.getScale(this.orientedBoundingBox.halfAxes,scratchObbHalfScale),n=2*Cartesian3.maximumComponent(t);this.approximateVoxelSize=n/Cartesian3.minimumComponent(this.dimensions)};SpatialNode.prototype.constructChildNodes=function(e){const{level:t,x:n,y:i,z:r}=this,o=n*2,a=i*2,s=r*2,l=a+1,c=o+1,d=s+1,h=t+1,f=[[h,o,a,s],[h,c,a,s],[h,o,l,s],[h,c,l,s],[h,o,a,d],[h,c,a,d],[h,o,l,d],[h,c,l,d]];this.children=f.map(([p,u,m,g])=>new SpatialNode(p,u,m,g,this,e,this.dimensions))};SpatialNode.prototype.visibility=function(e,t){const n=this.orientedBoundingBox;return e.cullingVolume.computeVisibilityWithPlaneMask(n,t)};SpatialNode.prototype.computeScreenSpaceError=function(e,t){const n=this.orientedBoundingBox;let i=Math.sqrt(n.distanceSquaredTo(e));i=Math.max(i,CesiumMath.EPSILON7);const r=this.approximateVoxelSize,o=t*(r/i);this.screenSpaceError=o};const scratchBinarySearchKeyframeNode={keyframe:0};function findKeyframeIndex(e,t){return scratchBinarySearchKeyframeNode.keyframe=e,binarySearch(t,scratchBinarySearchKeyframeNode,KeyframeNode.searchComparator)}SpatialNode.prototype.computeSurroundingRenderableKeyframeNodes=function(e){let t=this;const n=t.level,i=Math.floor(e),r=Math.ceil(e);let o,a,s=+Number.MAX_VALUE,l=+Number.MAX_VALUE;for(;defined(t);){const{renderableKeyframeNodes:h}=t;if(h.length>=1){const f=getKeyframeIndexPrev(i,h),p=h[f],u=r===i||i<p.keyframe?f:Math.min(f+1,h.length-1),m=h[u],g=i-p.keyframe,_=getWeightedKeyframeDistance(n-t.level,g);_<s&&(s=_,o=p);const C=m.keyframe-r,A=getWeightedKeyframeDistance(n-t.level,C);if(A<l&&(l=A,a=m),g===0&&C===0)break}t=t.parent}if(this.renderableKeyframeNodePrevious=o,this.renderableKeyframeNodeNext=a,!defined(o)||!defined(a))return;const c=o.keyframe,d=a.keyframe;this.renderableKeyframeNodeLerp=c===d?0:CesiumMath.clamp((e-c)/(d-c),0,1)};function getKeyframeIndexPrev(e,t){const n=findKeyframeIndex(e,t);return n<0?CesiumMath.clamp(~n-1,0,t.length-1):n}function getWeightedKeyframeDistance(e,t){const n=Math.exp(e*4),i=t>=0?1:-200;return e*n+t*i}SpatialNode.prototype.isVisited=function(e){return this.visitedFrameNumber===e};SpatialNode.prototype.createKeyframeNode=function(e){let t=findKeyframeIndex(e,this.keyframeNodes);if(t<0){t=~t;const n=new KeyframeNode(this,e);this.keyframeNodes.splice(t,0,n)}};SpatialNode.prototype.destroyKeyframeNode=function(e,t){const n=e.keyframe,i=findKeyframeIndex(n,this.keyframeNodes);if(i<0)throw new DeveloperError("Keyframe node does not exist.");if(this.keyframeNodes.splice(i,1),e.megatextureIndex!==-1){for(let o=0;o<t.length;o++)t[o].remove(e.megatextureIndex);const r=findKeyframeIndex(n,this.renderableKeyframeNodes);if(r<0)throw new DeveloperError("Renderable keyframe node does not exist.");this.renderableKeyframeNodes.splice(r,1)}e.spatialNode=void 0,e.state=KeyframeNode.LoadState.UNLOADED,e.metadata={},e.megatextureIndex=-1,e.priority=-Number.MAX_VALUE,e.highPriorityFrameNumber=-1};SpatialNode.prototype.addKeyframeNodeToMegatextures=function(e,t){if(e.state!==KeyframeNode.LoadState.RECEIVED||e.megatextureIndex!==-1||e.metadata.length!==t.length)throw new DeveloperError("Keyframe node cannot be added to megatexture");for(let r=0;r<t.length;r++){const o=t[r];e.megatextureIndex=o.add(e.metadata[r])}e.state=KeyframeNode.LoadState.LOADED;const n=this.renderableKeyframeNodes;let i=findKeyframeIndex(e.keyframe,n);if(i>=0)throw new DeveloperError("Keyframe already renderable");i=~i,n.splice(i,0,e)};SpatialNode.prototype.isRenderable=function(e){const t=this.renderableKeyframeNodePrevious,n=this.renderableKeyframeNodeNext,i=this.level;return defined(t)&&defined(n)&&(t.spatialNode.level===i||n.spatialNode.level===i)&&this.visitedFrameNumber===e};function VoxelTraversal(e,t,n,i,r,o,a){this._primitive=e,this.megatextures=new Array(i.length);for(let u=0;u<i.length;u++){const m=i[u],g=MetadataType.getComponentCount(m),_=r[u];this.megatextures[u]=new Megatexture(t,n,g,_,a)}const s=this.megatextures[0].maximumTileCount;this._simultaneousRequestCount=0,this._debugPrint=!1,this._frameNumber=0;const l=e._shape;this.rootNode=new SpatialNode(0,0,0,0,void 0,l,n),this._priorityQueue=new DoubleEndedPriorityQueue({maximumLength:s,comparator:KeyframeNode.priorityComparator}),this._highPriorityKeyframeNodes=new Array(s),this._keyframeNodesInMegatexture=new Array(s),this._keyframeCount=o,this._sampleCount=void 0,this._keyframeLocation=0,this._binaryTreeKeyframeWeighting=new Array(o);const c=this._binaryTreeKeyframeWeighting;c[0]=0,c[o-1]=0,binaryTreeWeightingRecursive(c,1,o-2,0);const d=9,h=2048,f=Math.floor(h/d),p=Math.ceil(s/f);this.internalNodeTexture=new Texture({context:t,pixelFormat:PixelFormat.RGBA,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,flipY:!1,width:h,height:p,sampler:new Sampler({minificationFilter:TextureMinificationFilter.NEAREST,magnificationFilter:TextureMagnificationFilter.NEAREST})}),this.internalNodeTilesPerRow=f,this.internalNodeTexelSizeUv=new Cartesian2(1/h,1/p),this.leafNodeTexture=void 0,this.leafNodeTilesPerRow=void 0,this.leafNodeTexelSizeUv=new Cartesian2}VoxelTraversal.prototype.findKeyframeNode=function(e){return this._keyframeNodesInMegatexture.find(function(t){return t.megatextureIndex===e})};function binaryTreeWeightingRecursive(e,t,n,i){if(t>n)return;const r=Math.floor((t+n)/2);e[r]=i,binaryTreeWeightingRecursive(e,t,r-1,i+1),binaryTreeWeightingRecursive(e,r+1,n,i+1)}VoxelTraversal.simultaneousRequestCountMaximum=50;VoxelTraversal.prototype.update=function(e,t,n,i){const r=this._primitive,o=e.context,a=this.megatextures[0].maximumTileCount,s=this._keyframeCount,l=r._levelBlendFactor,c=l>0,d=s>1,h=(c?2:1)*(d?2:1);this._sampleCount=h;const f=h>=2;if(f&&!defined(this.leafNodeTexture)){const C=Math.floor(512),A=Math.ceil(a/C);this.leafNodeTexture=new Texture({context:o,pixelFormat:PixelFormat.RGBA,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,flipY:!1,width:1024,height:A,sampler:new Sampler({minificationFilter:TextureMinificationFilter.NEAREST,magnificationFilter:TextureMagnificationFilter.NEAREST})}),this.leafNodeTexelSizeUv=Cartesian2.fromElements(1/1024,1/A,this.leafNodeTexelSizeUv),this.leafNodeTilesPerRow=C}else!f&&defined(this.leafNodeTexture)&&(this.leafNodeTexture=this.leafNodeTexture.destroy());if(this._keyframeLocation=CesiumMath.clamp(t,0,s-1),n&&recomputeBoundingVolumesRecursive(this,this.rootNode),i)return;this._frameNumber=e.frameNumber;const p=getTimestamp();loadAndUnload(this,e);const u=getTimestamp();generateOctree(this,h,l);const m=getTimestamp();if(this._debugPrint){const g=u-p,_=m-u,C=m-p;printDebugInformation(this,g,_,C)}};VoxelTraversal.prototype.isRenderable=function(e){return e.isRenderable(this._frameNumber)};VoxelTraversal.prototype.isDestroyed=function(){return!1};VoxelTraversal.prototype.destroy=function(){const e=this.megatextures,t=e.length;for(let n=0;n<t;n++)e[n]=e[n]&&e[n].destroy();return this.internalNodeTexture=this.internalNodeTexture&&this.internalNodeTexture.destroy(),this.leafNodeTexture=this.leafNodeTexture&&this.leafNodeTexture.destroy(),destroyObject(this)};function recomputeBoundingVolumesRecursive(e,t){if(t.computeBoundingVolumes(e._primitive._shape),defined(t.children))for(let n=0;n<8;n++){const i=t.children[n];recomputeBoundingVolumesRecursive(e,i)}}function requestData(e,t){if(e._simultaneousRequestCount>=VoxelTraversal.simultaneousRequestCountMaximum)return;const n=e._primitive._provider;function i(l){e._simultaneousRequestCount--;const c=n.types.length;if(!defined(l))t.state=KeyframeNode.LoadState.UNAVAILABLE;else if(l===KeyframeNode.LoadState.FAILED)t.state=KeyframeNode.LoadState.FAILED;else if(!Array.isArray(l)||l.length!==c)t.state=KeyframeNode.LoadState.FAILED;else{const d=e.megatextures;for(let h=0;h<c;h++){const{voxelCountPerTile:f,channelCount:p}=d[h],{x:u,y:m,z:g}=f,_=u*m*g,C=l[h],A=_*p;if(C.length===A)t.metadata[h]=C,t.state=KeyframeNode.LoadState.RECEIVED;else{t.state=KeyframeNode.LoadState.FAILED;break}}}}function r(){e._simultaneousRequestCount--,t.state=KeyframeNode.LoadState.FAILED}const{keyframe:o,spatialNode:a}=t,s=n.requestData({tileLevel:a.level,tileX:a.x,tileY:a.y,tileZ:a.z,keyframe:o});defined(s)?(e._simultaneousRequestCount++,t.state=KeyframeNode.LoadState.RECEIVING,s.then(i).catch(r)):t.state=KeyframeNode.LoadState.FAILED}function mapInfiniteRangeToZeroOne(e){return e/(1+e)}function loadAndUnload(e,t){const n=e._frameNumber,i=e._primitive,r=i._shape,o=i.screenSpaceError,a=e._priorityQueue,s=e._keyframeCount,l=CesiumMath.clamp(Math.floor(e._keyframeLocation),0,s-2),c=l+1,{camera:d,context:h,pixelRatio:f}=t,{positionWC:p,frustum:u}=d,g=h.drawingBufferHeight/f/u.sseDenominator;function _(N,y){if(N.computeScreenSpaceError(p,g),y=N.visibility(t,y),y===CullingVolume.MASK_OUTSIDE)return;if(N.visitedFrameNumber=n,s===1)N.createKeyframeNode(0);else if(N.keyframeNodes.length!==s)for(let M=0;M<s;M++)N.createKeyframeNode(M);const{screenSpaceError:x,keyframeNodes:T}=N,E=mapInfiniteRangeToZeroOne(x);let P=!1;for(let M=0;M<T.length;M++){const O=T[M];O.priority=10*E+keyframePriority(l,O.keyframe,c,e),O.state!==KeyframeNode.LoadState.UNAVAILABLE&&O.state!==KeyframeNode.LoadState.FAILED&&O.priority!==-Number.MAX_VALUE&&a.insert(O),O.state===KeyframeNode.LoadState.LOADED&&(P=!0)}if(x<o||!P){N.children=void 0;return}defined(N.children)||N.constructChildNodes(r);for(let M=0;M<8;M++){const O=N.children[M];_(O,y)}}a.reset(),_(e.rootNode,CullingVolume.MASK_INDETERMINATE);const C=e._highPriorityKeyframeNodes;let A=0,S;for(;a.length>0;)S=a.removeMaximum(),S.highPriorityFrameNumber=n,C[A]=S,A++;const v=e._keyframeNodesInMegatexture,b=e.megatextures[0],D=b.occupiedCount;v.length=D,v.sort(function(N,y){return N.highPriorityFrameNumber===y.highPriorityFrameNumber?y.priority-N.priority:y.highPriorityFrameNumber-N.highPriorityFrameNumber});let I=0,L=0;for(let N=0;N<A;N++)if(S=C[N],!(S.state===KeyframeNode.LoadState.LOADED||S.spatialNode===void 0)&&(S.state===KeyframeNode.LoadState.UNLOADED&&requestData(e,S),S.state===KeyframeNode.LoadState.RECEIVED)){let y=0;if(b.isFull()){y=D-1-I,I++;const x=v[y];x.spatialNode.destroyKeyframeNode(x,e.megatextures)}else y=D+L,L++;S.spatialNode.addKeyframeNodeToMegatextures(S,e.megatextures),v[y]=S}}function keyframePriority(e,t,n,i){const r=Math.min(Math.abs(t-e),Math.abs(t-n)),o=Math.max(e,i._keyframeCount-n-1,1),a=Math.pow(1-r/o,4),s=Math.exp(-i._binaryTreeKeyframeWeighting[t]);return CesiumMath.lerp(s,a,.15+.85*a)}function printDebugInformation(e,t,n,i){const r=e._keyframeCount,o=e.rootNode,a=Object.keys(KeyframeNode.LoadState).length,s=new Array(a),l=new Array(a);let c=0;for(let _=0;_<a;_++){const C=new Array(r);s[_]=C;for(let A=0;A<r;A++)C[A]=0;l[_]=0}function d(_){const C=_.keyframeNodes;for(let A=0;A<C.length;A++){const S=C[A],v=S.keyframe,b=S.state;s[b][v]+=1,l[b]+=1,c++}if(defined(_.children))for(let A=0;A<8;A++){const S=_.children[A];d(S)}}d(o);const h=`KEYFRAMES: ${s[KeyframeNode.LoadState.LOADED]}`,f=`UNLOADED: ${l[KeyframeNode.LoadState.UNLOADED]} | RECEIVING: ${l[KeyframeNode.LoadState.RECEIVING]} | RECEIVED: ${l[KeyframeNode.LoadState.RECEIVED]} | LOADED: ${l[KeyframeNode.LoadState.LOADED]} | FAILED: ${l[KeyframeNode.LoadState.FAILED]} | UNAVAILABLE: ${l[KeyframeNode.LoadState.UNAVAILABLE]} | TOTAL: ${c}`,p=Math.round(t*100)/100,u=Math.round(n*100)/100,m=Math.round(i*100)/100,g=`LOAD: ${p} | OCT: ${u} | ALL: ${m}`;console.log(`${h} || ${f} || ${g}`)}const GpuOctreeFlag={INTERNAL:0,LEAF:1,PACKED_LEAF_FROM_PARENT:2};function generateOctree(e,t,n){const i=e._primitive._screenSpaceError,r=e._keyframeLocation,o=e._frameNumber,a=t>=2;let s=0,l=0;const c=[],d=[];function h(p,u,m,g,_){let C=!1;if(defined(p.children))for(let A=0;A<8;A++){const S=p.children[A];S.computeSurroundingRenderableKeyframeNodes(r),S.isRenderable(o)&&(C=!0)}if(C){c[_]=GpuOctreeFlag.INTERNAL<<16|u,c[m]=g,s++,g=u,_=g*9+1;for(let A=0;A<8;A++){const S=p.children[A];u=s,m=u*9+0,h(S,u,m,g,_+A)}}else{if(a){const A=l*5,S=p.renderableKeyframeNodePrevious,v=p.level-S.spatialNode.level,b=S.spatialNode.parent,D=defined(b)?b.renderableKeyframeNodePrevious:S,I=getLodLerp(p,i,n),L=v,N=1,y=S.megatextureIndex,x=D.megatextureIndex;d[A+0]=I,d[A+1]=L,d[A+2]=N,d[A+3]=y,d[A+4]=x,c[_]=GpuOctreeFlag.LEAF<<16|l}else{const A=p.renderableKeyframeNodePrevious,v=p.level-A.spatialNode.level===0?GpuOctreeFlag.LEAF:GpuOctreeFlag.PACKED_LEAF_FROM_PARENT;c[_]=v<<16|A.megatextureIndex}l++}}const f=e.rootNode;f.computeSurroundingRenderableKeyframeNodes(r),f.isRenderable(o)&&h(f,0,0,0,0),copyToInternalNodeTexture(c,9,e.internalNodeTilesPerRow,e.internalNodeTexture),a&&copyToLeafNodeTexture(d,2,e.leafNodeTilesPerRow,e.leafNodeTexture)}function getLodLerp(e,t,n){if(e.parent===void 0)return 0;const i=e.screenSpaceError,r=e.parent.screenSpaceError,a=((t-i)/(r-i)+n-1)/n;return CesiumMath.clamp(a,0,1)}function copyToInternalNodeTexture(e,t,n,i){const r=PixelFormat.componentsLength(i.pixelFormat),o=Math.ceil(e.length/t),a=Math.max(1,t*Math.min(o,n)),s=Math.max(1,Math.ceil(o/n)),l=new Uint8Array(a*s*r);for(let h=0;h<e.length;h++){const f=e[h],p=h*r;for(let u=0;u<r;u++)l[p+u]=f>>>u*8&255}const d={source:{arrayBufferView:l,width:a,height:s},xOffset:0,yOffset:0};i.copyFrom(d)}function copyToLeafNodeTexture(e,t,n,i){const r=PixelFormat.componentsLength(i.pixelFormat),o=5,a=Math.ceil(e.length/o),s=Math.max(1,t*Math.min(a,n)),l=Math.max(1,Math.ceil(a/n)),c=new Uint8Array(s*l*r);for(let f=0;f<a;f++){const p=e[f*o+0],u=e[f*o+1],m=e[f*o+2],g=e[f*o+3],_=e[f*o+4],C=CesiumMath.clamp(Math.floor(65536*p),0,65535);c[f*8+0]=C>>>0&255,c[f*8+1]=C>>>8&255,c[f*8+2]=u&255,c[f*8+3]=m&255,c[f*8+4]=g>>>0&255,c[f*8+5]=g>>>8&255,c[f*8+6]=_>>>0&255,c[f*8+7]=_>>>8&255}const h={source:{arrayBufferView:c,width:s,height:l},xOffset:0,yOffset:0};i.copyFrom(h)}VoxelTraversal.getApproximateTextureMemoryByteLength=function(e,t,n,i){let r=0;const o=n.length;for(let a=0;a<o;a++){const s=n[a],l=i[a],c=MetadataType.getComponentCount(s);r+=Megatexture.getApproximateTextureMemoryByteLength(e,t,c,l)}return r};const UniformType={FLOAT:"float",VEC2:"vec2",VEC3:"vec3",VEC4:"vec4",INT:"int",INT_VEC2:"ivec2",INT_VEC3:"ivec3",INT_VEC4:"ivec4",BOOL:"bool",BOOL_VEC2:"bvec2",BOOL_VEC3:"bvec3",BOOL_VEC4:"bvec4",MAT2:"mat2",MAT3:"mat3",MAT4:"mat4",SAMPLER_2D:"sampler2D",SAMPLER_CUBE:"samplerCube"},UniformType$1=Object.freeze(UniformType);function getImageFromTypedArray(e,t,n){const i=new Uint8ClampedArray(e.buffer),r=new ImageData(i,t,n),o=document.createElement("canvas");return o.width=t,o.height=n,o.getContext("2d").putImageData(r,0,0),o}function TextureManager(){this._defaultTexture=void 0,this._textures={},this._loadedImages=[],this._lastUpdatedFrame=-1}TextureManager.prototype.getTexture=function(e){return this._textures[e]};function fetchTexture2D(e,t,n){n.resource.fetchImage().then(function(i){e._loadedImages.push({id:t,image:i,textureUniform:n})}).catch(function(){const i=e._textures[t];defined(i)&&i!==e._defaultTexture&&i.destroy(),e._textures[t]=e._defaultTexture})}TextureManager.prototype.loadTexture2D=function(e,t){defined(t.typedArray)?this._loadedImages.push({id:e,textureUniform:t}):fetchTexture2D(this,e,t)};function createTexture(e,t,n){const{id:i,textureUniform:r,image:o}=t,a=n.webgl2?getTextureAndMips(r,o,n):getWebGL1Texture(r,o,n),s=e._textures[i];defined(s)&&s!==n.defaultTexture&&s.destroy(),e._textures[i]=a}function getTextureAndMips(e,t,n){const{typedArray:i,sampler:r}=e,o=defined(i)?getTextureFromTypedArray(e,n):new Texture({context:n,source:t,sampler:r});return samplerRequiresMipmap(r)&&o.generateMipmap(),o}function getWebGL1Texture(e,t,n){const{typedArray:i,sampler:r}=e,o=samplerRequiresMipmap(r),a=r.wrapS===TextureWrap.REPEAT||r.wrapS===TextureWrap.MIRRORED_REPEAT||r.wrapT===TextureWrap.REPEAT||r.wrapT===TextureWrap.MIRRORED_REPEAT,{width:s,height:l}=defined(i)?e:t,c=[s,l].every(CesiumMath.isPowerOfTwo);if((o||a)&&!c)if(defined(i)){if(e.pixelDatatype===PixelDatatype.UNSIGNED_BYTE){const h=getImageFromTypedArray(i,s,l),f=resizeImageToNextPowerOfTwo(h);return getTextureAndMips({sampler:r},f,n)}}else{const h=resizeImageToNextPowerOfTwo(t);return getTextureAndMips(e,h,n)}else return getTextureAndMips(e,t,n);return o?console.warn("Texture requires resizing for mipmaps but pixelDataType cannot be resized. The texture may be rendered incorrectly."):a&&console.warn("Texture requires resizing for wrapping but pixelDataType cannot be resized. The texture may be rendered incorrectly."),getTextureFromTypedArray(e,n)}function samplerRequiresMipmap(e){return[TextureMinificationFilter.NEAREST_MIPMAP_NEAREST,TextureMinificationFilter.NEAREST_MIPMAP_LINEAR,TextureMinificationFilter.LINEAR_MIPMAP_NEAREST,TextureMinificationFilter.LINEAR_MIPMAP_LINEAR].includes(e.minificationFilter)}function getTextureFromTypedArray(e,t){const{pixelFormat:n,pixelDatatype:i,width:r,height:o,typedArray:a,sampler:s}=e;return new Texture({context:t,pixelFormat:n,pixelDatatype:i,source:{arrayBufferView:a,width:r,height:o},sampler:s,flipY:!1})}TextureManager.prototype.update=function(e){if(e.frameNumber===this._lastUpdatedFrame)return;this._lastUpdatedFrame=e.frameNumber;const t=e.context;this._defaultTexture=t.defaultTexture;const n=this._loadedImages;for(let i=0;i<n.length;i++){const r=n[i];createTexture(this,r,t)}n.length=0};TextureManager.prototype.isDestroyed=function(){return!1};TextureManager.prototype.destroy=function(){const e=this._textures;for(const t in e)if(e.hasOwnProperty(t)){const n=e[t];n!==this._defaultTexture&&n.destroy()}return destroyObject(this)};function CustomShader(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this.mode=defaultValue(e.mode,CustomShaderMode.MODIFY_MATERIAL),this.lightingModel=e.lightingModel,this.uniforms=defaultValue(e.uniforms,defaultValue.EMPTY_OBJECT),this.varyings=defaultValue(e.varyings,defaultValue.EMPTY_OBJECT),this.vertexShaderText=e.vertexShaderText,this.fragmentShaderText=e.fragmentShaderText,this.translucencyMode=defaultValue(e.translucencyMode,CustomShaderTranslucencyMode.INHERIT),this._textureManager=new TextureManager,this._defaultTexture=void 0,this.uniformMap=buildUniformMap(this),this.usedVariablesVertex={attributeSet:{},featureIdSet:{},metadataSet:{}},this.usedVariablesFragment={attributeSet:{},featureIdSet:{},metadataSet:{},materialSet:{}},findUsedVariables(this),validateBuiltinVariables(this)}function buildUniformMap(e){const t=e.uniforms,n={};for(const i in t)if(t.hasOwnProperty(i)){const r=t[i],o=r.type;if(o===UniformType$1.SAMPLER_CUBE)throw new DeveloperError("CustomShader does not support samplerCube uniforms");o===UniformType$1.SAMPLER_2D?(e._textureManager.loadTexture2D(i,r.value),n[i]=createUniformTexture2DFunction(e,i)):n[i]=createUniformFunction(e,i)}return n}function createUniformTexture2DFunction(e,t){return function(){return defaultValue(e._textureManager.getTexture(t),e._defaultTexture)}}function createUniformFunction(e,t){return function(){return e.uniforms[t].value}}function getVariables(e,t,n){let i;for(;(i=t.exec(e))!==null;){const r=i[1];n[r]=!0}}function findUsedVariables(e){const t=/[vf]sInput\.attributes\.(\w+)/g,n=/[vf]sInput\.featureIds\.(\w+)/g,i=/[vf]sInput\.metadata.(\w+)/g;let r;const o=e.vertexShaderText;defined(o)&&(r=e.usedVariablesVertex.attributeSet,getVariables(o,t,r),r=e.usedVariablesVertex.featureIdSet,getVariables(o,n,r),r=e.usedVariablesVertex.metadataSet,getVariables(o,i,r));const a=e.fragmentShaderText;if(defined(a)){r=e.usedVariablesFragment.attributeSet,getVariables(a,t,r),r=e.usedVariablesFragment.featureIdSet,getVariables(a,n,r),r=e.usedVariablesFragment.metadataSet,getVariables(a,i,r);const s=/material\.(\w+)/g,l=e.usedVariablesFragment.materialSet;getVariables(a,s,l)}}function expandCoordinateAbbreviations(e){const t=/^.*MC$/,n=/^.*WC$/,i=/^.*EC$/;return t.test(e)?`${e} (model coordinates)`:n.test(e)?`${e} (Cartesian world coordinates)`:i.test(e)?`${e} (eye coordinates)`:e}function validateVariableUsage(e,t,n,i){if(e.hasOwnProperty(t)){const r=`${expandCoordinateAbbreviations(t)} is not available in the ${i} shader. Did you mean ${expandCoordinateAbbreviations(n)} instead?`;throw new DeveloperError(r)}}function validateBuiltinVariables(e){const t=e.usedVariablesVertex.attributeSet;validateVariableUsage(t,"position","positionMC","vertex"),validateVariableUsage(t,"normal","normalMC","vertex"),validateVariableUsage(t,"tangent","tangentMC","vertex"),validateVariableUsage(t,"bitangent","bitangentMC","vertex"),validateVariableUsage(t,"positionWC","positionMC","vertex"),validateVariableUsage(t,"positionEC","positionMC","vertex"),validateVariableUsage(t,"normalEC","normalMC","vertex"),validateVariableUsage(t,"tangentEC","tangentMC","vertex"),validateVariableUsage(t,"bitangentEC","bitangentMC","vertex");const n=e.usedVariablesFragment.attributeSet;validateVariableUsage(n,"position","positionEC","fragment"),validateVariableUsage(n,"normal","normalEC","fragment"),validateVariableUsage(n,"tangent","tangentEC","fragment"),validateVariableUsage(n,"bitangent","bitangentEC","fragment"),validateVariableUsage(n,"normalMC","normalEC","fragment"),validateVariableUsage(n,"tangentMC","tangentEC","fragment"),validateVariableUsage(n,"bitangentMC","bitangentEC","fragment")}CustomShader.prototype.setUniform=function(e,t){if(Check.typeOf.string("uniformName",e),Check.defined("value",t),!defined(this.uniforms[e]))throw new DeveloperError(`Uniform ${e} must be declared in the CustomShader constructor.`);const n=this.uniforms[e];n.type===UniformType$1.SAMPLER_2D?this._textureManager.loadTexture2D(e,t):defined(t.clone)?n.value=t.clone(n.value):n.value=t};CustomShader.prototype.update=function(e){this._defaultTexture=e.context.defaultTexture,this._textureManager.update(e)};CustomShader.prototype.isDestroyed=function(){return!1};CustomShader.prototype.destroy=function(){this._textureManager=this._textureManager&&this._textureManager.destroy(),destroyObject(this)};function VoxelPrimitive(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._ready=!1,this._provider=defaultValue(e.provider,VoxelPrimitive.DefaultProvider),this._traversal=void 0,this._shape=void 0,this._shapeVisible=!1,this._paddingBefore=new Cartesian3,this._paddingAfter=new Cartesian3,this._minBounds=new Cartesian3,this._minBoundsOld=new Cartesian3,this._maxBounds=new Cartesian3,this._maxBoundsOld=new Cartesian3,this._exaggeratedMinBounds=new Cartesian3,this._exaggeratedMinBoundsOld=new Cartesian3,this._exaggeratedMaxBounds=new Cartesian3,this._exaggeratedMaxBoundsOld=new Cartesian3,this._minClippingBounds=new Cartesian3,this._minClippingBoundsOld=new Cartesian3,this._maxClippingBounds=new Cartesian3,this._maxClippingBoundsOld=new Cartesian3,this._clippingPlanes=void 0,this._clippingPlanesState=0,this._clippingPlanesEnabled=!1,this._modelMatrix=Matrix4.clone(defaultValue(e.modelMatrix,Matrix4.IDENTITY)),this._exaggeratedModelMatrix=Matrix4.clone(this._modelMatrix),this._compoundModelMatrix=new Matrix4,this._compoundModelMatrixOld=new Matrix4,this._customShader=defaultValue(e.customShader,VoxelPrimitive.DefaultCustomShader),this._customShaderCompilationEvent=new Event,this._shaderDirty=!0,this._drawCommand=void 0,this._drawCommandPick=void 0,this._pickId=void 0,this._clock=e.clock,this._transformPositionWorldToUv=new Matrix4,this._transformPositionUvToWorld=new Matrix4,this._transformDirectionWorldToLocal=new Matrix3,this._transformNormalLocalToWorld=new Matrix3,this._jitter=!1,this._nearestSampling=!1,this._levelBlendFactor=0,this._stepSizeMultiplier=1,this._depthTest=!0,this._useLogDepth=void 0,this._screenSpaceError=4,this._debugPolylines=new PolylineCollection,this._debugDraw=!1,this._disableRender=!1,this._disableUpdate=!1,this._uniforms={octreeInternalNodeTexture:void 0,octreeInternalNodeTilesPerRow:0,octreeInternalNodeTexelSizeUv:new Cartesian2,octreeLeafNodeTexture:void 0,octreeLeafNodeTilesPerRow:0,octreeLeafNodeTexelSizeUv:new Cartesian2,megatextureTextures:[],megatextureSliceDimensions:new Cartesian2,megatextureTileDimensions:new Cartesian2,megatextureVoxelSizeUv:new Cartesian2,megatextureSliceSizeUv:new Cartesian2,megatextureTileSizeUv:new Cartesian2,dimensions:new Cartesian3,paddingBefore:new Cartesian3,paddingAfter:new Cartesian3,transformPositionViewToUv:new Matrix4,transformPositionUvToView:new Matrix4,transformDirectionViewToLocal:new Matrix3,transformNormalLocalToWorld:new Matrix3,cameraPositionUv:new Cartesian3,ndcSpaceAxisAlignedBoundingBox:new Cartesian4,clippingPlanesTexture:void 0,clippingPlanesMatrix:new Matrix4,stepSize:0,pickColor:new Color},this._shapeDefinesOld={},this._uniformMap={};const t=this._uniforms,n=this._uniformMap;for(const r in t)if(t.hasOwnProperty(r)){const o=`u_${r}`;n[o]=function(){return t[r]}}const i=this._provider;initialize$1(this,i)}function initialize$1(e,t){const{shape:n,minBounds:i=VoxelShapeType$1.getMinBounds(n),maxBounds:r=VoxelShapeType$1.getMaxBounds(n)}=t;e.minBounds=i,e.maxBounds=r,e.minClippingBounds=VoxelShapeType$1.getMinBounds(n),e.maxClippingBounds=VoxelShapeType$1.getMaxBounds(n),e._exaggeratedMinBounds=Cartesian3.clone(e._minBounds,e._exaggeratedMinBounds),e._exaggeratedMaxBounds=Cartesian3.clone(e._maxBounds,e._exaggeratedMaxBounds),e._exaggeratedModelMatrix=Matrix4.clone(e._modelMatrix,e._exaggeratedModelMatrix),checkTransformAndBounds(e,t);const o=VoxelShapeType$1.getShapeConstructor(n);e._shape=new o,e._shapeVisible=updateShapeAndTransforms(e,e._shape)}Object.defineProperties(VoxelPrimitive.prototype,{ready:{get:function(){return this._ready}},provider:{get:function(){return this._provider}},boundingSphere:{get:function(){return this._shape.boundingSphere}},orientedBoundingBox:{get:function(){return this._shape.orientedBoundingBox}},modelMatrix:{get:function(){return this._modelMatrix},set:function(e){Check.typeOf.object("modelMatrix",e),this._modelMatrix=Matrix4.clone(e,this._modelMatrix)}},shape:{get:function(){return this._provider.shape}},dimensions:{get:function(){return this._provider.dimensions}},minimumValues:{get:function(){return this._provider.minimumValues}},maximumValues:{get:function(){return this._provider.maximumValues}},show:{get:function(){return!this._disableRender},set:function(e){Check.typeOf.bool("show",e),this._disableRender=!e}},disableUpdate:{get:function(){return this._disableUpdate},set:function(e){Check.typeOf.bool("disableUpdate",e),this._disableUpdate=e}},debugDraw:{get:function(){return this._debugDraw},set:function(e){Check.typeOf.bool("debugDraw",e),this._debugDraw=e}},depthTest:{get:function(){return this._depthTest},set:function(e){Check.typeOf.bool("depthTest",e),this._depthTest!==e&&(this._depthTest=e,this._shaderDirty=!0)}},jitter:{get:function(){return this._jitter},set:function(e){Check.typeOf.bool("jitter",e),this._jitter!==e&&(this._jitter=e,this._shaderDirty=!0)}},nearestSampling:{get:function(){return this._nearestSampling},set:function(e){Check.typeOf.bool("nearestSampling",e),this._nearestSampling!==e&&(this._nearestSampling=e,this._shaderDirty=!0)}},levelBlendFactor:{get:function(){return this._levelBlendFactor},set:function(e){Check.typeOf.number("levelBlendFactor",e),this._levelBlendFactor=CesiumMath.clamp(e,0,1)}},screenSpaceError:{get:function(){return this._screenSpaceError},set:function(e){Check.typeOf.number("screenSpaceError",e),this._screenSpaceError=e}},stepSize:{get:function(){return this._stepSizeMultiplier},set:function(e){Check.typeOf.number("stepSize",e),this._stepSizeMultiplier=e}},minBounds:{get:function(){return this._minBounds},set:function(e){Check.defined("minBounds",e),this._minBounds=Cartesian3.clone(e,this._minBounds)}},maxBounds:{get:function(){return this._maxBounds},set:function(e){Check.defined("maxBounds",e),this._maxBounds=Cartesian3.clone(e,this._maxBounds)}},minClippingBounds:{get:function(){return this._minClippingBounds},set:function(e){Check.defined("minClippingBounds",e),this._minClippingBounds=Cartesian3.clone(e,this._minClippingBounds)}},maxClippingBounds:{get:function(){return this._maxClippingBounds},set:function(e){Check.defined("maxClippingBounds",e),this._maxClippingBounds=Cartesian3.clone(e,this._maxClippingBounds)}},clippingPlanes:{get:function(){return this._clippingPlanes},set:function(e){ClippingPlaneCollection.setOwner(e,this,"_clippingPlanes")}},customShader:{get:function(){return this._customShader},set:function(e){if(this._customShader!==e){const t=this._uniformMap,i=this._customShader.uniformMap;for(const r in i)i.hasOwnProperty(r)&&delete t[r];defined(e)?this._customShader=e:this._customShader=VoxelPrimitive.DefaultCustomShader,this._shaderDirty=!0}}},customShaderCompilationEvent:{get:function(){return this._customShaderCompilationEvent}}});const scratchDimensions=new Cartesian3,scratchIntersect=new Cartesian4,scratchNdcAabb=new Cartesian4,scratchScale$2=new Cartesian3,scratchLocalScale=new Cartesian3,scratchRotation$1=new Matrix3,scratchRotationAndLocalScale=new Matrix3,scratchTransformPositionWorldToLocal=new Matrix4,scratchTransformPositionLocalToWorld=new Matrix4,scratchTransformPositionLocalToProjection=new Matrix4,transformPositionLocalToUv=Matrix4.fromRotationTranslation(Matrix3.fromUniformScale(.5,new Matrix3),new Cartesian3(.5,.5,.5),new Matrix4),transformPositionUvToLocal=Matrix4.fromRotationTranslation(Matrix3.fromUniformScale(2,new Matrix3),new Cartesian3(-1,-1,-1),new Matrix4);VoxelPrimitive.prototype.update=function(e){const t=this._provider;this._customShader.update(e);const n=e.context;if(!this._ready){initFromProvider(this,t,n),e.afterRender.push(()=>(this._ready=!0,!0));return}updateVerticalExaggeration(this,e);const i=checkTransformAndBounds(this,t),r=this._shape;if(i&&(this._shapeVisible=updateShapeAndTransforms(this,r),checkShapeDefines(this,r)&&(this._shaderDirty=!0)),!this._shapeVisible)return;const o=getKeyframeLocation(t.timeIntervalCollection,this._clock),a=this._traversal,s=a._sampleCount;if(a.update(e,o,i,this._disableUpdate),s!==a._sampleCount&&(this._shaderDirty=!0),!a.isRenderable(a.rootNode)||(this._debugDraw&&debugDraw(this,e),this._disableRender))return;this._useLogDepth!==e.useLogDepth&&(this._useLogDepth=e.useLogDepth,this._shaderDirty=!0),updateClippingPlanes(this,e)&&(this._shaderDirty=!0);const c=a.leafNodeTexture,d=this._uniforms;defined(c)&&(d.octreeLeafNodeTexture=a.leafNodeTexture,d.octreeLeafNodeTexelSizeUv=Cartesian2.clone(a.leafNodeTexelSizeUv,d.octreeLeafNodeTexelSizeUv),d.octreeLeafNodeTilesPerRow=a.leafNodeTilesPerRow),this._shaderDirty&&(buildVoxelDrawCommands(this,n),this._shaderDirty=!1);const h=n.uniformState.viewProjection,f=r.orientedBoundingBox,p=orientedBoundingBoxToNdcAabb(f,h,scratchNdcAabb);if(p.x===1||p.y===1||p.z===-1||p.w===-1)return;d.ndcSpaceAxisAlignedBoundingBox=Cartesian4.clone(p,d.ndcSpaceAxisAlignedBoundingBox);const m=n.uniformState.inverseView;d.transformPositionViewToUv=Matrix4.multiplyTransformation(this._transformPositionWorldToUv,m,d.transformPositionViewToUv);const g=n.uniformState.view;d.transformPositionUvToView=Matrix4.multiplyTransformation(g,this._transformPositionUvToWorld,d.transformPositionUvToView);const _=n.uniformState.inverseViewRotation;d.transformDirectionViewToLocal=Matrix3.multiply(this._transformDirectionWorldToLocal,_,d.transformDirectionViewToLocal),d.transformNormalLocalToWorld=Matrix3.clone(this._transformNormalLocalToWorld,d.transformNormalLocalToWorld);const C=e.camera.positionWC;d.cameraPositionUv=Matrix4.multiplyByPoint(this._transformPositionWorldToUv,C,d.cameraPositionUv),d.stepSize=this._stepSizeMultiplier;const A=e.passes.pick?this._drawCommandPick:e.passes.pickVoxel?this._drawCommandPickVoxel:this._drawCommand;A.boundingVolume=r.boundingSphere,e.commandList.push(A)};const scratchExaggerationScale=new Cartesian3,scratchExaggerationCenter=new Cartesian3,scratchCartographicCenter=new Cartographic,scratchExaggerationTranslation=new Cartesian3;function updateVerticalExaggeration(e,t){if(e._exaggeratedMinBounds=Cartesian3.clone(e._minBounds,e._exaggeratedMinBounds),e._exaggeratedMaxBounds=Cartesian3.clone(e._maxBounds,e._exaggeratedMaxBounds),e.shape===VoxelShapeType$1.ELLIPSOID){const n=t.verticalExaggerationRelativeHeight,i=t.verticalExaggeration;e._exaggeratedMinBounds.z=(e._minBounds.z-n)*i+n,e._exaggeratedMaxBounds.z=(e._maxBounds.z-n)*i+n}else if(e.shape===VoxelShapeType$1.BOX){const n=Cartesian3.fromElements(1,1,t.verticalExaggeration,scratchExaggerationScale);e._exaggeratedModelMatrix=Matrix4.multiplyByScale(e._modelMatrix,n,e._exaggeratedModelMatrix),e._exaggeratedModelMatrix=Matrix4.multiplyByTranslation(e._exaggeratedModelMatrix,computeBoxExaggerationTranslation(e,t),e._exaggeratedModelMatrix)}}function computeBoxExaggerationTranslation(e,t){const{shapeTransform:n=Matrix4.IDENTITY,globalTransform:i=Matrix4.IDENTITY}=e._provider,r=Matrix4.getTranslation(n,scratchExaggerationCenter),o=Matrix4.multiplyByPoint(e._modelMatrix,r,scratchExaggerationCenter),a=Matrix4.multiplyByPoint(i,o,scratchExaggerationCenter),l=Ellipsoid.WGS84.cartesianToCartographic(a,scratchCartographicCenter);let c=0;defined(l)&&(c=l.height);const d=VerticalExaggeration.getHeight(c,t.verticalExaggeration,t.verticalExaggerationRelativeHeight);return Cartesian3.fromElements(0,0,(d-c)/t.verticalExaggeration,scratchExaggerationTranslation)}function initFromProvider(e,t,n){const i=e._uniforms;e._pickId=n.createPickId({primitive:e}),i.pickColor=Color.clone(e._pickId.color,i.pickColor);const{shaderDefines:r,shaderUniforms:o}=e._shape;e._shapeDefinesOld=clone(r,!0);const a=e._uniformMap;for(const s in o)if(o.hasOwnProperty(s)){const l=`u_${s}`;defined(a[l])&&oneTimeWarning(`VoxelPrimitive: Uniform name "${l}" is already defined`),a[l]=function(){return o[s]}}i.dimensions=Cartesian3.clone(t.dimensions,i.dimensions),e._paddingBefore=Cartesian3.clone(defaultValue(t.paddingBefore,Cartesian3.ZERO),e._paddingBefore),i.paddingBefore=Cartesian3.clone(e._paddingBefore,i.paddingBefore),e._paddingAfter=Cartesian3.clone(defaultValue(t.paddingAfter,Cartesian3.ZERO),e._paddingBefore),i.paddingAfter=Cartesian3.clone(e._paddingAfter,i.paddingAfter),e._traversal=setupTraversal(e,t,n),setTraversalUniforms(e._traversal,i)}function checkTransformAndBounds(e,t){const n=defaultValue(t.shapeTransform,Matrix4.IDENTITY),i=defaultValue(t.globalTransform,Matrix4.IDENTITY);return Matrix4.multiplyTransformation(i,e._exaggeratedModelMatrix,e._compoundModelMatrix),Matrix4.multiplyTransformation(e._compoundModelMatrix,n,e._compoundModelMatrix),updateBound(e,"_compoundModelMatrix","_compoundModelMatrixOld")+updateBound(e,"_minBounds","_minBoundsOld")+updateBound(e,"_maxBounds","_maxBoundsOld")+updateBound(e,"_exaggeratedMinBounds","_exaggeratedMinBoundsOld")+updateBound(e,"_exaggeratedMaxBounds","_exaggeratedMaxBoundsOld")+updateBound(e,"_minClippingBounds","_minClippingBoundsOld")+updateBound(e,"_maxClippingBounds","_maxClippingBoundsOld")>0}function updateBound(e,t,n){const i=e[t],r=e[n],o=!i.equals(r);return o&&i.clone(r),o?1:0}function updateShapeAndTransforms(e,t,n){if(!t.update(e._compoundModelMatrix,e._exaggeratedMinBounds,e._exaggeratedMaxBounds,e.minClippingBounds,e.maxClippingBounds))return!1;const r=t.shapeTransform,o=Matrix4.inverse(r,scratchTransformPositionWorldToLocal),a=Matrix4.getRotation(r,scratchRotation$1),s=Matrix4.getScale(r,scratchScale$2),l=Cartesian3.maximumComponent(s),c=Cartesian3.divideByScalar(s,l,scratchLocalScale),d=Matrix3.multiplyByScale(a,c,scratchRotationAndLocalScale);return e._transformPositionWorldToUv=Matrix4.multiplyTransformation(transformPositionLocalToUv,o,e._transformPositionWorldToUv),e._transformPositionUvToWorld=Matrix4.multiplyTransformation(r,transformPositionUvToLocal,e._transformPositionUvToWorld),e._transformDirectionWorldToLocal=Matrix4.getMatrix3(o,e._transformDirectionWorldToLocal),e._transformNormalLocalToWorld=Matrix3.inverseTranspose(d,e._transformNormalLocalToWorld),!0}function setupTraversal(e,t,n){const i=Cartesian3.clone(t.dimensions,scratchDimensions);Cartesian3.add(i,e._paddingBefore,i),Cartesian3.add(i,e._paddingAfter,i);const r=t.maximumTileCount,o=defined(r)?VoxelTraversal.getApproximateTextureMemoryByteLength(r,i,t.types,t.componentTypes):void 0,a=defaultValue(t.keyframeCount,1);return new VoxelTraversal(e,n,i,t.types,t.componentTypes,a,o)}function setTraversalUniforms(e,t){t.octreeInternalNodeTexture=e.internalNodeTexture,t.octreeInternalNodeTexelSizeUv=Cartesian2.clone(e.internalNodeTexelSizeUv,t.octreeInternalNodeTexelSizeUv),t.octreeInternalNodeTilesPerRow=e.internalNodeTilesPerRow;const n=e.megatextures,i=n[0],r=n.length;t.megatextureTextures=new Array(r);for(let o=0;o<r;o++)t.megatextureTextures[o]=n[o].texture;t.megatextureSliceDimensions=Cartesian2.clone(i.sliceCountPerRegion,t.megatextureSliceDimensions),t.megatextureTileDimensions=Cartesian2.clone(i.regionCountPerMegatexture,t.megatextureTileDimensions),t.megatextureVoxelSizeUv=Cartesian2.clone(i.voxelSizeUv,t.megatextureVoxelSizeUv),t.megatextureSliceSizeUv=Cartesian2.clone(i.sliceSizeUv,t.megatextureSliceSizeUv),t.megatextureTileSizeUv=Cartesian2.clone(i.regionSizeUv,t.megatextureTileSizeUv)}function checkShapeDefines(e,t){const n=t.shaderDefines,i=Object.keys(n).some(r=>n[r]!==e._shapeDefinesOld[r]);return i&&(e._shapeDefinesOld=clone(n,!0)),i}function getKeyframeLocation(e,t){if(!defined(e)||!defined(t))return 0;let n=t.currentTime,i,r=e.indexOf(n);r>=0?i=e.get(r):(r=~r,r===e.length?(r=e.length-1,i=e.get(r),n=i.stop):(i=e.get(r),n=i.start));const o=JulianDate.secondsDifference(i.stop,i.start),s=JulianDate.secondsDifference(n,i.start)/o;return r+s}function updateClippingPlanes(e,t){const n=e.clippingPlanes;if(!defined(n))return!1;n.update(t);const{clippingPlanesState:i,enabled:r}=n;if(r){const o=e._uniforms;o.clippingPlanesTexture=n.texture,o.clippingPlanesMatrix=Matrix4.transpose(Matrix4.multiplyTransformation(Matrix4.inverse(n.modelMatrix,o.clippingPlanesMatrix),e._transformPositionUvToWorld,o.clippingPlanesMatrix),o.clippingPlanesMatrix)}return e._clippingPlanesState===i&&e._clippingPlanesEnabled===r?!1:(e._clippingPlanesState=i,e._clippingPlanesEnabled=r,!0)}VoxelPrimitive.prototype.isDestroyed=function(){return!1};VoxelPrimitive.prototype.destroy=function(){const e=this._drawCommand;defined(e)&&(e.shaderProgram=e.shaderProgram&&e.shaderProgram.destroy());const t=this._drawCommandPick;return defined(t)&&(t.shaderProgram=t.shaderProgram&&t.shaderProgram.destroy()),this._pickId=this._pickId&&this._pickId.destroy(),this._traversal=this._traversal&&this._traversal.destroy(),this._clippingPlanes=this._clippingPlanes&&this._clippingPlanes.destroy(),destroyObject(this)};const corners=new Array(new Cartesian4(-1,-1,-1,1),new Cartesian4(1,-1,-1,1),new Cartesian4(-1,1,-1,1),new Cartesian4(1,1,-1,1),new Cartesian4(-1,-1,1,1),new Cartesian4(1,-1,1,1),new Cartesian4(-1,1,1,1),new Cartesian4(1,1,1,1)),vertexNeighborIndices=new Array(1,2,4,0,3,5,0,3,6,1,2,7,0,5,6,1,4,7,2,4,7,3,5,6),scratchCornersClipSpace=new Array(new Cartesian4,new Cartesian4,new Cartesian4,new Cartesian4,new Cartesian4,new Cartesian4,new Cartesian4,new Cartesian4);function orientedBoundingBoxToNdcAabb(e,t,n){const i=Matrix4.fromRotationTranslation(e.halfAxes,e.center,scratchTransformPositionLocalToWorld),r=Matrix4.multiply(t,i,scratchTransformPositionLocalToProjection);let o=+Number.MAX_VALUE,a=-Number.MAX_VALUE,s=+Number.MAX_VALUE,l=-Number.MAX_VALUE,c;const d=scratchCornersClipSpace,h=corners.length;for(c=0;c<h;c++)Matrix4.multiplyByVector(r,corners[c],d[c]);for(c=0;c<h;c++){const f=d[c];if(f.z>=-f.w){const p=f.x/f.w,u=f.y/f.w;o=Math.min(o,p),a=Math.max(a,p),s=Math.min(s,u),l=Math.max(l,u)}else for(let p=0;p<3;p++){const u=vertexNeighborIndices[c*3+p],m=d[u];if(m.z>=-m.w){const g=f.z+f.w,_=m.z+m.w,C=g/(g-_),A=Cartesian4.lerp(f,m,C,scratchIntersect),S=A.x/A.w,v=A.y/A.w;o=Math.min(o,S),a=Math.max(a,S),s=Math.min(s,v),l=Math.max(l,v)}}}return o=CesiumMath.clamp(o,-1,1),s=CesiumMath.clamp(s,-1,1),a=CesiumMath.clamp(a,-1,1),l=CesiumMath.clamp(l,-1,1),n=Cartesian4.fromElements(o,s,a,l,n),n}const polylineAxisDistance=3e7,polylineXAxis=new Cartesian3(polylineAxisDistance,0,0),polylineYAxis=new Cartesian3(0,polylineAxisDistance,0),polylineZAxis=new Cartesian3(0,0,polylineAxisDistance);function debugDraw(e,t){const n=e._traversal,i=e._debugPolylines;i.removeAll();function r(l,c,d,h){i.add({positions:[l,c],width:h,material:Material.fromType("Color",{color:d})})}function o(l,c,d){const h=l.computeCorners();r(h[0],h[1],c,d),r(h[2],h[3],c,d),r(h[4],h[5],c,d),r(h[6],h[7],c,d),r(h[0],h[2],c,d),r(h[4],h[6],c,d),r(h[1],h[3],c,d),r(h[5],h[7],c,d),r(h[0],h[4],c,d),r(h[2],h[6],c,d),r(h[1],h[5],c,d),r(h[3],h[7],c,d)}function a(l){if(!n.isRenderable(l))return;const c=l.level,h=Math.max(1,5/Math.pow(2,c)),p=[Color.RED,Color.LIME,Color.BLUE][c%3];if(o(l.orientedBoundingBox,p,h),defined(l.children))for(let u=0;u<8;u++)a(l.children[u])}o(e._shape.orientedBoundingBox,Color.WHITE,5),a(n.rootNode);const s=10;r(Cartesian3.ZERO,polylineXAxis,Color.RED,s),r(Cartesian3.ZERO,polylineYAxis,Color.LIME,s),r(Cartesian3.ZERO,polylineZAxis,Color.BLUE,s),i.update(t)}VoxelPrimitive.DefaultCustomShader=new CustomShader({fragmentShaderText:`void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material)
{
    material.diffuse = vec3(1.0);
    material.alpha = 1.0;
}`});function DefaultVoxelProvider(){this.ready=!0,this.shape=VoxelShapeType$1.BOX,this.dimensions=new Cartesian3(1,1,1),this.names=["data"],this.types=[MetadataType.SCALAR],this.componentTypes=[MetadataComponentType.FLOAT32],this.maximumTileCount=1}DefaultVoxelProvider.prototype.requestData=function(e){if(!((defined(e)?defaultValue(e.tileLevel,0):0)>=1))return Promise.resolve([new Float32Array(1)])};VoxelPrimitive.DefaultProvider=new DefaultVoxelProvider;const requestRenderAfterFrame=function(e){return function(){e.frameState.afterRender.push(function(){e.requestRender()})}};function Scene(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.canvas;let n=e.creditContainer,i=e.creditViewport;const r=clone(e.contextOptions);if(!defined(t))throw new DeveloperError("options and options.canvas are required.");const o=defined(n),a=new Context(t,r);o||(n=document.createElement("div"),n.style.position="absolute",n.style.bottom="0",n.style["text-shadow"]="0 0 2px #000000",n.style.color="#ffffff",n.style["font-size"]="10px",n.style["padding-right"]="5px",t.parentNode.appendChild(n)),defined(i)||(i=t.parentNode),this._id=createGuid(),this._jobScheduler=new JobScheduler,this._frameState=new FrameState(a,new CreditDisplay(n,"",i),this._jobScheduler),this._frameState.scene3DOnly=defaultValue(e.scene3DOnly,!1),this._removeCreditContainer=!o,this._creditContainer=n,this._canvas=t,this._context=a,this._computeEngine=new ComputeEngine(a),this._ellipsoid=defaultValue(e.ellipsoid,Ellipsoid.default),this._globe=void 0,this._globeTranslucencyState=new GlobeTranslucencyState,this._primitives=new PrimitiveCollection,this._groundPrimitives=new PrimitiveCollection,this._globeHeight=void 0,this._globeHeightDirty=!0,this._cameraUnderground=!1,this._removeUpdateHeightCallback=void 0,this._logDepthBuffer=Scene.defaultLogDepthBuffer&&a.fragmentDepth,this._logDepthBufferDirty=!0,this._tweens=new TweenCollection,this._shaderFrameCount=0,this._sunPostProcess=void 0,this._computeCommandList=[],this._overlayCommandList=[],this._useOIT=defaultValue(e.orderIndependentTranslucency,!0),this._executeOITFunction=void 0,this._depthPlane=new DepthPlane(e.depthPlaneEllipsoidOffset),this._clearColorCommand=new ClearCommand({color:new Color,stencil:0,owner:this}),this._depthClearCommand=new ClearCommand({depth:1,owner:this}),this._stencilClearCommand=new ClearCommand({stencil:0}),this._classificationStencilClearCommand=new ClearCommand({stencil:0,renderState:RenderState.fromCache({stencilMask:StencilConstants.CLASSIFICATION_MASK})}),this._depthOnlyRenderStateCache={},this._transitioner=new SceneTransitioner(this),this._preUpdate=new Event,this._postUpdate=new Event,this._renderError=new Event,this._preRender=new Event,this._postRender=new Event,this._minimumDisableDepthTestDistance=0,this._debugInspector=new DebugInspector,this._msaaSamples=defaultValue(e.msaaSamples,1),this.rethrowRenderErrors=!1,this.completeMorphOnUserInput=!0,this.morphStart=new Event,this.morphComplete=new Event,this.skyBox=void 0,this.skyAtmosphere=void 0,this.sun=void 0,this.sunBloom=!0,this._sunBloom=void 0,this.moon=void 0,this.backgroundColor=Color.clone(Color.BLACK),this._mode=SceneMode.SCENE3D,this._mapProjection=defined(e.mapProjection)?e.mapProjection:new GeographicProjection(this._ellipsoid),this.morphTime=1,this.farToNearRatio=1e3,this.logarithmicDepthFarToNearRatio=1e9,this.nearToFarDistance2D=175e4,this.verticalExaggeration=1,this.verticalExaggerationRelativeHeight=0,this.debugCommandFilter=void 0,this.debugShowCommands=!1,this.debugShowFrustums=!1,this.debugShowFramesPerSecond=!1,this.debugShowDepthFrustum=1,this.debugShowFrustumPlanes=!1,this._debugShowFrustumPlanes=!1,this._debugFrustumPlanes=void 0,this.useDepthPicking=!0,this.pickTranslucentDepth=!1,this.cameraEventWaitTime=500,this.atmosphere=new Atmosphere,this.fog=new Fog,this.fog.enabled=Ellipsoid.WGS84.equals(this._ellipsoid),Ellipsoid.WGS84.equals(this._ellipsoid)||(Camera.DEFAULT_VIEW_RECTANGLE=Rectangle.fromDegrees(-45,-45,45,45)),this._shadowMapCamera=new Camera(this),this.shadowMap=new ShadowMap({context:a,lightCamera:this._shadowMapCamera,enabled:defaultValue(e.shadows,!1)}),this.invertClassification=!1,this.invertClassificationColor=Color.clone(Color.WHITE),this._actualInvertClassificationColor=Color.clone(this._invertClassificationColor),this._invertClassification=new InvertClassification,this.focalLength=void 0,this.eyeSeparation=void 0,this.postProcessStages=new PostProcessStageCollection,this._brdfLutGenerator=new BrdfLutGenerator,this._performanceDisplay=void 0,this._debugVolume=void 0,this._screenSpaceCameraController=new ScreenSpaceCameraController(this),this._cameraUnderground=!1,this._mapMode2D=defaultValue(e.mapMode2D,MapMode2D$1.INFINITE_SCROLL),this._environmentState={skyBoxCommand:void 0,skyAtmosphereCommand:void 0,sunDrawCommand:void 0,sunComputeCommand:void 0,moonCommand:void 0,isSunVisible:!1,isMoonVisible:!1,isReadyForAtmosphere:!1,isSkyAtmosphereVisible:!1,clearGlobeDepth:!1,useDepthPlane:!1,renderTranslucentDepthForPick:!1,originalFramebuffer:void 0,useGlobeDepthFramebuffer:!1,useOIT:!1,useInvertClassification:!1,usePostProcess:!1,usePostProcessSelected:!1,useWebVR:!1},this._useWebVR=!1,this._cameraVR=void 0,this._aspectRatioVR=void 0,this.requestRenderMode=defaultValue(e.requestRenderMode,!1),this._renderRequested=!0,this.maximumRenderTimeChange=defaultValue(e.maximumRenderTimeChange,0),this._lastRenderTime=void 0,this._frameRateMonitor=void 0,this._removeRequestListenerCallback=RequestScheduler.requestCompletedEvent.addEventListener(requestRenderAfterFrame(this)),this._removeTaskProcessorListenerCallback=TaskProcessor.taskCompletedEvent.addEventListener(requestRenderAfterFrame(this)),this._removeGlobeCallbacks=[],this._removeTerrainProviderReadyListener=void 0;const s=new BoundingRectangle(0,0,a.drawingBufferWidth,a.drawingBufferHeight),l=new Camera(this);this._logDepthBuffer&&(l.frustum.near=.1,l.frustum.far=1e10),this.preloadFlightCamera=new Camera(this),this.preloadFlightCullingVolume=void 0,this._picking=new Picking(this),this._defaultView=new View(this,l,s),this._view=this._defaultView,this._hdr=void 0,this._hdrDirty=void 0,this.highDynamicRange=!1,this.gamma=2.2,this.sphericalHarmonicCoefficients=void 0,this.specularEnvironmentMaps=void 0,this._specularEnvironmentMapAtlas=void 0,this.light=new SunLight,updateFrameNumber(this,0,JulianDate.now()),this.updateFrameState(),this.initializeFrame()}Scene.defaultLogDepthBuffer=!0;function updateGlobeListeners(e,t){for(let i=0;i<e._removeGlobeCallbacks.length;++i)e._removeGlobeCallbacks[i]();e._removeGlobeCallbacks.length=0;const n=[];defined(t)&&(n.push(t.imageryLayersUpdatedEvent.addEventListener(requestRenderAfterFrame(e))),n.push(t.terrainProviderChanged.addEventListener(requestRenderAfterFrame(e)))),e._removeGlobeCallbacks=n}Object.defineProperties(Scene.prototype,{canvas:{get:function(){return this._canvas}},drawingBufferHeight:{get:function(){return this._context.drawingBufferHeight}},drawingBufferWidth:{get:function(){return this._context.drawingBufferWidth}},maximumAliasedLineWidth:{get:function(){return ContextLimits.maximumAliasedLineWidth}},maximumCubeMapSize:{get:function(){return ContextLimits.maximumCubeMapSize}},pickPositionSupported:{get:function(){return this._context.depthTexture}},sampleHeightSupported:{get:function(){return this._context.depthTexture}},clampToHeightSupported:{get:function(){return this._context.depthTexture}},invertClassificationSupported:{get:function(){return this._context.depthTexture}},specularEnvironmentMapsSupported:{get:function(){return OctahedralProjectedCubeMap.isSupported(this._context)}},ellipsoid:{get:function(){return this._ellipsoid}},globe:{get:function(){return this._globe},set:function(e){this._globe=this._globe&&this._globe.destroy(),this._globe=e,updateGlobeListeners(this,e)}},primitives:{get:function(){return this._primitives}},groundPrimitives:{get:function(){return this._groundPrimitives}},camera:{get:function(){return this._view.camera},set:function(e){this._view.camera=e}},view:{get:function(){return this._view},set:function(e){this._view=e}},defaultView:{get:function(){return this._defaultView}},picking:{get:function(){return this._picking}},screenSpaceCameraController:{get:function(){return this._screenSpaceCameraController}},mapProjection:{get:function(){return this._mapProjection}},jobScheduler:{get:function(){return this._jobScheduler}},frameState:{get:function(){return this._frameState}},environmentState:{get:function(){return this._environmentState}},tweens:{get:function(){return this._tweens}},imageryLayers:{get:function(){if(defined(this.globe))return this.globe.imageryLayers}},terrainProvider:{get:function(){if(defined(this.globe))return this.globe.terrainProvider},set:function(e){this._removeTerrainProviderReadyListener=this._removeTerrainProviderReadyListener&&this._removeTerrainProviderReadyListener(),defined(this.globe)&&(this.globe.terrainProvider=e)}},terrainProviderChanged:{get:function(){if(defined(this.globe))return this.globe.terrainProviderChanged}},preUpdate:{get:function(){return this._preUpdate}},postUpdate:{get:function(){return this._postUpdate}},renderError:{get:function(){return this._renderError}},preRender:{get:function(){return this._preRender}},postRender:{get:function(){return this._postRender}},lastRenderTime:{get:function(){return this._lastRenderTime}},context:{get:function(){return this._context}},debugFrustumStatistics:{get:function(){return this._view.debugFrustumStatistics}},scene3DOnly:{get:function(){return this._frameState.scene3DOnly}},orderIndependentTranslucency:{get:function(){return this._useOIT}},id:{get:function(){return this._id}},mode:{get:function(){return this._mode},set:function(e){if(this.scene3DOnly&&e!==SceneMode.SCENE3D)throw new DeveloperError("Only SceneMode.SCENE3D is valid when scene3DOnly is true.");if(e===SceneMode.SCENE2D)this.morphTo2D(0);else if(e===SceneMode.SCENE3D)this.morphTo3D(0);else if(e===SceneMode.COLUMBUS_VIEW)this.morphToColumbusView(0);else throw new DeveloperError("value must be a valid SceneMode enumeration.");this._mode=e}},frustumCommandsList:{get:function(){return this._view.frustumCommandsList}},numberOfFrustums:{get:function(){return this._view.frustumCommandsList.length}},useWebVR:{get:function(){return this._useWebVR},set:function(e){if(this.camera.frustum instanceof OrthographicFrustum)throw new DeveloperError("VR is unsupported with an orthographic projection.");this._useWebVR=e,this._useWebVR?(this._frameState.creditDisplay.container.style.visibility="hidden",this._cameraVR=new Camera(this),defined(this._deviceOrientationCameraController)||(this._deviceOrientationCameraController=new DeviceOrientationCameraController(this)),this._aspectRatioVR=this.camera.frustum.aspectRatio):(this._frameState.creditDisplay.container.style.visibility="visible",this._cameraVR=void 0,this._deviceOrientationCameraController=this._deviceOrientationCameraController&&!this._deviceOrientationCameraController.isDestroyed()&&this._deviceOrientationCameraController.destroy(),this.camera.frustum.aspectRatio=this._aspectRatioVR,this.camera.frustum.xOffset=0)}},mapMode2D:{get:function(){return this._mapMode2D}},splitPosition:{get:function(){return this._frameState.splitPosition},set:function(e){this._frameState.splitPosition=e}},minimumDisableDepthTestDistance:{get:function(){return this._minimumDisableDepthTestDistance},set:function(e){if(!defined(e)||e<0)throw new DeveloperError("minimumDisableDepthTestDistance must be greater than or equal to 0.0.");this._minimumDisableDepthTestDistance=e}},logarithmicDepthBuffer:{get:function(){return this._logDepthBuffer},set:function(e){e=this._context.fragmentDepth&&e,this._logDepthBuffer!==e&&(this._logDepthBuffer=e,this._logDepthBufferDirty=!0)}},gamma:{get:function(){return this._context.uniformState.gamma},set:function(e){this._context.uniformState.gamma=e}},highDynamicRange:{get:function(){return this._hdr},set:function(e){const t=this._context,n=e&&t.depthTexture&&(t.colorBufferFloat||t.colorBufferHalfFloat);this._hdrDirty=n!==this._hdr,this._hdr=n}},highDynamicRangeSupported:{get:function(){const e=this._context;return e.depthTexture&&(e.colorBufferFloat||e.colorBufferHalfFloat)}},cameraUnderground:{get:function(){return this._cameraUnderground}},msaaSamples:{get:function(){return this._msaaSamples},set:function(e){e=Math.min(e,ContextLimits.maximumSamples),this._msaaSamples=e}},msaaSupported:{get:function(){return this._context.msaa}},pixelRatio:{get:function(){return this._frameState.pixelRatio},set:function(e){this._frameState.pixelRatio=e}},opaqueFrustumNearOffset:{get:function(){return .9999}},globeHeight:{get:function(){return this._globeHeight}}});Scene.prototype.getCompressedTextureFormatSupported=function(e){const t=this.context;return(e==="WEBGL_compressed_texture_s3tc"||e==="s3tc")&&t.s3tc||(e==="WEBGL_compressed_texture_pvrtc"||e==="pvrtc")&&t.pvrtc||(e==="WEBGL_compressed_texture_etc"||e==="etc")&&t.etc||(e==="WEBGL_compressed_texture_etc1"||e==="etc1")&&t.etc1||(e==="WEBGL_compressed_texture_astc"||e==="astc")&&t.astc||(e==="EXT_texture_compression_bptc"||e==="bc7")&&t.bc7};function updateDerivedCommands(e,t,n){const i=e._frameState,r=e._context,o=e._view.oit,a=i.shadowState.lightShadowMaps,s=i.shadowState.lightShadowsEnabled;let l=t.derivedCommands;defined(t.pickId)&&(l.picking=DerivedCommand.createPickDerivedCommand(e,t,r,l.picking)),t.pickOnly||(l.depth=DerivedCommand.createDepthOnlyDerivedCommand(e,t,r,l.depth)),l.originalCommand=t,e._hdr&&(l.hdr=DerivedCommand.createHdrCommand(t,r,l.hdr),t=l.hdr.command,l=t.derivedCommands),s&&t.receiveShadows&&(l.shadows=ShadowMap.createReceiveDerivedCommand(a,t,n,r,l.shadows)),t.pass===Pass.TRANSLUCENT&&defined(o)&&o.isSupported()&&(s&&t.receiveShadows?(l.oit=defined(l.oit)?l.oit:{},l.oit.shadows=o.createDerivedCommands(l.shadows.receiveCommand,r,l.oit.shadows)):l.oit=o.createDerivedCommands(t,r,l.oit))}Scene.prototype.updateDerivedCommands=function(e){if(!defined(e.derivedCommands))return;const t=this._frameState,n=this._context;let i=!1;const r=t.shadowState.lastDirtyTime;e.lastDirtyTime!==r&&(e.lastDirtyTime=r,e.dirty=!0,i=!0);const o=t.useLogDepth,a=this._hdr,s=e.derivedCommands,l=defined(s.logDepth),c=defined(s.hdr),d=defined(s.originalCommand),h=o&&!l,f=a&&!c,p=(!o||!a)&&!d;if(e.dirty=e.dirty||h||f||p,e.dirty){e.dirty=!1;const u=t.shadowState.shadowMaps;t.shadowState.shadowsEnabled&&e.castShadows&&(s.shadows=ShadowMap.createCastDerivedCommand(u,e,i,n,s.shadows)),(l||h)&&(s.logDepth=DerivedCommand.createLogDepthCommand(e,n,s.logDepth),updateDerivedCommands(this,s.logDepth.command,i)),(d||p)&&updateDerivedCommands(this,e,i)}};const renderTilesetPassState=new Cesium3DTilePassState({pass:Cesium3DTilePass.RENDER}),preloadTilesetPassState=new Cesium3DTilePassState({pass:Cesium3DTilePass.PRELOAD}),preloadFlightTilesetPassState=new Cesium3DTilePassState({pass:Cesium3DTilePass.PRELOAD_FLIGHT}),requestRenderModeDeferCheckPassState=new Cesium3DTilePassState({pass:Cesium3DTilePass.REQUEST_RENDER_MODE_DEFER_CHECK}),scratchOccluderBoundingSphere=new BoundingSphere;let scratchOccluder;function getOccluder(e){const t=e.globe;if(e._mode===SceneMode.SCENE3D&&defined(t)&&t.show&&!e._cameraUnderground&&!e._globeTranslucencyState.translucent){const n=e.ellipsoid,i=e.frameState.minimumTerrainHeight;return scratchOccluderBoundingSphere.radius=n.minimumRadius+i,scratchOccluder=Occluder.fromBoundingSphere(scratchOccluderBoundingSphere,e.camera.positionWC,scratchOccluder),scratchOccluder}}Scene.prototype.clearPasses=function(e){e.render=!1,e.pick=!1,e.pickVoxel=!1,e.depth=!1,e.postProcess=!1,e.offscreen=!1};function updateFrameNumber(e,t,n){const i=e._frameState;i.frameNumber=t,i.time=JulianDate.clone(n,i.time)}Scene.prototype.updateFrameState=function(){const e=this.camera,t=this._frameState;t.commandList.length=0,t.shadowMaps.length=0,t.brdfLutGenerator=this._brdfLutGenerator,t.environmentMap=this.skyBox&&this.skyBox._cubeMap,t.mode=this._mode,t.morphTime=this.morphTime,t.mapProjection=this.mapProjection,t.camera=e,t.cullingVolume=e.frustum.computeCullingVolume(e.positionWC,e.directionWC,e.upWC),t.occluder=getOccluder(this),t.minimumTerrainHeight=0,t.minimumDisableDepthTestDistance=this._minimumDisableDepthTestDistance,t.invertClassification=this.invertClassification,t.useLogDepth=this._logDepthBuffer&&!(this.camera.frustum instanceof OrthographicFrustum||this.camera.frustum instanceof OrthographicOffCenterFrustum),t.light=this.light,t.cameraUnderground=this._cameraUnderground,t.globeTranslucencyState=this._globeTranslucencyState;const{globe:n}=this;defined(n)&&n._terrainExaggerationChanged&&(this.verticalExaggeration=n._terrainExaggeration,this.verticalExaggerationRelativeHeight=n._terrainExaggerationRelativeHeight,n._terrainExaggerationChanged=!1),t.verticalExaggeration=this.verticalExaggeration,t.verticalExaggerationRelativeHeight=this.verticalExaggerationRelativeHeight,defined(this._specularEnvironmentMapAtlas)&&this._specularEnvironmentMapAtlas.ready?(t.specularEnvironmentMaps=this._specularEnvironmentMapAtlas.texture,t.specularEnvironmentMapsMaximumLOD=this._specularEnvironmentMapAtlas.maximumMipmapLevel):(t.specularEnvironmentMaps=void 0,t.specularEnvironmentMapsMaximumLOD=void 0),t.sphericalHarmonicCoefficients=this.sphericalHarmonicCoefficients,this._actualInvertClassificationColor=Color.clone(this.invertClassificationColor,this._actualInvertClassificationColor),InvertClassification.isTranslucencySupported(this._context)||(this._actualInvertClassificationColor.alpha=1),t.invertClassificationColor=this._actualInvertClassificationColor,defined(this.globe)?t.maximumScreenSpaceError=this.globe.maximumScreenSpaceError:t.maximumScreenSpaceError=2,this.clearPasses(t.passes),t.tilesetPassState=void 0};Scene.prototype.isVisible=function(e,t,n){return defined(e)&&(!defined(e.boundingVolume)||!e.cull||t.computeVisibility(e.boundingVolume)!==Intersect.OUTSIDE&&(!defined(n)||!e.occlude||!e.boundingVolume.isOccluded(n)))};let transformFrom2D=new Matrix4(0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,1);transformFrom2D=Matrix4.inverseTransformation(transformFrom2D,transformFrom2D);function debugShowBoundingVolume(e,t,n,i){const r=t._frameState,o=r.context,a=e.boundingVolume;defined(t._debugVolume)&&t._debugVolume.destroy();let s,l=Cartesian3.clone(a.center);if(r.mode!==SceneMode.SCENE3D){l=Matrix4.multiplyByPoint(transformFrom2D,l,l);const f=r.mapProjection,p=f.unproject(l);l=f.ellipsoid.cartographicToCartesian(p)}if(defined(a.radius)){const f=a.radius;s=GeometryPipeline.toWireframe(EllipsoidGeometry.createGeometry(new EllipsoidGeometry({radii:new Cartesian3(f,f,f),vertexFormat:PerInstanceColorAppearance.FLAT_VERTEX_FORMAT}))),t._debugVolume=new Primitive({geometryInstances:new GeometryInstance({geometry:s,modelMatrix:Matrix4.fromTranslation(l),attributes:{color:new ColorGeometryInstanceAttribute(1,0,0,1)}}),appearance:new PerInstanceColorAppearance({flat:!0,translucent:!1}),asynchronous:!1})}else{const f=a.halfAxes;s=GeometryPipeline.toWireframe(BoxGeometry.createGeometry(BoxGeometry.fromDimensions({dimensions:new Cartesian3(2,2,2),vertexFormat:PerInstanceColorAppearance.FLAT_VERTEX_FORMAT}))),t._debugVolume=new Primitive({geometryInstances:new GeometryInstance({geometry:s,modelMatrix:Matrix4.fromRotationTranslation(f,l,new Matrix4),attributes:{color:new ColorGeometryInstanceAttribute(1,0,0,1)}}),appearance:new PerInstanceColorAppearance({flat:!0,translucent:!1}),asynchronous:!1})}const c=r.commandList,d=r.commandList=[];t._debugVolume.update(r),e=d[0],r.useLogDepth&&(e=DerivedCommand.createLogDepthCommand(e,o).command);let h;defined(i)&&(h=n.framebuffer,n.framebuffer=i),e.execute(o,n),defined(h)&&(n.framebuffer=h),r.commandList=c}function executeCommand(e,t,n,i,r){const o=t._frameState;if(defined(t.debugCommandFilter)&&!t.debugCommandFilter(e))return;if(e instanceof ClearCommand){e.execute(n,i);return}e.debugShowBoundingVolume&&defined(e.boundingVolume)&&debugShowBoundingVolume(e,t,i,r),o.useLogDepth&&defined(e.derivedCommands.logDepth)&&(e=e.derivedCommands.logDepth.command);const a=o.passes;if(!a.pick&&!a.pickVoxel&&!a.depth&&t._hdr&&defined(e.derivedCommands)&&defined(e.derivedCommands.hdr)&&(e=e.derivedCommands.hdr.command),a.pick||a.depth){if(a.pick&&!a.depth&&defined(e.derivedCommands.picking)){e=e.derivedCommands.picking.pickCommand,e.execute(n,i);return}else if(defined(e.derivedCommands.depth)){e=e.derivedCommands.depth.depthOnlyCommand,e.execute(n,i);return}}if(t.debugShowCommands||t.debugShowFrustums){t._debugInspector.executeDebugShowFrustumsCommand(t,e,i);return}o.shadowState.lightShadowsEnabled&&e.receiveShadows&&defined(e.derivedCommands.shadows)?e.derivedCommands.shadows.receiveCommand.execute(n,i):e.execute(n,i)}function executeIdCommand(e,t,n,i){const r=t._frameState;let o=e.derivedCommands;defined(o)&&(r.useLogDepth&&defined(o.logDepth)&&(e=o.logDepth.command),o=e.derivedCommands,defined(o.picking)?(e=o.picking.pickCommand,e.execute(n,i)):defined(o.depth)&&(e=o.depth.depthOnlyCommand,e.execute(n,i)))}function backToFront(e,t,n){return t.boundingVolume.distanceSquaredTo(n)-e.boundingVolume.distanceSquaredTo(n)}function frontToBack(e,t,n){return e.boundingVolume.distanceSquaredTo(n)-t.boundingVolume.distanceSquaredTo(n)+CesiumMath.EPSILON12}function executeTranslucentCommandsBackToFront(e,t,n,i,r){const o=e.context;mergeSort(i,backToFront,e.camera.positionWC),defined(r)&&t(r.unclassifiedCommand,e,o,n);const a=i.length;for(let s=0;s<a;++s)t(i[s],e,o,n)}function executeTranslucentCommandsFrontToBack(e,t,n,i,r){const o=e.context;mergeSort(i,frontToBack,e.camera.positionWC),defined(r)&&t(r.unclassifiedCommand,e,o,n);const a=i.length;for(let s=0;s<a;++s)t(i[s],e,o,n)}function executeVoxelCommands(e,t,n,i){const r=e.context;mergeSort(i,backToFront,e.camera.positionWC);const o=i.length;for(let a=0;a<o;++a)t(i[a],e,r,n)}const scratchPerspectiveFrustum=new PerspectiveFrustum,scratchPerspectiveOffCenterFrustum=new PerspectiveOffCenterFrustum,scratchOrthographicFrustum=new OrthographicFrustum,scratchOrthographicOffCenterFrustum=new OrthographicOffCenterFrustum;function executeCommands(e,t){const{camera:n,context:i,frameState:r}=e,{uniformState:o}=i;o.updateCamera(n);let a;defined(n.frustum.fov)?a=n.frustum.clone(scratchPerspectiveFrustum):defined(n.frustum.infiniteProjectionMatrix)?a=n.frustum.clone(scratchPerspectiveOffCenterFrustum):defined(n.frustum.width)?a=n.frustum.clone(scratchOrthographicFrustum):a=n.frustum.clone(scratchOrthographicOffCenterFrustum),a.near=n.frustum.near,a.far=n.frustum.far,o.updateFrustum(a),o.updatePass(Pass.ENVIRONMENT);const s=r.passes,l=s.pick||s.pickVoxel,c=e._environmentState,d=e._view,h=c.renderTranslucentDepthForPick,f=c.useWebVR;if(!l){const x=c.skyBoxCommand;if(defined(x)&&executeCommand(x,e,i,t),c.isSkyAtmosphereVisible&&executeCommand(c.skyAtmosphereCommand,e,i,t),c.isSunVisible&&(c.sunDrawCommand.execute(i,t),e.sunBloom&&!f)){let T;c.useGlobeDepthFramebuffer?T=d.globeDepth.framebuffer:c.usePostProcess?T=d.sceneFramebuffer.framebuffer:T=c.originalFramebuffer,e._sunPostProcess.execute(i),e._sunPostProcess.copy(i,T),t.framebuffer=T}c.isMoonVisible&&c.moonCommand.execute(i,t)}let p;c.useOIT?(defined(e._executeOITFunction)||(e._executeOITFunction=function(x,T,E,P,M){d.globeDepth.prepareColorTextures(i),d.oit.executeCommands(x,T,E,P,M)}),p=e._executeOITFunction):s.render?p=executeTranslucentCommandsBackToFront:p=executeTranslucentCommandsFrontToBack;const u=d.frustumCommandsList,m=u.length,g=c.clearGlobeDepth,_=c.useDepthPlane,C=e._globeTranslucencyState,A=C.translucent,S=e._view.globeTranslucencyFramebuffer,v=e._depthClearCommand,b=e._stencilClearCommand,D=e._classificationStencilClearCommand,I=e._depthPlane,L=c.usePostProcessSelected,N=n.position.z;let y;for(let x=0;x<m;++x){const T=m-x-1,E=u[T];e.mode===SceneMode.SCENE2D?(n.position.z=N-E.near+1,a.far=Math.max(1,E.far-E.near),a.near=1,o.update(r),o.updateFrustum(a)):(a.near=T!==0?E.near*e.opaqueFrustumNearOffset:E.near,a.far=E.far,o.updateFrustum(a)),v.execute(i,t),i.stencilBuffer&&b.execute(i,t),o.updatePass(Pass.GLOBE);let P=E.commands[Pass.GLOBE],M=E.indices[Pass.GLOBE];if(A)C.executeGlobeCommands(E,executeCommand,S,e,t);else for(y=0;y<M;++y)executeCommand(P[y],e,i,t);const O=d.globeDepth;if(defined(O)&&c.useGlobeDepthFramebuffer&&O.executeCopyDepth(i,t),!c.renderTranslucentDepthForPick)if(o.updatePass(Pass.TERRAIN_CLASSIFICATION),P=E.commands[Pass.TERRAIN_CLASSIFICATION],M=E.indices[Pass.TERRAIN_CLASSIFICATION],A)C.executeGlobeClassificationCommands(E,executeCommand,S,e,t);else for(y=0;y<M;++y)executeCommand(P[y],e,i,t);if(g&&(v.execute(i,t),_&&I.execute(i,t)),!c.useInvertClassification||l||c.renderTranslucentDepthForPick){for(o.updatePass(Pass.CESIUM_3D_TILE),P=E.commands[Pass.CESIUM_3D_TILE],M=E.indices[Pass.CESIUM_3D_TILE],y=0;y<M;++y)executeCommand(P[y],e,i,t);if(M>0&&(defined(O)&&c.useGlobeDepthFramebuffer&&(O.prepareColorTextures(i,g),O.executeUpdateDepth(i,t,g,O.depthStencilTexture)),!c.renderTranslucentDepthForPick))for(o.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION),P=E.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION],M=E.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION],y=0;y<M;++y)executeCommand(P[y],e,i,t)}else{e._invertClassification.clear(i,t);const U=t.framebuffer;for(t.framebuffer=e._invertClassification._fbo.framebuffer,o.updatePass(Pass.CESIUM_3D_TILE),P=E.commands[Pass.CESIUM_3D_TILE],M=E.indices[Pass.CESIUM_3D_TILE],y=0;y<M;++y)executeCommand(P[y],e,i,t);for(defined(O)&&c.useGlobeDepthFramebuffer&&(e._invertClassification.prepareTextures(i),O.executeUpdateDepth(i,t,g,e._invertClassification._fbo.getDepthStencilTexture())),o.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW),P=E.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW],M=E.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW],y=0;y<M;++y)executeCommand(P[y],e,i,t);for(t.framebuffer=U,e._invertClassification.executeClassified(i,t),r.invertClassificationColor.alpha===1&&e._invertClassification.executeUnclassified(i,t),M>0&&i.stencilBuffer&&D.execute(i,t),o.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION),P=E.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION],M=E.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION],y=0;y<M;++y)executeCommand(P[y],e,i,t)}for(M>0&&i.stencilBuffer&&b.execute(i,t),o.updatePass(Pass.VOXELS),P=E.commands[Pass.VOXELS],M=E.indices[Pass.VOXELS],P.length=M,executeVoxelCommands(e,executeCommand,t,P),o.updatePass(Pass.OPAQUE),P=E.commands[Pass.OPAQUE],M=E.indices[Pass.OPAQUE],y=0;y<M;++y)executeCommand(P[y],e,i,t);T!==0&&e.mode!==SceneMode.SCENE2D&&(a.near=E.near,o.updateFrustum(a));let V;if(!l&&c.useInvertClassification&&r.invertClassificationColor.alpha<1&&(V=e._invertClassification),o.updatePass(Pass.TRANSLUCENT),P=E.commands[Pass.TRANSLUCENT],P.length=E.indices[Pass.TRANSLUCENT],p(e,executeCommand,t,P,V),E.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION]>0&&d.translucentTileClassification.isSupported()&&(d.translucentTileClassification.executeTranslucentCommands(e,executeCommand,t,P,O.depthStencilTexture),d.translucentTileClassification.executeClassificationCommands(e,executeCommand,t,E)),i.depthTexture&&e.useDepthPicking&&(c.useGlobeDepthFramebuffer||h)){const U=O.depthStencilTexture,k=e._picking.getPickDepth(e,T);k.update(i,U),k.executeCopyDepth(i,t)}if(l||!L)continue;const w=t.framebuffer;if(t.framebuffer=d.sceneFramebuffer.getIdFramebuffer(),a.near=T!==0?E.near*e.opaqueFrustumNearOffset:E.near,a.far=E.far,o.updateFrustum(a),o.updatePass(Pass.GLOBE),P=E.commands[Pass.GLOBE],M=E.indices[Pass.GLOBE],A)C.executeGlobeCommands(E,executeIdCommand,S,e,t);else for(y=0;y<M;++y)executeIdCommand(P[y],e,i,t);for(g&&(v.framebuffer=t.framebuffer,v.execute(i,t),v.framebuffer=void 0),g&&_&&I.execute(i,t),o.updatePass(Pass.CESIUM_3D_TILE),P=E.commands[Pass.CESIUM_3D_TILE],M=E.indices[Pass.CESIUM_3D_TILE],y=0;y<M;++y)executeIdCommand(P[y],e,i,t);for(o.updatePass(Pass.OPAQUE),P=E.commands[Pass.OPAQUE],M=E.indices[Pass.OPAQUE],y=0;y<M;++y)executeIdCommand(P[y],e,i,t);for(o.updatePass(Pass.TRANSLUCENT),P=E.commands[Pass.TRANSLUCENT],M=E.indices[Pass.TRANSLUCENT],y=0;y<M;++y)executeIdCommand(P[y],e,i,t);t.framebuffer=w}}function executeComputeCommands(e){e.context.uniformState.updatePass(Pass.COMPUTE);const n=e._environmentState.sunComputeCommand;defined(n)&&n.execute(e._computeEngine);const i=e._computeCommandList,r=i.length;for(let o=0;o<r;++o)i[o].execute(e._computeEngine)}function executeOverlayCommands(e,t){e.context.uniformState.updatePass(Pass.OVERLAY);const i=e.context,r=e._overlayCommandList,o=r.length;for(let a=0;a<o;++a)r[a].execute(i,t)}function insertShadowCastCommands(e,t,n){const i=n.shadowMapCullingVolume,r=n.isPointLight,o=n.passes,a=o.length,s=t.length;for(let l=0;l<s;++l){const c=t[l];if(e.updateDerivedCommands(c),c.castShadows&&(c.pass===Pass.GLOBE||c.pass===Pass.CESIUM_3D_TILE||c.pass===Pass.OPAQUE||c.pass===Pass.TRANSLUCENT)&&e.isVisible(c,i))if(r)for(let d=0;d<a;++d)o[d].commandList.push(c);else if(a===1)o[0].commandList.push(c);else{let d=!1;for(let h=a-1;h>=0;--h){const f=o[h].cullingVolume;if(e.isVisible(c,f))o[h].commandList.push(c),d=!0;else if(d)break}}}}function executeShadowMapCastCommands(e){const t=e.frameState,n=t.shadowState.shadowMaps,i=n.length;if(!t.shadowState.shadowsEnabled)return;const r=e.context,o=r.uniformState;for(let a=0;a<i;++a){const s=n[a];if(s.outOfView)continue;const l=s.passes,c=l.length;for(let h=0;h<c;++h)l[h].commandList.length=0;const d=e.frameState.commandList;insertShadowCastCommands(e,d,s);for(let h=0;h<c;++h){const f=s.passes[h];o.updateCamera(f.camera),s.updatePass(r,h);const p=f.commandList.length;for(let u=0;u<p;++u){const m=f.commandList[u];o.updatePass(m.pass),executeCommand(m.derivedCommands.shadows.castCommands[a],e,r,f.passState)}}}}const scratchEyeTranslation=new Cartesian3;Scene.prototype.updateAndExecuteCommands=function(e,t){const i=this._frameState.mode;this._environmentState.useWebVR?executeWebVRCommands(this,e,t):i!==SceneMode.SCENE2D||this._mapMode2D===MapMode2D$1.ROTATE?executeCommandsInViewport(!0,this,e,t):(updateAndClearFramebuffers(this,e,t),execute2DViewportCommands(this,e))};function executeWebVRCommands(e,t,n){const i=e._view,r=i.camera,a=e._environmentState.renderTranslucentDepthForPick;updateAndClearFramebuffers(e,t,n),updateAndRenderPrimitives(e),i.createPotentiallyVisibleSet(e),executeComputeCommands(e),a||executeShadowMapCastCommands(e);const s=t.viewport;s.x=0,s.y=0,s.width=s.width*.5;const l=Camera.clone(r,e._cameraVR);l.frustum=r.frustum;const c=r.frustum.near,d=c*defaultValue(e.focalLength,5),h=defaultValue(e.eyeSeparation,d/30),f=Cartesian3.multiplyByScalar(l.right,h*.5,scratchEyeTranslation);r.frustum.aspectRatio=s.width/s.height;const p=.5*h*c/d;Cartesian3.add(l.position,f,r.position),r.frustum.xOffset=p,executeCommands(e,t),s.x=s.width,Cartesian3.subtract(l.position,f,r.position),r.frustum.xOffset=-p,executeCommands(e,t),Camera.clone(l,r)}const scratch2DViewportCartographic=new Cartographic(Math.PI,CesiumMath.PI_OVER_TWO),scratch2DViewportMaxCoord=new Cartesian3,scratch2DViewportSavedPosition=new Cartesian3,scratch2DViewportTransform=new Matrix4,scratch2DViewportCameraTransform=new Matrix4,scratch2DViewportEyePoint=new Cartesian3,scratch2DViewportWindowCoords=new Cartesian3,scratch2DViewport=new BoundingRectangle;function execute2DViewportCommands(e,t){const n=e.context,i=e.frameState,r=e.camera,o=t.viewport,a=BoundingRectangle.clone(o,scratch2DViewport);t.viewport=a;const s=scratch2DViewportCartographic,l=scratch2DViewportMaxCoord;e.mapProjection.project(s,l);const d=Cartesian3.clone(r.position,scratch2DViewportSavedPosition),h=Matrix4.clone(r.transform,scratch2DViewportCameraTransform),f=r.frustum.clone();r._setTransform(Matrix4.IDENTITY);const p=Matrix4.computeViewportTransformation(a,0,1,scratch2DViewportTransform),u=r.frustum.projectionMatrix,m=r.positionWC.y,g=Cartesian3.fromElements(CesiumMath.sign(m)*l.x-m,0,-r.positionWC.x,scratch2DViewportEyePoint),_=Transforms.pointToGLWindowCoordinates(u,p,g,scratch2DViewportWindowCoords);_.x=Math.floor(_.x);const C=a.x,A=a.width;if(m===0||_.x<=C||_.x>=C+A)executeCommandsInViewport(!0,e,t);else if(Math.abs(C+A*.5-_.x)<1)a.width=_.x-a.x,r.position.x*=CesiumMath.sign(r.position.x),r.frustum.right=0,i.cullingVolume=r.frustum.computeCullingVolume(r.positionWC,r.directionWC,r.upWC),n.uniformState.update(i),executeCommandsInViewport(!0,e,t),a.x=_.x,r.position.x=-r.position.x,r.frustum.right=-r.frustum.left,r.frustum.left=0,i.cullingVolume=r.frustum.computeCullingVolume(r.positionWC,r.directionWC,r.upWC),n.uniformState.update(i),executeCommandsInViewport(!1,e,t);else if(_.x>C+A*.5){a.width=_.x-C;const S=r.frustum.right;r.frustum.right=l.x-m,i.cullingVolume=r.frustum.computeCullingVolume(r.positionWC,r.directionWC,r.upWC),n.uniformState.update(i),executeCommandsInViewport(!0,e,t),a.x=_.x,a.width=C+A-_.x,r.position.x=-r.position.x,r.frustum.left=-r.frustum.right,r.frustum.right=S-r.frustum.right*2,i.cullingVolume=r.frustum.computeCullingVolume(r.positionWC,r.directionWC,r.upWC),n.uniformState.update(i),executeCommandsInViewport(!1,e,t)}else{a.x=_.x,a.width=C+A-_.x;const S=r.frustum.left;r.frustum.left=-l.x-m,i.cullingVolume=r.frustum.computeCullingVolume(r.positionWC,r.directionWC,r.upWC),n.uniformState.update(i),executeCommandsInViewport(!0,e,t),a.x=C,a.width=_.x-C,r.position.x=-r.position.x,r.frustum.right=-r.frustum.left,r.frustum.left=S-r.frustum.left*2,i.cullingVolume=r.frustum.computeCullingVolume(r.positionWC,r.directionWC,r.upWC),n.uniformState.update(i),executeCommandsInViewport(!1,e,t)}r._setTransform(h),Cartesian3.clone(d,r.position),r.frustum=f.clone(),t.viewport=o}function executeCommandsInViewport(e,t,n,i){const r=t._environmentState,o=t._view,a=r.renderTranslucentDepthForPick;e||(t.frameState.commandList.length=0),updateAndRenderPrimitives(t),o.createPotentiallyVisibleSet(t),e&&(defined(i)&&updateAndClearFramebuffers(t,n,i),executeComputeCommands(t),a||executeShadowMapCastCommands(t)),executeCommands(t,n)}const scratchCullingVolume=new CullingVolume;Scene.prototype.updateEnvironment=function(){const e=this._frameState,t=this._view,n=this._environmentState,i=e.passes.render,r=e.passes.offscreen,o=this.atmosphere,a=this.skyAtmosphere,s=this.globe,l=this._globeTranslucencyState;if(!i||this._mode!==SceneMode.SCENE2D&&t.camera.frustum instanceof OrthographicFrustum||!l.environmentVisible)n.skyAtmosphereCommand=void 0,n.skyBoxCommand=void 0,n.sunDrawCommand=void 0,n.sunComputeCommand=void 0,n.moonCommand=void 0;else{if(defined(a)){if(defined(s))a.setDynamicLighting(DynamicAtmosphereLightingType$1.fromGlobeFlags(s)),n.isReadyForAtmosphere=n.isReadyForAtmosphere||!s.show||s._surface._tilesToRender.length>0;else{const _=o.dynamicLighting;a.setDynamicLighting(_),n.isReadyForAtmosphere=!0}n.skyAtmosphereCommand=a.update(e,s),defined(n.skyAtmosphereCommand)&&this.updateDerivedCommands(n.skyAtmosphereCommand)}else n.skyAtmosphereCommand=void 0;n.skyBoxCommand=defined(this.skyBox)?this.skyBox.update(e,this._hdr):void 0;const g=defined(this.sun)?this.sun.update(e,t.passState,this._hdr):void 0;n.sunDrawCommand=defined(g)?g.drawCommand:void 0,n.sunComputeCommand=defined(g)?g.computeCommand:void 0,n.moonCommand=defined(this.moon)?this.moon.update(e):void 0}const c=n.clearGlobeDepth=defined(s)&&s.show&&(!s.depthTestAgainstTerrain||this.mode===SceneMode.SCENE2D);(n.useDepthPlane=c&&this.mode===SceneMode.SCENE3D&&l.useDepthPlane)&&this._depthPlane.update(e),n.renderTranslucentDepthForPick=!1,n.useWebVR=this._useWebVR&&this.mode!==SceneMode.SCENE2D&&!r;const h=e.mode===SceneMode.SCENE3D&&!l.sunVisibleThroughGlobe?e.occluder:void 0;let f=e.cullingVolume;const p=scratchCullingVolume.planes;for(let g=0;g<5;++g)p[g]=f.planes[g];f=scratchCullingVolume,n.isSkyAtmosphereVisible=defined(n.skyAtmosphereCommand)&&n.isReadyForAtmosphere,n.isSunVisible=this.isVisible(n.sunDrawCommand,f,h),n.isMoonVisible=this.isVisible(n.moonCommand,f,h);const u=this.specularEnvironmentMaps;let m=this._specularEnvironmentMapAtlas;defined(u)&&(!defined(m)||m.url!==u)?(m=m&&m.destroy(),this._specularEnvironmentMapAtlas=new OctahedralProjectedCubeMap(u)):!defined(u)&&defined(m)&&(m.destroy(),this._specularEnvironmentMapAtlas=void 0),defined(this._specularEnvironmentMapAtlas)&&this._specularEnvironmentMapAtlas.update(e)};function updateDebugFrustumPlanes(e){const t=e._frameState;e.debugShowFrustumPlanes!==e._debugShowFrustumPlanes&&(e.debugShowFrustumPlanes?e._debugFrustumPlanes=new DebugCameraPrimitive({camera:e.camera,updateOnChange:!1,frustumSplits:t.frustumSplits}):e._debugFrustumPlanes=e._debugFrustumPlanes&&e._debugFrustumPlanes.destroy(),e._debugShowFrustumPlanes=e.debugShowFrustumPlanes),defined(e._debugFrustumPlanes)&&e._debugFrustumPlanes.update(t)}function updateShadowMaps(e){const t=e._frameState,n=t.shadowMaps,i=n.length,r=i>0&&!t.passes.pick&&!t.passes.pickVoxel&&e.mode===SceneMode.SCENE3D;if(r!==t.shadowState.shadowsEnabled&&(++t.shadowState.lastDirtyTime,t.shadowState.shadowsEnabled=r),t.shadowState.lightShadowsEnabled=!1,!!r){for(let o=0;o<i;++o)if(n[o]!==t.shadowState.shadowMaps[o]){++t.shadowState.lastDirtyTime;break}t.shadowState.shadowMaps.length=0,t.shadowState.lightShadowMaps.length=0;for(let o=0;o<i;++o){const a=n[o];a.update(t),t.shadowState.shadowMaps.push(a),a.fromLightSource&&(t.shadowState.lightShadowMaps.push(a),t.shadowState.lightShadowsEnabled=!0),a.dirty&&(++t.shadowState.lastDirtyTime,a.dirty=!1)}}}function updateAndRenderPrimitives(e){const t=e._frameState;e._groundPrimitives.update(t),e._primitives.update(t),updateDebugFrustumPlanes(e),updateShadowMaps(e),e._globe&&e._globe.render(t)}function updateAndClearFramebuffers(e,t,n){const i=e._context,r=e._frameState,o=e._environmentState,a=e._view,s=e._frameState.passes,l=s.pick||s.pickVoxel;defined(a.globeDepth)&&(a.globeDepth.picking=l);const c=o.useWebVR;o.originalFramebuffer=t.framebuffer,defined(e.sun)&&e.sunBloom!==e._sunBloom?(e.sunBloom&&!c?e._sunPostProcess=new SunPostProcess:defined(e._sunPostProcess)&&(e._sunPostProcess=e._sunPostProcess.destroy()),e._sunBloom=e.sunBloom):!defined(e.sun)&&defined(e._sunPostProcess)&&(e._sunPostProcess=e._sunPostProcess.destroy(),e._sunBloom=!1);const d=e._clearColorCommand;Color.clone(n,d.color),d.execute(i,t);const h=o.useGlobeDepthFramebuffer=defined(a.globeDepth);h&&(a.globeDepth.update(i,t,a.viewport,e.msaaSamples,e._hdr,o.clearGlobeDepth),a.globeDepth.clear(i,t,n));const f=a.oit,p=o.useOIT=!l&&defined(f)&&f.isSupported();p&&(f.update(i,t,a.globeDepth.colorFramebufferManager,e._hdr,e.msaaSamples),f.clear(i,t,n),o.useOIT=f.isSupported());const u=e.postProcessStages;let m=o.usePostProcess=!l&&(e._hdr||u.length>0||u.ambientOcclusion.enabled||u.fxaa.enabled||u.bloom.enabled);if(o.usePostProcessSelected=!1,m&&(a.sceneFramebuffer.update(i,a.viewport,e._hdr,e.msaaSamples),a.sceneFramebuffer.clear(i,t,n),u.update(i,r.useLogDepth,e._hdr),u.clear(i),m=o.usePostProcess=u.ready,o.usePostProcessSelected=m&&u.hasSelected),o.isSunVisible&&e.sunBloom&&!c?(t.framebuffer=e._sunPostProcess.update(t),e._sunPostProcess.clear(i,t,n)):h?t.framebuffer=a.globeDepth.framebuffer:m&&(t.framebuffer=a.sceneFramebuffer.framebuffer),defined(t.framebuffer)&&d.execute(i,t),o.useInvertClassification=!l&&defined(t.framebuffer)&&e.invertClassification){let _;if(e.frameState.invertClassificationColor.alpha===1&&o.useGlobeDepthFramebuffer&&(_=a.globeDepth.framebuffer),defined(_)||i.depthTexture){if(e._invertClassification.previousFramebuffer=_,e._invertClassification.update(i,e.msaaSamples,a.globeDepth.colorFramebufferManager),e._invertClassification.clear(i,t),e.frameState.invertClassificationColor.alpha<1&&p){const C=e._invertClassification.unclassifiedCommand,A=C.derivedCommands;A.oit=f.createDerivedCommands(C,i,A.oit)}}else o.useInvertClassification=!1}e._globeTranslucencyState.translucent&&a.globeTranslucencyFramebuffer.updateAndClear(e._hdr,a.viewport,i,t)}Scene.prototype.resolveFramebuffers=function(e){const t=this._context,n=this._environmentState,i=this._view,r=i.globeDepth;defined(r)&&r.prepareColorTextures(t);const o=n.useOIT,a=n.useGlobeDepthFramebuffer,s=n.usePostProcess,l=n.originalFramebuffer,c=a?r.colorFramebufferManager:void 0,d=i.sceneFramebuffer._colorFramebuffer,h=i.sceneFramebuffer.idFramebuffer;o&&(e.framebuffer=s?d.framebuffer:l,i.oit.execute(t,e));const f=i.translucentTileClassification;if(f.hasTranslucentDepth&&f.isSupported()&&f.execute(this,e),s){i.sceneFramebuffer.prepareColorTextures(t);let p=d;a&&!o&&(p=c);const u=this.postProcessStages,m=p.getColorTexture(0),g=h.getColorTexture(0),_=defaultValue(c,d).getDepthStencilTexture();u.execute(t,m,_,g),u.copy(t,l)}!o&&!s&&a&&(e.framebuffer=l,r.executeCopyColor(t,e))};function callAfterRenderFunctions(e){const t=e._frameState.afterRender;for(let n=0,i=t.length;n<i;++n)t[n]()&&e.requestRender();t.length=0}function getGlobeHeight(e){if(e.mode===SceneMode.MORPHING)return;const n=e.camera.positionCartographic;return e.getHeight(n)}Scene.prototype.getHeight=function(e,t){if(!defined(e))return;const n=t===HeightReference.CLAMP_TO_TERRAIN||t===HeightReference.RELATIVE_TO_TERRAIN,i=t===HeightReference.CLAMP_TO_3D_TILE||t===HeightReference.RELATIVE_TO_3D_TILE;if(!defined(e))return;let r=Number.NEGATIVE_INFINITY;if(!n){const a=this.primitives.length;for(let s=0;s<a;++s){const l=this.primitives.get(s);if(!l.isCesium3DTileset||!l.show||!l.enableCollision)continue;const c=l.getHeight(e,this);defined(c)&&c>r&&(r=c)}}const o=this._globe;if(!i&&defined(o)&&o.show){const a=o.getHeight(e);a>r&&(r=a)}if(r>Number.NEGATIVE_INFINITY)return r};const updateHeightScratchCartographic=new Cartographic;Scene.prototype.updateHeight=function(e,t,n){Check.typeOf.func("callback",t);const i=()=>{Cartographic.clone(e,updateHeightScratchCartographic);const p=this.getHeight(e,n);defined(p)&&(updateHeightScratchCartographic.height=p,t(updateHeightScratchCartographic))},r=n===HeightReference.CLAMP_TO_TERRAIN||n===HeightReference.RELATIVE_TO_TERRAIN,o=n===HeightReference.CLAMP_TO_3D_TILE||n===HeightReference.RELATIVE_TO_3D_TILE;let a;!o&&defined(this.globe)&&(a=this.globe._surface.updateHeight(e,i));let s={};const l=this._ellipsoid,c=p=>{if(r||p.isDestroyed()||!p.isCesium3DTileset)return;const u=p.updateHeight(e,i,l);s[p.id]=u};if(!r){const p=this.primitives.length;for(let u=0;u<p;++u){const m=this.primitives.get(u);c(m)}}const d=this.primitives.primitiveAdded.addEventListener(c),h=this.primitives.primitiveRemoved.addEventListener(p=>{p.isDestroyed()||!p.isCesium3DTileset||(defined(s[p.id])&&s[p.id](),delete s[p.id])});return()=>{a=a&&a(),Object.values(s).forEach(p=>p()),s={},d(),h()}};function isCameraUnderground(e){const t=e.camera,n=e._mode,i=e._screenSpaceCameraController,r=t.positionCartographic;if(!defined(r))return!1;if(!i.onMap()&&r.height<0)return!0;if(n===SceneMode.SCENE2D||n===SceneMode.MORPHING)return!1;const o=e._globeHeight;return defined(o)&&r.height<o}Scene.prototype.initializeFrame=function(){if(this._shaderFrameCount++===120&&(this._shaderFrameCount=0,this._context.shaderCache.destroyReleasedShaderPrograms(),this._context.textureCache.destroyReleasedTextures()),this._tweens.update(),this._globeHeightDirty){defined(this._removeUpdateHeightCallback)&&(this._removeUpdateHeightCallback(),this._removeUpdateHeightCallback=void 0),this._globeHeight=getGlobeHeight(this),this._globeHeightDirty=!1;const e=this.camera.positionCartographic;this._removeUpdateHeightCallback=this.updateHeight(e,t=>{this.isDestroyed()||(this._globeHeight=t.height)})}this._cameraUnderground=isCameraUnderground(this),this._globeTranslucencyState.update(this),this._screenSpaceCameraController.update(),defined(this._deviceOrientationCameraController)&&this._deviceOrientationCameraController.update(),this.camera.update(this._mode),this.camera._updateCameraChanged()};function updateDebugShowFramesPerSecond(e,t){if(e.debugShowFramesPerSecond){if(!defined(e._performanceDisplay)){const n=document.createElement("div");n.className="cesium-performanceDisplay-defaultContainer",e._canvas.parentNode.appendChild(n);const r=new PerformanceDisplay({container:n});e._performanceDisplay=r,e._performanceContainer=n}e._performanceDisplay.throttled=e.requestRenderMode,e._performanceDisplay.update(t)}else defined(e._performanceDisplay)&&(e._performanceDisplay=e._performanceDisplay&&e._performanceDisplay.destroy(),e._performanceContainer.parentNode.removeChild(e._performanceContainer))}function prePassesUpdate(e){e._jobScheduler.resetBudgets();const t=e._frameState;e.primitives.prePassesUpdate(t),defined(e.globe)&&e.globe.update(t),e._picking.update(),t.creditDisplay.update()}function postPassesUpdate(e){const t=e._frameState;e.primitives.postPassesUpdate(t),RequestScheduler.update()}const scratchBackgroundColor=new Color;function render(e){const t=e._frameState,n=e.context,i=n.uniformState,r=e._defaultView;e._view=r,e.updateFrameState(),t.passes.render=!0,t.passes.postProcess=e.postProcessStages.hasSelected,t.tilesetPassState=renderTilesetPassState;let o=defaultValue(e.backgroundColor,Color.BLACK);e._hdr&&(o=Color.clone(o,scratchBackgroundColor),o.red=Math.pow(o.red,e.gamma),o.green=Math.pow(o.green,e.gamma),o.blue=Math.pow(o.blue,e.gamma)),t.backgroundColor=o,t.atmosphere=e.atmosphere,e.fog.update(t),i.update(t);const a=e.shadowMap;defined(a)&&a.enabled&&(!defined(e.light)||e.light instanceof SunLight?Cartesian3.negate(i.sunDirectionWC,e._shadowMapCamera.direction):Cartesian3.clone(e.light.direction,e._shadowMapCamera.direction),t.shadowMaps.push(a)),e._computeCommandList.length=0,e._overlayCommandList.length=0;const s=r.viewport;s.x=0,s.y=0,s.width=n.drawingBufferWidth,s.height=n.drawingBufferHeight;const l=r.passState;l.framebuffer=void 0,l.blendingEnabled=void 0,l.scissorTest=void 0,l.viewport=BoundingRectangle.clone(s,l.viewport),defined(e.globe)&&e.globe.beginFrame(t),e.updateEnvironment(),e.updateAndExecuteCommands(l,o),e.resolveFramebuffers(l),l.framebuffer=void 0,executeOverlayCommands(e,l),defined(e.globe)&&(e.globe.endFrame(t),e.globe.tilesLoaded||(e._renderRequested=!0)),n.endFrame()}function tryAndCatchError(e,t){try{t(e)}catch(n){if(e._renderError.raiseEvent(e,n),e.rethrowRenderErrors)throw n}}function updateMostDetailedRayPicks(e){return e._picking.updateMostDetailedRayPicks(e)}Scene.prototype.render=function(e){this._preUpdate.raiseEvent(this,e);const t=this._frameState;t.newFrame=!1,defined(e)||(e=JulianDate.now());const n=this._view.checkForCameraUpdates(this);n&&(this._globeHeightDirty=!0);let i=!this.requestRenderMode||this._renderRequested||n||this._logDepthBufferDirty||this._hdrDirty||this.mode===SceneMode.MORPHING;if(!i&&defined(this.maximumRenderTimeChange)&&defined(this._lastRenderTime)){const r=Math.abs(JulianDate.secondsDifference(this._lastRenderTime,e));i=i||r>this.maximumRenderTimeChange}if(i){this._lastRenderTime=JulianDate.clone(e,this._lastRenderTime),this._renderRequested=!1,this._logDepthBufferDirty=!1,this._hdrDirty=!1;const r=CesiumMath.incrementWrap(t.frameNumber,15e6,1);updateFrameNumber(this,r,e),t.newFrame=!0}tryAndCatchError(this,prePassesUpdate),this.primitives.show&&(tryAndCatchError(this,updateMostDetailedRayPicks),tryAndCatchError(this,updatePreloadPass),tryAndCatchError(this,updatePreloadFlightPass),i||tryAndCatchError(this,updateRequestRenderModeDeferCheckPass)),this._postUpdate.raiseEvent(this,e),i&&(this._preRender.raiseEvent(this,e),t.creditDisplay.beginFrame(),tryAndCatchError(this,render)),updateDebugShowFramesPerSecond(this,i),tryAndCatchError(this,postPassesUpdate),callAfterRenderFunctions(this),i&&(this._postRender.raiseEvent(this,e),t.creditDisplay.endFrame())};Scene.prototype.forceRender=function(e){this._renderRequested=!0,this.render(e)};Scene.prototype.requestRender=function(){this._renderRequested=!0};Scene.prototype.clampLineWidth=function(e){return Math.max(ContextLimits.minimumAliasedLineWidth,Math.min(e,ContextLimits.maximumAliasedLineWidth))};Scene.prototype.pick=function(e,t,n){return this._picking.pick(this,e,t,n)};Scene.prototype.pickVoxel=function(e,t,n){const i=this.pick(e,t,n);if(!defined(i))return;const r=i.primitive;if(!(r instanceof VoxelPrimitive))return;const o=this._picking.pickVoxelCoordinate(this,e,t,n),a=255*o[0]+o[1],s=r._traversal.findKeyframeNode(a);if(!defined(s))return;const l=255*o[2]+o[3];return VoxelCell.fromKeyframeNode(r,a,l,s)};Scene.prototype.pickPositionWorldCoordinates=function(e,t){return this._picking.pickPositionWorldCoordinates(this,e,t)};Scene.prototype.pickPosition=function(e,t){return this._picking.pickPosition(this,e,t)};Scene.prototype.drillPick=function(e,t,n,i){return this._picking.drillPick(this,e,t,n,i)};function updatePreloadPass(e){const t=e._frameState;preloadTilesetPassState.camera=t.camera,preloadTilesetPassState.cullingVolume=t.cullingVolume,e.primitives.updateForPass(t,preloadTilesetPassState)}function updatePreloadFlightPass(e){const t=e._frameState;if(!t.camera.canPreloadFlight())return;preloadFlightTilesetPassState.camera=e.preloadFlightCamera,preloadFlightTilesetPassState.cullingVolume=e.preloadFlightCullingVolume,e.primitives.updateForPass(t,preloadFlightTilesetPassState)}function updateRequestRenderModeDeferCheckPass(e){e.primitives.updateForPass(e._frameState,requestRenderModeDeferCheckPassState)}Scene.prototype.pickFromRay=function(e,t,n){return this._picking.pickFromRay(this,e,t,n)};Scene.prototype.drillPickFromRay=function(e,t,n,i){return this._picking.drillPickFromRay(this,e,t,n,i)};Scene.prototype.pickFromRayMostDetailed=function(e,t,n){return this._picking.pickFromRayMostDetailed(this,e,t,n)};Scene.prototype.drillPickFromRayMostDetailed=function(e,t,n,i){return this._picking.drillPickFromRayMostDetailed(this,e,t,n,i)};Scene.prototype.sampleHeight=function(e,t,n){return this._picking.sampleHeight(this,e,t,n)};Scene.prototype.clampToHeight=function(e,t,n,i){return this._picking.clampToHeight(this,e,t,n,i)};Scene.prototype.sampleHeightMostDetailed=function(e,t,n){return this._picking.sampleHeightMostDetailed(this,e,t,n)};Scene.prototype.clampToHeightMostDetailed=function(e,t,n){return this._picking.clampToHeightMostDetailed(this,e,t,n)};Scene.prototype.cartesianToCanvasCoordinates=function(e,t){return SceneTransforms.worldToWindowCoordinates(this,e,t)};Scene.prototype.completeMorph=function(){this._transitioner.completeMorph()};Scene.prototype.morphTo2D=function(e){e=defaultValue(e,2),this._transitioner.morphTo2D(e,this._ellipsoid)};Scene.prototype.morphToColumbusView=function(e){e=defaultValue(e,2),this._transitioner.morphToColumbusView(e,this._ellipsoid)};Scene.prototype.morphTo3D=function(e){e=defaultValue(e,2),this._transitioner.morphTo3D(e,this._ellipsoid)};function setTerrain(e,t){if(e._removeTerrainProviderReadyListener=e._removeTerrainProviderReadyListener&&e._removeTerrainProviderReadyListener(),t.ready){defined(e.globe)&&(e.globe.terrainProvider=t.provider);return}e.globe.terrainProvider=void 0,e._removeTerrainProviderReadyListener=t.readyEvent.addEventListener(n=>{defined(e)&&defined(e.globe)&&(e.globe.terrainProvider=n),e._removeTerrainProviderReadyListener()})}Scene.prototype.setTerrain=function(e){return Check.typeOf.object("terrain",e),setTerrain(this,e),e};Scene.prototype.isDestroyed=function(){return!1};Scene.prototype.destroy=function(){this._tweens.removeAll(),this._computeEngine=this._computeEngine&&this._computeEngine.destroy(),this._screenSpaceCameraController=this._screenSpaceCameraController&&this._screenSpaceCameraController.destroy(),this._deviceOrientationCameraController=this._deviceOrientationCameraController&&!this._deviceOrientationCameraController.isDestroyed()&&this._deviceOrientationCameraController.destroy(),this._primitives=this._primitives&&this._primitives.destroy(),this._groundPrimitives=this._groundPrimitives&&this._groundPrimitives.destroy(),this._globe=this._globe&&this._globe.destroy(),this._removeTerrainProviderReadyListener=this._removeTerrainProviderReadyListener&&this._removeTerrainProviderReadyListener(),this.skyBox=this.skyBox&&this.skyBox.destroy(),this.skyAtmosphere=this.skyAtmosphere&&this.skyAtmosphere.destroy(),this._debugSphere=this._debugSphere&&this._debugSphere.destroy(),this.sun=this.sun&&this.sun.destroy(),this._sunPostProcess=this._sunPostProcess&&this._sunPostProcess.destroy(),this._depthPlane=this._depthPlane&&this._depthPlane.destroy(),this._transitioner=this._transitioner&&this._transitioner.destroy(),this._debugFrustumPlanes=this._debugFrustumPlanes&&this._debugFrustumPlanes.destroy(),this._brdfLutGenerator=this._brdfLutGenerator&&this._brdfLutGenerator.destroy(),this._picking=this._picking&&this._picking.destroy(),this._defaultView=this._defaultView&&this._defaultView.destroy(),this._view=void 0,this._removeCreditContainer&&this._canvas.parentNode.removeChild(this._creditContainer),this.postProcessStages=this.postProcessStages&&this.postProcessStages.destroy(),this._context=this._context&&this._context.destroy(),this._frameState.creditDisplay=this._frameState.creditDisplay&&this._frameState.creditDisplay.destroy(),defined(this._performanceDisplay)&&(this._performanceDisplay=this._performanceDisplay&&this._performanceDisplay.destroy(),this._performanceContainer.parentNode.removeChild(this._performanceContainer)),this._removeRequestListenerCallback(),this._removeTaskProcessorListenerCallback();for(let e=0;e<this._removeGlobeCallbacks.length;++e)this._removeGlobeCallbacks[e]();return this._removeGlobeCallbacks.length=0,defined(this._removeUpdateHeightCallback)&&(this._removeUpdateHeightCallback(),this._removeUpdateHeightCallback=void 0),destroyObject(this)};function SkyAtmosphere(e){e=defaultValue(e,Ellipsoid.WGS84),this.show=!0,this.perFragmentAtmosphere=!1,this._ellipsoid=e;const t=1.025,n=Cartesian3.multiplyByScalar(e.radii,t,new Cartesian3);this._scaleMatrix=Matrix4.fromScale(n),this._modelMatrix=new Matrix4,this._command=new DrawCommand({owner:this,modelMatrix:this._modelMatrix}),this._spSkyFromSpace=void 0,this._spSkyFromAtmosphere=void 0,this._flags=void 0,this.atmosphereLightIntensity=50,this.atmosphereRayleighCoefficient=new Cartesian3(55e-7,13e-6,284e-7),this.atmosphereMieCoefficient=new Cartesian3(21e-6,21e-6,21e-6),this.atmosphereRayleighScaleHeight=1e4,this.atmosphereMieScaleHeight=3200,this.atmosphereMieAnisotropy=.9,this.hueShift=0,this.saturationShift=0,this.brightnessShift=0,this._hueSaturationBrightness=new Cartesian3;const i=new Cartesian3;i.x=e.maximumRadius*t,i.y=e.maximumRadius,i.z=0,this._radiiAndDynamicAtmosphereColor=i;const r=this;this._command.uniformMap={u_radiiAndDynamicAtmosphereColor:function(){return r._radiiAndDynamicAtmosphereColor},u_hsbShift:function(){return r._hueSaturationBrightness.x=r.hueShift,r._hueSaturationBrightness.y=r.saturationShift,r._hueSaturationBrightness.z=r.brightnessShift,r._hueSaturationBrightness},u_atmosphereLightIntensity:function(){return r.atmosphereLightIntensity},u_atmosphereRayleighCoefficient:function(){return r.atmosphereRayleighCoefficient},u_atmosphereMieCoefficient:function(){return r.atmosphereMieCoefficient},u_atmosphereRayleighScaleHeight:function(){return r.atmosphereRayleighScaleHeight},u_atmosphereMieScaleHeight:function(){return r.atmosphereMieScaleHeight},u_atmosphereMieAnisotropy:function(){return r.atmosphereMieAnisotropy}}}Object.defineProperties(SkyAtmosphere.prototype,{ellipsoid:{get:function(){return this._ellipsoid}}});SkyAtmosphere.prototype.setDynamicLighting=function(e){this._radiiAndDynamicAtmosphereColor.z=e};const scratchModelMatrix$1=new Matrix4;SkyAtmosphere.prototype.update=function(e,t){if(!this.show)return;const n=e.mode;if(n!==SceneMode.SCENE3D&&n!==SceneMode.MORPHING||!e.passes.render)return;const i=Matrix4.fromRotationTranslation(e.context.uniformState.inverseViewRotation,Cartesian3.ZERO,scratchModelMatrix$1),r=Matrix4.multiplyTransformation(i,Axis.Y_UP_TO_Z_UP,scratchModelMatrix$1),o=Matrix4.multiply(this._scaleMatrix,r,scratchModelMatrix$1);Matrix4.clone(o,this._modelMatrix);const a=e.context,s=hasColorCorrection(this),l=e.globeTranslucencyState.translucent,c=this.perFragmentAtmosphere||l||!defined(t)||!t.show,d=this._command;if(!defined(d.vertexArray)){const f=EllipsoidGeometry.createGeometry(new EllipsoidGeometry({radii:new Cartesian3(1,1,1),slicePartitions:256,stackPartitions:256,vertexFormat:VertexFormat.POSITION_ONLY}));d.vertexArray=VertexArray.fromGeometry({context:a,geometry:f,attributeLocations:GeometryPipeline.createAttributeLocations(f),bufferUsage:BufferUsage.STATIC_DRAW}),d.renderState=RenderState.fromCache({cull:{enabled:!0,face:CullFace.FRONT},blending:BlendingState.ALPHA_BLEND,depthMask:!1})}const h=s|c<<2|l<<3;if(h!==this._flags){this._flags=h;const f=[];s&&f.push("COLOR_CORRECT"),c&&f.push("PER_FRAGMENT_ATMOSPHERE"),l&&f.push("GLOBE_TRANSLUCENT");const p=new ShaderSource({defines:f,sources:[AtmosphereCommon,SkyAtmosphereCommon,SkyAtmosphereVS]}),u=new ShaderSource({defines:f,sources:[AtmosphereCommon,SkyAtmosphereCommon,SkyAtmosphereFS]});this._spSkyAtmosphere=ShaderProgram.fromCache({context:a,vertexShaderSource:p,fragmentShaderSource:u}),d.shaderProgram=this._spSkyAtmosphere}return d};function hasColorCorrection(e){return!(CesiumMath.equalsEpsilon(e.hueShift,0,CesiumMath.EPSILON7)&&CesiumMath.equalsEpsilon(e.saturationShift,0,CesiumMath.EPSILON7)&&CesiumMath.equalsEpsilon(e.brightnessShift,0,CesiumMath.EPSILON7))}SkyAtmosphere.prototype.isDestroyed=function(){return!1};SkyAtmosphere.prototype.destroy=function(){const e=this._command;return e.vertexArray=e.vertexArray&&e.vertexArray.destroy(),this._spSkyAtmosphere=this._spSkyAtmosphere&&this._spSkyAtmosphere.destroy(),destroyObject(this)};function loadCubeMap(e,t,n){if(Check.defined("context",e),!defined(t)||!defined(t.positiveX)||!defined(t.negativeX)||!defined(t.positiveY)||!defined(t.negativeY)||!defined(t.positiveZ)||!defined(t.negativeZ))throw new DeveloperError("urls is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.");const i={flipY:!0,skipColorSpaceConversion:n,preferImageBitmap:!0},r=[Resource.createIfNeeded(t.positiveX).fetchImage(i),Resource.createIfNeeded(t.negativeX).fetchImage(i),Resource.createIfNeeded(t.positiveY).fetchImage(i),Resource.createIfNeeded(t.negativeY).fetchImage(i),Resource.createIfNeeded(t.positiveZ).fetchImage(i),Resource.createIfNeeded(t.negativeZ).fetchImage(i)];return Promise.all(r).then(function(o){return new CubeMap({context:e,source:{positiveX:o[0],negativeX:o[1],positiveY:o[2],negativeY:o[3],positiveZ:o[4],negativeZ:o[5]}})})}function SkyBox(e){this.sources=e.sources,this._sources=void 0,this.show=defaultValue(e.show,!0),this._command=new DrawCommand({modelMatrix:Matrix4.clone(Matrix4.IDENTITY),owner:this}),this._cubeMap=void 0,this._attributeLocations=void 0,this._useHdr=void 0}SkyBox.prototype.update=function(e,t){const n=this;if(!this.show||e.mode!==SceneMode.SCENE3D&&e.mode!==SceneMode.MORPHING||!e.passes.render)return;const i=e.context;if(this._sources!==this.sources){this._sources=this.sources;const o=this.sources;if(!defined(o.positiveX)||!defined(o.negativeX)||!defined(o.positiveY)||!defined(o.negativeY)||!defined(o.positiveZ)||!defined(o.negativeZ))throw new DeveloperError("this.sources is required and must have positiveX, negativeX, positiveY, negativeY, positiveZ, and negativeZ properties.");if(typeof o.positiveX!=typeof o.negativeX||typeof o.positiveX!=typeof o.positiveY||typeof o.positiveX!=typeof o.negativeY||typeof o.positiveX!=typeof o.positiveZ||typeof o.positiveX!=typeof o.negativeZ)throw new DeveloperError("this.sources properties must all be the same type.");typeof o.positiveX=="string"?loadCubeMap(i,this._sources).then(function(a){n._cubeMap=n._cubeMap&&n._cubeMap.destroy(),n._cubeMap=a}):(this._cubeMap=this._cubeMap&&this._cubeMap.destroy(),this._cubeMap=new CubeMap({context:i,source:o}))}const r=this._command;if(!defined(r.vertexArray)){r.uniformMap={u_cubeMap:function(){return n._cubeMap}};const o=BoxGeometry.createGeometry(BoxGeometry.fromDimensions({dimensions:new Cartesian3(2,2,2),vertexFormat:VertexFormat.POSITION_ONLY})),a=this._attributeLocations=GeometryPipeline.createAttributeLocations(o);r.vertexArray=VertexArray.fromGeometry({context:i,geometry:o,attributeLocations:a,bufferUsage:BufferUsage.STATIC_DRAW}),r.renderState=RenderState.fromCache({blending:BlendingState.ALPHA_BLEND})}if(!defined(r.shaderProgram)||this._useHdr!==t){const o=new ShaderSource({defines:[t?"HDR":""],sources:[SkyBoxFS]});r.shaderProgram=ShaderProgram.fromCache({context:i,vertexShaderSource:SkyBoxVS,fragmentShaderSource:o,attributeLocations:this._attributeLocations}),this._useHdr=t}if(defined(this._cubeMap))return r};SkyBox.prototype.isDestroyed=function(){return!1};SkyBox.prototype.destroy=function(){const e=this._command;return e.vertexArray=e.vertexArray&&e.vertexArray.destroy(),e.shaderProgram=e.shaderProgram&&e.shaderProgram.destroy(),this._cubeMap=this._cubeMap&&this._cubeMap.destroy(),destroyObject(this)};function getDefaultSkyBoxUrl(e){return buildModuleUrl(`Assets/Textures/SkyBox/tycho2t3_80_${e}.jpg`)}SkyBox.createEarthSkyBox=function(){return new SkyBox({sources:{positiveX:getDefaultSkyBoxUrl("px"),negativeX:getDefaultSkyBoxUrl("mx"),positiveY:getDefaultSkyBoxUrl("py"),negativeY:getDefaultSkyBoxUrl("my"),positiveZ:getDefaultSkyBoxUrl("pz"),negativeZ:getDefaultSkyBoxUrl("mz")}})};function Sun(){this.show=!0,this._drawCommand=new DrawCommand({primitiveType:PrimitiveType.TRIANGLES,boundingVolume:new BoundingSphere,owner:this}),this._commands={drawCommand:this._drawCommand,computeCommand:void 0},this._boundingVolume=new BoundingSphere,this._boundingVolume2D=new BoundingSphere,this._texture=void 0,this._drawingBufferWidth=void 0,this._drawingBufferHeight=void 0,this._radiusTS=void 0,this._size=void 0,this.glowFactor=1,this._glowFactorDirty=!1,this._useHdr=void 0;const e=this;this._uniformMap={u_texture:function(){return e._texture},u_size:function(){return e._size}}}Object.defineProperties(Sun.prototype,{glowFactor:{get:function(){return this._glowFactor},set:function(e){e=Math.max(e,0),this._glowFactor=e,this._glowFactorDirty=!0}}});const scratchPositionWC=new Cartesian2,scratchLimbWC=new Cartesian2,scratchPositionEC=new Cartesian4,scratchCartesian4=new Cartesian4;Sun.prototype.update=function(e,t,n){if(!this.show)return;const i=e.mode;if(i===SceneMode.SCENE2D||i===SceneMode.MORPHING||!e.passes.render)return;const r=e.context,o=t.viewport.width,a=t.viewport.height;if(!defined(this._texture)||o!==this._drawingBufferWidth||a!==this._drawingBufferHeight||this._glowFactorDirty||n!==this._useHdr){this._texture=this._texture&&this._texture.destroy(),this._drawingBufferWidth=o,this._drawingBufferHeight=a,this._glowFactorDirty=!1,this._useHdr=n;let S=Math.max(o,a);S=Math.pow(2,Math.ceil(Math.log(S)/Math.log(2))-2),S=Math.max(1,S);const v=n?r.halfFloatingPointTexture?PixelDatatype.HALF_FLOAT:PixelDatatype.FLOAT:PixelDatatype.UNSIGNED_BYTE;this._texture=new Texture({context:r,width:S,height:S,pixelFormat:PixelFormat.RGBA,pixelDatatype:v}),this._glowLengthTS=this._glowFactor*5,this._radiusTS=1/(1+2*this._glowLengthTS)*.5;const b=this,D={u_radiusTS:function(){return b._radiusTS}};this._commands.computeCommand=new ComputeCommand({fragmentShaderSource:SunTextureFS,outputTexture:this._texture,uniformMap:D,persists:!1,owner:this,postExecute:function(){b._commands.computeCommand=void 0}})}const s=this._drawCommand;if(!defined(s.vertexArray)){const S={direction:0},v=new Uint8Array(4*2);v[0]=0,v[1]=0,v[2]=255,v[3]=0,v[4]=255,v[5]=255,v[6]=0,v[7]=255;const b=Buffer.createVertexBuffer({context:r,typedArray:v,usage:BufferUsage.STATIC_DRAW}),D=[{index:S.direction,vertexBuffer:b,componentsPerAttribute:2,normalize:!0,componentDatatype:ComponentDatatype.UNSIGNED_BYTE}],I=Buffer.createIndexBuffer({context:r,typedArray:new Uint16Array([0,1,2,0,2,3]),usage:BufferUsage.STATIC_DRAW,indexDatatype:IndexDatatype.UNSIGNED_SHORT});s.vertexArray=new VertexArray({context:r,attributes:D,indexBuffer:I}),s.shaderProgram=ShaderProgram.fromCache({context:r,vertexShaderSource:SunVS,fragmentShaderSource:SunFS,attributeLocations:S}),s.renderState=RenderState.fromCache({blending:BlendingState.ALPHA_BLEND}),s.uniformMap=this._uniformMap}const l=r.uniformState.sunPositionWC,c=r.uniformState.sunPositionColumbusView,d=this._boundingVolume,h=this._boundingVolume2D;Cartesian3.clone(l,d.center),h.center.x=c.z,h.center.y=c.x,h.center.z=c.y,d.radius=CesiumMath.SOLAR_RADIUS+CesiumMath.SOLAR_RADIUS*this._glowLengthTS,h.radius=d.radius,i===SceneMode.SCENE3D?BoundingSphere.clone(d,s.boundingVolume):i===SceneMode.COLUMBUS_VIEW&&BoundingSphere.clone(h,s.boundingVolume);const f=SceneTransforms.computeActualEllipsoidPosition(e,l,scratchCartesian4),p=Cartesian3.magnitude(Cartesian3.subtract(f,e.camera.position,scratchCartesian4)),u=r.uniformState.projection,m=scratchPositionEC;m.x=0,m.y=0,m.z=-p,m.w=1;const g=Matrix4.multiplyByVector(u,m,scratchCartesian4),_=SceneTransforms.clipToGLWindowCoordinates(t.viewport,g,scratchPositionWC);m.x=CesiumMath.SOLAR_RADIUS;const C=Matrix4.multiplyByVector(u,m,scratchCartesian4),A=SceneTransforms.clipToGLWindowCoordinates(t.viewport,C,scratchLimbWC);return this._size=Cartesian2.magnitude(Cartesian2.subtract(A,_,scratchCartesian4)),this._size=2*this._size*(1+2*this._glowLengthTS),this._size=Math.ceil(this._size),this._commands};Sun.prototype.isDestroyed=function(){return!1};Sun.prototype.destroy=function(){const e=this._drawCommand;return e.vertexArray=e.vertexArray&&e.vertexArray.destroy(),e.shaderProgram=e.shaderProgram&&e.shaderProgram.destroy(),this._texture=this._texture&&this._texture.destroy(),destroyObject(this)};function startRenderLoop(e){e._renderLoopRunning=!0;let t=0;function n(i){if(!e.isDestroyed())if(e._useDefaultRenderLoop)try{const r=e._targetFrameRate;if(!defined(r))e.resize(),e.render(),requestAnimationFrame(n);else{const o=1e3/r,a=i-t;a>o&&(e.resize(),e.render(),t=i-a%o),requestAnimationFrame(n)}}catch(r){e._useDefaultRenderLoop=!1,e._renderLoopRunning=!1,e._showRenderLoopErrors&&e.showErrorPanel("An error occurred while rendering.  Rendering has stopped.",void 0,r)}else e._renderLoopRunning=!1}requestAnimationFrame(n)}function configurePixelRatio(e){let t=e._useBrowserRecommendedResolution?1:window.devicePixelRatio;return t*=e._resolutionScale,defined(e._scene)&&(e._scene.pixelRatio=t),t}function configureCanvasSize(e){const t=e._canvas;let n=t.clientWidth,i=t.clientHeight;const r=configurePixelRatio(e);e._canvasClientWidth=n,e._canvasClientHeight=i,n*=r,i*=r,t.width=n,t.height=i,e._canRender=n!==0&&i!==0,e._lastDevicePixelRatio=window.devicePixelRatio}function configureCameraFrustum(e){const t=e._canvas,n=t.width,i=t.height;if(n!==0&&i!==0){const r=e._scene.camera.frustum;defined(r.aspectRatio)?r.aspectRatio=n/i:(r.top=r.right*(i/n),r.bottom=-r.top)}}function CesiumWidget(e,t){if(!defined(e))throw new DeveloperError("container is required.");e=getElement(e),t=defaultValue(t,defaultValue.EMPTY_OBJECT);const n=document.createElement("div");n.className="cesium-widget",e.appendChild(n);const i=document.createElement("canvas"),r=FeatureDetection.supportsImageRenderingPixelated();this._supportsImageRenderingPixelated=r,r&&(i.style.imageRendering=FeatureDetection.imageRenderingValue()),i.oncontextmenu=function(){return!1},i.onselectstart=function(){return!1};function o(){i!==i.ownerDocument.activeElement&&i.ownerDocument.activeElement.blur()}defaultValue(t.blurActiveElementOnCanvasFocus,!0)&&(i.addEventListener("mousedown",o),i.addEventListener("pointerdown",o)),n.appendChild(i);const s=document.createElement("div");s.className="cesium-widget-credits";const l=defined(t.creditContainer)?getElement(t.creditContainer):n;l.appendChild(s);const c=defined(t.creditViewport)?getElement(t.creditViewport):n,d=defaultValue(t.showRenderLoopErrors,!0),h=defaultValue(t.useBrowserRecommendedResolution,!0);this._element=n,this._container=e,this._canvas=i,this._canvasClientWidth=0,this._canvasClientHeight=0,this._lastDevicePixelRatio=0,this._creditViewport=c,this._creditContainer=l,this._innerCreditContainer=s,this._canRender=!1,this._renderLoopRunning=!1,this._showRenderLoopErrors=d,this._resolutionScale=1,this._useBrowserRecommendedResolution=h,this._forceResize=!1,this._clock=defined(t.clock)?t.clock:new Clock,configureCanvasSize(this);try{const f=defaultValue(t.ellipsoid,Ellipsoid.default),p=new Scene({canvas:i,contextOptions:t.contextOptions,creditContainer:s,creditViewport:c,ellipsoid:f,mapProjection:t.mapProjection,orderIndependentTranslucency:t.orderIndependentTranslucency,scene3DOnly:defaultValue(t.scene3DOnly,!1),shadows:t.shadows,mapMode2D:t.mapMode2D,requestRenderMode:t.requestRenderMode,maximumRenderTimeChange:t.maximumRenderTimeChange,depthPlaneEllipsoidOffset:t.depthPlaneEllipsoidOffset,msaaSamples:t.msaaSamples});this._scene=p,p.camera.constrainedAxis=Cartesian3.UNIT_Z,configurePixelRatio(this),configureCameraFrustum(this);let u=t.globe;defined(u)||(u=new Globe(f)),u!==!1&&(p.globe=u,p.globe.shadows=defaultValue(t.terrainShadows,ShadowMode.RECEIVE_ONLY));let m=t.skyBox;!defined(m)&&Ellipsoid.WGS84.equals(f)&&(m=SkyBox.createEarthSkyBox()),m!==!1&&(p.skyBox=m,p.sun=new Sun,Ellipsoid.WGS84.equals(f)&&(p.moon=new Moon));let g=t.skyAtmosphere;!defined(g)&&Ellipsoid.WGS84.equals(f)&&(g=new SkyAtmosphere(f),g.show=t.globe!==!1&&u.show),g!==!1&&(p.skyAtmosphere=g);let _=t.baseLayer;if(t.globe!==!1&&_!==!1&&(defined(_)||(_=ImageryLayer.fromWorldImagery()),p.imageryLayers.add(_)),defined(t.terrainProvider)&&t.globe!==!1&&(p.terrainProvider=t.terrainProvider),defined(t.terrain)&&t.globe!==!1){if(defined(t.terrainProvider))throw new DeveloperError("Specify either options.terrainProvider or options.terrain.");p.setTerrain(t.terrain)}this._screenSpaceEventHandler=new ScreenSpaceEventHandler(i),defined(t.sceneMode)&&(t.sceneMode===SceneMode.SCENE2D&&this._scene.morphTo2D(0),t.sceneMode===SceneMode.COLUMBUS_VIEW&&this._scene.morphToColumbusView(0)),this._useDefaultRenderLoop=void 0,this.useDefaultRenderLoop=defaultValue(t.useDefaultRenderLoop,!0),this._targetFrameRate=void 0,this.targetFrameRate=t.targetFrameRate;const C=this;this._onRenderError=function(A,S){C._useDefaultRenderLoop=!1,C._renderLoopRunning=!1,C._showRenderLoopErrors&&C.showErrorPanel("An error occurred while rendering.  Rendering has stopped.",void 0,S)},p.renderError.addEventListener(this._onRenderError)}catch(f){throw d&&this.showErrorPanel("Error constructing CesiumWidget.",'Visit <a href="http://get.webgl.org">http://get.webgl.org</a> to verify that your web browser and hardware support WebGL.  Consider trying a different web browser or updating your video drivers.  Detailed error information is below:',f),f}}Object.defineProperties(CesiumWidget.prototype,{container:{get:function(){return this._container}},canvas:{get:function(){return this._canvas}},creditContainer:{get:function(){return this._creditContainer}},creditViewport:{get:function(){return this._creditViewport}},scene:{get:function(){return this._scene}},imageryLayers:{get:function(){return this._scene.imageryLayers}},terrainProvider:{get:function(){return this._scene.terrainProvider},set:function(e){this._scene.terrainProvider=e}},creditDisplay:{get:function(){return this._scene.frameState.creditDisplay}},camera:{get:function(){return this._scene.camera}},ellipsoid:{get:function(){return this._scene.ellipsoid}},clock:{get:function(){return this._clock}},screenSpaceEventHandler:{get:function(){return this._screenSpaceEventHandler}},targetFrameRate:{get:function(){return this._targetFrameRate},set:function(e){if(e<=0)throw new DeveloperError("targetFrameRate must be greater than 0, or undefined.");this._targetFrameRate=e}},useDefaultRenderLoop:{get:function(){return this._useDefaultRenderLoop},set:function(e){this._useDefaultRenderLoop!==e&&(this._useDefaultRenderLoop=e,e&&!this._renderLoopRunning&&startRenderLoop(this))}},resolutionScale:{get:function(){return this._resolutionScale},set:function(e){if(e<=0)throw new DeveloperError("resolutionScale must be greater than 0.");this._resolutionScale!==e&&(this._resolutionScale=e,this._forceResize=!0)}},useBrowserRecommendedResolution:{get:function(){return this._useBrowserRecommendedResolution},set:function(e){this._useBrowserRecommendedResolution!==e&&(this._useBrowserRecommendedResolution=e,this._forceResize=!0)}}});CesiumWidget.prototype.showErrorPanel=function(e,t,n){const i=this._element,r=document.createElement("div");r.className="cesium-widget-errorPanel";const o=document.createElement("div");o.className="cesium-widget-errorPanel-content",r.appendChild(o);const a=document.createElement("div");a.className="cesium-widget-errorPanel-header",a.appendChild(document.createTextNode(e)),o.appendChild(a);const s=document.createElement("div");s.className="cesium-widget-errorPanel-scroll",o.appendChild(s);function l(){s.style.maxHeight=`${Math.max(Math.round(i.clientHeight*.9-100),30)}px`}l(),defined(window.addEventListener)&&window.addEventListener("resize",l,!1);const c=defined(t),d=defined(n);if(c||d){const p=document.createElement("div");if(p.className="cesium-widget-errorPanel-message",s.appendChild(p),d){let u=formatError(n);c||(typeof n=="string"&&(n=new Error(n)),t=formatError({name:n.name,message:n.message}),u=n.stack),typeof console<"u"&&console.error(`${e}
${t}
${u}`);const m=document.createElement("div");m.className="cesium-widget-errorPanel-message-details collapsed";const g=document.createElement("span");g.className="cesium-widget-errorPanel-more-details",g.appendChild(document.createTextNode("See more...")),m.appendChild(g),m.onclick=function(_){m.removeChild(g),m.appendChild(document.createTextNode(u)),m.className="cesium-widget-errorPanel-message-details",o.className="cesium-widget-errorPanel-content expanded",m.onclick=void 0},s.appendChild(m)}p.innerHTML=`<p>${t}</p>`}const h=document.createElement("div");h.className="cesium-widget-errorPanel-buttonPanel",o.appendChild(h);const f=document.createElement("button");f.setAttribute("type","button"),f.className="cesium-button",f.appendChild(document.createTextNode("OK")),f.onclick=function(){defined(l)&&defined(window.removeEventListener)&&window.removeEventListener("resize",l,!1),i.removeChild(r)},h.appendChild(f),i.appendChild(r)};CesiumWidget.prototype.isDestroyed=function(){return!1};CesiumWidget.prototype.destroy=function(){defined(this._scene)&&(this._scene.renderError.removeEventListener(this._onRenderError),this._scene=this._scene.destroy()),this._container.removeChild(this._element),this._creditContainer.removeChild(this._innerCreditContainer),destroyObject(this)};CesiumWidget.prototype.resize=function(){const e=this._canvas;!this._forceResize&&this._canvasClientWidth===e.clientWidth&&this._canvasClientHeight===e.clientHeight&&this._lastDevicePixelRatio===window.devicePixelRatio||(this._forceResize=!1,configureCanvasSize(this),configureCameraFrustum(this),this._scene.requestRender())};CesiumWidget.prototype.render=function(){if(this._canRender){this._scene.initializeFrame();const e=this._clock.tick();this._scene.render(e)}else this._clock.tick()};function TileAvailability(e,t){this._tilingScheme=e,this._maximumLevel=t,this._rootNodes=[]}const rectangleScratch$2=new Rectangle;function findNode(e,t,n,i){const r=i.length;for(let o=0;o<r;++o){const a=i[o];if(a.x===t&&a.y===n&&a.level===e)return!0}return!1}TileAvailability.prototype.addAvailableTileRange=function(e,t,n,i,r){const o=this._tilingScheme,a=this._rootNodes;if(e===0)for(let f=n;f<=r;++f)for(let p=t;p<=i;++p)findNode(e,p,f,a)||a.push(new QuadtreeNode(o,void 0,0,p,f));o.tileXYToRectangle(t,n,e,rectangleScratch$2);const s=rectangleScratch$2.west,l=rectangleScratch$2.north;o.tileXYToRectangle(i,r,e,rectangleScratch$2);const c=rectangleScratch$2.east,d=rectangleScratch$2.south,h=new RectangleWithLevel(e,s,d,c,l);for(let f=0;f<a.length;++f){const p=a[f];rectanglesOverlap(p.extent,h)&&putRectangleInQuadtree(this._maximumLevel,p,h)}};TileAvailability.prototype.computeMaximumLevelAtPosition=function(e){let t;for(let n=0;n<this._rootNodes.length;++n){const i=this._rootNodes[n];if(rectangleContainsPosition(i.extent,e)){t=i;break}}return defined(t)?findMaxLevelFromNode(void 0,t,e):-1};const rectanglesScratch=[],remainingToCoverByLevelScratch=[],westScratch=new Rectangle,eastScratch=new Rectangle;TileAvailability.prototype.computeBestAvailableLevelOverRectangle=function(e){const t=rectanglesScratch;t.length=0,e.east<e.west?(t.push(Rectangle.fromRadians(-Math.PI,e.south,e.east,e.north,westScratch)),t.push(Rectangle.fromRadians(e.west,e.south,Math.PI,e.north,eastScratch))):t.push(e);const n=remainingToCoverByLevelScratch;n.length=0;let i;for(i=0;i<this._rootNodes.length;++i)updateCoverageWithNode(n,this._rootNodes[i],t);for(i=n.length-1;i>=0;--i)if(defined(n[i])&&n[i].length===0)return i;return 0};const cartographicScratch=new Cartographic;TileAvailability.prototype.isTileAvailable=function(e,t,n){const i=this._tilingScheme.tileXYToRectangle(t,n,e,rectangleScratch$2);return Rectangle.center(i,cartographicScratch),this.computeMaximumLevelAtPosition(cartographicScratch)>=e};TileAvailability.prototype.computeChildMaskForTile=function(e,t,n){const i=e+1;if(i>=this._maximumLevel)return 0;let r=0;return r|=this.isTileAvailable(i,2*t,2*n+1)?1:0,r|=this.isTileAvailable(i,2*t+1,2*n+1)?2:0,r|=this.isTileAvailable(i,2*t,2*n)?4:0,r|=this.isTileAvailable(i,2*t+1,2*n)?8:0,r};function QuadtreeNode(e,t,n,i,r){this.tilingScheme=e,this.parent=t,this.level=n,this.x=i,this.y=r,this.extent=e.tileXYToRectangle(i,r,n),this.rectangles=[],this._sw=void 0,this._se=void 0,this._nw=void 0,this._ne=void 0}Object.defineProperties(QuadtreeNode.prototype,{nw:{get:function(){return this._nw||(this._nw=new QuadtreeNode(this.tilingScheme,this,this.level+1,this.x*2,this.y*2)),this._nw}},ne:{get:function(){return this._ne||(this._ne=new QuadtreeNode(this.tilingScheme,this,this.level+1,this.x*2+1,this.y*2)),this._ne}},sw:{get:function(){return this._sw||(this._sw=new QuadtreeNode(this.tilingScheme,this,this.level+1,this.x*2,this.y*2+1)),this._sw}},se:{get:function(){return this._se||(this._se=new QuadtreeNode(this.tilingScheme,this,this.level+1,this.x*2+1,this.y*2+1)),this._se}}});function RectangleWithLevel(e,t,n,i,r){this.level=e,this.west=t,this.south=n,this.east=i,this.north=r}function rectanglesOverlap(e,t){const n=Math.max(e.west,t.west),i=Math.max(e.south,t.south),r=Math.min(e.east,t.east),o=Math.min(e.north,t.north);return i<o&&n<r}function putRectangleInQuadtree(e,t,n){for(;t.level<e;)if(rectangleFullyContainsRectangle(t.nw.extent,n))t=t.nw;else if(rectangleFullyContainsRectangle(t.ne.extent,n))t=t.ne;else if(rectangleFullyContainsRectangle(t.sw.extent,n))t=t.sw;else if(rectangleFullyContainsRectangle(t.se.extent,n))t=t.se;else break;if(t.rectangles.length===0||t.rectangles[t.rectangles.length-1].level<=n.level)t.rectangles.push(n);else{let i=binarySearch(t.rectangles,n.level,rectangleLevelComparator);i<0&&(i=~i),t.rectangles.splice(i,0,n)}}function rectangleLevelComparator(e,t){return e.level-t}function rectangleFullyContainsRectangle(e,t){return t.west>=e.west&&t.east<=e.east&&t.south>=e.south&&t.north<=e.north}function rectangleContainsPosition(e,t){return t.longitude>=e.west&&t.longitude<=e.east&&t.latitude>=e.south&&t.latitude<=e.north}function findMaxLevelFromNode(e,t,n){let i=0,r=!1;for(;!r;){const o=t._nw&&rectangleContainsPosition(t._nw.extent,n),a=t._ne&&rectangleContainsPosition(t._ne.extent,n),s=t._sw&&rectangleContainsPosition(t._sw.extent,n),l=t._se&&rectangleContainsPosition(t._se.extent,n);if(o+a+s+l>1){o&&(i=Math.max(i,findMaxLevelFromNode(t,t._nw,n))),a&&(i=Math.max(i,findMaxLevelFromNode(t,t._ne,n))),s&&(i=Math.max(i,findMaxLevelFromNode(t,t._sw,n))),l&&(i=Math.max(i,findMaxLevelFromNode(t,t._se,n)));break}else o?t=t._nw:a?t=t._ne:s?t=t._sw:l?t=t._se:r=!0}for(;t!==e;){const o=t.rectangles;for(let a=o.length-1;a>=0&&o[a].level>i;--a){const s=o[a];rectangleContainsPosition(s,n)&&(i=s.level)}t=t.parent}return i}function updateCoverageWithNode(e,t,n){if(!t)return;let i,r=!1;for(i=0;i<n.length;++i)r=r||rectanglesOverlap(t.extent,n[i]);if(!r)return;const o=t.rectangles;for(i=0;i<o.length;++i){const a=o[i];e[a.level]||(e[a.level]=n),e[a.level]=subtractRectangle(e[a.level],a)}updateCoverageWithNode(e,t._nw,n),updateCoverageWithNode(e,t._ne,n),updateCoverageWithNode(e,t._sw,n),updateCoverageWithNode(e,t._se,n)}function subtractRectangle(e,t){const n=[];for(let i=0;i<e.length;++i){const r=e[i];rectanglesOverlap(r,t)?(r.west<t.west&&n.push(new Rectangle(r.west,r.south,t.west,r.north)),r.east>t.east&&n.push(new Rectangle(t.east,r.south,r.east,r.north)),r.south<t.south&&n.push(new Rectangle(Math.max(t.west,r.west),r.south,Math.min(t.east,r.east),t.south)),r.north>t.north&&n.push(new Rectangle(Math.max(t.west,r.west),t.north,Math.min(t.east,r.east),r.north))):n.push(r)}return n}const ALL_CHILDREN=15;function TerrainProviderBuilder$2(e){this.ellipsoid=defaultValue(e.ellipsoid,Ellipsoid.default),this.credit=void 0,this.tilingScheme=void 0,this.height=void 0,this.width=void 0,this.encoding=void 0,this.lodCount=void 0,this.hasAvailability=!1,this.tilesAvailable=void 0,this.tilesAvailabilityLoaded=void 0,this.levelZeroMaximumGeometricError=void 0,this.terrainDataStructure=void 0}TerrainProviderBuilder$2.prototype.build=function(e){e._credit=this.credit,e._tilingScheme=this.tilingScheme,e._height=this.height,e._width=this.width,e._encoding=this.encoding,e._lodCount=this.lodCount,e._hasAvailability=this.hasAvailability,e._tilesAvailable=this.tilesAvailable,e._tilesAvailabilityLoaded=this.tilesAvailabilityLoaded,e._levelZeroMaximumGeometricError=this.levelZeroMaximumGeometricError,e._terrainDataStructure=this.terrainDataStructure};function parseMetadataSuccess$1(e,t){const n=t.copyrightText;defined(n)&&(e.credit=new Credit(n));const i=t.spatialReference,r=defaultValue(i.latestWkid,i.wkid),o=t.extent,a={ellipsoid:e.ellipsoid};if(r===4326)a.rectangle=Rectangle.fromDegrees(o.xmin,o.ymin,o.xmax,o.ymax),e.tilingScheme=new GeographicTilingScheme(a);else if(r===3857){const c=Math.PI*e.ellipsoid.maximumRadius;t.extent.xmax>c&&(t.extent.xmax=c),t.extent.ymax>c&&(t.extent.ymax=c),t.extent.xmin<-c&&(t.extent.xmin=-c),t.extent.ymin<-c&&(t.extent.ymin=-c),a.rectangleSouthwestInMeters=new Cartesian2(o.xmin,o.ymin),a.rectangleNortheastInMeters=new Cartesian2(o.xmax,o.ymax),e.tilingScheme=new WebMercatorTilingScheme(a)}else throw new RuntimeError("Invalid spatial reference");const s=t.tileInfo;if(!defined(s))throw new RuntimeError("tileInfo is required");e.width=s.rows+1,e.height=s.cols+1,e.encoding=s.format==="LERC"?HeightmapEncoding$1.LERC:HeightmapEncoding$1.NONE,e.lodCount=s.lods.length-1,(e.hasAvailability=t.capabilities.indexOf("Tilemap")!==-1)&&(e.tilesAvailable=new TileAvailability(e.tilingScheme,e.lodCount),e.tilesAvailable.addAvailableTileRange(0,0,0,e.tilingScheme.getNumberOfXTilesAtLevel(0),e.tilingScheme.getNumberOfYTilesAtLevel(0)),e.tilesAvailabilityLoaded=new TileAvailability(e.tilingScheme,e.lodCount)),e.levelZeroMaximumGeometricError=TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(e.tilingScheme.ellipsoid,e.width,e.tilingScheme.getNumberOfXTilesAtLevel(0)),t.bandCount>1&&console.log("ArcGISTiledElevationTerrainProvider: Terrain data has more than 1 band. Using the first one."),defined(t.minValues)&&defined(t.maxValues)?e.terrainDataStructure={elementMultiplier:1,lowestEncodedHeight:t.minValues[0],highestEncodedHeight:t.maxValues[0]}:e.terrainDataStructure={elementMultiplier:1}}async function requestMetadata$1(e,t,n){try{const i=await t.fetchJson();parseMetadataSuccess$1(e,i)}catch(i){const r=`An error occurred while accessing ${t}.`;throw TileProviderError.reportError(void 0,n,defined(n)?n._errorEvent:void 0,r),i}}function ArcGISTiledElevationTerrainProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._resource=void 0,this._credit=void 0,this._tilingScheme=void 0,this._levelZeroMaximumGeometricError=void 0,this._maxLevel=void 0,this._terrainDataStructure=void 0,this._width=void 0,this._height=void 0,this._encoding=void 0,this._lodCount=void 0,this._hasAvailability=!1,this._tilesAvailable=void 0,this._tilesAvailabilityLoaded=void 0,this._availableCache={},this._errorEvent=new Event}Object.defineProperties(ArcGISTiledElevationTerrainProvider.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){return this._credit}},tilingScheme:{get:function(){return this._tilingScheme}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},availability:{get:function(){return this._tilesAvailable}}});ArcGISTiledElevationTerrainProvider.fromUrl=async function(e,t){Check.defined("url",e),t=defaultValue(t,defaultValue.EMPTY_OBJECT),e=await Promise.resolve(e);let n=Resource.createIfNeeded(e);n.appendForwardSlash(),defined(t.token)&&(n=n.getDerivedResource({queryParameters:{token:t.token}}));const i=n.getDerivedResource({queryParameters:{f:"pjson"}}),r=new TerrainProviderBuilder$2(t);await requestMetadata$1(r,i);const o=new ArcGISTiledElevationTerrainProvider(t);return r.build(o),o._resource=n,o};ArcGISTiledElevationTerrainProvider.prototype.requestTileGeometry=function(e,t,n,i){const r=this._resource.getDerivedResource({url:`tile/${n}/${t}/${e}`,request:i}),o=this._hasAvailability;let a=Promise.resolve(!0),s;if(o&&!defined(isTileAvailable(this,n+1,e*2,t*2))){const h=requestAvailability(this,n+1,e*2,t*2);a=h.promise,s=h.request}const l=r.fetchArrayBuffer();if(!defined(l)||!defined(a))return;const c=this,d=this._tilesAvailable;return Promise.all([l,a]).then(function(h){return new HeightmapTerrainData({buffer:h[0],width:c._width,height:c._height,childTileMask:o?d.computeChildMaskForTile(n,e,t):ALL_CHILDREN,structure:c._terrainDataStructure,encoding:c._encoding})}).catch(async function(h){var f;if(defined(s)&&s.state===RequestState.CANCELLED){i.cancel();try{await((f=i.deferred)==null?void 0:f.promise)}catch{}return i.state=RequestState.CANCELLED,Promise.reject(h)}return Promise.reject(h)})};function isTileAvailable(e,t,n,i){if(!e._hasAvailability)return;const r=e._tilesAvailabilityLoaded,o=e._tilesAvailable;if(t>e._lodCount)return!1;if(o.isTileAvailable(t,n,i))return!0;if(r.isTileAvailable(t,n,i))return!1}ArcGISTiledElevationTerrainProvider.prototype.getLevelMaximumGeometricError=function(e){return this._levelZeroMaximumGeometricError/(1<<e)};ArcGISTiledElevationTerrainProvider.prototype.getTileDataAvailable=function(e,t,n){if(!this._hasAvailability)return;const i=isTileAvailable(this,n,e,t);if(defined(i))return i;requestAvailability(this,n,e,t)};ArcGISTiledElevationTerrainProvider.prototype.loadTileDataAvailability=function(e,t,n){};function findRange(e,t,n,i){const r=t-1,o=n-1,a=i[e.y*t+e.x],s=[],l={startX:e.x,startY:e.y,endX:0,endY:0},c=new Cartesian2(e.x+1,e.y+1);let d=!1,h=!1;for(;!(d&&h);){let f=c.x;const p=h?c.y+1:c.y;if(!d){for(let u=e.y;u<p;++u)if(i[u*t+c.x]!==a){d=!0;break}d?(s.push(new Cartesian2(c.x,e.y)),--c.x,--f,l.endX=c.x):c.x===r?(l.endX=c.x,d=!0):++c.x}if(!h){const u=c.y*t;for(let m=e.x;m<=f;++m)if(i[u+m]!==a){h=!0;break}h?(s.push(new Cartesian2(e.x,c.y)),--c.y,l.endY=c.y):c.y===o?(l.endY=c.y,h=!0):++c.y}}return{endingIndices:s,range:l,value:a}}function computeAvailability(e,t,n,i,r){const o=[];if(r.every(function(l){return l===r[0]}))return r[0]===1&&o.push({startX:e,startY:t,endX:e+n-1,endY:t+i-1}),o;let s=[new Cartesian2(0,0)];for(;s.length>0;){const l=s.pop(),c=findRange(l,n,i,r);if(c.value===1){const h=c.range;h.startX+=e,h.endX+=e,h.startY+=t,h.endY+=t,o.push(h)}const d=c.endingIndices;d.length>0&&(s=s.concat(d))}return o}function requestAvailability(e,t,n,i){if(!e._hasAvailability)return{};const r=Math.floor(n/128)*128,o=Math.floor(i/128)*128,a=Math.min(1<<t,128),s=`tilemap/${t}/${o}/${r}/${a}/${a}`,l=e._availableCache;if(defined(l[s]))return l[s];const c=new Request({throttle:!1,throttleByServer:!0,type:RequestType.TERRAIN});let h=e._resource.getDerivedResource({url:s,request:c}).fetchJson();return defined(h)?(h=h.then(function(f){const p=computeAvailability(r,o,a,a,f.data);e._tilesAvailabilityLoaded.addAvailableTileRange(t,r,o,r+a,o+a);const u=e._tilesAvailable;for(let m=0;m<p.length;++m){const g=p[m];u.addAvailableTileRange(t,g.startX,g.startY,g.endX,g.endY)}return isTileAvailable(e,t,n,i)}),l[s]={promise:h,request:c},h=h.finally(function(f){return delete l[s],f}),{promise:h,request:c}):{}}const url="https://dev.virtualearth.net/REST/v1/Locations";function BingMapsGeocoderService(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.key;if(!defined(t))throw new DeveloperError("options.key is required.");this._key=t;const n={key:t};defined(e.culture)&&(n.culture=e.culture),this._resource=new Resource({url,queryParameters:n}),this._credit=new Credit('<img src="http://dev.virtualearth.net/Branding/logo_powered_by.png"/>',!1)}Object.defineProperties(BingMapsGeocoderService.prototype,{url:{get:function(){return url}},key:{get:function(){return this._key}},credit:{get:function(){return this._credit}}});BingMapsGeocoderService.prototype.geocode=async function(e){return Check.typeOf.string("query",e),this._resource.getDerivedResource({queryParameters:{query:e}}).fetchJsonp("jsonp").then(function(n){return n.resourceSets.length===0?[]:n.resourceSets[0].resources.map(function(r){const o=r.bbox,a=o[0],s=o[1],l=o[2],c=o[3];return{displayName:r.name,destination:Rectangle.fromDegrees(s,a,c,l)}})})};function CartographicGeocoderService(){}Object.defineProperties(CartographicGeocoderService.prototype,{credit:{get:function(){}}});CartographicGeocoderService.prototype.geocode=function(e){Check.typeOf.string("query",e);const t=e.match(/[^\s,\n]+/g);if(t.length===2||t.length===3){let n=+t[0],i=+t[1];const r=t.length===3?+t[2]:300;if(isNaN(n)&&isNaN(i)){const o=/^(\d+.?\d*)([nsew])/i;for(let a=0;a<t.length;++a){const s=t[a].match(o);o.test(t[a])&&s.length===3&&(/^[ns]/i.test(s[2])?i=/^[n]/i.test(s[2])?+s[1]:-s[1]:/^[ew]/i.test(s[2])&&(n=/^[e]/i.test(s[2])?+s[1]:-s[1]))}}if(!isNaN(n)&&!isNaN(i)&&!isNaN(r)){const o={displayName:e,destination:Cartesian3.fromDegrees(n,i,r)};return Promise.resolve([o])}}return Promise.resolve([])};const scratchTimeVec=new Cartesian4,scratchTemp0=new Cartesian3,scratchTemp1=new Cartesian3;function createEvaluateFunction(e){const t=e.points,n=e.times;if(t.length<3){const i=n[0],r=1/(n[1]-i),o=t[0],a=t[1];return function(s,l){defined(l)||(l=new Cartesian3);const c=(s-i)*r;return Cartesian3.lerp(o,a,c,l)}}return function(i,r){defined(r)||(r=new Cartesian3);const o=e._lastTimeIndex=e.findTimeInterval(i,e._lastTimeIndex),a=(i-n[o])/(n[o+1]-n[o]),s=scratchTimeVec;s.z=a,s.y=a*a,s.x=s.y*a,s.w=1;let l,c,d,h,f;return o===0?(l=t[0],c=t[1],d=e.firstTangent,h=Cartesian3.subtract(t[2],l,scratchTemp0),Cartesian3.multiplyByScalar(h,.5,h),f=Matrix4.multiplyByVector(HermiteSpline.hermiteCoefficientMatrix,s,s)):o===t.length-2?(l=t[o],c=t[o+1],h=e.lastTangent,d=Cartesian3.subtract(c,t[o-1],scratchTemp0),Cartesian3.multiplyByScalar(d,.5,d),f=Matrix4.multiplyByVector(HermiteSpline.hermiteCoefficientMatrix,s,s)):(l=t[o-1],c=t[o],d=t[o+1],h=t[o+2],f=Matrix4.multiplyByVector(CatmullRomSpline.catmullRomCoefficientMatrix,s,s)),r=Cartesian3.multiplyByScalar(l,f.x,r),Cartesian3.multiplyByScalar(c,f.y,scratchTemp1),Cartesian3.add(r,scratchTemp1,r),Cartesian3.multiplyByScalar(d,f.z,scratchTemp1),Cartesian3.add(r,scratchTemp1,r),Cartesian3.multiplyByScalar(h,f.w,scratchTemp1),Cartesian3.add(r,scratchTemp1,r)}}const firstTangentScratch=new Cartesian3,lastTangentScratch=new Cartesian3;function CatmullRomSpline(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.points,n=e.times;let i=e.firstTangent,r=e.lastTangent;if(Check.defined("points",t),Check.defined("times",n),Check.typeOf.number.greaterThanOrEquals("points.length",t.length,2),Check.typeOf.number.equals("times.length","points.length",n.length,t.length),t.length>2&&(defined(i)||(i=firstTangentScratch,Cartesian3.multiplyByScalar(t[1],2,i),Cartesian3.subtract(i,t[2],i),Cartesian3.subtract(i,t[0],i),Cartesian3.multiplyByScalar(i,.5,i)),!defined(r))){const o=t.length-1;r=lastTangentScratch,Cartesian3.multiplyByScalar(t[o-1],2,r),Cartesian3.subtract(t[o],r,r),Cartesian3.add(r,t[o-2],r),Cartesian3.multiplyByScalar(r,.5,r)}this._times=n,this._points=t,this._firstTangent=Cartesian3.clone(i),this._lastTangent=Cartesian3.clone(r),this._evaluateFunction=createEvaluateFunction(this),this._lastTimeIndex=0}Object.defineProperties(CatmullRomSpline.prototype,{times:{get:function(){return this._times}},points:{get:function(){return this._points}},firstTangent:{get:function(){return this._firstTangent}},lastTangent:{get:function(){return this._lastTangent}}});CatmullRomSpline.catmullRomCoefficientMatrix=new Matrix4(-.5,1,-.5,0,1.5,-2.5,0,1,-1.5,2,.5,0,.5,-.5,0,0);CatmullRomSpline.prototype.findTimeInterval=Spline.prototype.findTimeInterval;CatmullRomSpline.prototype.wrapTime=Spline.prototype.wrapTime;CatmullRomSpline.prototype.clampTime=Spline.prototype.clampTime;CatmullRomSpline.prototype.evaluate=function(e,t){return this._evaluateFunction(e,t)};const Intersections2D={};Intersections2D.clipTriangleAtAxisAlignedThreshold=function(e,t,n,i,r,o){if(!defined(e))throw new DeveloperError("threshold is required.");if(!defined(t))throw new DeveloperError("keepAbove is required.");if(!defined(n))throw new DeveloperError("u0 is required.");if(!defined(i))throw new DeveloperError("u1 is required.");if(!defined(r))throw new DeveloperError("u2 is required.");defined(o)?o.length=0:o=[];let a,s,l;t?(a=n<e,s=i<e,l=r<e):(a=n>e,s=i>e,l=r>e);const c=a+s+l;let d,h,f,p,u,m;return c===1?a?(d=(e-n)/(i-n),h=(e-n)/(r-n),o.push(1),o.push(2),h!==1&&(o.push(-1),o.push(0),o.push(2),o.push(h)),d!==1&&(o.push(-1),o.push(0),o.push(1),o.push(d))):s?(f=(e-i)/(r-i),p=(e-i)/(n-i),o.push(2),o.push(0),p!==1&&(o.push(-1),o.push(1),o.push(0),o.push(p)),f!==1&&(o.push(-1),o.push(1),o.push(2),o.push(f))):l&&(u=(e-r)/(n-r),m=(e-r)/(i-r),o.push(0),o.push(1),m!==1&&(o.push(-1),o.push(2),o.push(1),o.push(m)),u!==1&&(o.push(-1),o.push(2),o.push(0),o.push(u))):c===2?!a&&n!==e?(p=(e-i)/(n-i),u=(e-r)/(n-r),o.push(0),o.push(-1),o.push(1),o.push(0),o.push(p),o.push(-1),o.push(2),o.push(0),o.push(u)):!s&&i!==e?(m=(e-r)/(i-r),d=(e-n)/(i-n),o.push(1),o.push(-1),o.push(2),o.push(1),o.push(m),o.push(-1),o.push(0),o.push(1),o.push(d)):!l&&r!==e&&(h=(e-n)/(r-n),f=(e-i)/(r-i),o.push(2),o.push(-1),o.push(0),o.push(2),o.push(h),o.push(-1),o.push(1),o.push(2),o.push(f)):c!==3&&(o.push(0),o.push(1),o.push(2)),o};Intersections2D.computeBarycentricCoordinates=function(e,t,n,i,r,o,a,s,l){if(!defined(e))throw new DeveloperError("x is required.");if(!defined(t))throw new DeveloperError("y is required.");if(!defined(n))throw new DeveloperError("x1 is required.");if(!defined(i))throw new DeveloperError("y1 is required.");if(!defined(r))throw new DeveloperError("x2 is required.");if(!defined(o))throw new DeveloperError("y2 is required.");if(!defined(a))throw new DeveloperError("x3 is required.");if(!defined(s))throw new DeveloperError("y3 is required.");const c=n-a,d=a-r,h=o-s,f=i-s,p=1/(h*c+d*f),u=t-s,m=e-a,g=(h*m+d*u)*p,_=(-f*m+c*u)*p,C=1-g-_;return defined(l)?(l.x=g,l.y=_,l.z=C,l):new Cartesian3(g,_,C)};Intersections2D.computeLineSegmentLineSegmentIntersection=function(e,t,n,i,r,o,a,s,l){Check.typeOf.number("x00",e),Check.typeOf.number("y00",t),Check.typeOf.number("x01",n),Check.typeOf.number("y01",i),Check.typeOf.number("x10",r),Check.typeOf.number("y10",o),Check.typeOf.number("x11",a),Check.typeOf.number("y11",s);const c=(a-r)*(t-o)-(s-o)*(e-r),d=(n-e)*(t-o)-(i-t)*(e-r),h=(s-o)*(n-e)-(a-r)*(i-t);if(h===0)return;const f=c/h,p=d/h;if(f>=0&&f<=1&&p>=0&&p<=1)return defined(l)||(l=new Cartesian2),l.x=e+f*(n-e),l.y=t+f*(i-t),l};const Intersections2D$1=Intersections2D;function QuantizedMeshTerrainData(e){if(!defined(e)||!defined(e.quantizedVertices))throw new DeveloperError("options.quantizedVertices is required.");if(!defined(e.indices))throw new DeveloperError("options.indices is required.");if(!defined(e.minimumHeight))throw new DeveloperError("options.minimumHeight is required.");if(!defined(e.maximumHeight))throw new DeveloperError("options.maximumHeight is required.");if(!defined(e.maximumHeight))throw new DeveloperError("options.maximumHeight is required.");if(!defined(e.boundingSphere))throw new DeveloperError("options.boundingSphere is required.");if(!defined(e.horizonOcclusionPoint))throw new DeveloperError("options.horizonOcclusionPoint is required.");if(!defined(e.westIndices))throw new DeveloperError("options.westIndices is required.");if(!defined(e.southIndices))throw new DeveloperError("options.southIndices is required.");if(!defined(e.eastIndices))throw new DeveloperError("options.eastIndices is required.");if(!defined(e.northIndices))throw new DeveloperError("options.northIndices is required.");if(!defined(e.westSkirtHeight))throw new DeveloperError("options.westSkirtHeight is required.");if(!defined(e.southSkirtHeight))throw new DeveloperError("options.southSkirtHeight is required.");if(!defined(e.eastSkirtHeight))throw new DeveloperError("options.eastSkirtHeight is required.");if(!defined(e.northSkirtHeight))throw new DeveloperError("options.northSkirtHeight is required.");this._quantizedVertices=e.quantizedVertices,this._encodedNormals=e.encodedNormals,this._indices=e.indices,this._minimumHeight=e.minimumHeight,this._maximumHeight=e.maximumHeight,this._boundingSphere=e.boundingSphere,this._orientedBoundingBox=e.orientedBoundingBox,this._horizonOcclusionPoint=e.horizonOcclusionPoint,this._credits=e.credits;const t=this._quantizedVertices.length/3,n=this._uValues=this._quantizedVertices.subarray(0,t),i=this._vValues=this._quantizedVertices.subarray(t,2*t);this._heightValues=this._quantizedVertices.subarray(2*t,3*t);function r(a,s){return i[a]-i[s]}function o(a,s){return n[a]-n[s]}this._westIndices=sortIndicesIfNecessary(e.westIndices,r,t),this._southIndices=sortIndicesIfNecessary(e.southIndices,o,t),this._eastIndices=sortIndicesIfNecessary(e.eastIndices,r,t),this._northIndices=sortIndicesIfNecessary(e.northIndices,o,t),this._westSkirtHeight=e.westSkirtHeight,this._southSkirtHeight=e.southSkirtHeight,this._eastSkirtHeight=e.eastSkirtHeight,this._northSkirtHeight=e.northSkirtHeight,this._childTileMask=defaultValue(e.childTileMask,15),this._createdByUpsampling=defaultValue(e.createdByUpsampling,!1),this._waterMask=e.waterMask,this._mesh=void 0}Object.defineProperties(QuantizedMeshTerrainData.prototype,{credits:{get:function(){return this._credits}},waterMask:{get:function(){return this._waterMask}},childTileMask:{get:function(){return this._childTileMask}},canUpsample:{get:function(){return defined(this._mesh)}}});const arrayScratch=[];function sortIndicesIfNecessary(e,t,n){arrayScratch.length=e.length;let i=!1;for(let r=0,o=e.length;r<o;++r)arrayScratch[r]=e[r],i=i||r>0&&t(e[r-1],e[r])>0;return i?(arrayScratch.sort(t),IndexDatatype.createTypedArray(n,arrayScratch)):e}const createMeshTaskName$1="createVerticesFromQuantizedTerrainMesh",createMeshTaskProcessorNoThrottle$1=new TaskProcessor(createMeshTaskName$1),createMeshTaskProcessorThrottle$1=new TaskProcessor(createMeshTaskName$1,TerrainData.maximumAsynchronousTasks);QuantizedMeshTerrainData.prototype.createMesh=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),Check.typeOf.object("options.tilingScheme",e.tilingScheme),Check.typeOf.number("options.x",e.x),Check.typeOf.number("options.y",e.y),Check.typeOf.number("options.level",e.level);const t=e.tilingScheme,n=e.x,i=e.y,r=e.level,o=defaultValue(e.exaggeration,1),a=defaultValue(e.exaggerationRelativeHeight,0),s=defaultValue(e.throttle,!0),l=t.ellipsoid,c=t.tileXYToRectangle(n,i,r),h=(s?createMeshTaskProcessorThrottle$1:createMeshTaskProcessorNoThrottle$1).scheduleTask({minimumHeight:this._minimumHeight,maximumHeight:this._maximumHeight,quantizedVertices:this._quantizedVertices,octEncodedNormals:this._encodedNormals,includeWebMercatorT:!0,indices:this._indices,westIndices:this._westIndices,southIndices:this._southIndices,eastIndices:this._eastIndices,northIndices:this._northIndices,westSkirtHeight:this._westSkirtHeight,southSkirtHeight:this._southSkirtHeight,eastSkirtHeight:this._eastSkirtHeight,northSkirtHeight:this._northSkirtHeight,rectangle:c,relativeToCenter:this._boundingSphere.center,ellipsoid:l,exaggeration:o,exaggerationRelativeHeight:a});if(!defined(h))return;const f=this;return Promise.resolve(h).then(function(p){const u=f._quantizedVertices.length/3,m=u+f._westIndices.length+f._southIndices.length+f._eastIndices.length+f._northIndices.length,g=IndexDatatype.createTypedArray(m,p.indices),_=new Float32Array(p.vertices),C=p.center,A=p.minimumHeight,S=p.maximumHeight,v=f._boundingSphere,b=f._orientedBoundingBox,D=defaultValue(Cartesian3.clone(p.occludeePointInScaledSpace),f._horizonOcclusionPoint),I=p.vertexStride,L=TerrainEncoding.clone(p.encoding);return f._mesh=new TerrainMesh(C,_,g,p.indexCountWithoutSkirts,u,A,S,v,D,I,b,L,p.westIndicesSouthToNorth,p.southIndicesEastToWest,p.eastIndicesNorthToSouth,p.northIndicesWestToEast),f._quantizedVertices=void 0,f._encodedNormals=void 0,f._indices=void 0,f._uValues=void 0,f._vValues=void 0,f._heightValues=void 0,f._westIndices=void 0,f._southIndices=void 0,f._eastIndices=void 0,f._northIndices=void 0,f._mesh})};const upsampleTaskProcessor$1=new TaskProcessor("upsampleQuantizedTerrainMesh",TerrainData.maximumAsynchronousTasks);QuantizedMeshTerrainData.prototype.upsample=function(e,t,n,i,r,o,a){if(!defined(e))throw new DeveloperError("tilingScheme is required.");if(!defined(t))throw new DeveloperError("thisX is required.");if(!defined(n))throw new DeveloperError("thisY is required.");if(!defined(i))throw new DeveloperError("thisLevel is required.");if(!defined(r))throw new DeveloperError("descendantX is required.");if(!defined(o))throw new DeveloperError("descendantY is required.");if(!defined(a))throw new DeveloperError("descendantLevel is required.");if(a-i>1)throw new DeveloperError("Upsampling through more than one level at a time is not currently supported.");const l=this._mesh;if(!defined(this._mesh))return;const c=t*2!==r,d=n*2===o,h=e.ellipsoid,f=e.tileXYToRectangle(r,o,a),p=upsampleTaskProcessor$1.scheduleTask({vertices:l.vertices,vertexCountWithoutSkirts:l.vertexCountWithoutSkirts,indices:l.indices,indexCountWithoutSkirts:l.indexCountWithoutSkirts,encoding:l.encoding,minimumHeight:this._minimumHeight,maximumHeight:this._maximumHeight,isEastChild:c,isNorthChild:d,childRectangle:f,ellipsoid:h});if(!defined(p))return;let u=Math.min(this._westSkirtHeight,this._eastSkirtHeight);u=Math.min(u,this._southSkirtHeight),u=Math.min(u,this._northSkirtHeight);const m=c?u*.5:this._westSkirtHeight,g=d?u*.5:this._southSkirtHeight,_=c?this._eastSkirtHeight:u*.5,C=d?this._northSkirtHeight:u*.5,A=this._credits;return Promise.resolve(p).then(function(S){const v=new Uint16Array(S.vertices),b=IndexDatatype.createTypedArray(v.length/3,S.indices);let D;return defined(S.encodedNormals)&&(D=new Uint8Array(S.encodedNormals)),new QuantizedMeshTerrainData({quantizedVertices:v,indices:b,encodedNormals:D,minimumHeight:S.minimumHeight,maximumHeight:S.maximumHeight,boundingSphere:BoundingSphere.clone(S.boundingSphere),orientedBoundingBox:OrientedBoundingBox.clone(S.orientedBoundingBox),horizonOcclusionPoint:Cartesian3.clone(S.horizonOcclusionPoint),westIndices:S.westIndices,southIndices:S.southIndices,eastIndices:S.eastIndices,northIndices:S.northIndices,westSkirtHeight:m,southSkirtHeight:g,eastSkirtHeight:_,northSkirtHeight:C,childTileMask:0,credits:A,createdByUpsampling:!0})})};const maxShort=32767,barycentricCoordinateScratch$1=new Cartesian3;QuantizedMeshTerrainData.prototype.interpolateHeight=function(e,t,n){let i=CesiumMath.clamp((t-e.west)/e.width,0,1);i*=maxShort;let r=CesiumMath.clamp((n-e.south)/e.height,0,1);return r*=maxShort,defined(this._mesh)?interpolateMeshHeight$1(this,i,r):interpolateHeight$1(this,i,r)};function pointInBoundingBox(e,t,n,i,r,o,a,s){const l=Math.min(n,r,a),c=Math.max(n,r,a),d=Math.min(i,o,s),h=Math.max(i,o,s);return e>=l&&e<=c&&t>=d&&t<=h}const texCoordScratch0$1=new Cartesian2,texCoordScratch1$1=new Cartesian2,texCoordScratch2$1=new Cartesian2;function interpolateMeshHeight$1(e,t,n){const i=e._mesh,r=i.vertices,o=i.encoding,a=i.indices;for(let s=0,l=a.length;s<l;s+=3){const c=a[s],d=a[s+1],h=a[s+2],f=o.decodeTextureCoordinates(r,c,texCoordScratch0$1),p=o.decodeTextureCoordinates(r,d,texCoordScratch1$1),u=o.decodeTextureCoordinates(r,h,texCoordScratch2$1);if(pointInBoundingBox(t,n,f.x,f.y,p.x,p.y,u.x,u.y)){const m=Intersections2D$1.computeBarycentricCoordinates(t,n,f.x,f.y,p.x,p.y,u.x,u.y,barycentricCoordinateScratch$1);if(m.x>=-1e-15&&m.y>=-1e-15&&m.z>=-1e-15){const g=o.decodeHeight(r,c),_=o.decodeHeight(r,d),C=o.decodeHeight(r,h);return m.x*g+m.y*_+m.z*C}}}}function interpolateHeight$1(e,t,n){const i=e._uValues,r=e._vValues,o=e._heightValues,a=e._indices;for(let s=0,l=a.length;s<l;s+=3){const c=a[s],d=a[s+1],h=a[s+2],f=i[c],p=i[d],u=i[h],m=r[c],g=r[d],_=r[h];if(pointInBoundingBox(t,n,f,m,p,g,u,_)){const C=Intersections2D$1.computeBarycentricCoordinates(t,n,f,m,p,g,u,_,barycentricCoordinateScratch$1);if(C.x>=-1e-15&&C.y>=-1e-15&&C.z>=-1e-15){const A=C.x*o[c]+C.y*o[d]+C.z*o[h];return CesiumMath.lerp(e._minimumHeight,e._maximumHeight,A/maxShort)}}}}QuantizedMeshTerrainData.prototype.isChildAvailable=function(e,t,n,i){if(!defined(e))throw new DeveloperError("thisX is required.");if(!defined(t))throw new DeveloperError("thisY is required.");if(!defined(n))throw new DeveloperError("childX is required.");if(!defined(i))throw new DeveloperError("childY is required.");let r=2;return n!==e*2&&++r,i!==t*2&&(r-=2),(this._childTileMask&1<<r)!==0};QuantizedMeshTerrainData.prototype.wasCreatedByUpsampling=function(){return this._createdByUpsampling};function LayerInformation(e){this.resource=e.resource,this.version=e.version,this.isHeightmap=e.isHeightmap,this.tileUrlTemplates=e.tileUrlTemplates,this.availability=e.availability,this.hasVertexNormals=e.hasVertexNormals,this.hasWaterMask=e.hasWaterMask,this.hasMetadata=e.hasMetadata,this.availabilityLevels=e.availabilityLevels,this.availabilityTilesLoaded=e.availabilityTilesLoaded,this.littleEndianExtensionSize=e.littleEndianExtensionSize,this.availabilityPromiseCache={}}function TerrainProviderBuilder$1(e){this.requestVertexNormals=defaultValue(e.requestVertexNormals,!1),this.requestWaterMask=defaultValue(e.requestWaterMask,!1),this.requestMetadata=defaultValue(e.requestMetadata,!0),this.ellipsoid=defaultValue(e.ellipsoid,Ellipsoid.default),this.heightmapWidth=65,this.heightmapStructure=void 0,this.hasWaterMask=!1,this.hasMetadata=!1,this.hasVertexNormals=!1,this.scheme=void 0,this.lastResource=void 0,this.layerJsonResource=void 0,this.previousError=void 0,this.availability=void 0,this.tilingScheme=void 0,this.levelZeroMaximumGeometricError=void 0,this.heightmapStructure=void 0,this.layers=[],this.attribution="",this.overallAvailability=[],this.overallMaxZoom=0,this.tileCredits=[]}TerrainProviderBuilder$1.prototype.build=function(e){e._heightmapWidth=this.heightmapWidth,e._scheme=this.scheme;const t=defined(this.lastResource.credits)?this.lastResource.credits:[];e._tileCredits=t.concat(this.tileCredits),e._availability=this.availability,e._tilingScheme=this.tilingScheme,e._requestWaterMask=this.requestWaterMask,e._levelZeroMaximumGeometricError=this.levelZeroMaximumGeometricError,e._heightmapStructure=this.heightmapStructure,e._layers=this.layers,e._hasWaterMask=this.hasWaterMask,e._hasVertexNormals=this.hasVertexNormals,e._hasMetadata=this.hasMetadata};async function parseMetadataSuccess(e,t,n){if(!t.format){const m="The tile format is not specified in the layer.json file.";throw e.previousError=TileProviderError.reportError(e.previousError,n,defined(n)?n._errorEvent:void 0,m),new RuntimeError(m)}if(!t.tiles||t.tiles.length===0){const m="The layer.json file does not specify any tile URL templates.";throw e.previousError=TileProviderError.reportError(e.previousError,n,defined(n)?n._errorEvent:void 0,m),new RuntimeError(m)}let i=!1,r=!1,o=!1,a=!0,s=!1;if(t.format==="heightmap-1.0")s=!0,defined(e.heightmapStructure)||(e.heightmapStructure={heightScale:1/5,heightOffset:-1e3,elementsPerHeight:1,stride:1,elementMultiplier:256,isBigEndian:!1,lowestEncodedHeight:0,highestEncodedHeight:256*256-1}),r=!0,e.requestWaterMask=!0;else if(t.format.indexOf("quantized-mesh-1.")!==0){const m=`The tile format "${t.format}" is invalid or not supported.`;throw e.previousError=TileProviderError.reportError(e.previousError,n,defined(n)?n._errorEvent:void 0,m),new RuntimeError(m)}const l=t.tiles,c=t.maxzoom;if(e.overallMaxZoom=Math.max(e.overallMaxZoom,c),!t.projection||t.projection==="EPSG:4326")e.tilingScheme=new GeographicTilingScheme({numberOfLevelZeroTilesX:2,numberOfLevelZeroTilesY:1,ellipsoid:e.ellipsoid});else if(t.projection==="EPSG:3857")e.tilingScheme=new WebMercatorTilingScheme({numberOfLevelZeroTilesX:1,numberOfLevelZeroTilesY:1,ellipsoid:e.ellipsoid});else{const m=`The projection "${t.projection}" is invalid or not supported.`;throw e.previousError=TileProviderError.reportError(e.previousError,n,defined(n)?n._errorEvent:void 0,m),new RuntimeError(m)}if(e.levelZeroMaximumGeometricError=TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(e.tilingScheme.ellipsoid,e.heightmapWidth,e.tilingScheme.getNumberOfXTilesAtLevel(0)),!t.scheme||t.scheme==="tms"||t.scheme==="slippyMap")e.scheme=t.scheme;else{const m=`The scheme "${t.scheme}" is invalid or not supported.`;throw e.previousError=TileProviderError.reportError(e.previousError,n,defined(n)?n._errorEvent:void 0,m),new RuntimeError(m)}let d;defined(t.extensions)&&t.extensions.indexOf("octvertexnormals")!==-1?i=!0:defined(t.extensions)&&t.extensions.indexOf("vertexnormals")!==-1&&(i=!0,a=!1),defined(t.extensions)&&t.extensions.indexOf("watermask")!==-1&&(r=!0),defined(t.extensions)&&t.extensions.indexOf("metadata")!==-1&&(o=!0);const h=t.metadataAvailability,f=t.available;let p;if(defined(f)&&!defined(h)){p=new TileAvailability(e.tilingScheme,f.length);for(let m=0;m<f.length;++m){const g=f[m],_=e.tilingScheme.getNumberOfYTilesAtLevel(m);defined(e.overallAvailability[m])||(e.overallAvailability[m]=[]);for(let C=0;C<g.length;++C){const A=g[C],S=_-A.endY-1,v=_-A.startY-1;e.overallAvailability[m].push([A.startX,S,A.endX,v]),p.addAvailableTileRange(m,A.startX,S,A.endX,v)}}}else defined(h)&&(d=new TileAvailability(e.tilingScheme,c),p=new TileAvailability(e.tilingScheme,c),e.overallAvailability[0]=[[0,0,1,0]],p.addAvailableTileRange(0,0,0,1,0));e.hasWaterMask=e.hasWaterMask||r,e.hasVertexNormals=e.hasVertexNormals||i,e.hasMetadata=e.hasMetadata||o,defined(t.attribution)&&(e.attribution.length>0&&(e.attribution+=" "),e.attribution+=t.attribution),e.layers.push(new LayerInformation({resource:e.lastResource,version:t.version,isHeightmap:s,tileUrlTemplates:l,availability:p,hasVertexNormals:i,hasWaterMask:r,hasMetadata:o,availabilityLevels:h,availabilityTilesLoaded:d,littleEndianExtensionSize:a}));const u=t.parentUrl;return defined(u)?defined(p)?(e.lastResource=e.lastResource.getDerivedResource({url:u}),e.lastResource.appendForwardSlash(),e.layerJsonResource=e.lastResource.getDerivedResource({url:"layer.json"}),await requestLayerJson(e),!0):(console.log("A layer.json can't have a parentUrl if it does't have an available array."),!0):!0}function parseMetadataFailure(e,t,n){let i=`An error occurred while accessing ${e.layerJsonResource.url}.`;if(defined(t)&&(i+=`
${t.message}`),e.previousError=TileProviderError.reportError(e.previousError,n,defined(n)?n._errorEvent:void 0,i),e.previousError.retry)return requestLayerJson(e,n);throw new RuntimeError(i)}async function metadataSuccess$1(e,t,n){await parseMetadataSuccess(e,t,n);const i=e.overallAvailability.length;if(i>0){const r=e.availability=new TileAvailability(e.tilingScheme,e.overallMaxZoom);for(let o=0;o<i;++o){const a=e.overallAvailability[o];for(let s=0;s<a.length;++s){const l=a[s];r.addAvailableTileRange(o,l[0],l[1],l[2],l[3])}}}if(e.attribution.length>0){const r=new Credit(e.attribution);e.tileCredits.push(r)}return!0}async function requestLayerJson(e,t){try{const n=await e.layerJsonResource.fetchJson();return metadataSuccess$1(e,n,t)}catch(n){return defined(n)&&n.statusCode===404?(await parseMetadataSuccess(e,{tilejson:"2.1.0",format:"heightmap-1.0",version:"1.0.0",scheme:"tms",tiles:["{z}/{x}/{y}.terrain?v={version}"]},t),!0):parseMetadataFailure(e,n,t)}}function CesiumTerrainProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._heightmapWidth=void 0,this._heightmapStructure=void 0,this._hasWaterMask=!1,this._hasVertexNormals=!1,this._hasMetadata=!1,this._scheme=void 0,this._ellipsoid=e.ellipsoid,this._requestVertexNormals=defaultValue(e.requestVertexNormals,!1),this._requestWaterMask=defaultValue(e.requestWaterMask,!1),this._requestMetadata=defaultValue(e.requestMetadata,!0),this._errorEvent=new Event;let t=e.credit;typeof t=="string"&&(t=new Credit(t)),this._credit=t,this._availability=void 0,this._tilingScheme=void 0,this._levelZeroMaximumGeometricError=void 0,this._layers=void 0,this._tileCredits=void 0}const QuantizedMeshExtensionIds={OCT_VERTEX_NORMALS:1,WATER_MASK:2,METADATA:4};function getRequestHeader(e){return!defined(e)||e.length===0?{Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9,*/*;q=0.01"}:{Accept:`application/vnd.quantized-mesh;extensions=${e.join("-")},application/octet-stream;q=0.9,*/*;q=0.01`}}function createHeightmapTerrainData(e,t,n,i,r){const o=new Uint16Array(t,0,e._heightmapWidth*e._heightmapWidth);return new HeightmapTerrainData({buffer:o,childTileMask:new Uint8Array(t,o.byteLength,1)[0],waterMask:new Uint8Array(t,o.byteLength+1,t.byteLength-o.byteLength-1),width:e._heightmapWidth,height:e._heightmapWidth,structure:e._heightmapStructure,credits:e._tileCredits})}function createQuantizedMeshTerrainData(e,t,n,i,r,o){const a=o.littleEndianExtensionSize;let s=0;const l=3,c=l+1,d=Float64Array.BYTES_PER_ELEMENT*l,h=Float64Array.BYTES_PER_ELEMENT*c,p=Uint16Array.BYTES_PER_ELEMENT*3,u=3;let m=Uint16Array.BYTES_PER_ELEMENT,g=m*u;const _=new DataView(t),C=new Cartesian3(_.getFloat64(s,!0),_.getFloat64(s+8,!0),_.getFloat64(s+16,!0));s+=d;const A=_.getFloat32(s,!0);s+=Float32Array.BYTES_PER_ELEMENT;const S=_.getFloat32(s,!0);s+=Float32Array.BYTES_PER_ELEMENT;const v=new BoundingSphere(new Cartesian3(_.getFloat64(s,!0),_.getFloat64(s+8,!0),_.getFloat64(s+16,!0)),_.getFloat64(s+d,!0));s+=h;const b=new Cartesian3(_.getFloat64(s,!0),_.getFloat64(s+8,!0),_.getFloat64(s+16,!0));s+=d;const D=_.getUint32(s,!0);s+=Uint32Array.BYTES_PER_ELEMENT;const I=new Uint16Array(t,s,D*3);s+=D*p,D>64*1024&&(m=Uint32Array.BYTES_PER_ELEMENT,g=m*u);const L=I.subarray(0,D),N=I.subarray(D,2*D),y=I.subarray(D*2,3*D);AttributeCompression.zigZagDeltaDecode(L,N,y),s%m!==0&&(s+=m-s%m);const x=_.getUint32(s,!0);s+=Uint32Array.BYTES_PER_ELEMENT;const T=IndexDatatype.createTypedArrayFromArrayBuffer(D,t,s,x*u);s+=x*g;let E=0;const P=T.length;for(let z=0;z<P;++z){const X=T[z];T[z]=E-X,X===0&&++E}const M=_.getUint32(s,!0);s+=Uint32Array.BYTES_PER_ELEMENT;const O=IndexDatatype.createTypedArrayFromArrayBuffer(D,t,s,M);s+=M*m;const V=_.getUint32(s,!0);s+=Uint32Array.BYTES_PER_ELEMENT;const R=IndexDatatype.createTypedArrayFromArrayBuffer(D,t,s,V);s+=V*m;const w=_.getUint32(s,!0);s+=Uint32Array.BYTES_PER_ELEMENT;const U=IndexDatatype.createTypedArrayFromArrayBuffer(D,t,s,w);s+=w*m;const k=_.getUint32(s,!0);s+=Uint32Array.BYTES_PER_ELEMENT;const H=IndexDatatype.createTypedArrayFromArrayBuffer(D,t,s,k);s+=k*m;let F,G;for(;s<_.byteLength;){const z=_.getUint8(s,!0);s+=Uint8Array.BYTES_PER_ELEMENT;const X=_.getUint32(s,a);if(s+=Uint32Array.BYTES_PER_ELEMENT,z===QuantizedMeshExtensionIds.OCT_VERTEX_NORMALS&&e._requestVertexNormals)F=new Uint8Array(t,s,D*2);else if(z===QuantizedMeshExtensionIds.WATER_MASK&&e._requestWaterMask)G=new Uint8Array(t,s,X);else if(z===QuantizedMeshExtensionIds.METADATA&&e._requestMetadata){const q=_.getUint32(s,!0);if(q>0){const Z=getJsonFromTypedArray(new Uint8Array(t),s+Uint32Array.BYTES_PER_ELEMENT,q).available;if(defined(Z))for(let K=0;K<Z.length;++K){const J=n+K+1,se=Z[K],ae=e._tilingScheme.getNumberOfYTilesAtLevel(J);for(let te=0;te<se.length;++te){const ee=se[te],ce=ae-ee.endY-1,re=ae-ee.startY-1;e.availability.addAvailableTileRange(J,ee.startX,ce,ee.endX,re),o.availability.addAvailableTileRange(J,ee.startX,ce,ee.endX,re)}}}o.availabilityTilesLoaded.addAvailableTileRange(n,i,r,i,r)}s+=X}const B=e.getLevelMaximumGeometricError(n)*5,W=e._tilingScheme.tileXYToRectangle(i,r,n),Y=OrientedBoundingBox.fromRectangle(W,A,S,e._tilingScheme.ellipsoid);return new QuantizedMeshTerrainData({center:C,minimumHeight:A,maximumHeight:S,boundingSphere:v,orientedBoundingBox:Y,horizonOcclusionPoint:b,quantizedVertices:I,encodedNormals:F,indices:T,westIndices:O,southIndices:R,eastIndices:U,northIndices:H,westSkirtHeight:B,southSkirtHeight:B,eastSkirtHeight:B,northSkirtHeight:B,childTileMask:e.availability.computeChildMaskForTile(n,i,r),waterMask:G,credits:e._tileCredits})}CesiumTerrainProvider.prototype.requestTileGeometry=function(e,t,n,i){const r=this._layers;let o;const a=r.length;let s=!1,l=Promise.resolve();if(a===1)o=r[0];else for(let c=0;c<a;++c){const d=r[c];if(!defined(d.availability)||d.availability.isTileAvailable(n,e,t)){o=d;break}const h=checkLayer(this,e,t,n,d,c===0);h.result&&(s=!0,l=l.then(()=>h.promise))}return!defined(o)&&s?l.then(()=>new Promise(c=>{setTimeout(()=>{const d=this.requestTileGeometry(e,t,n,i);c(d)},0)})):requestTileGeometry(this,e,t,n,o,i)};function requestTileGeometry(e,t,n,i,r,o){if(!defined(r))return Promise.reject(new RuntimeError("Terrain tile doesn't exist"));const a=r.tileUrlTemplates;if(a.length===0)return;let s;!e._scheme||e._scheme==="tms"?s=e._tilingScheme.getNumberOfYTilesAtLevel(i)-n-1:s=n;const l=[];e._requestVertexNormals&&r.hasVertexNormals&&l.push(r.littleEndianExtensionSize?"octvertexnormals":"vertexnormals"),e._requestWaterMask&&r.hasWaterMask&&l.push("watermask"),e._requestMetadata&&r.hasMetadata&&l.push("metadata");let c,d;const h=a[(t+s+i)%a.length],f=r.resource;defined(f._ionEndpoint)&&!defined(f._ionEndpoint.externalType)?(l.length!==0&&(d={extensions:l.join("-")}),c=getRequestHeader(void 0)):c=getRequestHeader(l);const p=f.getDerivedResource({url:h,templateValues:{version:r.version,z:i,x:t,y:s},queryParameters:d,headers:c,request:o}).fetchArrayBuffer();if(defined(p))return p.then(function(u){return defined(u)?defined(e._heightmapStructure)?createHeightmapTerrainData(e,u):createQuantizedMeshTerrainData(e,u,i,t,n,r):Promise.reject(new RuntimeError("Mesh buffer doesn't exist."))})}Object.defineProperties(CesiumTerrainProvider.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){return this._credit}},tilingScheme:{get:function(){return this._tilingScheme}},hasWaterMask:{get:function(){return this._hasWaterMask&&this._requestWaterMask}},hasVertexNormals:{get:function(){return this._hasVertexNormals&&this._requestVertexNormals}},hasMetadata:{get:function(){return this._hasMetadata&&this._requestMetadata}},requestVertexNormals:{get:function(){return this._requestVertexNormals}},requestWaterMask:{get:function(){return this._requestWaterMask}},requestMetadata:{get:function(){return this._requestMetadata}},availability:{get:function(){return this._availability}}});CesiumTerrainProvider.prototype.getLevelMaximumGeometricError=function(e){return this._levelZeroMaximumGeometricError/(1<<e)};CesiumTerrainProvider.fromIonAssetId=async function(e,t){Check.defined("assetId",e);const n=await IonResource.fromAssetId(e);return CesiumTerrainProvider.fromUrl(n,t)};CesiumTerrainProvider.fromUrl=async function(e,t){Check.defined("url",e),t=defaultValue(t,defaultValue.EMPTY_OBJECT),e=await Promise.resolve(e);const n=Resource.createIfNeeded(e);n.appendForwardSlash();const i=new TerrainProviderBuilder$1(t);i.lastResource=n,i.layerJsonResource=i.lastResource.getDerivedResource({url:"layer.json"}),await requestLayerJson(i);const r=new CesiumTerrainProvider(t);return i.build(r),r};CesiumTerrainProvider.prototype.getTileDataAvailable=function(e,t,n){if(!defined(this._availability))return;if(n>this._availability._maximumLevel)return!1;if(this._availability.isTileAvailable(n,e,t))return!0;if(!this._hasMetadata)return!1;const i=this._layers,r=i.length;for(let o=0;o<r;++o)if(checkLayer(this,e,t,n,i[o],o===0).result)return;return!1};CesiumTerrainProvider.prototype.loadTileDataAvailability=function(e,t,n){if(!defined(this._availability)||n>this._availability._maximumLevel||this._availability.isTileAvailable(n,e,t)||!this._hasMetadata)return;const i=this._layers,r=i.length;for(let o=0;o<r;++o){const a=checkLayer(this,e,t,n,i[o],o===0);if(defined(a.promise))return a.promise}};function getAvailabilityTile(e,t,n,i){if(i===0)return;const r=e.availabilityLevels,o=i%r===0?i-r:(i/r|0)*r,a=1<<i-o,s=t/a|0,l=n/a|0;return{level:o,x:s,y:l}}function checkLayer(e,t,n,i,r,o){if(!defined(r.availabilityLevels))return{result:!1};let a;const s=function(){delete r.availabilityPromiseCache[a]},l=r.availabilityTilesLoaded,c=r.availability;let d=getAvailabilityTile(r,t,n,i);for(;defined(d);){if(c.isTileAvailable(d.level,d.x,d.y)&&!l.isTileAvailable(d.level,d.x,d.y)){let h;if(!o&&(a=`${d.level}-${d.x}-${d.y}`,h=r.availabilityPromiseCache[a],!defined(h))){const f=new Request({throttle:!1,throttleByServer:!0,type:RequestType.TERRAIN});h=requestTileGeometry(e,d.x,d.y,d.level,r,f),defined(h)&&(r.availabilityPromiseCache[a]=h,h.then(s))}return{result:!0,promise:h}}d=getAvailabilityTile(r,d.x,d.y,d.level)}return{result:!1}}CesiumTerrainProvider._getAvailabilityTile=getAvailabilityTile;function CircleGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.radius;Check.typeOf.number("radius",t);const n={center:e.center,semiMajorAxis:t,semiMinorAxis:t,ellipsoid:e.ellipsoid,height:e.height,extrudedHeight:e.extrudedHeight,granularity:e.granularity,vertexFormat:e.vertexFormat,stRotation:e.stRotation,shadowVolume:e.shadowVolume};this._ellipseGeometry=new EllipseGeometry(n),this._workerName="createCircleGeometry"}CircleGeometry.packedLength=EllipseGeometry.packedLength;CircleGeometry.pack=function(e,t,n){return Check.typeOf.object("value",e),EllipseGeometry.pack(e._ellipseGeometry,t,n)};const scratchEllipseGeometry$1=new EllipseGeometry({center:new Cartesian3,semiMajorAxis:1,semiMinorAxis:1}),scratchOptions$2={center:new Cartesian3,radius:void 0,ellipsoid:Ellipsoid.clone(Ellipsoid.default),height:void 0,extrudedHeight:void 0,granularity:void 0,vertexFormat:new VertexFormat,stRotation:void 0,semiMajorAxis:void 0,semiMinorAxis:void 0,shadowVolume:void 0};CircleGeometry.unpack=function(e,t,n){const i=EllipseGeometry.unpack(e,t,scratchEllipseGeometry$1);return scratchOptions$2.center=Cartesian3.clone(i._center,scratchOptions$2.center),scratchOptions$2.ellipsoid=Ellipsoid.clone(i._ellipsoid,scratchOptions$2.ellipsoid),scratchOptions$2.ellipsoid=Ellipsoid.clone(i._ellipsoid,scratchEllipseGeometry$1._ellipsoid),scratchOptions$2.height=i._height,scratchOptions$2.extrudedHeight=i._extrudedHeight,scratchOptions$2.granularity=i._granularity,scratchOptions$2.vertexFormat=VertexFormat.clone(i._vertexFormat,scratchOptions$2.vertexFormat),scratchOptions$2.stRotation=i._stRotation,scratchOptions$2.shadowVolume=i._shadowVolume,defined(n)?(scratchOptions$2.semiMajorAxis=i._semiMajorAxis,scratchOptions$2.semiMinorAxis=i._semiMinorAxis,n._ellipseGeometry=new EllipseGeometry(scratchOptions$2),n):(scratchOptions$2.radius=i._semiMajorAxis,new CircleGeometry(scratchOptions$2))};CircleGeometry.createGeometry=function(e){return EllipseGeometry.createGeometry(e._ellipseGeometry)};CircleGeometry.createShadowVolume=function(e,t,n){const i=e._ellipseGeometry._granularity,r=e._ellipseGeometry._ellipsoid,o=t(i,r),a=n(i,r);return new CircleGeometry({center:e._ellipseGeometry._center,radius:e._ellipseGeometry._semiMajorAxis,ellipsoid:r,stRotation:e._ellipseGeometry._stRotation,granularity:i,extrudedHeight:o,height:a,vertexFormat:VertexFormat.POSITION_ONLY,shadowVolume:!0})};Object.defineProperties(CircleGeometry.prototype,{rectangle:{get:function(){return this._ellipseGeometry.rectangle}},textureCoordinateRotationPoints:{get:function(){return this._ellipseGeometry.textureCoordinateRotationPoints}}});function CircleOutlineGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.radius;Check.typeOf.number("radius",t);const n={center:e.center,semiMajorAxis:t,semiMinorAxis:t,ellipsoid:e.ellipsoid,height:e.height,extrudedHeight:e.extrudedHeight,granularity:e.granularity,numberOfVerticalLines:e.numberOfVerticalLines};this._ellipseGeometry=new EllipseOutlineGeometry(n),this._workerName="createCircleOutlineGeometry"}CircleOutlineGeometry.packedLength=EllipseOutlineGeometry.packedLength;CircleOutlineGeometry.pack=function(e,t,n){return Check.typeOf.object("value",e),EllipseOutlineGeometry.pack(e._ellipseGeometry,t,n)};const scratchEllipseGeometry=new EllipseOutlineGeometry({center:new Cartesian3,semiMajorAxis:1,semiMinorAxis:1}),scratchOptions$1={center:new Cartesian3,radius:void 0,ellipsoid:Ellipsoid.clone(Ellipsoid.UNIT_SPHERE),height:void 0,extrudedHeight:void 0,granularity:void 0,numberOfVerticalLines:void 0,semiMajorAxis:void 0,semiMinorAxis:void 0};CircleOutlineGeometry.unpack=function(e,t,n){const i=EllipseOutlineGeometry.unpack(e,t,scratchEllipseGeometry);return scratchOptions$1.center=Cartesian3.clone(i._center,scratchOptions$1.center),scratchOptions$1.ellipsoid=Ellipsoid.clone(i._ellipsoid,scratchOptions$1.ellipsoid),scratchOptions$1.height=i._height,scratchOptions$1.extrudedHeight=i._extrudedHeight,scratchOptions$1.granularity=i._granularity,scratchOptions$1.numberOfVerticalLines=i._numberOfVerticalLines,defined(n)?(scratchOptions$1.semiMajorAxis=i._semiMajorAxis,scratchOptions$1.semiMinorAxis=i._semiMinorAxis,n._ellipseGeometry=new EllipseOutlineGeometry(scratchOptions$1),n):(scratchOptions$1.radius=i._semiMajorAxis,new CircleOutlineGeometry(scratchOptions$1))};CircleOutlineGeometry.createGeometry=function(e){return EllipseOutlineGeometry.createGeometry(e._ellipseGeometry)};function CustomHeightmapTerrainProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),Check.defined("options.callback",e.callback),Check.defined("options.width",e.width),Check.defined("options.height",e.height),this._callback=e.callback,this._tilingScheme=e.tilingScheme,defined(this._tilingScheme)||(this._tilingScheme=new GeographicTilingScheme({ellipsoid:defaultValue(e.ellipsoid,Ellipsoid.default)})),this._width=e.width,this._height=e.height;const t=Math.max(this._width,this._height);this._levelZeroMaximumGeometricError=TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(this._tilingScheme.ellipsoid,t,this._tilingScheme.getNumberOfXTilesAtLevel(0)),this._errorEvent=new Event;let n=e.credit;typeof n=="string"&&(n=new Credit(n)),this._credit=n}Object.defineProperties(CustomHeightmapTerrainProvider.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){return this._credit}},tilingScheme:{get:function(){return this._tilingScheme}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},availability:{get:function(){}},width:{get:function(){return this._width}},height:{get:function(){return this._height}}});CustomHeightmapTerrainProvider.prototype.requestTileGeometry=function(e,t,n,i){const r=this._callback(e,t,n);if(!defined(r))return;const o=this._width,a=this._height;return Promise.resolve(r).then(function(s){let l=s;return Array.isArray(l)&&(l=new Float64Array(l)),new HeightmapTerrainData({buffer:l,width:o,height:a})})};CustomHeightmapTerrainProvider.prototype.getLevelMaximumGeometricError=function(e){return this._levelZeroMaximumGeometricError/(1<<e)};CustomHeightmapTerrainProvider.prototype.getTileDataAvailable=function(e,t,n){};CustomHeightmapTerrainProvider.prototype.loadTileDataAvailability=function(e,t,n){};function DefaultProxy(e){this.proxy=e}DefaultProxy.prototype.getURL=function(e){const t=this.proxy.indexOf("?")===-1?"?":"";return this.proxy+t+encodeURIComponent(e)};const GeocodeType={SEARCH:0,AUTOCOMPLETE:1},GeocodeType$1=Object.freeze(GeocodeType);function GeocoderService(){DeveloperError.throwInstantiationError()}Object.defineProperties(GeocoderService.prototype,{credit:{get:DeveloperError.throwInstantiationError}});GeocoderService.getCreditsFromResult=function(e){if(defined(e.attributions))return e.attributions.map(Credit.getIonCredit)};GeocoderService.prototype.geocode=DeveloperError.throwInstantiationError;function GeometryFactory(){DeveloperError.throwInstantiationError()}GeometryFactory.createGeometry=function(e){DeveloperError.throwInstantiationError()};var protobuf$2={exports:{}};/*!
 * protobuf.js v7.3.2 (c) 2016, daniel wirtz
 * compiled wed, 12 jun 2024 08:24:21 utc
 * licensed under the bsd-3-clause license
 * see: https://github.com/dcodeio/protobuf.js for details
 */(function(module){(function(undefined$1){(function(t,n,i){function r(a){var s=n[a];return s||t[a][0].call(s=n[a]={exports:{}},r,s,s.exports),s.exports}var o=r(i[0]);o.util.global.protobuf=o,typeof undefined$1=="function"&&undefined$1.amd&&undefined$1(["long"],function(a){return a&&a.isLong&&(o.util.Long=a,o.configure()),o}),module&&module.exports&&(module.exports=o)})({1:[function(e,t,n){t.exports=i;function i(r,o){for(var a=new Array(arguments.length-1),s=0,l=2,c=!0;l<arguments.length;)a[s++]=arguments[l++];return new Promise(function(h,f){a[s]=function(u){if(c)if(c=!1,u)f(u);else{for(var m=new Array(arguments.length-1),g=0;g<m.length;)m[g++]=arguments[g];h.apply(null,m)}};try{r.apply(o||null,a)}catch(p){c&&(c=!1,f(p))}})}},{}],2:[function(e,t,n){var i=n;i.length=function(c){var d=c.length;if(!d)return 0;for(var h=0;--d%4>1&&c.charAt(d)==="=";)++h;return Math.ceil(c.length*3)/4-h};for(var r=new Array(64),o=new Array(123),a=0;a<64;)o[r[a]=a<26?a+65:a<52?a+71:a<62?a-4:a-59|43]=a++;i.encode=function(c,d,h){for(var f=null,p=[],u=0,m=0,g;d<h;){var _=c[d++];switch(m){case 0:p[u++]=r[_>>2],g=(_&3)<<4,m=1;break;case 1:p[u++]=r[g|_>>4],g=(_&15)<<2,m=2;break;case 2:p[u++]=r[g|_>>6],p[u++]=r[_&63],m=0;break}u>8191&&((f||(f=[])).push(String.fromCharCode.apply(String,p)),u=0)}return m&&(p[u++]=r[g],p[u++]=61,m===1&&(p[u++]=61)),f?(u&&f.push(String.fromCharCode.apply(String,p.slice(0,u))),f.join("")):String.fromCharCode.apply(String,p.slice(0,u))};var s="invalid encoding";i.decode=function(c,d,h){for(var f=h,p=0,u,m=0;m<c.length;){var g=c.charCodeAt(m++);if(g===61&&p>1)break;if((g=o[g])===undefined$1)throw Error(s);switch(p){case 0:u=g,p=1;break;case 1:d[h++]=u<<2|(g&48)>>4,u=g,p=2;break;case 2:d[h++]=(u&15)<<4|(g&60)>>2,u=g,p=3;break;case 3:d[h++]=(u&3)<<6|g,p=0;break}}if(p===1)throw Error(s);return h-f},i.test=function(c){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(c)}},{}],3:[function(e,t,n){t.exports=i;function i(){this._listeners={}}i.prototype.on=function(o,a,s){return(this._listeners[o]||(this._listeners[o]=[])).push({fn:a,ctx:s||this}),this},i.prototype.off=function(o,a){if(o===undefined$1)this._listeners={};else if(a===undefined$1)this._listeners[o]=[];else for(var s=this._listeners[o],l=0;l<s.length;)s[l].fn===a?s.splice(l,1):++l;return this},i.prototype.emit=function(o){var a=this._listeners[o];if(a){for(var s=[],l=1;l<arguments.length;)s.push(arguments[l++]);for(l=0;l<a.length;)a[l].fn.apply(a[l++].ctx,s)}return this}},{}],4:[function(e,t,n){t.exports=i(i);function i(l){return typeof Float32Array<"u"?function(){var c=new Float32Array([-0]),d=new Uint8Array(c.buffer),h=d[3]===128;function f(g,_,C){c[0]=g,_[C]=d[0],_[C+1]=d[1],_[C+2]=d[2],_[C+3]=d[3]}function p(g,_,C){c[0]=g,_[C]=d[3],_[C+1]=d[2],_[C+2]=d[1],_[C+3]=d[0]}l.writeFloatLE=h?f:p,l.writeFloatBE=h?p:f;function u(g,_){return d[0]=g[_],d[1]=g[_+1],d[2]=g[_+2],d[3]=g[_+3],c[0]}function m(g,_){return d[3]=g[_],d[2]=g[_+1],d[1]=g[_+2],d[0]=g[_+3],c[0]}l.readFloatLE=h?u:m,l.readFloatBE=h?m:u}():function(){function c(h,f,p,u){var m=f<0?1:0;if(m&&(f=-f),f===0)h(1/f>0?0:2147483648,p,u);else if(isNaN(f))h(2143289344,p,u);else if(f>34028234663852886e22)h((m<<31|2139095040)>>>0,p,u);else if(f<11754943508222875e-54)h((m<<31|Math.round(f/1401298464324817e-60))>>>0,p,u);else{var g=Math.floor(Math.log(f)/Math.LN2),_=Math.round(f*Math.pow(2,-g)*8388608)&8388607;h((m<<31|g+127<<23|_)>>>0,p,u)}}l.writeFloatLE=c.bind(null,r),l.writeFloatBE=c.bind(null,o);function d(h,f,p){var u=h(f,p),m=(u>>31)*2+1,g=u>>>23&255,_=u&8388607;return g===255?_?NaN:m*(1/0):g===0?m*1401298464324817e-60*_:m*Math.pow(2,g-150)*(_+8388608)}l.readFloatLE=d.bind(null,a),l.readFloatBE=d.bind(null,s)}(),typeof Float64Array<"u"?function(){var c=new Float64Array([-0]),d=new Uint8Array(c.buffer),h=d[7]===128;function f(g,_,C){c[0]=g,_[C]=d[0],_[C+1]=d[1],_[C+2]=d[2],_[C+3]=d[3],_[C+4]=d[4],_[C+5]=d[5],_[C+6]=d[6],_[C+7]=d[7]}function p(g,_,C){c[0]=g,_[C]=d[7],_[C+1]=d[6],_[C+2]=d[5],_[C+3]=d[4],_[C+4]=d[3],_[C+5]=d[2],_[C+6]=d[1],_[C+7]=d[0]}l.writeDoubleLE=h?f:p,l.writeDoubleBE=h?p:f;function u(g,_){return d[0]=g[_],d[1]=g[_+1],d[2]=g[_+2],d[3]=g[_+3],d[4]=g[_+4],d[5]=g[_+5],d[6]=g[_+6],d[7]=g[_+7],c[0]}function m(g,_){return d[7]=g[_],d[6]=g[_+1],d[5]=g[_+2],d[4]=g[_+3],d[3]=g[_+4],d[2]=g[_+5],d[1]=g[_+6],d[0]=g[_+7],c[0]}l.readDoubleLE=h?u:m,l.readDoubleBE=h?m:u}():function(){function c(h,f,p,u,m,g){var _=u<0?1:0;if(_&&(u=-u),u===0)h(0,m,g+f),h(1/u>0?0:2147483648,m,g+p);else if(isNaN(u))h(0,m,g+f),h(2146959360,m,g+p);else if(u>17976931348623157e292)h(0,m,g+f),h((_<<31|2146435072)>>>0,m,g+p);else{var C;if(u<22250738585072014e-324)C=u/5e-324,h(C>>>0,m,g+f),h((_<<31|C/4294967296)>>>0,m,g+p);else{var A=Math.floor(Math.log(u)/Math.LN2);A===1024&&(A=1023),C=u*Math.pow(2,-A),h(C*4503599627370496>>>0,m,g+f),h((_<<31|A+1023<<20|C*1048576&1048575)>>>0,m,g+p)}}}l.writeDoubleLE=c.bind(null,r,0,4),l.writeDoubleBE=c.bind(null,o,4,0);function d(h,f,p,u,m){var g=h(u,m+f),_=h(u,m+p),C=(_>>31)*2+1,A=_>>>20&2047,S=4294967296*(_&1048575)+g;return A===2047?S?NaN:C*(1/0):A===0?C*5e-324*S:C*Math.pow(2,A-1075)*(S+4503599627370496)}l.readDoubleLE=d.bind(null,a,0,4),l.readDoubleBE=d.bind(null,s,4,0)}(),l}function r(l,c,d){c[d]=l&255,c[d+1]=l>>>8&255,c[d+2]=l>>>16&255,c[d+3]=l>>>24}function o(l,c,d){c[d]=l>>>24,c[d+1]=l>>>16&255,c[d+2]=l>>>8&255,c[d+3]=l&255}function a(l,c){return(l[c]|l[c+1]<<8|l[c+2]<<16|l[c+3]<<24)>>>0}function s(l,c){return(l[c]<<24|l[c+1]<<16|l[c+2]<<8|l[c+3])>>>0}},{}],5:[function(require,module,exports){module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}},{}],6:[function(e,t,n){t.exports=i;function i(r,o,a){var s=a||8192,l=s>>>1,c=null,d=s;return function(f){if(f<1||f>l)return r(f);d+f>s&&(c=r(s),d=0);var p=o.call(c,d,d+=f);return d&7&&(d=(d|7)+1),p}}},{}],7:[function(e,t,n){var i=n;i.length=function(o){for(var a=0,s=0,l=0;l<o.length;++l)s=o.charCodeAt(l),s<128?a+=1:s<2048?a+=2:(s&64512)===55296&&(o.charCodeAt(l+1)&64512)===56320?(++l,a+=4):a+=3;return a},i.read=function(o,a,s){var l=s-a;if(l<1)return"";for(var c=null,d=[],h=0,f;a<s;)f=o[a++],f<128?d[h++]=f:f>191&&f<224?d[h++]=(f&31)<<6|o[a++]&63:f>239&&f<365?(f=((f&7)<<18|(o[a++]&63)<<12|(o[a++]&63)<<6|o[a++]&63)-65536,d[h++]=55296+(f>>10),d[h++]=56320+(f&1023)):d[h++]=(f&15)<<12|(o[a++]&63)<<6|o[a++]&63,h>8191&&((c||(c=[])).push(String.fromCharCode.apply(String,d)),h=0);return c?(h&&c.push(String.fromCharCode.apply(String,d.slice(0,h))),c.join("")):String.fromCharCode.apply(String,d.slice(0,h))},i.write=function(o,a,s){for(var l=s,c,d,h=0;h<o.length;++h)c=o.charCodeAt(h),c<128?a[s++]=c:c<2048?(a[s++]=c>>6|192,a[s++]=c&63|128):(c&64512)===55296&&((d=o.charCodeAt(h+1))&64512)===56320?(c=65536+((c&1023)<<10)+(d&1023),++h,a[s++]=c>>18|240,a[s++]=c>>12&63|128,a[s++]=c>>6&63|128,a[s++]=c&63|128):(a[s++]=c>>12|224,a[s++]=c>>6&63|128,a[s++]=c&63|128);return s-l}},{}],8:[function(e,t,n){var i=n;i.build="minimal",i.Writer=e(16),i.BufferWriter=e(17),i.Reader=e(9),i.BufferReader=e(10),i.util=e(15),i.rpc=e(12),i.roots=e(11),i.configure=r;function r(){i.util._configure(),i.Writer._configure(i.BufferWriter),i.Reader._configure(i.BufferReader)}r()},{10:10,11:11,12:12,15:15,16:16,17:17,9:9}],9:[function(e,t,n){t.exports=l;var i=e(15),r,o=i.LongBits,a=i.utf8;function s(u,m){return RangeError("index out of range: "+u.pos+" + "+(m||1)+" > "+u.len)}function l(u){this.buf=u,this.pos=0,this.len=u.length}var c=typeof Uint8Array<"u"?function(m){if(m instanceof Uint8Array||Array.isArray(m))return new l(m);throw Error("illegal buffer")}:function(m){if(Array.isArray(m))return new l(m);throw Error("illegal buffer")},d=function(){return i.Buffer?function(g){return(l.create=function(C){return i.Buffer.isBuffer(C)?new r(C):c(C)})(g)}:c};l.create=d(),l.prototype._slice=i.Array.prototype.subarray||i.Array.prototype.slice,l.prototype.uint32=function(){var m=4294967295;return function(){if(m=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(m=(m|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(m=(m|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(m=(m|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(m=(m|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return m;if((this.pos+=5)>this.len)throw this.pos=this.len,s(this,10);return m}}(),l.prototype.int32=function(){return this.uint32()|0},l.prototype.sint32=function(){var m=this.uint32();return m>>>1^-(m&1)|0};function h(){var u=new o(0,0),m=0;if(this.len-this.pos>4){for(;m<4;++m)if(u.lo=(u.lo|(this.buf[this.pos]&127)<<m*7)>>>0,this.buf[this.pos++]<128)return u;if(u.lo=(u.lo|(this.buf[this.pos]&127)<<28)>>>0,u.hi=(u.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return u;m=0}else{for(;m<3;++m){if(this.pos>=this.len)throw s(this);if(u.lo=(u.lo|(this.buf[this.pos]&127)<<m*7)>>>0,this.buf[this.pos++]<128)return u}return u.lo=(u.lo|(this.buf[this.pos++]&127)<<m*7)>>>0,u}if(this.len-this.pos>4){for(;m<5;++m)if(u.hi=(u.hi|(this.buf[this.pos]&127)<<m*7+3)>>>0,this.buf[this.pos++]<128)return u}else for(;m<5;++m){if(this.pos>=this.len)throw s(this);if(u.hi=(u.hi|(this.buf[this.pos]&127)<<m*7+3)>>>0,this.buf[this.pos++]<128)return u}throw Error("invalid varint encoding")}l.prototype.bool=function(){return this.uint32()!==0};function f(u,m){return(u[m-4]|u[m-3]<<8|u[m-2]<<16|u[m-1]<<24)>>>0}l.prototype.fixed32=function(){if(this.pos+4>this.len)throw s(this,4);return f(this.buf,this.pos+=4)},l.prototype.sfixed32=function(){if(this.pos+4>this.len)throw s(this,4);return f(this.buf,this.pos+=4)|0};function p(){if(this.pos+8>this.len)throw s(this,8);return new o(f(this.buf,this.pos+=4),f(this.buf,this.pos+=4))}l.prototype.float=function(){if(this.pos+4>this.len)throw s(this,4);var m=i.float.readFloatLE(this.buf,this.pos);return this.pos+=4,m},l.prototype.double=function(){if(this.pos+8>this.len)throw s(this,4);var m=i.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,m},l.prototype.bytes=function(){var m=this.uint32(),g=this.pos,_=this.pos+m;if(_>this.len)throw s(this,m);if(this.pos+=m,Array.isArray(this.buf))return this.buf.slice(g,_);if(g===_){var C=i.Buffer;return C?C.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,g,_)},l.prototype.string=function(){var m=this.bytes();return a.read(m,0,m.length)},l.prototype.skip=function(m){if(typeof m=="number"){if(this.pos+m>this.len)throw s(this,m);this.pos+=m}else do if(this.pos>=this.len)throw s(this);while(this.buf[this.pos++]&128);return this},l.prototype.skipType=function(u){switch(u){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(u=this.uint32()&7)!==4;)this.skipType(u);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+u+" at offset "+this.pos)}return this},l._configure=function(u){r=u,l.create=d(),r._configure();var m=i.Long?"toLong":"toNumber";i.merge(l.prototype,{int64:function(){return h.call(this)[m](!1)},uint64:function(){return h.call(this)[m](!0)},sint64:function(){return h.call(this).zzDecode()[m](!1)},fixed64:function(){return p.call(this)[m](!0)},sfixed64:function(){return p.call(this)[m](!1)}})}},{15:15}],10:[function(e,t,n){t.exports=o;var i=e(9);(o.prototype=Object.create(i.prototype)).constructor=o;var r=e(15);function o(a){i.call(this,a)}o._configure=function(){r.Buffer&&(o.prototype._slice=r.Buffer.prototype.slice)},o.prototype.string=function(){var s=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+s,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+s,this.len))},o._configure()},{15:15,9:9}],11:[function(e,t,n){t.exports={}},{}],12:[function(e,t,n){var i=n;i.Service=e(13)},{13:13}],13:[function(e,t,n){t.exports=r;var i=e(15);(r.prototype=Object.create(i.EventEmitter.prototype)).constructor=r;function r(o,a,s){if(typeof o!="function")throw TypeError("rpcImpl must be a function");i.EventEmitter.call(this),this.rpcImpl=o,this.requestDelimited=!!a,this.responseDelimited=!!s}r.prototype.rpcCall=function o(a,s,l,c,d){if(!c)throw TypeError("request must be specified");var h=this;if(!d)return i.asPromise(o,h,a,s,l,c);if(!h.rpcImpl)return setTimeout(function(){d(Error("already ended"))},0),undefined$1;try{return h.rpcImpl(a,s[h.requestDelimited?"encodeDelimited":"encode"](c).finish(),function(p,u){if(p)return h.emit("error",p,a),d(p);if(u===null)return h.end(!0),undefined$1;if(!(u instanceof l))try{u=l[h.responseDelimited?"decodeDelimited":"decode"](u)}catch(m){return h.emit("error",m,a),d(m)}return h.emit("data",u,a),d(null,u)})}catch(f){return h.emit("error",f,a),setTimeout(function(){d(f)},0),undefined$1}},r.prototype.end=function(a){return this.rpcImpl&&(a||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},{15:15}],14:[function(e,t,n){t.exports=r;var i=e(15);function r(l,c){this.lo=l>>>0,this.hi=c>>>0}var o=r.zero=new r(0,0);o.toNumber=function(){return 0},o.zzEncode=o.zzDecode=function(){return this},o.length=function(){return 1};var a=r.zeroHash="\0\0\0\0\0\0\0\0";r.fromNumber=function(c){if(c===0)return o;var d=c<0;d&&(c=-c);var h=c>>>0,f=(c-h)/4294967296>>>0;return d&&(f=~f>>>0,h=~h>>>0,++h>4294967295&&(h=0,++f>4294967295&&(f=0))),new r(h,f)},r.from=function(c){if(typeof c=="number")return r.fromNumber(c);if(i.isString(c))if(i.Long)c=i.Long.fromString(c);else return r.fromNumber(parseInt(c,10));return c.low||c.high?new r(c.low>>>0,c.high>>>0):o},r.prototype.toNumber=function(c){if(!c&&this.hi>>>31){var d=~this.lo+1>>>0,h=~this.hi>>>0;return d||(h=h+1>>>0),-(d+h*4294967296)}return this.lo+this.hi*4294967296},r.prototype.toLong=function(c){return i.Long?new i.Long(this.lo|0,this.hi|0,!!c):{low:this.lo|0,high:this.hi|0,unsigned:!!c}};var s=String.prototype.charCodeAt;r.fromHash=function(c){return c===a?o:new r((s.call(c,0)|s.call(c,1)<<8|s.call(c,2)<<16|s.call(c,3)<<24)>>>0,(s.call(c,4)|s.call(c,5)<<8|s.call(c,6)<<16|s.call(c,7)<<24)>>>0)},r.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},r.prototype.zzEncode=function(){var c=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^c)>>>0,this.lo=(this.lo<<1^c)>>>0,this},r.prototype.zzDecode=function(){var c=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^c)>>>0,this.hi=(this.hi>>>1^c)>>>0,this},r.prototype.length=function(){var c=this.lo,d=(this.lo>>>28|this.hi<<4)>>>0,h=this.hi>>>24;return h===0?d===0?c<16384?c<128?1:2:c<2097152?3:4:d<16384?d<128?5:6:d<2097152?7:8:h<128?9:10}},{15:15}],15:[function(e,t,n){var i=n;i.asPromise=e(1),i.base64=e(2),i.EventEmitter=e(3),i.float=e(4),i.inquire=e(5),i.utf8=e(7),i.pool=e(6),i.LongBits=e(14),i.isNode=!!(typeof commonjsGlobal<"u"&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),i.global=i.isNode&&commonjsGlobal||typeof window<"u"&&window||typeof self<"u"&&self||this,i.emptyArray=Object.freeze?Object.freeze([]):[],i.emptyObject=Object.freeze?Object.freeze({}):{},i.isInteger=Number.isInteger||function(s){return typeof s=="number"&&isFinite(s)&&Math.floor(s)===s},i.isString=function(s){return typeof s=="string"||s instanceof String},i.isObject=function(s){return s&&typeof s=="object"},i.isset=i.isSet=function(s,l){var c=s[l];return c!=null&&s.hasOwnProperty(l)?typeof c!="object"||(Array.isArray(c)?c.length:Object.keys(c).length)>0:!1},i.Buffer=function(){try{var a=i.inquire("buffer").Buffer;return a.prototype.utf8Write?a:null}catch{return null}}(),i._Buffer_from=null,i._Buffer_allocUnsafe=null,i.newBuffer=function(s){return typeof s=="number"?i.Buffer?i._Buffer_allocUnsafe(s):new i.Array(s):i.Buffer?i._Buffer_from(s):typeof Uint8Array>"u"?s:new Uint8Array(s)},i.Array=typeof Uint8Array<"u"?Uint8Array:Array,i.Long=i.global.dcodeIO&&i.global.dcodeIO.Long||i.global.Long||i.inquire("long"),i.key2Re=/^true|false|0|1$/,i.key32Re=/^-?(?:0|[1-9][0-9]*)$/,i.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,i.longToHash=function(s){return s?i.LongBits.from(s).toHash():i.LongBits.zeroHash},i.longFromHash=function(s,l){var c=i.LongBits.fromHash(s);return i.Long?i.Long.fromBits(c.lo,c.hi,l):c.toNumber(!!l)};function r(a,s,l){for(var c=Object.keys(s),d=0;d<c.length;++d)(a[c[d]]===undefined$1||!l)&&(a[c[d]]=s[c[d]]);return a}i.merge=r,i.lcFirst=function(s){return s.charAt(0).toLowerCase()+s.substring(1)};function o(a){function s(l,c){if(!(this instanceof s))return new s(l,c);Object.defineProperty(this,"message",{get:function(){return l}}),Error.captureStackTrace?Error.captureStackTrace(this,s):Object.defineProperty(this,"stack",{value:new Error().stack||""}),c&&r(this,c)}return s.prototype=Object.create(Error.prototype,{constructor:{value:s,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return a},set:undefined$1,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),s}i.newError=o,i.ProtocolError=o("ProtocolError"),i.oneOfGetter=function(s){for(var l={},c=0;c<s.length;++c)l[s[c]]=1;return function(){for(var d=Object.keys(this),h=d.length-1;h>-1;--h)if(l[d[h]]===1&&this[d[h]]!==undefined$1&&this[d[h]]!==null)return d[h]}},i.oneOfSetter=function(s){return function(l){for(var c=0;c<s.length;++c)s[c]!==l&&delete this[s[c]]}},i.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},i._configure=function(){var a=i.Buffer;if(!a){i._Buffer_from=i._Buffer_allocUnsafe=null;return}i._Buffer_from=a.from!==Uint8Array.from&&a.from||function(l,c){return new a(l,c)},i._Buffer_allocUnsafe=a.allocUnsafe||function(l){return new a(l)}}},{1:1,14:14,2:2,3:3,4:4,5:5,6:6,7:7}],16:[function(e,t,n){t.exports=h;var i=e(15),r,o=i.LongBits,a=i.base64,s=i.utf8;function l(A,S,v){this.fn=A,this.len=S,this.next=undefined$1,this.val=v}function c(){}function d(A){this.head=A.head,this.tail=A.tail,this.len=A.len,this.next=A.states}function h(){this.len=0,this.head=new l(c,0,0),this.tail=this.head,this.states=null}var f=function(){return i.Buffer?function(){return(h.create=function(){return new r})()}:function(){return new h}};h.create=f(),h.alloc=function(S){return new i.Array(S)},i.Array!==Array&&(h.alloc=i.pool(h.alloc,i.Array.prototype.subarray)),h.prototype._push=function(S,v,b){return this.tail=this.tail.next=new l(S,v,b),this.len+=v,this};function p(A,S,v){S[v]=A&255}function u(A,S,v){for(;A>127;)S[v++]=A&127|128,A>>>=7;S[v]=A}function m(A,S){this.len=A,this.next=undefined$1,this.val=S}m.prototype=Object.create(l.prototype),m.prototype.fn=u,h.prototype.uint32=function(S){return this.len+=(this.tail=this.tail.next=new m((S=S>>>0)<128?1:S<16384?2:S<2097152?3:S<268435456?4:5,S)).len,this},h.prototype.int32=function(S){return S<0?this._push(g,10,o.fromNumber(S)):this.uint32(S)},h.prototype.sint32=function(S){return this.uint32((S<<1^S>>31)>>>0)};function g(A,S,v){for(;A.hi;)S[v++]=A.lo&127|128,A.lo=(A.lo>>>7|A.hi<<25)>>>0,A.hi>>>=7;for(;A.lo>127;)S[v++]=A.lo&127|128,A.lo=A.lo>>>7;S[v++]=A.lo}h.prototype.uint64=function(S){var v=o.from(S);return this._push(g,v.length(),v)},h.prototype.int64=h.prototype.uint64,h.prototype.sint64=function(S){var v=o.from(S).zzEncode();return this._push(g,v.length(),v)},h.prototype.bool=function(S){return this._push(p,1,S?1:0)};function _(A,S,v){S[v]=A&255,S[v+1]=A>>>8&255,S[v+2]=A>>>16&255,S[v+3]=A>>>24}h.prototype.fixed32=function(S){return this._push(_,4,S>>>0)},h.prototype.sfixed32=h.prototype.fixed32,h.prototype.fixed64=function(S){var v=o.from(S);return this._push(_,4,v.lo)._push(_,4,v.hi)},h.prototype.sfixed64=h.prototype.fixed64,h.prototype.float=function(S){return this._push(i.float.writeFloatLE,4,S)},h.prototype.double=function(S){return this._push(i.float.writeDoubleLE,8,S)};var C=i.Array.prototype.set?function(S,v,b){v.set(S,b)}:function(S,v,b){for(var D=0;D<S.length;++D)v[b+D]=S[D]};h.prototype.bytes=function(S){var v=S.length>>>0;if(!v)return this._push(p,1,0);if(i.isString(S)){var b=h.alloc(v=a.length(S));a.decode(S,b,0),S=b}return this.uint32(v)._push(C,v,S)},h.prototype.string=function(S){var v=s.length(S);return v?this.uint32(v)._push(s.write,v,S):this._push(p,1,0)},h.prototype.fork=function(){return this.states=new d(this),this.head=this.tail=new l(c,0,0),this.len=0,this},h.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new l(c,0,0),this.len=0),this},h.prototype.ldelim=function(){var S=this.head,v=this.tail,b=this.len;return this.reset().uint32(b),b&&(this.tail.next=S.next,this.tail=v,this.len+=b),this},h.prototype.finish=function(){for(var S=this.head.next,v=this.constructor.alloc(this.len),b=0;S;)S.fn(S.val,v,b),b+=S.len,S=S.next;return v},h._configure=function(A){r=A,h.create=f(),r._configure()}},{15:15}],17:[function(e,t,n){t.exports=o;var i=e(16);(o.prototype=Object.create(i.prototype)).constructor=o;var r=e(15);function o(){i.call(this)}o._configure=function(){o.alloc=r._Buffer_allocUnsafe,o.writeBytesBuffer=r.Buffer&&r.Buffer.prototype instanceof Uint8Array&&r.Buffer.prototype.set.name==="set"?function(l,c,d){c.set(l,d)}:function(l,c,d){if(l.copy)l.copy(c,d,0,l.length);else for(var h=0;h<l.length;)c[d++]=l[h++]}},o.prototype.bytes=function(l){r.isString(l)&&(l=r._Buffer_from(l,"base64"));var c=l.length>>>0;return this.uint32(c),c&&this._push(o.writeBytesBuffer,c,l),this};function a(s,l,c){s.length<40?r.utf8.write(s,l,c):l.utf8Write?l.utf8Write(s,c):l.write(s,c)}o.prototype.string=function(l){var c=r.Buffer.byteLength(l);return this.uint32(c),c&&this._push(a,c,l),this},o._configure()},{15:15,16:16}]},{},[8])})()})(protobuf$2);var protobufExports=protobuf$2.exports;const protobuf=getDefaultExportFromCjs(protobufExports),protobuf$1=_mergeNamespaces({__proto__:null,default:protobuf},[protobufExports]);function isBitSet(e,t){return(e&t)!==0}const childrenBitmasks=[1,2,4,8],anyChildBitmask=15,cacheFlagBitmask=16,imageBitmask=64,terrainBitmask=128;function GoogleEarthEnterpriseTileInformation(e,t,n,i,r,o){this._bits=e,this.cnodeVersion=t,this.imageryVersion=n,this.terrainVersion=i,this.imageryProvider=r,this.terrainProvider=o,this.ancestorHasTerrain=!1,this.terrainState=void 0}GoogleEarthEnterpriseTileInformation.clone=function(e,t){return defined(t)?(t._bits=e._bits,t.cnodeVersion=e.cnodeVersion,t.imageryVersion=e.imageryVersion,t.terrainVersion=e.terrainVersion,t.imageryProvider=e.imageryProvider,t.terrainProvider=e.terrainProvider):t=new GoogleEarthEnterpriseTileInformation(e._bits,e.cnodeVersion,e.imageryVersion,e.terrainVersion,e.imageryProvider,e.terrainProvider),t.ancestorHasTerrain=e.ancestorHasTerrain,t.terrainState=e.terrainState,t};GoogleEarthEnterpriseTileInformation.prototype.setParent=function(e){this.ancestorHasTerrain=e.ancestorHasTerrain||this.hasTerrain()};GoogleEarthEnterpriseTileInformation.prototype.hasSubtree=function(){return isBitSet(this._bits,cacheFlagBitmask)};GoogleEarthEnterpriseTileInformation.prototype.hasImagery=function(){return isBitSet(this._bits,imageBitmask)};GoogleEarthEnterpriseTileInformation.prototype.hasTerrain=function(){return isBitSet(this._bits,terrainBitmask)};GoogleEarthEnterpriseTileInformation.prototype.hasChildren=function(){return isBitSet(this._bits,anyChildBitmask)};GoogleEarthEnterpriseTileInformation.prototype.hasChild=function(e){return isBitSet(this._bits,childrenBitmasks[e])};GoogleEarthEnterpriseTileInformation.prototype.getChildBitmask=function(){return this._bits&anyChildBitmask};function stringToBuffer(e){const t=e.length,n=new ArrayBuffer(t),i=new Uint8Array(n);for(let r=0;r<t;++r)i[r]=e.charCodeAt(r);return n}const defaultKey=stringToBuffer(`E\vyjE",qIFgQ\0B%a,f)\b4jb%y
wmikNuA[@V\fr|3SOlq{EVZwUe\v3*l50s3>mF8J.uDt"a"\f3"So9D\v99L\\P_"ux\x07qh;<VqH'UfYNeuaF}a?A\04MF'{+Mg0\\P[/Fn5/'C.
\f^s\x1Be4l.jC'c#U?q{gC}:TUK/(\\-f\x07;/*"Nk.\r}}GC+>M>}Ix\fa1-O~q \r1N\v\0nPh}=\b\rnh$[k#s\r\v@Q]".jI\0wUj{GLFS\x07+S4\x07Y81NXFk-#p\x005"1&/u-6,rt#G&7r\0D3-\`i#i*|KQ\rT9w.)\x1BPjoP\\>TP[\v\x07Em(w7JfJo pq~\fmI-zrY0]s x B|G\`&q3=c+SD\\qD2O<)=RaX}e\r=\bB#	^PIMGLO{+1;ol\r?_FaZU\0gJi H]~q NV<rv)I]-6;fj=P^RKsWx.Y\x07oKW>''\`;SD>?mw
?RU^1I7&-'Tj *xprh_H~XL?f>ep8iVldI'xtOV9\0w\v-\x1B5O\bQ\`
ZGM&30xFG[y\`In7gS
>F94\rSun\fY){IIwyIV.6\v:Ob{M1/8{O!Fpv})"x
\\QYRe|3H*u\`\x1B5(1\x07-F|["`);function GoogleEarthEnterpriseMetadata(e){this.imageryPresent=!0,this.protoImagery=void 0,this.terrainPresent=!0,this.negativeAltitudeExponentBias=32,this.negativeAltitudeThreshold=CesiumMath.EPSILON12,this.providers={},this.key=void 0,this._resource=void 0,this._quadPacketVersion=1,this._tileInfo={},this._subtreePromises={}}Object.defineProperties(GoogleEarthEnterpriseMetadata.prototype,{url:{get:function(){return this._resource.url}},proxy:{get:function(){return this._resource.proxy}},resource:{get:function(){return this._resource}}});GoogleEarthEnterpriseMetadata.fromUrl=async function(e){Check.defined("resourceOrUrl",e);let t=e;typeof t!="string"&&!(t instanceof Resource)&&(Check.typeOf.string("resourceOrUrl.url",e.url),t=e.url);const n=Resource.createIfNeeded(t);n.appendForwardSlash();const i=new GoogleEarthEnterpriseMetadata;i._resource=n;try{await requestDbRoot(i),await i.getQuadTreePacket("",i._quadPacketVersion)}catch(r){const o=`An error occurred while accessing ${getMetadataResource(i,"",1).url}: ${r}`;throw new RuntimeError(o)}return i};GoogleEarthEnterpriseMetadata.tileXYToQuadKey=function(e,t,n){let i="";for(let r=n;r>=0;--r){const o=1<<r;let a=0;isBitSet(t,o)?isBitSet(e,o)&&(a|=1):(a|=2,isBitSet(e,o)||(a|=1)),i+=a}return i};GoogleEarthEnterpriseMetadata.quadKeyToTileXY=function(e){let t=0,n=0;const i=e.length-1;for(let r=i;r>=0;--r){const o=1<<r,a=+e[i-r];isBitSet(a,2)?isBitSet(a,1)||(t|=o):(n|=o,isBitSet(a,1)&&(t|=o))}return{x:t,y:n,level:i}};GoogleEarthEnterpriseMetadata.prototype.isValid=function(e){let t=this.getTileInformationFromQuadKey(e);if(defined(t))return t!==null;let n=!0,i=e,r;for(;i.length>1;)if(r=i.substring(i.length-1),i=i.substring(0,i.length-1),t=this.getTileInformationFromQuadKey(i),defined(t)){!t.hasSubtree()&&!t.hasChild(parseInt(r))&&(n=!1);break}else if(t===null){n=!1;break}return n};const taskProcessor$1=new TaskProcessor("decodeGoogleEarthEnterprisePacket");GoogleEarthEnterpriseMetadata.prototype.getQuadTreePacket=function(e,t,n){t=defaultValue(t,1),e=defaultValue(e,"");const r=getMetadataResource(this,e,t,n).fetchArrayBuffer();if(!defined(r))return;const o=this._tileInfo,a=this.key;return r.then(function(s){return taskProcessor$1.scheduleTask({buffer:s,quadKey:e,type:"Metadata",key:a},[s]).then(function(c){let d,h=-1;if(e!==""){h=e.length+1;const u=c[e];d=o[e],d._bits|=u._bits,delete c[e]}const f=Object.keys(c);f.sort(function(u,m){return u.length-m.length});const p=f.length;for(let u=0;u<p;++u){const m=f[u];if(c[m]!==null){const _=GoogleEarthEnterpriseTileInformation.clone(c[m]),C=m.length;if(C===h)_.setParent(d);else if(C>1){const A=o[m.substring(0,m.length-1)];_.setParent(A)}o[m]=_}else o[m]=null}})})};GoogleEarthEnterpriseMetadata.prototype.populateSubtree=function(e,t,n,i){const r=GoogleEarthEnterpriseMetadata.tileXYToQuadKey(e,t,n);return populateSubtree(this,r,i)};function populateSubtree(e,t,n){const i=e._tileInfo;let r=t,o=i[r];if(defined(o)&&(!o.hasSubtree()||o.hasChildren()))return o;for(;o===void 0&&r.length>1;)r=r.substring(0,r.length-1),o=i[r];let a;const s=e._subtreePromises;let l=s[r];if(defined(l))return l.then(function(){return a=new Request({throttle:n.throttle,throttleByServer:n.throttleByServer,type:n.type,priorityFunction:n.priorityFunction}),populateSubtree(e,t,a)});if(!defined(o)||!o.hasSubtree())return Promise.reject(new RuntimeError(`Couldn't load metadata for tile ${t}`));if(l=e.getQuadTreePacket(r,o.cnodeVersion,n),!!defined(l))return s[r]=l,l.then(function(){return a=new Request({throttle:n.throttle,throttleByServer:n.throttleByServer,type:n.type,priorityFunction:n.priorityFunction}),populateSubtree(e,t,a)}).finally(function(){delete s[r]})}GoogleEarthEnterpriseMetadata.prototype.getTileInformation=function(e,t,n){const i=GoogleEarthEnterpriseMetadata.tileXYToQuadKey(e,t,n);return this._tileInfo[i]};GoogleEarthEnterpriseMetadata.prototype.getTileInformationFromQuadKey=function(e){return this._tileInfo[e]};function getMetadataResource(e,t,n,i){return e._resource.getDerivedResource({url:`flatfile?q2-0${t}-q.${n.toString()}`,request:i})}let dbrootParser,dbrootParserPromise;function requestDbRoot(e){const t=e._resource.getDerivedResource({url:"dbRoot.v5",queryParameters:{output:"proto"}});if(!defined(dbrootParserPromise)){const n=buildModuleUrl("ThirdParty/google-earth-dbroot-parser.js"),i=window.cesiumGoogleEarthDbRootParser;dbrootParserPromise=loadAndExecuteScript(n).then(function(){dbrootParser=window.cesiumGoogleEarthDbRootParser(protobuf$1),defined(i)?window.cesiumGoogleEarthDbRootParser=i:delete window.cesiumGoogleEarthDbRootParser})}return dbrootParserPromise.then(function(){return t.fetchArrayBuffer()}).then(function(n){const i=dbrootParser.EncryptedDbRootProto.decode(new Uint8Array(n));let r=i.encryptionData,o=r.byteOffset,a=o+r.byteLength;const s=e.key=r.buffer.slice(o,a);r=i.dbrootData,o=r.byteOffset,a=o+r.byteLength;const l=r.buffer.slice(o,a);return taskProcessor$1.scheduleTask({buffer:l,type:"DbRoot",key:s},[l])}).then(function(n){const i=dbrootParser.DbRootProto.decode(new Uint8Array(n.buffer));if(e.imageryPresent=defaultValue(i.imageryPresent,e.imageryPresent),e.protoImagery=i.protoImagery,e.terrainPresent=defaultValue(i.terrainPresent,e.terrainPresent),defined(i.endSnippet)&&defined(i.endSnippet.model)){const s=i.endSnippet.model;e.negativeAltitudeExponentBias=defaultValue(s.negativeAltitudeExponentBias,e.negativeAltitudeExponentBias),e.negativeAltitudeThreshold=defaultValue(s.compressedNegativeAltitudeThreshold,e.negativeAltitudeThreshold)}defined(i.databaseVersion)&&(e._quadPacketVersion=defaultValue(i.databaseVersion.quadtreeVersion,e._quadPacketVersion));const r=e.providers,o=defaultValue(i.providerInfo,[]),a=o.length;for(let s=0;s<a;++s){const l=o[s],c=l.copyrightString;defined(c)&&(r[l.providerId]=new Credit(c.value))}}).catch(function(){console.log(`Failed to retrieve ${t.url}. Using defaults.`),e.key=defaultKey})}function GoogleEarthEnterpriseTerrainData(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),Check.typeOf.object("options.buffer",e.buffer),Check.typeOf.number("options.negativeAltitudeExponentBias",e.negativeAltitudeExponentBias),Check.typeOf.number("options.negativeElevationThreshold",e.negativeElevationThreshold),this._buffer=e.buffer,this._credits=e.credits,this._negativeAltitudeExponentBias=e.negativeAltitudeExponentBias,this._negativeElevationThreshold=e.negativeElevationThreshold;const t=defaultValue(e.childTileMask,15);let n=t&3;n|=t&4?8:0,n|=t&8?4:0,this._childTileMask=n,this._createdByUpsampling=defaultValue(e.createdByUpsampling,!1),this._skirtHeight=void 0,this._bufferType=this._buffer.constructor,this._mesh=void 0,this._minimumHeight=void 0,this._maximumHeight=void 0}Object.defineProperties(GoogleEarthEnterpriseTerrainData.prototype,{credits:{get:function(){return this._credits}},waterMask:{get:function(){}}});const createMeshTaskName="createVerticesFromGoogleEarthEnterpriseBuffer",createMeshTaskProcessorNoThrottle=new TaskProcessor(createMeshTaskName),createMeshTaskProcessorThrottle=new TaskProcessor(createMeshTaskName,TerrainData.maximumAsynchronousTasks),nativeRectangleScratch=new Rectangle,rectangleScratch$1=new Rectangle;GoogleEarthEnterpriseTerrainData.prototype.createMesh=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),Check.typeOf.object("options.tilingScheme",e.tilingScheme),Check.typeOf.number("options.x",e.x),Check.typeOf.number("options.y",e.y),Check.typeOf.number("options.level",e.level);const t=e.tilingScheme,n=e.x,i=e.y,r=e.level,o=defaultValue(e.exaggeration,1),a=defaultValue(e.exaggerationRelativeHeight,0),s=defaultValue(e.throttle,!0),l=t.ellipsoid;t.tileXYToNativeRectangle(n,i,r,nativeRectangleScratch),t.tileXYToRectangle(n,i,r,rectangleScratch$1);const c=l.cartographicToCartesian(Rectangle.center(rectangleScratch$1)),h=40075.16/(1<<r);this._skirtHeight=Math.min(h*8,1e3);const p=(s?createMeshTaskProcessorThrottle:createMeshTaskProcessorNoThrottle).scheduleTask({buffer:this._buffer,nativeRectangle:nativeRectangleScratch,rectangle:rectangleScratch$1,relativeToCenter:c,ellipsoid:l,skirtHeight:this._skirtHeight,exaggeration:o,exaggerationRelativeHeight:a,includeWebMercatorT:!0,negativeAltitudeExponentBias:this._negativeAltitudeExponentBias,negativeElevationThreshold:this._negativeElevationThreshold});if(!defined(p))return;const u=this;return p.then(function(m){return u._mesh=new TerrainMesh(c,new Float32Array(m.vertices),new Uint16Array(m.indices),m.indexCountWithoutSkirts,m.vertexCountWithoutSkirts,m.minimumHeight,m.maximumHeight,BoundingSphere.clone(m.boundingSphere3D),Cartesian3.clone(m.occludeePointInScaledSpace),m.numberOfAttributes,OrientedBoundingBox.clone(m.orientedBoundingBox),TerrainEncoding.clone(m.encoding),m.westIndicesSouthToNorth,m.southIndicesEastToWest,m.eastIndicesNorthToSouth,m.northIndicesWestToEast),u._minimumHeight=m.minimumHeight,u._maximumHeight=m.maximumHeight,u._buffer=void 0,u._mesh})};GoogleEarthEnterpriseTerrainData.prototype.interpolateHeight=function(e,t,n){const i=CesiumMath.clamp((t-e.west)/e.width,0,1),r=CesiumMath.clamp((n-e.south)/e.height,0,1);return defined(this._mesh)?interpolateMeshHeight(this,i,r):interpolateHeight(this,i,r,e)};const upsampleTaskProcessor=new TaskProcessor("upsampleQuantizedTerrainMesh",TerrainData.maximumAsynchronousTasks);GoogleEarthEnterpriseTerrainData.prototype.upsample=function(e,t,n,i,r,o,a){if(Check.typeOf.object("tilingScheme",e),Check.typeOf.number("thisX",t),Check.typeOf.number("thisY",n),Check.typeOf.number("thisLevel",i),Check.typeOf.number("descendantX",r),Check.typeOf.number("descendantY",o),Check.typeOf.number("descendantLevel",a),a-i>1)throw new DeveloperError("Upsampling through more than one level at a time is not currently supported.");const l=this._mesh;if(!defined(this._mesh))return;const c=t*2!==r,d=n*2===o,h=e.ellipsoid,f=e.tileXYToRectangle(r,o,a),p=upsampleTaskProcessor.scheduleTask({vertices:l.vertices,indices:l.indices,indexCountWithoutSkirts:l.indexCountWithoutSkirts,vertexCountWithoutSkirts:l.vertexCountWithoutSkirts,encoding:l.encoding,minimumHeight:this._minimumHeight,maximumHeight:this._maximumHeight,isEastChild:c,isNorthChild:d,childRectangle:f,ellipsoid:h});if(!defined(p))return;const u=this;return p.then(function(m){const g=new Uint16Array(m.vertices),_=IndexDatatype.createTypedArray(g.length/3,m.indices),C=u._skirtHeight;return new QuantizedMeshTerrainData({quantizedVertices:g,indices:_,minimumHeight:m.minimumHeight,maximumHeight:m.maximumHeight,boundingSphere:BoundingSphere.clone(m.boundingSphere),orientedBoundingBox:OrientedBoundingBox.clone(m.orientedBoundingBox),horizonOcclusionPoint:Cartesian3.clone(m.horizonOcclusionPoint),westIndices:m.westIndices,southIndices:m.southIndices,eastIndices:m.eastIndices,northIndices:m.northIndices,westSkirtHeight:C,southSkirtHeight:C,eastSkirtHeight:C,northSkirtHeight:C,childTileMask:0,createdByUpsampling:!0,credits:u._credits})})};GoogleEarthEnterpriseTerrainData.prototype.isChildAvailable=function(e,t,n,i){Check.typeOf.number("thisX",e),Check.typeOf.number("thisY",t),Check.typeOf.number("childX",n),Check.typeOf.number("childY",i);let r=2;return n!==e*2&&++r,i!==t*2&&(r-=2),(this._childTileMask&1<<r)!==0};GoogleEarthEnterpriseTerrainData.prototype.wasCreatedByUpsampling=function(){return this._createdByUpsampling};const texCoordScratch0=new Cartesian2,texCoordScratch1=new Cartesian2,texCoordScratch2=new Cartesian2,barycentricCoordinateScratch=new Cartesian3;function interpolateMeshHeight(e,t,n){const i=e._mesh,r=i.vertices,o=i.encoding,a=i.indices;for(let s=0,l=a.length;s<l;s+=3){const c=a[s],d=a[s+1],h=a[s+2],f=o.decodeTextureCoordinates(r,c,texCoordScratch0),p=o.decodeTextureCoordinates(r,d,texCoordScratch1),u=o.decodeTextureCoordinates(r,h,texCoordScratch2),m=Intersections2D$1.computeBarycentricCoordinates(t,n,f.x,f.y,p.x,p.y,u.x,u.y,barycentricCoordinateScratch);if(m.x>=-1e-15&&m.y>=-1e-15&&m.z>=-1e-15){const g=o.decodeHeight(r,c),_=o.decodeHeight(r,d),C=o.decodeHeight(r,h);return m.x*g+m.y*_+m.z*C}}}const sizeOfUint16=Uint16Array.BYTES_PER_ELEMENT,sizeOfUint32=Uint32Array.BYTES_PER_ELEMENT,sizeOfInt32=Int32Array.BYTES_PER_ELEMENT,sizeOfFloat=Float32Array.BYTES_PER_ELEMENT,sizeOfDouble=Float64Array.BYTES_PER_ELEMENT;function interpolateHeight(e,t,n,i){const r=e._buffer;let o=0,a=0,s=0;n>.5?(t>.5?(o=2,a=.5):o=3,s=.5):t>.5&&(o=1,a=.5);const l=new DataView(r);let c=0;for(let v=0;v<o;++v)c+=l.getUint32(c,!0),c+=sizeOfUint32;c+=sizeOfUint32,c+=2*sizeOfDouble;const d=CesiumMath.toRadians(l.getFloat64(c,!0)*180);c+=sizeOfDouble;const h=CesiumMath.toRadians(l.getFloat64(c,!0)*180);c+=sizeOfDouble;const f=i.width/d/2,p=i.height/h/2,u=l.getInt32(c,!0);c+=sizeOfInt32;const m=l.getInt32(c,!0)*3;c+=sizeOfInt32,c+=sizeOfInt32;const g=new Array(u),_=new Array(u),C=new Array(u);let A;for(A=0;A<u;++A)g[A]=a+l.getUint8(c++)*f,_[A]=s+l.getUint8(c++)*p,C[A]=l.getFloat32(c,!0)*6371010,c+=sizeOfFloat;const S=new Array(m);for(A=0;A<m;++A)S[A]=l.getUint16(c,!0),c+=sizeOfUint16;for(A=0;A<m;A+=3){const v=S[A],b=S[A+1],D=S[A+2],I=g[v],L=g[b],N=g[D],y=_[v],x=_[b],T=_[D],E=Intersections2D$1.computeBarycentricCoordinates(t,n,I,y,L,x,N,T,barycentricCoordinateScratch);if(E.x>=-1e-15&&E.y>=-1e-15&&E.z>=-1e-15)return E.x*C[v]+E.y*C[b]+E.z*C[D]}}const TerrainState={UNKNOWN:0,NONE:1,SELF:2,PARENT:3},julianDateScratch=new JulianDate;function TerrainCache(){this._terrainCache={},this._lastTidy=JulianDate.now()}TerrainCache.prototype.add=function(e,t){this._terrainCache[e]={buffer:t,timestamp:JulianDate.now()}};TerrainCache.prototype.get=function(e){const n=this._terrainCache[e];if(defined(n))return delete this._terrainCache[e],n.buffer};TerrainCache.prototype.tidy=function(){if(JulianDate.now(julianDateScratch),JulianDate.secondsDifference(julianDateScratch,this._lastTidy)>10){const e=this._terrainCache,t=Object.keys(e),n=t.length;for(let i=0;i<n;++i){const r=t[i],o=e[r];JulianDate.secondsDifference(julianDateScratch,o.timestamp)>10&&delete e[r]}JulianDate.clone(julianDateScratch,this._lastTidy)}};function GoogleEarthEnterpriseTerrainProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._tilingScheme=new GeographicTilingScheme({numberOfLevelZeroTilesX:2,numberOfLevelZeroTilesY:2,rectangle:new Rectangle(-CesiumMath.PI,-CesiumMath.PI,CesiumMath.PI,CesiumMath.PI),ellipsoid:e.ellipsoid});let t=e.credit;typeof t=="string"&&(t=new Credit(t)),this._credit=t,this._levelZeroMaximumGeometricError=40075.16,this._terrainCache=new TerrainCache,this._terrainPromises={},this._terrainRequests={},this._errorEvent=new Event}Object.defineProperties(GoogleEarthEnterpriseTerrainProvider.prototype,{url:{get:function(){return this._metadata.url}},proxy:{get:function(){return this._metadata.proxy}},tilingScheme:{get:function(){return this._tilingScheme}},errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){return this._credit}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},availability:{get:function(){}}});GoogleEarthEnterpriseTerrainProvider.fromMetadata=function(e,t){if(Check.defined("metadata",e),!e.terrainPresent)throw new RuntimeError(`The server ${e.url} doesn't have terrain`);const n=new GoogleEarthEnterpriseTerrainProvider(t);return n._metadata=e,n};const taskProcessor=new TaskProcessor("decodeGoogleEarthEnterprisePacket");function computeChildMask(e,t,n){let i=t.getChildBitmask();if(t.terrainState===TerrainState.PARENT){i=0;for(let r=0;r<4;++r){const o=n.getTileInformationFromQuadKey(e+r.toString());defined(o)&&o.hasTerrain()&&(i|=1<<r)}}return i}GoogleEarthEnterpriseTerrainProvider.prototype.requestTileGeometry=function(e,t,n,i){const r=GoogleEarthEnterpriseMetadata.tileXYToQuadKey(e,t,n),o=this._terrainCache,a=this._metadata,s=a.getTileInformationFromQuadKey(r);if(!defined(s))return Promise.reject(new RuntimeError("Terrain tile doesn't exist"));let l=s.terrainState;defined(l)||(l=s.terrainState=TerrainState.UNKNOWN);const c=o.get(r);if(defined(c)){const _=a.providers[s.terrainProvider];return Promise.resolve(new GoogleEarthEnterpriseTerrainData({buffer:c,childTileMask:computeChildMask(r,s,a),credits:defined(_)?[_]:void 0,negativeAltitudeExponentBias:a.negativeAltitudeExponentBias,negativeElevationThreshold:a.negativeAltitudeThreshold}))}if(o.tidy(),s.ancestorHasTerrain){if(l===TerrainState.NONE)return Promise.reject(new RuntimeError("Terrain tile doesn't exist"))}else return Promise.resolve(new HeightmapTerrainData({buffer:new Uint8Array(16*16),width:16,height:16}));let d,h=r,f=-1;switch(l){case TerrainState.SELF:f=s.terrainVersion;break;case TerrainState.PARENT:h=h.substring(0,h.length-1),d=a.getTileInformationFromQuadKey(h),f=d.terrainVersion;break;case TerrainState.UNKNOWN:s.hasTerrain()?f=s.terrainVersion:(h=h.substring(0,h.length-1),d=a.getTileInformationFromQuadKey(h),defined(d)&&d.hasTerrain()&&(f=d.terrainVersion));break}if(f<0)return Promise.reject(new RuntimeError("Terrain tile doesn't exist"));const p=this._terrainPromises,u=this._terrainRequests;let m,g;if(defined(p[h]))m=p[h],g=u[h];else{g=i;const _=buildTerrainResource(this,h,f,g).fetchArrayBuffer();if(!defined(_))return;m=_.then(function(C){return defined(C)?taskProcessor.scheduleTask({buffer:C,type:"Terrain",key:a.key},[C]).then(function(A){const S=a.getTileInformationFromQuadKey(h);S.terrainState=TerrainState.SELF,o.add(h,A[0]);const v=S.terrainProvider,b=A.length-1;for(let D=0;D<b;++D){const I=h+D.toString(),L=a.getTileInformationFromQuadKey(I);defined(L)&&(o.add(I,A[D+1]),L.terrainState=TerrainState.PARENT,L.terrainProvider===0&&(L.terrainProvider=v))}}):Promise.reject(new RuntimeError("Failed to load terrain."))}),p[h]=m,u[h]=g,m=m.finally(function(){delete p[h],delete u[h]})}return m.then(function(){const _=o.get(r);if(defined(_)){const C=a.providers[s.terrainProvider];return new GoogleEarthEnterpriseTerrainData({buffer:_,childTileMask:computeChildMask(r,s,a),credits:defined(C)?[C]:void 0,negativeAltitudeExponentBias:a.negativeAltitudeExponentBias,negativeElevationThreshold:a.negativeAltitudeThreshold})}return Promise.reject(new RuntimeError("Failed to load terrain."))}).catch(function(_){return g.state===RequestState.CANCELLED?(i.state=g.state,Promise.reject(_)):(s.terrainState=TerrainState.NONE,Promise.reject(_))})};GoogleEarthEnterpriseTerrainProvider.prototype.getLevelMaximumGeometricError=function(e){return this._levelZeroMaximumGeometricError/(1<<e)};GoogleEarthEnterpriseTerrainProvider.prototype.getTileDataAvailable=function(e,t,n){const i=this._metadata;let r=GoogleEarthEnterpriseMetadata.tileXYToQuadKey(e,t,n);const o=i.getTileInformation(e,t,n);if(o===null)return!1;if(defined(o)){if(!o.ancestorHasTerrain)return!0;const a=o.terrainState;if(a===TerrainState.NONE)return!1;if((!defined(a)||a===TerrainState.UNKNOWN)&&(o.terrainState=TerrainState.UNKNOWN,!o.hasTerrain())){r=r.substring(0,r.length-1);const s=i.getTileInformationFromQuadKey(r);if(!defined(s)||!s.hasTerrain())return!1}return!0}if(i.isValid(r)){const a=new Request({throttle:!1,throttleByServer:!0,type:RequestType.TERRAIN});i.populateSubtree(e,t,n,a)}return!1};GoogleEarthEnterpriseTerrainProvider.prototype.loadTileDataAvailability=function(e,t,n){};function buildTerrainResource(e,t,n,i){return n=defined(n)&&n>0?n:1,e._metadata.resource.getDerivedResource({url:`flatfile?f1c-0${t}-t.${n.toString()}`,request:i})}const GoogleMaps={};GoogleMaps.defaultApiKey=void 0;GoogleMaps.mapTilesApiEndpoint=new Resource({url:"https://tile.googleapis.com/v1/"});GoogleMaps.getDefaultCredit=function(){return new Credit('<img src="https://assets.ion.cesium.com/google-credit.png" style="vertical-align: -5px" alt="Google">',!0)};const GoogleMaps$1=GoogleMaps,InterpolationAlgorithm={};InterpolationAlgorithm.type=void 0;InterpolationAlgorithm.getRequiredDataPoints=DeveloperError.throwInstantiationError;InterpolationAlgorithm.interpolateOrderZero=DeveloperError.throwInstantiationError;InterpolationAlgorithm.interpolate=DeveloperError.throwInstantiationError;const InterpolationAlgorithm$1=InterpolationAlgorithm;function PeliasGeocoderService(e){Check.defined("url",e),this._url=Resource.createIfNeeded(e),this._url.appendForwardSlash()}Object.defineProperties(PeliasGeocoderService.prototype,{url:{get:function(){return this._url}},credit:{get:function(){}}});PeliasGeocoderService.prototype.geocode=async function(e,t){return Check.typeOf.string("query",e),this._url.getDerivedResource({url:t===GeocodeType$1.AUTOCOMPLETE?"autocomplete":"search",queryParameters:{text:e}}).fetchJson().then(function(i){return i.features.map(function(r){let o;const a=r.bbox;if(defined(a))o=Rectangle.fromDegrees(a[0],a[1],a[2],a[3]);else{const s=r.geometry.coordinates[0],l=r.geometry.coordinates[1];o=Cartesian3.fromDegrees(s,l)}return{displayName:r.properties.label,destination:o,attributions:i.attributions}})})};function IonGeocoderService(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),Check.typeOf.object("options.scene",e.scene);const t=defaultValue(e.accessToken,Ion.defaultAccessToken),n=Resource.createIfNeeded(defaultValue(e.server,Ion.defaultServer));n.appendForwardSlash();const i=Ion.getDefaultTokenCredit(t);defined(i)&&e.scene.frameState.creditDisplay.addStaticCredit(Credit.clone(i));const r=n.getDerivedResource({url:"v1/geocode"});defined(t)&&r.appendQueryParameters({access_token:t}),this._accessToken=t,this._server=n,this._pelias=new PeliasGeocoderService(r)}Object.defineProperties(IonGeocoderService.prototype,{credit:{get:function(){}}});IonGeocoderService.prototype.geocode=async function(e,t){return this._pelias.geocode(e,t)};function MapProjection(){DeveloperError.throwInstantiationError()}Object.defineProperties(MapProjection.prototype,{ellipsoid:{get:DeveloperError.throwInstantiationError}});MapProjection.prototype.project=DeveloperError.throwInstantiationError;MapProjection.prototype.unproject=DeveloperError.throwInstantiationError;function MorphWeightSpline(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.weights,n=e.times;if(Check.defined("weights",t),Check.defined("times",n),Check.typeOf.number.greaterThanOrEquals("weights.length",t.length,3),t.length%n.length!==0)throw new DeveloperError("times.length must be a factor of weights.length.");this._times=n,this._weights=t,this._count=t.length/n.length,this._lastTimeIndex=0}Object.defineProperties(MorphWeightSpline.prototype,{times:{get:function(){return this._times}},weights:{get:function(){return this._weights}}});MorphWeightSpline.prototype.findTimeInterval=Spline.prototype.findTimeInterval;MorphWeightSpline.prototype.wrapTime=Spline.prototype.wrapTime;MorphWeightSpline.prototype.clampTime=Spline.prototype.clampTime;MorphWeightSpline.prototype.evaluate=function(e,t){const n=this.weights,i=this.times,r=this._lastTimeIndex=this.findTimeInterval(e,this._lastTimeIndex),o=(e-i[r])/(i[r+1]-i[r]);defined(t)||(t=new Array(this._count));for(let a=0;a<this._count;a++){const s=r*this._count+a;t[a]=n[s]*(1-o)+n[s+this._count]*o}return t};function OpenCageGeocoderService(e,t,n){Check.defined("url",e),Check.defined("apiKey",t),defined(n)&&Check.typeOf.object("params",n),e=Resource.createIfNeeded(e),e.appendForwardSlash(),e.setQueryParameters({key:t}),this._url=e,this._params=defaultValue(n,{}),this._credit=new Credit('Geodata copyright <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors',!1)}Object.defineProperties(OpenCageGeocoderService.prototype,{url:{get:function(){return this._url}},params:{get:function(){return this._params}},credit:{get:function(){return this._credit}}});OpenCageGeocoderService.prototype.geocode=async function(e){return Check.typeOf.string("query",e),this._url.getDerivedResource({url:"json",queryParameters:combine$2(this._params,{q:e})}).fetchJson().then(function(n){return n.results.map(function(i){let r;const o=i.bounds;if(defined(o))r=Rectangle.fromDegrees(o.southwest.lng,o.southwest.lat,o.northeast.lng,o.northeast.lat);else{const a=i.geometry.lat,s=i.geometry.lng;r=Cartesian3.fromDegrees(a,s)}return{displayName:i.formatted,destination:r}})})};const Packable={packedLength:void 0,pack:DeveloperError.throwInstantiationError,unpack:DeveloperError.throwInstantiationError},Packable$1=Packable,PackableForInterpolation={packedInterpolationLength:void 0,convertPackedArrayForInterpolation:DeveloperError.throwInstantiationError,unpackInterpolationResult:DeveloperError.throwInstantiationError},PackableForInterpolation$1=PackableForInterpolation;function Proxy(){DeveloperError.throwInstantiationError()}Proxy.prototype.getURL=DeveloperError.throwInstantiationError;function interpolateColors(e,t,n,i,r,o,a){const s=PolylinePipeline.numberOfPoints(e,t,r);let l;const c=n.red,d=n.green,h=n.blue,f=n.alpha,p=i.red,u=i.green,m=i.blue,g=i.alpha;if(Color.equals(n,i)){for(l=0;l<s;l++)o[a++]=Color.floatToByte(c),o[a++]=Color.floatToByte(d),o[a++]=Color.floatToByte(h),o[a++]=Color.floatToByte(f);return a}const _=(p-c)/s,C=(u-d)/s,A=(m-h)/s,S=(g-f)/s;let v=a;for(l=0;l<s;l++)o[v++]=Color.floatToByte(c+l*_),o[v++]=Color.floatToByte(d+l*C),o[v++]=Color.floatToByte(h+l*A),o[v++]=Color.floatToByte(f+l*S);return v}function SimplePolylineGeometry(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.positions,n=e.colors,i=defaultValue(e.colorsPerVertex,!1);if(!defined(t)||t.length<2)throw new DeveloperError("At least two positions are required.");if(defined(n)&&(i&&n.length<t.length||!i&&n.length<t.length-1))throw new DeveloperError("colors has an invalid length.");this._positions=t,this._colors=n,this._colorsPerVertex=i,this._arcType=defaultValue(e.arcType,ArcType.GEODESIC),this._granularity=defaultValue(e.granularity,CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=defaultValue(e.ellipsoid,Ellipsoid.default),this._workerName="createSimplePolylineGeometry";let r=1+t.length*Cartesian3.packedLength;r+=defined(n)?1+n.length*Color.packedLength:1,this.packedLength=r+Ellipsoid.packedLength+3}SimplePolylineGeometry.pack=function(e,t,n){if(!defined(e))throw new DeveloperError("value is required");if(!defined(t))throw new DeveloperError("array is required");n=defaultValue(n,0);let i;const r=e._positions;let o=r.length;for(t[n++]=o,i=0;i<o;++i,n+=Cartesian3.packedLength)Cartesian3.pack(r[i],t,n);const a=e._colors;for(o=defined(a)?a.length:0,t[n++]=o,i=0;i<o;++i,n+=Color.packedLength)Color.pack(a[i],t,n);return Ellipsoid.pack(e._ellipsoid,t,n),n+=Ellipsoid.packedLength,t[n++]=e._colorsPerVertex?1:0,t[n++]=e._arcType,t[n]=e._granularity,t};SimplePolylineGeometry.unpack=function(e,t,n){if(!defined(e))throw new DeveloperError("array is required");t=defaultValue(t,0);let i,r=e[t++];const o=new Array(r);for(i=0;i<r;++i,t+=Cartesian3.packedLength)o[i]=Cartesian3.unpack(e,t);r=e[t++];const a=r>0?new Array(r):void 0;for(i=0;i<r;++i,t+=Color.packedLength)a[i]=Color.unpack(e,t);const s=Ellipsoid.unpack(e,t);t+=Ellipsoid.packedLength;const l=e[t++]===1,c=e[t++],d=e[t];return defined(n)?(n._positions=o,n._colors=a,n._ellipsoid=s,n._colorsPerVertex=l,n._arcType=c,n._granularity=d,n):new SimplePolylineGeometry({positions:o,colors:a,ellipsoid:s,colorsPerVertex:l,arcType:c,granularity:d})};const scratchArray1=new Array(2),scratchArray2=new Array(2),generateArcOptionsScratch={positions:scratchArray1,height:scratchArray2,ellipsoid:void 0,minDistance:void 0,granularity:void 0};SimplePolylineGeometry.createGeometry=function(e){const t=e._positions,n=e._colors,i=e._colorsPerVertex,r=e._arcType,o=e._granularity,a=e._ellipsoid,s=CesiumMath.chordLength(o,a.maximumRadius),l=defined(n)&&!i;let c;const d=t.length;let h,f,p,u,m=0;if(r===ArcType.GEODESIC||r===ArcType.RHUMB){let S,v,b;r===ArcType.GEODESIC?(S=CesiumMath.chordLength(o,a.maximumRadius),v=PolylinePipeline.numberOfPoints,b=PolylinePipeline.generateArc):(S=o,v=PolylinePipeline.numberOfPointsRhumbLine,b=PolylinePipeline.generateRhumbArc);const D=PolylinePipeline.extractHeights(t,a),I=generateArcOptionsScratch;if(r===ArcType.GEODESIC?I.minDistance=s:I.granularity=o,I.ellipsoid=a,l){let L=0;for(c=0;c<d-1;c++)L+=v(t[c],t[c+1],S)+1;h=new Float64Array(L*3),p=new Uint8Array(L*4),I.positions=scratchArray1,I.height=scratchArray2;let N=0;for(c=0;c<d-1;++c){scratchArray1[0]=t[c],scratchArray1[1]=t[c+1],scratchArray2[0]=D[c],scratchArray2[1]=D[c+1];const y=b(I);if(defined(n)){const x=y.length/3;u=n[c];for(let T=0;T<x;++T)p[N++]=Color.floatToByte(u.red),p[N++]=Color.floatToByte(u.green),p[N++]=Color.floatToByte(u.blue),p[N++]=Color.floatToByte(u.alpha)}h.set(y,m),m+=y.length}}else if(I.positions=t,I.height=D,h=new Float64Array(b(I)),defined(n)){for(p=new Uint8Array(h.length/3*4),c=0;c<d-1;++c){const N=t[c],y=t[c+1],x=n[c],T=n[c+1];m=interpolateColors(N,y,x,T,s,p,m)}const L=n[d-1];p[m++]=Color.floatToByte(L.red),p[m++]=Color.floatToByte(L.green),p[m++]=Color.floatToByte(L.blue),p[m++]=Color.floatToByte(L.alpha)}}else{f=l?d*2-2:d,h=new Float64Array(f*3),p=defined(n)?new Uint8Array(f*4):void 0;let S=0,v=0;for(c=0;c<d;++c){const b=t[c];if(l&&c>0&&(Cartesian3.pack(b,h,S),S+=3,u=n[c-1],p[v++]=Color.floatToByte(u.red),p[v++]=Color.floatToByte(u.green),p[v++]=Color.floatToByte(u.blue),p[v++]=Color.floatToByte(u.alpha)),l&&c===d-1)break;Cartesian3.pack(b,h,S),S+=3,defined(n)&&(u=n[c],p[v++]=Color.floatToByte(u.red),p[v++]=Color.floatToByte(u.green),p[v++]=Color.floatToByte(u.blue),p[v++]=Color.floatToByte(u.alpha))}}const g=new GeometryAttributes;g.position=new GeometryAttribute({componentDatatype:ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:h}),defined(n)&&(g.color=new GeometryAttribute({componentDatatype:ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:p,normalize:!0})),f=h.length/3;const _=(f-1)*2,C=IndexDatatype.createTypedArray(f,_);let A=0;for(c=0;c<f-1;++c)C[A++]=c,C[A++]=c+1;return new Geometry({attributes:g,indices:C,primitiveType:PrimitiveType.LINES,boundingSphere:BoundingSphere.fromPoints(t)})};function SphereGeometry(e){const t=defaultValue(e.radius,1),i={radii:new Cartesian3(t,t,t),stackPartitions:e.stackPartitions,slicePartitions:e.slicePartitions,vertexFormat:e.vertexFormat};this._ellipsoidGeometry=new EllipsoidGeometry(i),this._workerName="createSphereGeometry"}SphereGeometry.packedLength=EllipsoidGeometry.packedLength;SphereGeometry.pack=function(e,t,n){return Check.typeOf.object("value",e),EllipsoidGeometry.pack(e._ellipsoidGeometry,t,n)};const scratchEllipsoidGeometry=new EllipsoidGeometry,scratchOptions={radius:void 0,radii:new Cartesian3,vertexFormat:new VertexFormat,stackPartitions:void 0,slicePartitions:void 0};SphereGeometry.unpack=function(e,t,n){const i=EllipsoidGeometry.unpack(e,t,scratchEllipsoidGeometry);return scratchOptions.vertexFormat=VertexFormat.clone(i._vertexFormat,scratchOptions.vertexFormat),scratchOptions.stackPartitions=i._stackPartitions,scratchOptions.slicePartitions=i._slicePartitions,defined(n)?(Cartesian3.clone(i._radii,scratchOptions.radii),n._ellipsoidGeometry=new EllipsoidGeometry(scratchOptions),n):(scratchOptions.radius=i._radii.x,new SphereGeometry(scratchOptions))};SphereGeometry.createGeometry=function(e){return EllipsoidGeometry.createGeometry(e._ellipsoidGeometry)};function TilingScheme(e){throw new DeveloperError("This type should not be instantiated directly.  Instead, use WebMercatorTilingScheme or GeographicTilingScheme.")}Object.defineProperties(TilingScheme.prototype,{ellipsoid:{get:DeveloperError.throwInstantiationError},rectangle:{get:DeveloperError.throwInstantiationError},projection:{get:DeveloperError.throwInstantiationError}});TilingScheme.prototype.getNumberOfXTilesAtLevel=DeveloperError.throwInstantiationError;TilingScheme.prototype.getNumberOfYTilesAtLevel=DeveloperError.throwInstantiationError;TilingScheme.prototype.rectangleToNativeRectangle=DeveloperError.throwInstantiationError;TilingScheme.prototype.tileXYToNativeRectangle=DeveloperError.throwInstantiationError;TilingScheme.prototype.tileXYToRectangle=DeveloperError.throwInstantiationError;TilingScheme.prototype.positionToTileXY=DeveloperError.throwInstantiationError;function DataRectangle(e,t){this.rectangle=e,this.maxLevel=t}function TerrainProviderBuilder(e){this.ellipsoid=defaultValue(e.ellipsoid,Ellipsoid.default),this.tilingScheme=void 0,this.heightmapWidth=void 0,this.heightmapHeight=void 0,this.levelZeroMaximumGeometricError=void 0,this.rectangles=[]}TerrainProviderBuilder.prototype.build=function(e){e._tilingScheme=this.tilingScheme,e._heightmapWidth=this.heightmapWidth,e._heightmapHeight=this.heightmapHeight,e._levelZeroMaximumGeometricError=this.levelZeroMaximumGeometricError,e._rectangles=this.rectangles};function metadataSuccess(e,t){const n=t.getElementsByTagName("SRS")[0].textContent;if(n==="EPSG:4326")e.tilingScheme=new GeographicTilingScheme({ellipsoid:e.ellipsoid});else throw new RuntimeError(`SRS ${n} is not supported`);const i=t.getElementsByTagName("TileFormat")[0];e.heightmapWidth=parseInt(i.getAttribute("width"),10),e.heightmapHeight=parseInt(i.getAttribute("height"),10),e.levelZeroMaximumGeometricError=TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(e.ellipsoid,Math.min(e.heightmapWidth,e.heightmapHeight),e.tilingScheme.getNumberOfXTilesAtLevel(0));const r=t.getElementsByTagName("DataExtent");for(let o=0;o<r.length;++o){const a=r[o],s=CesiumMath.toRadians(parseFloat(a.getAttribute("minx"))),l=CesiumMath.toRadians(parseFloat(a.getAttribute("miny"))),c=CesiumMath.toRadians(parseFloat(a.getAttribute("maxx"))),d=CesiumMath.toRadians(parseFloat(a.getAttribute("maxy"))),h=parseInt(a.getAttribute("maxlevel"),10);e.rectangles.push(new DataRectangle(new Rectangle(s,l,c,d),h))}}function metadataFailure(e,t,n){let i=`An error occurred while accessing ${e.url}`;throw defined(t)&&defined(t.message)&&(i=`${i}: ${t.message}`),TileProviderError.reportError(void 0,n,defined(n)?n._errorEvent:void 0,i),new RuntimeError(i)}async function requestMetadata(e,t,n){try{const i=await t.fetchXML();metadataSuccess(e,i)}catch(i){metadataFailure(t,i,n)}}function VRTheWorldTerrainProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._errorEvent=new Event,this._terrainDataStructure={heightScale:1/1e3,heightOffset:-1e3,elementsPerHeight:3,stride:4,elementMultiplier:256,isBigEndian:!0,lowestEncodedHeight:0,highestEncodedHeight:256*256*256-1};let t=e.credit;typeof t=="string"&&(t=new Credit(t)),this._credit=t,this._tilingScheme=void 0,this._rectangles=[]}Object.defineProperties(VRTheWorldTerrainProvider.prototype,{errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){return this._credit}},tilingScheme:{get:function(){return this._tilingScheme}},hasWaterMask:{get:function(){return!1}},hasVertexNormals:{get:function(){return!1}},availability:{get:function(){}}});VRTheWorldTerrainProvider.fromUrl=async function(e,t){Check.defined("url",e),t=defaultValue(t,defaultValue.EMPTY_OBJECT);const n=new TerrainProviderBuilder(t),i=Resource.createIfNeeded(e);await requestMetadata(n,i);const r=new VRTheWorldTerrainProvider(t);return n.build(r),r._resource=i,r};VRTheWorldTerrainProvider.prototype.requestTileGeometry=function(e,t,n,i){const r=this._tilingScheme.getNumberOfYTilesAtLevel(n),a=this._resource.getDerivedResource({url:`${n}/${e}/${r-t-1}.tif`,queryParameters:{cesium:!0},request:i}).fetchImage({preferImageBitmap:!0});if(!defined(a))return;const s=this;return Promise.resolve(a).then(function(l){return new HeightmapTerrainData({buffer:getImagePixels(l),width:s._heightmapWidth,height:s._heightmapHeight,childTileMask:getChildMask(s,e,t,n),structure:s._terrainDataStructure})})};VRTheWorldTerrainProvider.prototype.getLevelMaximumGeometricError=function(e){return this._levelZeroMaximumGeometricError/(1<<e)};const rectangleScratch=new Rectangle;function getChildMask(e,t,n,i){const r=e._tilingScheme,o=e._rectangles,a=r.tileXYToRectangle(t,n,i);let s=0;for(let l=0;l<o.length&&s!==15;++l){const c=o[l];if(c.maxLevel<=i)continue;const d=c.rectangle,h=Rectangle.intersection(d,a,rectangleScratch);defined(h)&&(isTileInRectangle(r,d,t*2,n*2,i+1)&&(s|=4),isTileInRectangle(r,d,t*2+1,n*2,i+1)&&(s|=8),isTileInRectangle(r,d,t*2,n*2+1,i+1)&&(s|=1),isTileInRectangle(r,d,t*2+1,n*2+1,i+1)&&(s|=2))}return s}function isTileInRectangle(e,t,n,i,r){const o=e.tileXYToRectangle(n,i,r);return defined(Rectangle.intersection(o,t,rectangleScratch))}VRTheWorldTerrainProvider.prototype.getTileDataAvailable=function(e,t,n){};VRTheWorldTerrainProvider.prototype.loadTileDataAvailability=function(e,t,n){};function VideoSynchronizer(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._clock=void 0,this._element=void 0,this._clockSubscription=void 0,this._seekFunction=void 0,this._lastPlaybackRate=void 0,this.clock=e.clock,this.element=e.element,this.epoch=defaultValue(e.epoch,Iso8601.MINIMUM_VALUE),this.tolerance=defaultValue(e.tolerance,1),this._seeking=!1,this._seekFunction=void 0,this._firstTickAfterSeek=!1}Object.defineProperties(VideoSynchronizer.prototype,{clock:{get:function(){return this._clock},set:function(e){const t=this._clock;t!==e&&(defined(t)&&(this._clockSubscription(),this._clockSubscription=void 0),defined(e)&&(this._clockSubscription=e.onTick.addEventListener(VideoSynchronizer.prototype._onTick,this)),this._clock=e)}},element:{get:function(){return this._element},set:function(e){const t=this._element;t!==e&&(defined(t)&&t.removeEventListener("seeked",this._seekFunction,!1),defined(e)&&(this._seeking=!1,this._seekFunction=createSeekFunction(this),e.addEventListener("seeked",this._seekFunction,!1)),this._element=e,this._seeking=!1,this._firstTickAfterSeek=!1)}}});VideoSynchronizer.prototype.destroy=function(){return this.element=void 0,this.clock=void 0,destroyObject(this)};VideoSynchronizer.prototype.isDestroyed=function(){return!1};VideoSynchronizer.prototype._trySetPlaybackRate=function(e){if(this._lastPlaybackRate===e.multiplier)return;const t=this._element;try{t.playbackRate=e.multiplier}catch{t.playbackRate=0}this._lastPlaybackRate=e.multiplier};VideoSynchronizer.prototype._onTick=function(e){const t=this._element;if(!defined(t)||t.readyState<2)return;const n=t.paused,i=e.shouldAnimate;if(i===n&&(i?t.play():t.pause()),this._seeking||this._firstTickAfterSeek){this._firstTickAfterSeek=!1;return}this._trySetPlaybackRate(e);const r=e.currentTime,o=defaultValue(this.epoch,Iso8601.MINIMUM_VALUE);let a=JulianDate.secondsDifference(r,o);const s=t.duration;let l;const c=t.currentTime;t.loop?(a=a%s,a<0&&(a=s-a),l=a):a>s?l=s:a<0?l=0:l=a;const d=i?defaultValue(this.tolerance,1):.001;Math.abs(l-c)>d&&(this._seeking=!0,t.currentTime=l)};function createSeekFunction(e){return function(){e._seeking=!1,e._firstTickAfterSeek=!0}}const VulkanConstants={VK_FORMAT_UNDEFINED:0,VK_FORMAT_R4G4_UNORM_PACK8:1,VK_FORMAT_R4G4B4A4_UNORM_PACK16:2,VK_FORMAT_B4G4R4A4_UNORM_PACK16:3,VK_FORMAT_R5G6B5_UNORM_PACK16:4,VK_FORMAT_B5G6R5_UNORM_PACK16:5,VK_FORMAT_R5G5B5A1_UNORM_PACK16:6,VK_FORMAT_B5G5R5A1_UNORM_PACK16:7,VK_FORMAT_A1R5G5B5_UNORM_PACK16:8,VK_FORMAT_R8_UNORM:9,VK_FORMAT_R8_SNORM:10,VK_FORMAT_R8_USCALED:11,VK_FORMAT_R8_SSCALED:12,VK_FORMAT_R8_UINT:13,VK_FORMAT_R8_SINT:14,VK_FORMAT_R8_SRGB:15,VK_FORMAT_R8G8_UNORM:16,VK_FORMAT_R8G8_SNORM:17,VK_FORMAT_R8G8_USCALED:18,VK_FORMAT_R8G8_SSCALED:19,VK_FORMAT_R8G8_UINT:20,VK_FORMAT_R8G8_SINT:21,VK_FORMAT_R8G8_SRGB:22,VK_FORMAT_R8G8B8_UNORM:23,VK_FORMAT_R8G8B8_SNORM:24,VK_FORMAT_R8G8B8_USCALED:25,VK_FORMAT_R8G8B8_SSCALED:26,VK_FORMAT_R8G8B8_UINT:27,VK_FORMAT_R8G8B8_SINT:28,VK_FORMAT_R8G8B8_SRGB:29,VK_FORMAT_B8G8R8_UNORM:30,VK_FORMAT_B8G8R8_SNORM:31,VK_FORMAT_B8G8R8_USCALED:32,VK_FORMAT_B8G8R8_SSCALED:33,VK_FORMAT_B8G8R8_UINT:34,VK_FORMAT_B8G8R8_SINT:35,VK_FORMAT_B8G8R8_SRGB:36,VK_FORMAT_R8G8B8A8_UNORM:37,VK_FORMAT_R8G8B8A8_SNORM:38,VK_FORMAT_R8G8B8A8_USCALED:39,VK_FORMAT_R8G8B8A8_SSCALED:40,VK_FORMAT_R8G8B8A8_UINT:41,VK_FORMAT_R8G8B8A8_SINT:42,VK_FORMAT_R8G8B8A8_SRGB:43,VK_FORMAT_B8G8R8A8_UNORM:44,VK_FORMAT_B8G8R8A8_SNORM:45,VK_FORMAT_B8G8R8A8_USCALED:46,VK_FORMAT_B8G8R8A8_SSCALED:47,VK_FORMAT_B8G8R8A8_UINT:48,VK_FORMAT_B8G8R8A8_SINT:49,VK_FORMAT_B8G8R8A8_SRGB:50,VK_FORMAT_A8B8G8R8_UNORM_PACK32:51,VK_FORMAT_A8B8G8R8_SNORM_PACK32:52,VK_FORMAT_A8B8G8R8_USCALED_PACK32:53,VK_FORMAT_A8B8G8R8_SSCALED_PACK32:54,VK_FORMAT_A8B8G8R8_UINT_PACK32:55,VK_FORMAT_A8B8G8R8_SINT_PACK32:56,VK_FORMAT_A8B8G8R8_SRGB_PACK32:57,VK_FORMAT_A2R10G10B10_UNORM_PACK32:58,VK_FORMAT_A2R10G10B10_SNORM_PACK32:59,VK_FORMAT_A2R10G10B10_USCALED_PACK32:60,VK_FORMAT_A2R10G10B10_SSCALED_PACK32:61,VK_FORMAT_A2R10G10B10_UINT_PACK32:62,VK_FORMAT_A2R10G10B10_SINT_PACK32:63,VK_FORMAT_A2B10G10R10_UNORM_PACK32:64,VK_FORMAT_A2B10G10R10_SNORM_PACK32:65,VK_FORMAT_A2B10G10R10_USCALED_PACK32:66,VK_FORMAT_A2B10G10R10_SSCALED_PACK32:67,VK_FORMAT_A2B10G10R10_UINT_PACK32:68,VK_FORMAT_A2B10G10R10_SINT_PACK32:69,VK_FORMAT_R16_UNORM:70,VK_FORMAT_R16_SNORM:71,VK_FORMAT_R16_USCALED:72,VK_FORMAT_R16_SSCALED:73,VK_FORMAT_R16_UINT:74,VK_FORMAT_R16_SINT:75,VK_FORMAT_R16_SFLOAT:76,VK_FORMAT_R16G16_UNORM:77,VK_FORMAT_R16G16_SNORM:78,VK_FORMAT_R16G16_USCALED:79,VK_FORMAT_R16G16_SSCALED:80,VK_FORMAT_R16G16_UINT:81,VK_FORMAT_R16G16_SINT:82,VK_FORMAT_R16G16_SFLOAT:83,VK_FORMAT_R16G16B16_UNORM:84,VK_FORMAT_R16G16B16_SNORM:85,VK_FORMAT_R16G16B16_USCALED:86,VK_FORMAT_R16G16B16_SSCALED:87,VK_FORMAT_R16G16B16_UINT:88,VK_FORMAT_R16G16B16_SINT:89,VK_FORMAT_R16G16B16_SFLOAT:90,VK_FORMAT_R16G16B16A16_UNORM:91,VK_FORMAT_R16G16B16A16_SNORM:92,VK_FORMAT_R16G16B16A16_USCALED:93,VK_FORMAT_R16G16B16A16_SSCALED:94,VK_FORMAT_R16G16B16A16_UINT:95,VK_FORMAT_R16G16B16A16_SINT:96,VK_FORMAT_R16G16B16A16_SFLOAT:97,VK_FORMAT_R32_UINT:98,VK_FORMAT_R32_SINT:99,VK_FORMAT_R32_SFLOAT:100,VK_FORMAT_R32G32_UINT:101,VK_FORMAT_R32G32_SINT:102,VK_FORMAT_R32G32_SFLOAT:103,VK_FORMAT_R32G32B32_UINT:104,VK_FORMAT_R32G32B32_SINT:105,VK_FORMAT_R32G32B32_SFLOAT:106,VK_FORMAT_R32G32B32A32_UINT:107,VK_FORMAT_R32G32B32A32_SINT:108,VK_FORMAT_R32G32B32A32_SFLOAT:109,VK_FORMAT_R64_UINT:110,VK_FORMAT_R64_SINT:111,VK_FORMAT_R64_SFLOAT:112,VK_FORMAT_R64G64_UINT:113,VK_FORMAT_R64G64_SINT:114,VK_FORMAT_R64G64_SFLOAT:115,VK_FORMAT_R64G64B64_UINT:116,VK_FORMAT_R64G64B64_SINT:117,VK_FORMAT_R64G64B64_SFLOAT:118,VK_FORMAT_R64G64B64A64_UINT:119,VK_FORMAT_R64G64B64A64_SINT:120,VK_FORMAT_R64G64B64A64_SFLOAT:121,VK_FORMAT_B10G11R11_UFLOAT_PACK32:122,VK_FORMAT_E5B9G9R9_UFLOAT_PACK32:123,VK_FORMAT_D16_UNORM:124,VK_FORMAT_X8_D24_UNORM_PACK32:125,VK_FORMAT_D32_SFLOAT:126,VK_FORMAT_S8_UINT:127,VK_FORMAT_D16_UNORM_S8_UINT:128,VK_FORMAT_D24_UNORM_S8_UINT:129,VK_FORMAT_D32_SFLOAT_S8_UINT:130,VK_FORMAT_BC1_RGB_UNORM_BLOCK:131,VK_FORMAT_BC1_RGB_SRGB_BLOCK:132,VK_FORMAT_BC1_RGBA_UNORM_BLOCK:133,VK_FORMAT_BC1_RGBA_SRGB_BLOCK:134,VK_FORMAT_BC2_UNORM_BLOCK:135,VK_FORMAT_BC2_SRGB_BLOCK:136,VK_FORMAT_BC3_UNORM_BLOCK:137,VK_FORMAT_BC3_SRGB_BLOCK:138,VK_FORMAT_BC4_UNORM_BLOCK:139,VK_FORMAT_BC4_SNORM_BLOCK:140,VK_FORMAT_BC5_UNORM_BLOCK:141,VK_FORMAT_BC5_SNORM_BLOCK:142,VK_FORMAT_BC6H_UFLOAT_BLOCK:143,VK_FORMAT_BC6H_SFLOAT_BLOCK:144,VK_FORMAT_BC7_UNORM_BLOCK:145,VK_FORMAT_BC7_SRGB_BLOCK:146,VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK:147,VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK:148,VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK:149,VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK:150,VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK:151,VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK:152,VK_FORMAT_EAC_R11_UNORM_BLOCK:153,VK_FORMAT_EAC_R11_SNORM_BLOCK:154,VK_FORMAT_EAC_R11G11_UNORM_BLOCK:155,VK_FORMAT_EAC_R11G11_SNORM_BLOCK:156,VK_FORMAT_ASTC_4x4_UNORM_BLOCK:157,VK_FORMAT_ASTC_4x4_SRGB_BLOCK:158,VK_FORMAT_ASTC_5x4_UNORM_BLOCK:159,VK_FORMAT_ASTC_5x4_SRGB_BLOCK:160,VK_FORMAT_ASTC_5x5_UNORM_BLOCK:161,VK_FORMAT_ASTC_5x5_SRGB_BLOCK:162,VK_FORMAT_ASTC_6x5_UNORM_BLOCK:163,VK_FORMAT_ASTC_6x5_SRGB_BLOCK:164,VK_FORMAT_ASTC_6x6_UNORM_BLOCK:165,VK_FORMAT_ASTC_6x6_SRGB_BLOCK:166,VK_FORMAT_ASTC_8x5_UNORM_BLOCK:167,VK_FORMAT_ASTC_8x5_SRGB_BLOCK:168,VK_FORMAT_ASTC_8x6_UNORM_BLOCK:169,VK_FORMAT_ASTC_8x6_SRGB_BLOCK:170,VK_FORMAT_ASTC_8x8_UNORM_BLOCK:171,VK_FORMAT_ASTC_8x8_SRGB_BLOCK:172,VK_FORMAT_ASTC_10x5_UNORM_BLOCK:173,VK_FORMAT_ASTC_10x5_SRGB_BLOCK:174,VK_FORMAT_ASTC_10x6_UNORM_BLOCK:175,VK_FORMAT_ASTC_10x6_SRGB_BLOCK:176,VK_FORMAT_ASTC_10x8_UNORM_BLOCK:177,VK_FORMAT_ASTC_10x8_SRGB_BLOCK:178,VK_FORMAT_ASTC_10x10_UNORM_BLOCK:179,VK_FORMAT_ASTC_10x10_SRGB_BLOCK:180,VK_FORMAT_ASTC_12x10_UNORM_BLOCK:181,VK_FORMAT_ASTC_12x10_SRGB_BLOCK:182,VK_FORMAT_ASTC_12x12_UNORM_BLOCK:183,VK_FORMAT_ASTC_12x12_SRGB_BLOCK:184,VK_FORMAT_G8B8G8R8_422_UNORM:1000156e3,VK_FORMAT_B8G8R8G8_422_UNORM:1000156001,VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM:1000156002,VK_FORMAT_G8_B8R8_2PLANE_420_UNORM:1000156003,VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM:1000156004,VK_FORMAT_G8_B8R8_2PLANE_422_UNORM:1000156005,VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM:1000156006,VK_FORMAT_R10X6_UNORM_PACK16:1000156007,VK_FORMAT_R10X6G10X6_UNORM_2PACK16:1000156008,VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16:1000156009,VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16:1000156010,VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16:1000156011,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16:1000156012,VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16:1000156013,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16:1000156014,VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16:1000156015,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16:1000156016,VK_FORMAT_R12X4_UNORM_PACK16:1000156017,VK_FORMAT_R12X4G12X4_UNORM_2PACK16:1000156018,VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16:1000156019,VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16:1000156020,VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16:1000156021,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16:1000156022,VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16:1000156023,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16:1000156024,VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16:1000156025,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16:1000156026,VK_FORMAT_G16B16G16R16_422_UNORM:1000156027,VK_FORMAT_B16G16R16G16_422_UNORM:1000156028,VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM:1000156029,VK_FORMAT_G16_B16R16_2PLANE_420_UNORM:1000156030,VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM:1000156031,VK_FORMAT_G16_B16R16_2PLANE_422_UNORM:1000156032,VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM:1000156033,VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG:1000054e3,VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG:1000054001,VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG:1000054002,VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG:1000054003,VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG:1000054004,VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG:1000054005,VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG:1000054006,VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG:1000054007,VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT:1000066e3,VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT:1000066001,VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT:1000066002,VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT:1000066003,VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT:1000066004,VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT:1000066005,VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT:1000066006,VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT:1000066007,VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT:1000066008,VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT:1000066009,VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT:1000066010,VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT:1000066011,VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT:1000066012,VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT:1000066013,VK_FORMAT_G8B8G8R8_422_UNORM_KHR:1000156e3,VK_FORMAT_B8G8R8G8_422_UNORM_KHR:1000156001,VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR:1000156002,VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR:1000156003,VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR:1000156004,VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR:1000156005,VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR:1000156006,VK_FORMAT_R10X6_UNORM_PACK16_KHR:1000156007,VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR:1000156008,VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR:1000156009,VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR:1000156010,VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR:1000156011,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR:1000156012,VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR:1000156013,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR:1000156014,VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR:1000156015,VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR:1000156016,VK_FORMAT_R12X4_UNORM_PACK16_KHR:1000156017,VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR:1000156018,VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR:1000156019,VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR:1000156020,VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR:1000156021,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR:1000156022,VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR:1000156023,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR:1000156024,VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR:1000156025,VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR:1000156026,VK_FORMAT_G16B16G16R16_422_UNORM_KHR:1000156027,VK_FORMAT_B16G16R16G16_422_UNORM_KHR:1000156028,VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR:1000156029,VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR:1000156030,VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR:1000156031,VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR:1000156032,VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR:1000156033},VulkanConstants$1=Object.freeze(VulkanConstants);function createWorldBathymetryAsync(e){return e=defaultValue(e,defaultValue.EMPTY_OBJECT),CesiumTerrainProvider.fromIonAssetId(2426648,{requestVertexNormals:defaultValue(e.requestVertexNormals,!1)})}function createWorldTerrainAsync(e){return e=defaultValue(e,defaultValue.EMPTY_OBJECT),CesiumTerrainProvider.fromIonAssetId(1,{requestVertexNormals:defaultValue(e.requestVertexNormals,!1),requestWaterMask:defaultValue(e.requestWaterMask,!1),ellipsoid:Ellipsoid.WGS84})}const compressedMagic=1953029805,compressedMagicSwap=2917034100;function decodeGoogleEarthEnterpriseData(e,t){if(decodeGoogleEarthEnterpriseData.passThroughDataForTesting)return t;Check.typeOf.object("key",e),Check.typeOf.object("data",t);const n=e.byteLength;if(n===0||n%4!==0)throw new RuntimeError("The length of key must be greater than 0 and a multiple of 4.");const i=new DataView(t),r=i.getUint32(0,!0);if(r===compressedMagic||r===compressedMagicSwap)return t;const o=new DataView(e);let a=0;const s=t.byteLength,l=s-s%8,c=n;let d,h=8;for(;a<l;)for(h=(h+8)%24,d=h;a<l&&d<c;)i.setUint32(a,i.getUint32(a,!0)^o.getUint32(d,!0),!0),i.setUint32(a+4,i.getUint32(a+4,!0)^o.getUint32(d+4,!0),!0),a+=8,d+=24;if(a<s)for(d>=c&&(h=(h+8)%24,d=h);a<s;)i.setUint8(a,i.getUint8(a)^o.getUint8(d)),a++,d++}decodeGoogleEarthEnterpriseData.passThroughDataForTesting=!1;const scratchBarycentricCoords=new Cartesian3;function pointInsideTriangle(e,t,n,i){const r=barycentricCoordinates(e,t,n,i,scratchBarycentricCoords);return defined(r)?r.x>0&&r.y>0&&r.z>0:!1}async function sampleTerrain(e,t,n,i){return defined(i)||(i=!1),Check.typeOf.object("terrainProvider",e),Check.typeOf.number("level",t),Check.typeOf.bool("rejectOnTileFail",i),Check.defined("positions",n),doSampling(e,t,n,i)}function attemptConsumeNextQueueItem(e,t,n){const i=e[0],r=i.terrainProvider.requestTileGeometry(i.x,i.y,i.level);if(!r)return!1;let o;return n?o=r.then(createInterpolateFunction(i)):o=r.then(createInterpolateFunction(i)).catch(createMarkFailedFunction(i)),e.shift(),t.push(o),!0}function delay(e){return new Promise(function(t){setTimeout(t,e)})}function drainTileRequestQueue(e,t,n){return e.length?attemptConsumeNextQueueItem(e,t,n)?drainTileRequestQueue(e,t,n):delay(100).then(()=>drainTileRequestQueue(e,t,n)):Promise.resolve()}function doSampling(e,t,n,i){const r=e.tilingScheme;let o;const a=[],s={};for(o=0;o<n.length;++o){const c=r.positionToTileXY(n[o],t);if(!defined(c))continue;const d=c.toString();if(!s.hasOwnProperty(d)){const h={x:c.x,y:c.y,level:t,tilingScheme:r,terrainProvider:e,positions:[]};s[d]=h,a.push(h)}s[d].positions.push(n[o])}const l=[];return drainTileRequestQueue(a,l,i).then(function(){return Promise.all(l).then(function(){return n})})}function interpolateAndAssignHeight(e,t,n){const i=t.interpolateHeight(n,e.longitude,e.latitude);return i===void 0?!1:(e.height=i,!0)}function createInterpolateFunction(e){const t=e.positions,n=e.tilingScheme.tileXYToRectangle(e.x,e.y,e.level);return function(i){let r=!1;for(let o=0;o<t.length;++o){const a=t[o];if(!interpolateAndAssignHeight(a,i,n)){r=!0;break}}return r?i.createMesh({tilingScheme:e.tilingScheme,x:e.x,y:e.y,level:e.level,throttle:!1}).then(function(){for(let o=0;o<t.length;++o){const a=t[o];interpolateAndAssignHeight(a,i,n)}}):Promise.resolve()}}function createMarkFailedFunction(e){const t=e.positions;return function(){for(let n=0;n<t.length;++n){const i=t[n];i.height=void 0}}}const scratchCartesian2$1=new Cartesian2;async function sampleTerrainMostDetailed(e,t,n){if(defined(n)||(n=!1),!defined(e))throw new DeveloperError("terrainProvider is required.");if(!defined(t))throw new DeveloperError("positions is required.");const i=[],r=[],o=e.availability;if(!defined(o))throw new DeveloperError("sampleTerrainMostDetailed requires a terrain provider that has tile availability.");const a=[];for(let l=0;l<t.length;++l){const c=t[l],d=o.computeMaximumLevelAtPosition(c);if(r[l]=d,d===0){e.tilingScheme.positionToTileXY(c,1,scratchCartesian2$1);const f=e.loadTileDataAvailability(scratchCartesian2$1.x,scratchCartesian2$1.y,1);defined(f)&&a.push(f)}let h=i[d];defined(h)||(i[d]=h=[]),h.push(c)}await Promise.all(a),await Promise.all(i.map(function(l,c){if(defined(l))return sampleTerrain(e,c,l,n)}));const s=[];for(let l=0;l<t.length;++l){const c=t[l];o.computeMaximumLevelAtPosition(c)!==r[l]&&s.push(c)}return s.length>0&&await sampleTerrainMostDetailed(e,s,n),t}function srgbToLinear(e){return Check.defined("value",e),e<=.04045?e*.07739938080495357:Math.pow((e+.055)*.9478672985781991,2.4)}function webGLConstantToGlslType(e){switch(e){case WebGLConstants.FLOAT:return"float";case WebGLConstants.FLOAT_VEC2:return"vec2";case WebGLConstants.FLOAT_VEC3:return"vec3";case WebGLConstants.FLOAT_VEC4:return"vec4";case WebGLConstants.FLOAT_MAT2:return"mat2";case WebGLConstants.FLOAT_MAT3:return"mat3";case WebGLConstants.FLOAT_MAT4:return"mat4";case WebGLConstants.SAMPLER_2D:return"sampler2D";case WebGLConstants.BOOL:return"bool"}}function wrapFunction(e,t,n){if(typeof t!="function")throw new DeveloperError("oldFunction is required to be a function.");if(typeof n!="function")throw new DeveloperError("oldFunction is required to be a function.");return function(){n.apply(e,arguments),t.apply(e,arguments)}}const defaultDimensions=new Cartesian3(1,1,1);function BoxEmitter(e){e=defaultValue(e,defaultDimensions),Check.defined("dimensions",e),Check.typeOf.number.greaterThanOrEquals("dimensions.x",e.x,0),Check.typeOf.number.greaterThanOrEquals("dimensions.y",e.y,0),Check.typeOf.number.greaterThanOrEquals("dimensions.z",e.z,0),this._dimensions=Cartesian3.clone(e)}Object.defineProperties(BoxEmitter.prototype,{dimensions:{get:function(){return this._dimensions},set:function(e){Check.defined("value",e),Check.typeOf.number.greaterThanOrEquals("value.x",e.x,0),Check.typeOf.number.greaterThanOrEquals("value.y",e.y,0),Check.typeOf.number.greaterThanOrEquals("value.z",e.z,0),Cartesian3.clone(e,this._dimensions)}}});const scratchHalfDim=new Cartesian3;BoxEmitter.prototype.emit=function(e){const t=this._dimensions,n=Cartesian3.multiplyByScalar(t,.5,scratchHalfDim),i=CesiumMath.randomBetween(-n.x,n.x),r=CesiumMath.randomBetween(-n.y,n.y),o=CesiumMath.randomBetween(-n.z,n.z);e.position=Cartesian3.fromElements(i,r,o,e.position),e.velocity=Cartesian3.normalize(e.position,e.velocity)};function Cesium3DTileContent(){this.featurePropertiesDirty=!1}Object.defineProperties(Cesium3DTileContent.prototype,{featuresLength:{get:function(){DeveloperError.throwInstantiationError()}},pointsLength:{get:function(){DeveloperError.throwInstantiationError()}},trianglesLength:{get:function(){DeveloperError.throwInstantiationError()}},geometryByteLength:{get:function(){DeveloperError.throwInstantiationError()}},texturesByteLength:{get:function(){DeveloperError.throwInstantiationError()}},batchTableByteLength:{get:function(){DeveloperError.throwInstantiationError()}},innerContents:{get:function(){DeveloperError.throwInstantiationError()}},ready:{get:function(){DeveloperError.throwInstantiationError()}},tileset:{get:function(){DeveloperError.throwInstantiationError()}},tile:{get:function(){DeveloperError.throwInstantiationError()}},url:{get:function(){DeveloperError.throwInstantiationError()}},batchTable:{get:function(){DeveloperError.throwInstantiationError()}},metadata:{get:function(){DeveloperError.throwInstantiationError()},set:function(e){DeveloperError.throwInstantiationError()}},group:{get:function(){DeveloperError.throwInstantiationError()},set:function(e){DeveloperError.throwInstantiationError()}}});Cesium3DTileContent.prototype.hasProperty=function(e,t){DeveloperError.throwInstantiationError()};Cesium3DTileContent.prototype.getFeature=function(e){DeveloperError.throwInstantiationError()};Cesium3DTileContent.prototype.applyDebugSettings=function(e,t){DeveloperError.throwInstantiationError()};Cesium3DTileContent.prototype.applyStyle=function(e){DeveloperError.throwInstantiationError()};Cesium3DTileContent.prototype.update=function(e,t){DeveloperError.throwInstantiationError()};Cesium3DTileContent.prototype.pick=function(e,t,n){DeveloperError.throwInstantiationError()};Cesium3DTileContent.prototype.isDestroyed=function(){DeveloperError.throwInstantiationError()};Cesium3DTileContent.prototype.destroy=function(){DeveloperError.throwInstantiationError()};function ConditionsExpression(e,t){this._conditionsExpression=clone(e,!0),this._conditions=e.conditions,this._runtimeConditions=void 0,setRuntime(this,t)}Object.defineProperties(ConditionsExpression.prototype,{conditionsExpression:{get:function(){return this._conditionsExpression}}});function Statement(e,t){this.condition=e,this.expression=t}function setRuntime(e,t){const n=[],i=e._conditions;if(!defined(i))return;const r=i.length;for(let o=0;o<r;++o){const a=i[o],s=String(a[0]),l=String(a[1]);n.push(new Statement(new Expression(s,t),new Expression(l,t)))}e._runtimeConditions=n}ConditionsExpression.prototype.evaluate=function(e,t){const n=this._runtimeConditions;if(!defined(n))return;const i=n.length;for(let r=0;r<i;++r){const o=n[r];if(o.condition.evaluate(e))return o.expression.evaluate(e,t)}};ConditionsExpression.prototype.evaluateColor=function(e,t){const n=this._runtimeConditions;if(!defined(n))return;const i=n.length;for(let r=0;r<i;++r){const o=n[r];if(o.condition.evaluate(e))return o.expression.evaluateColor(e,t)}};ConditionsExpression.prototype.getShaderFunction=function(e,t,n,i){const r=this._runtimeConditions;if(!defined(r)||r.length===0)return;let o="";const a=r.length;for(let s=0;s<a;++s){const l=r[s],c=l.condition.getShaderExpression(t,n),d=l.expression.getShaderExpression(t,n);o+=`    ${s===0?"if":"else if"} (${c})
    {
        return ${d};
    }
`}return o=`${i} ${e}
{
${o}    return ${i}(1.0);
}
`,o};ConditionsExpression.prototype.getVariables=function(){let e=[];const t=this._runtimeConditions;if(!defined(t)||t.length===0)return e;const n=t.length;for(let i=0;i<n;++i){const r=t[i];e.push.apply(e,r.condition.getVariables()),e.push.apply(e,r.expression.getVariables())}return e=e.filter(function(i,r,o){return o.indexOf(i)===r}),e};function Cesium3DTileStyle(e){this._style={},this._ready=!1,this._show=void 0,this._color=void 0,this._pointSize=void 0,this._pointOutlineColor=void 0,this._pointOutlineWidth=void 0,this._labelColor=void 0,this._labelOutlineColor=void 0,this._labelOutlineWidth=void 0,this._font=void 0,this._labelStyle=void 0,this._labelText=void 0,this._backgroundColor=void 0,this._backgroundPadding=void 0,this._backgroundEnabled=void 0,this._scaleByDistance=void 0,this._translucencyByDistance=void 0,this._distanceDisplayCondition=void 0,this._heightOffset=void 0,this._anchorLineEnabled=void 0,this._anchorLineColor=void 0,this._image=void 0,this._disableDepthTestDistance=void 0,this._horizontalOrigin=void 0,this._verticalOrigin=void 0,this._labelHorizontalOrigin=void 0,this._labelVerticalOrigin=void 0,this._meta=void 0,this._colorShaderFunction=void 0,this._showShaderFunction=void 0,this._pointSizeShaderFunction=void 0,this._colorShaderFunctionReady=!1,this._showShaderFunctionReady=!1,this._pointSizeShaderFunctionReady=!1,this._colorShaderTranslucent=!1,setup(this,e)}function setup(e,t){t=defaultValue(clone(t,!0),e._style),e._style=t,e.show=t.show,e.color=t.color,e.pointSize=t.pointSize,e.pointOutlineColor=t.pointOutlineColor,e.pointOutlineWidth=t.pointOutlineWidth,e.labelColor=t.labelColor,e.labelOutlineColor=t.labelOutlineColor,e.labelOutlineWidth=t.labelOutlineWidth,e.labelStyle=t.labelStyle,e.font=t.font,e.labelText=t.labelText,e.backgroundColor=t.backgroundColor,e.backgroundPadding=t.backgroundPadding,e.backgroundEnabled=t.backgroundEnabled,e.scaleByDistance=t.scaleByDistance,e.translucencyByDistance=t.translucencyByDistance,e.distanceDisplayCondition=t.distanceDisplayCondition,e.heightOffset=t.heightOffset,e.anchorLineEnabled=t.anchorLineEnabled,e.anchorLineColor=t.anchorLineColor,e.image=t.image,e.disableDepthTestDistance=t.disableDepthTestDistance,e.horizontalOrigin=t.horizontalOrigin,e.verticalOrigin=t.verticalOrigin,e.labelHorizontalOrigin=t.labelHorizontalOrigin,e.labelVerticalOrigin=t.labelVerticalOrigin;const n={};if(defined(t.meta)){const i=t.defines,r=defaultValue(t.meta,defaultValue.EMPTY_OBJECT);for(const o in r)r.hasOwnProperty(o)&&(n[o]=new Expression(r[o],i))}e._meta=n,e._ready=!0}function getExpression(e,t){const n=defaultValue(e._style,defaultValue.EMPTY_OBJECT).defines;if(defined(t)){if(typeof t=="boolean"||typeof t=="number")return new Expression(String(t));if(typeof t=="string")return new Expression(t,n);if(defined(t.conditions))return new ConditionsExpression(t,n)}else return;return t}function getJsonFromExpression(e){if(defined(e)){if(defined(e.expression))return e.expression;if(defined(e.conditionsExpression))return clone(e.conditionsExpression,!0)}else return;return e}Object.defineProperties(Cesium3DTileStyle.prototype,{style:{get:function(){return this._style}},show:{get:function(){return this._show},set:function(e){this._show=getExpression(this,e),this._style.show=getJsonFromExpression(this._show),this._showShaderFunctionReady=!1}},color:{get:function(){return this._color},set:function(e){this._color=getExpression(this,e),this._style.color=getJsonFromExpression(this._color),this._colorShaderFunctionReady=!1}},pointSize:{get:function(){return this._pointSize},set:function(e){this._pointSize=getExpression(this,e),this._style.pointSize=getJsonFromExpression(this._pointSize),this._pointSizeShaderFunctionReady=!1}},pointOutlineColor:{get:function(){return this._pointOutlineColor},set:function(e){this._pointOutlineColor=getExpression(this,e),this._style.pointOutlineColor=getJsonFromExpression(this._pointOutlineColor)}},pointOutlineWidth:{get:function(){return this._pointOutlineWidth},set:function(e){this._pointOutlineWidth=getExpression(this,e),this._style.pointOutlineWidth=getJsonFromExpression(this._pointOutlineWidth)}},labelColor:{get:function(){return this._labelColor},set:function(e){this._labelColor=getExpression(this,e),this._style.labelColor=getJsonFromExpression(this._labelColor)}},labelOutlineColor:{get:function(){return this._labelOutlineColor},set:function(e){this._labelOutlineColor=getExpression(this,e),this._style.labelOutlineColor=getJsonFromExpression(this._labelOutlineColor)}},labelOutlineWidth:{get:function(){return this._labelOutlineWidth},set:function(e){this._labelOutlineWidth=getExpression(this,e),this._style.labelOutlineWidth=getJsonFromExpression(this._labelOutlineWidth)}},font:{get:function(){return this._font},set:function(e){this._font=getExpression(this,e),this._style.font=getJsonFromExpression(this._font)}},labelStyle:{get:function(){return this._labelStyle},set:function(e){this._labelStyle=getExpression(this,e),this._style.labelStyle=getJsonFromExpression(this._labelStyle)}},labelText:{get:function(){return this._labelText},set:function(e){this._labelText=getExpression(this,e),this._style.labelText=getJsonFromExpression(this._labelText)}},backgroundColor:{get:function(){return this._backgroundColor},set:function(e){this._backgroundColor=getExpression(this,e),this._style.backgroundColor=getJsonFromExpression(this._backgroundColor)}},backgroundPadding:{get:function(){return this._backgroundPadding},set:function(e){this._backgroundPadding=getExpression(this,e),this._style.backgroundPadding=getJsonFromExpression(this._backgroundPadding)}},backgroundEnabled:{get:function(){return this._backgroundEnabled},set:function(e){this._backgroundEnabled=getExpression(this,e),this._style.backgroundEnabled=getJsonFromExpression(this._backgroundEnabled)}},scaleByDistance:{get:function(){return this._scaleByDistance},set:function(e){this._scaleByDistance=getExpression(this,e),this._style.scaleByDistance=getJsonFromExpression(this._scaleByDistance)}},translucencyByDistance:{get:function(){return this._translucencyByDistance},set:function(e){this._translucencyByDistance=getExpression(this,e),this._style.translucencyByDistance=getJsonFromExpression(this._translucencyByDistance)}},distanceDisplayCondition:{get:function(){return this._distanceDisplayCondition},set:function(e){this._distanceDisplayCondition=getExpression(this,e),this._style.distanceDisplayCondition=getJsonFromExpression(this._distanceDisplayCondition)}},heightOffset:{get:function(){return this._heightOffset},set:function(e){this._heightOffset=getExpression(this,e),this._style.heightOffset=getJsonFromExpression(this._heightOffset)}},anchorLineEnabled:{get:function(){return this._anchorLineEnabled},set:function(e){this._anchorLineEnabled=getExpression(this,e),this._style.anchorLineEnabled=getJsonFromExpression(this._anchorLineEnabled)}},anchorLineColor:{get:function(){return this._anchorLineColor},set:function(e){this._anchorLineColor=getExpression(this,e),this._style.anchorLineColor=getJsonFromExpression(this._anchorLineColor)}},image:{get:function(){return this._image},set:function(e){this._image=getExpression(this,e),this._style.image=getJsonFromExpression(this._image)}},disableDepthTestDistance:{get:function(){return this._disableDepthTestDistance},set:function(e){this._disableDepthTestDistance=getExpression(this,e),this._style.disableDepthTestDistance=getJsonFromExpression(this._disableDepthTestDistance)}},horizontalOrigin:{get:function(){return this._horizontalOrigin},set:function(e){this._horizontalOrigin=getExpression(this,e),this._style.horizontalOrigin=getJsonFromExpression(this._horizontalOrigin)}},verticalOrigin:{get:function(){return this._verticalOrigin},set:function(e){this._verticalOrigin=getExpression(this,e),this._style.verticalOrigin=getJsonFromExpression(this._verticalOrigin)}},labelHorizontalOrigin:{get:function(){return this._labelHorizontalOrigin},set:function(e){this._labelHorizontalOrigin=getExpression(this,e),this._style.labelHorizontalOrigin=getJsonFromExpression(this._labelHorizontalOrigin)}},labelVerticalOrigin:{get:function(){return this._labelVerticalOrigin},set:function(e){this._labelVerticalOrigin=getExpression(this,e),this._style.labelVerticalOrigin=getJsonFromExpression(this._labelVerticalOrigin)}},meta:{get:function(){return this._meta},set:function(e){this._meta=e}}});Cesium3DTileStyle.fromUrl=function(e){if(!defined(e))throw new DeveloperError("url is required");return Resource.createIfNeeded(e).fetchJson(e).then(function(n){return new Cesium3DTileStyle(n)})};Cesium3DTileStyle.prototype.getColorShaderFunction=function(e,t,n){return this._colorShaderFunctionReady?(n.translucent=this._colorShaderTranslucent,this._colorShaderFunction):(this._colorShaderFunctionReady=!0,defined(this.color)&&defined(this.color.getShaderFunction)?this._colorShaderFunction=this.color.getShaderFunction(e,t,n,"vec4"):this._colorShaderFunction=void 0,this._colorShaderTranslucent=n.translucent,this._colorShaderFunction)};Cesium3DTileStyle.prototype.getShowShaderFunction=function(e,t,n){return this._showShaderFunctionReady?this._showShaderFunction:(this._showShaderFunctionReady=!0,defined(this.show)&&defined(this.show.getShaderFunction)?this._showShaderFunction=this.show.getShaderFunction(e,t,n,"bool"):this._showShaderFunction=void 0,this._showShaderFunction)};Cesium3DTileStyle.prototype.getPointSizeShaderFunction=function(e,t,n){return this._pointSizeShaderFunctionReady?this._pointSizeShaderFunction:(this._pointSizeShaderFunctionReady=!0,defined(this.pointSize)&&defined(this.pointSize.getShaderFunction)?this._pointSizeShaderFunction=this.pointSize.getShaderFunction(e,t,n,"float"):this._pointSizeShaderFunction=void 0,this._pointSizeShaderFunction)};Cesium3DTileStyle.prototype.getVariables=function(){let e=[];return defined(this.color)&&defined(this.color.getVariables)&&e.push.apply(e,this.color.getVariables()),defined(this.show)&&defined(this.show.getVariables)&&e.push.apply(e,this.show.getVariables()),defined(this.pointSize)&&defined(this.pointSize.getVariables)&&e.push.apply(e,this.pointSize.getVariables()),e=e.filter(function(t,n,i){return i.indexOf(t)===n}),e};function ImplicitSubtreeCache(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._maximumSubtreeCount=defaultValue(e.maximumSubtreeCount,0),this._subtreeRequestCounter=0,this._queue=new DoubleEndedPriorityQueue({comparator:ImplicitSubtreeCache.comparator})}ImplicitSubtreeCache.prototype.addSubtree=function(e){const t=new ImplicitSubtreeCacheNode(e,this._subtreeRequestCounter);this._subtreeRequestCounter++,this._queue.insert(t);const n=e.implicitCoordinates;if(n.level>0){const i=n.getParentSubtreeCoordinates();if(this.find(i)===void 0)throw new DeveloperError("parent node needs to exist")}if(this._maximumSubtreeCount>0)for(;this._queue.length>this._maximumSubtreeCount&&this._queue.getMinimum()!==t;)this._queue.removeMinimum()};ImplicitSubtreeCache.prototype.find=function(e){const t=this._queue,n=t.internalArray,i=t.length;for(let r=0;r<i;r++){const o=n[r],s=o.subtree.implicitCoordinates;if(e.isEqual(s))return o.subtree}};ImplicitSubtreeCache.comparator=function(e,t){const n=e.subtree.implicitCoordinates,i=t.subtree.implicitCoordinates;return n.isAncestor(i)?1:i.isAncestor(n)?-1:e.stamp-t.stamp};function ImplicitSubtreeCacheNode(e,t){this.subtree=e,this.stamp=t}function VoxelContent(e){Check.typeOf.object("resource",e),this._resource=e,this._metadataTable=void 0}Object.defineProperties(VoxelContent.prototype,{metadataTable:{get:function(){return this._metadataTable}}});VoxelContent.fromJson=async function(e,t,n,i){if(Check.typeOf.object("resource",e),defined(t)===defined(n))throw new DeveloperError("One of json and binary must be defined.");let r;defined(t)?r={json:t,binary:void 0}:r=parseVoxelChunks(n);const o=await requestBuffers(e,r.json,r.binary),a={},s=r.json.bufferViews.length;for(let h=0;h<s;++h){const f=r.json.bufferViews[h],p=f.byteOffset,u=p+f.byteLength,g=o[f.buffer].subarray(p,u);a[h]=g}const l=r.json.voxelTable,c=r.json.propertyTables[l],d=new VoxelContent(e);return d._metadataTable=new MetadataTable({count:c.count,properties:c.properties,class:i.classes[c.class],bufferViews:a}),d};function requestBuffers(e,t,n){const i=t.buffers.length,r=new Array(i);for(let o=0;o<i;o++){const a=t.buffers[o];if(defined(a.uri)){const l=e.getDerivedResource({url:a.uri});r[o]=l.fetchArrayBuffer().then(function(c){return new Uint8Array(c)})}else r[o]=Promise.resolve(n)}return Promise.all(r)}function parseVoxelChunks(e){const n=new DataView(e.buffer,e.byteOffset);let i=8;const r=n.getUint32(i,!0);i+=8;const o=n.getUint32(i,!0);i+=8;const a=getJsonFromTypedArray(e,i,r);i+=r;const s=e.subarray(i,i+o);return{json:a,binary:s}}function Cesium3DTilesVoxelProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this.shapeTransform=void 0,this.globalTransform=void 0,this.shape=void 0,this.minBounds=void 0,this.maxBounds=void 0,this.dimensions=void 0,this.paddingBefore=void 0,this.paddingAfter=void 0,this.names=void 0,this.types=void 0,this.componentTypes=void 0,this.minimumValues=void 0,this.maximumValues=void 0,this.maximumTileCount=void 0,this._implicitTileset=void 0,this._subtreeCache=new ImplicitSubtreeCache}Cesium3DTilesVoxelProvider.fromUrl=async function(e){Check.defined("url",e);const t=Resource.createIfNeeded(e),n=await t.fetchJson();validate(n);const i=getMetadataSchemaLoader(n,t);await i.load();const r=n.root,o=r.content.extensions["3DTILES_content_voxels"],a=o.class,s=hasExtension(n,"3DTILES_metadata")?n.extensions["3DTILES_metadata"]:n,l=i.schema,c=new Cesium3DTilesetMetadata({metadataJson:s,schema:l}),d=new Cesium3DTilesVoxelProvider;addAttributeInfo(d,c,a);const h=new ImplicitTileset(t,r,l),{shape:f,minBounds:p,maxBounds:u,shapeTransform:m,globalTransform:g}=getShape(r);d.shape=f,d.minBounds=p,d.maxBounds=u,d.dimensions=Cartesian3.unpack(o.dimensions),d.shapeTransform=m,d.globalTransform=g,d.maximumTileCount=getTileCount(c);let _,C;return defined(o.padding)&&(_=Cartesian3.unpack(o.padding.before),C=Cartesian3.unpack(o.padding.after)),d.paddingBefore=_,d.paddingAfter=C,d._implicitTileset=h,ResourceCache.unload(i),d};function getTileCount(e){if(defined(e.tileset))return e.tileset.getPropertyBySemantic(MetadataSemantic.TILESET_TILE_COUNT)}function validate(e){const t=e.root;if(!defined(t.content))throw new RuntimeError("Root must have content");if(!hasExtension(t.content,"3DTILES_content_voxels"))throw new RuntimeError("Root tile content must have 3DTILES_content_voxels extension");if(!hasExtension(t,"3DTILES_implicit_tiling")&&!defined(t.implicitTiling))throw new RuntimeError("Root tile must have implicit tiling");if(!defined(e.schema)&&!defined(e.schemaUri)&&!hasExtension(e,"3DTILES_metadata"))throw new RuntimeError("Tileset must have a metadata schema")}function getShape(e){const t=e.boundingVolume;let n;if(defined(e.transform)?n=Matrix4.unpack(e.transform):n=Matrix4.clone(Matrix4.IDENTITY),defined(t.box))return getBoxShape(t.box,n);if(defined(t.region))return getEllipsoidShape(t.region);if(hasExtension(t,"3DTILES_bounding_volume_cylinder"))return getCylinderShape(t.extensions["3DTILES_bounding_volume_cylinder"].cylinder,n);throw new RuntimeError("Only box, region and 3DTILES_bounding_volume_cylinder are supported in Cesium3DTilesVoxelProvider")}function getEllipsoidShape(e){const t=e[0],n=e[1],i=e[2],r=e[3],o=e[4],a=e[5],s=Matrix4.fromScale(Ellipsoid.WGS84.radii),l=new Cartesian3(t,n,o),c=new Cartesian3(i,r,a);return{shape:VoxelShapeType$1.ELLIPSOID,minBounds:l,maxBounds:c,shapeTransform:s,globalTransform:Matrix4.clone(Matrix4.IDENTITY)}}function getBoxShape(e,t){const n=OrientedBoundingBox.unpack(e),i=Matrix4.fromRotationTranslation(n.halfAxes,n.center);return{shape:VoxelShapeType$1.BOX,minBounds:Cartesian3.clone(VoxelBoxShape.DefaultMinBounds),maxBounds:Cartesian3.clone(VoxelBoxShape.DefaultMaxBounds),shapeTransform:i,globalTransform:t}}function getCylinderShape(e,t){const n=OrientedBoundingBox.unpack(e),i=Matrix4.fromRotationTranslation(n.halfAxes,n.center);return{shape:VoxelShapeType$1.CYLINDER,minBounds:Cartesian3.clone(VoxelCylinderShape.DefaultMinBounds),maxBounds:Cartesian3.clone(VoxelCylinderShape.DefaultMaxBounds),shapeTransform:i,globalTransform:t}}function getMetadataSchemaLoader(e,t){const{schemaUri:n,schema:i}=e;return defined(n)?ResourceCache.getSchemaLoader({resource:t.getDerivedResource({url:n})}):ResourceCache.getSchemaLoader({schema:i})}function addAttributeInfo(e,t,n){const{schema:i,statistics:r}=t,o=r==null?void 0:r.classes[n],a=i.classes[n].properties,s=Object.entries(a).map(([h,f])=>{const{type:p,componentType:u}=f,m=o==null?void 0:o.properties[h].min,g=o==null?void 0:o.properties[h].max,_=MetadataType.getComponentCount(p),C=copyArray(m,_),A=copyArray(g,_);return{id:h,type:p,componentType:u,minValue:C,maxValue:A}});e.names=s.map(h=>h.id),e.types=s.map(h=>h.type),e.componentTypes=s.map(h=>h.componentType);const l=s.map(h=>h.minValue),c=s.map(h=>h.maxValue),d=l.some(defined);e.minimumValues=d?l:void 0,e.maximumValues=d?c:void 0}function copyArray(e,t){if(!defined(e))return;const n=Array.isArray(e)?e:[e];return Array.from({length:t},(i,r)=>n[r])}async function getVoxelContent(e,t){const n=e.contentUriTemplates[0].getDerivedResource({templateValues:t.getTemplateValues()}),i=e.baseResource.getDerivedResource({url:n.url}),r=await i.fetchArrayBuffer(),o=preprocess3DTileContent(r);return await VoxelContent.fromJson(i,o.jsonPayload,o.binaryPayload,e.metadataSchema)}async function getSubtreePromise(e,t){const n=e._implicitTileset,i=e._subtreeCache;let r=i.find(t);if(defined(r))return r;const o=n.subtreeUriTemplate.getDerivedResource({templateValues:t.getTemplateValues()}),a=n.baseResource.getDerivedResource({url:o.url}),s=await a.fetchArrayBuffer();if(r=i.find(t),defined(r))return r;const l=preprocess3DTileContent(s);return r=await ImplicitSubtree.fromSubtreeJson(a,l.jsonPayload,l.binaryPayload,n,t),i.addSubtree(r),r}Cesium3DTilesVoxelProvider.prototype.requestData=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=defaultValue(e.tileLevel,0),n=defaultValue(e.tileX,0),i=defaultValue(e.tileY,0),r=defaultValue(e.tileZ,0);if(defaultValue(e.keyframe,0)!==0)return;const a=this._implicitTileset,s=this.names,l=new ImplicitTileCoordinates({subdivisionScheme:a.subdivisionScheme,subtreeLevels:a.subtreeLevels,level:t,x:n,y:i,z:r}),c=l.isSubtreeRoot()&&l.level>0,d=c?l.getParentSubtreeCoordinates():l.getSubtreeCoordinates();return getSubtreePromise(this,d).then(function(f){return(c?f.childSubtreeIsAvailableAtCoordinates(l):f.tileIsAvailableAtCoordinates(l))?getVoxelContent(a,l):Promise.reject("Tile is not available")}).then(function(f){return s.map(function(p){return f.metadataTable.getPropertyTypedArray(p)})})};function CircleEmitter(e){e=defaultValue(e,1),Check.typeOf.number.greaterThan("radius",e,0),this._radius=defaultValue(e,1)}Object.defineProperties(CircleEmitter.prototype,{radius:{get:function(){return this._radius},set:function(e){Check.typeOf.number.greaterThan("value",e,0),this._radius=e}}});CircleEmitter.prototype.emit=function(e){const t=CesiumMath.randomBetween(0,CesiumMath.TWO_PI),n=CesiumMath.randomBetween(0,this._radius),i=n*Math.cos(t),r=n*Math.sin(t),o=0;e.position=Cartesian3.fromElements(i,r,o,e.position),e.velocity=Cartesian3.clone(Cartesian3.UNIT_Z,e.velocity)};const CloudType={CUMULUS:0};CloudType.validate=function(e){return e===CloudType.CUMULUS};const CloudType$1=Object.freeze(CloudType);function CumulusCloud(e,t){if(e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._show=defaultValue(e.show,!0),this._position=Cartesian3.clone(defaultValue(e.position,Cartesian3.ZERO)),!defined(e.scale)&&defined(e.maximumSize))this._maximumSize=Cartesian3.clone(e.maximumSize),this._scale=new Cartesian2(this._maximumSize.x,this._maximumSize.y);else{this._scale=Cartesian2.clone(defaultValue(e.scale,new Cartesian2(20,12)));const n=new Cartesian3(this._scale.x,this._scale.y,Math.min(this._scale.x,this._scale.y)/1.5);this._maximumSize=Cartesian3.clone(defaultValue(e.maximumSize,n))}this._slice=defaultValue(e.slice,-1),this._color=Color.clone(defaultValue(e.color,Color.WHITE)),this._brightness=defaultValue(e.brightness,1),this._cloudCollection=t,this._index=-1}const SHOW_INDEX$1=CumulusCloud.SHOW_INDEX=0,POSITION_INDEX$1=CumulusCloud.POSITION_INDEX=1,SCALE_INDEX$1=CumulusCloud.SCALE_INDEX=2,MAXIMUM_SIZE_INDEX$1=CumulusCloud.MAXIMUM_SIZE_INDEX=3,SLICE_INDEX$1=CumulusCloud.SLICE_INDEX=4,BRIGHTNESS_INDEX$1=CumulusCloud.BRIGHTNESS_INDEX=5,COLOR_INDEX$1=CumulusCloud.COLOR_INDEX=6;CumulusCloud.NUMBER_OF_PROPERTIES=7;function makeDirty(e,t){const n=e._cloudCollection;defined(n)&&(n._updateCloud(e,t),e._dirty=!0)}Object.defineProperties(CumulusCloud.prototype,{show:{get:function(){return this._show},set:function(e){Check.typeOf.bool("value",e),this._show!==e&&(this._show=e,makeDirty(this,SHOW_INDEX$1))}},position:{get:function(){return this._position},set:function(e){Check.typeOf.object("value",e);const t=this._position;Cartesian3.equals(t,e)||(Cartesian3.clone(e,t),makeDirty(this,POSITION_INDEX$1))}},scale:{get:function(){return this._scale},set:function(e){Check.typeOf.object("value",e);const t=this._scale;Cartesian2.equals(t,e)||(Cartesian2.clone(e,t),makeDirty(this,SCALE_INDEX$1))}},maximumSize:{get:function(){return this._maximumSize},set:function(e){Check.typeOf.object("value",e);const t=this._maximumSize;Cartesian3.equals(t,e)||(Cartesian3.clone(e,t),makeDirty(this,MAXIMUM_SIZE_INDEX$1))}},color:{get:function(){return this._color},set:function(e){Check.typeOf.object("value",e);const t=this._color;Color.equals(t,e)||(Color.clone(e,t),makeDirty(this,COLOR_INDEX$1))}},slice:{get:function(){return this._slice},set:function(e){Check.typeOf.number("value",e),this._slice!==e&&(this._slice=e,makeDirty(this,SLICE_INDEX$1))}},brightness:{get:function(){return this._brightness},set:function(e){Check.typeOf.number("value",e),this._brightness!==e&&(this._brightness=e,makeDirty(this,BRIGHTNESS_INDEX$1))}}});CumulusCloud.prototype._destroy=function(){this._cloudCollection=void 0};let attributeLocations;const scratchTextureDimensions=new Cartesian3,attributeLocationsBatched={positionHighAndScaleX:0,positionLowAndScaleY:1,packedAttribute0:2,packedAttribute1:3,color:4},attributeLocationsInstanced={direction:0,positionHighAndScaleX:1,positionLowAndScaleY:2,packedAttribute0:3,packedAttribute1:4,color:5},SHOW_INDEX=CumulusCloud.SHOW_INDEX,POSITION_INDEX=CumulusCloud.POSITION_INDEX,SCALE_INDEX=CumulusCloud.SCALE_INDEX,MAXIMUM_SIZE_INDEX=CumulusCloud.MAXIMUM_SIZE_INDEX,SLICE_INDEX=CumulusCloud.SLICE_INDEX,BRIGHTNESS_INDEX=CumulusCloud.BRIGHTNESS_INDEX,NUMBER_OF_PROPERTIES=CumulusCloud.NUMBER_OF_PROPERTIES,COLOR_INDEX=CumulusCloud.COLOR_INDEX;function CloudCollection(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._clouds=[],this._cloudsToUpdate=[],this._cloudsToUpdateIndex=0,this._cloudsRemoved=!1,this._createVertexArray=!1,this._propertiesChanged=new Uint32Array(NUMBER_OF_PROPERTIES),this._noiseTexture=void 0,this._textureSliceWidth=128,this._noiseTextureRows=4,this.noiseDetail=defaultValue(e.noiseDetail,16),this.noiseOffset=Cartesian3.clone(defaultValue(e.noiseOffset,Cartesian3.ZERO)),this._loading=!1,this._ready=!1;const t=this;this._uniforms={u_noiseTexture:function(){return t._noiseTexture},u_noiseTextureDimensions:getNoiseTextureDimensions(t),u_noiseDetail:function(){return t.noiseDetail}},this._vaNoise=void 0,this._spNoise=void 0,this._spCreated=!1,this._sp=void 0,this._rs=void 0,this.show=defaultValue(e.show,!0),this._colorCommands=[],this.debugBillboards=defaultValue(e.debugBillboards,!1),this._compiledDebugBillboards=!1,this.debugEllipsoids=defaultValue(e.debugEllipsoids,!1),this._compiledDebugEllipsoids=!1}function getNoiseTextureDimensions(e){return function(){return scratchTextureDimensions.x=e._textureSliceWidth,scratchTextureDimensions.y=e._noiseTextureRows,scratchTextureDimensions.z=1/e._noiseTextureRows,scratchTextureDimensions}}Object.defineProperties(CloudCollection.prototype,{length:{get:function(){return removeClouds(this),this._clouds.length}}});function destroyClouds(e){const t=e.length;for(let n=0;n<t;++n)e[n]&&e[n]._destroy()}CloudCollection.prototype.add=function(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=defaultValue(e.cloudType,CloudType$1.CUMULUS);if(!CloudType$1.validate(t))throw new DeveloperError("invalid cloud type");let n;return t===CloudType$1.CUMULUS&&(n=new CumulusCloud(e,this),n._index=this._clouds.length,this._clouds.push(n),this._createVertexArray=!0),n};CloudCollection.prototype.remove=function(e){return this.contains(e)?(this._clouds[e._index]=void 0,this._cloudsRemoved=!0,this._createVertexArray=!0,e._destroy(),!0):!1};CloudCollection.prototype.removeAll=function(){destroyClouds(this._clouds),this._clouds=[],this._cloudsToUpdate=[],this._cloudsToUpdateIndex=0,this._cloudsRemoved=!1,this._createVertexArray=!0};function removeClouds(e){if(e._cloudsRemoved){e._cloudsRemoved=!1;const t=[],n=e._clouds,i=n.length;for(let r=0,o=0;r<i;++r){const a=n[r];defined(a)&&(n._index=o++,t.push(a))}e._clouds=t}}CloudCollection.prototype._updateCloud=function(e,t){e._dirty||(this._cloudsToUpdate[this._cloudsToUpdateIndex++]=e),++this._propertiesChanged[t]};CloudCollection.prototype.contains=function(e){return defined(e)&&e._cloudCollection===this};CloudCollection.prototype.get=function(e){return Check.typeOf.number("index",e),removeClouds(this),this._clouds[e]};const texturePositions=new Float32Array([-1,-1,1,-1,1,1,-1,1]),textureIndices=new Uint16Array([0,1,2,0,2,3]);function createTextureVA(e){const t=Buffer.createVertexBuffer({context:e,typedArray:texturePositions,usage:BufferUsage.STATIC_DRAW}),n=Buffer.createIndexBuffer({context:e,typedArray:textureIndices,usage:BufferUsage.STATIC_DRAW,indexDatatype:IndexDatatype.UNSIGNED_SHORT}),i=[{index:0,vertexBuffer:t,componentsPerAttribute:2,componentDatatype:ComponentDatatype.FLOAT}];return new VertexArray({context:e,attributes:i,indexBuffer:n})}let getIndexBuffer;function getIndexBufferBatched(e){let n=e.cache.cloudCollection_indexBufferBatched;if(defined(n))return n;const i=16384*6-6,r=new Uint16Array(i);for(let o=0,a=0;o<i;o+=6,a+=4)r[o]=a,r[o+1]=a+1,r[o+2]=a+2,r[o+3]=a,r[o+4]=a+2,r[o+5]=a+3;return n=Buffer.createIndexBuffer({context:e,typedArray:r,usage:BufferUsage.STATIC_DRAW,indexDatatype:IndexDatatype.UNSIGNED_SHORT}),n.vertexArrayDestroyable=!1,e.cache.cloudCollection_indexBufferBatched=n,n}function getIndexBufferInstanced(e){let t=e.cache.cloudCollection_indexBufferInstanced;return defined(t)||(t=Buffer.createIndexBuffer({context:e,typedArray:new Uint16Array([0,1,2,0,2,3]),usage:BufferUsage.STATIC_DRAW,indexDatatype:IndexDatatype.UNSIGNED_SHORT}),t.vertexArrayDestroyable=!1,e.cache.cloudCollection_indexBufferInstanced=t),t}function getVertexBufferInstanced(e){let t=e.cache.cloudCollection_vertexBufferInstanced;return defined(t)||(t=Buffer.createVertexBuffer({context:e,typedArray:new Float32Array([0,0,1,0,1,1,0,1]),usage:BufferUsage.STATIC_DRAW}),t.vertexArrayDestroyable=!1,e.cache.cloudCollection_vertexBufferInstanced=t),t}function createVAF(e,t,n){const i=[{index:attributeLocations.positionHighAndScaleX,componentsPerAttribute:4,componentDatatype:ComponentDatatype.FLOAT,usage:BufferUsage.STATIC_DRAW},{index:attributeLocations.positionLowAndScaleY,componentsPerAttribute:4,componentDatatype:ComponentDatatype.FLOAT,usage:BufferUsage.STATIC_DRAW},{index:attributeLocations.packedAttribute0,componentsPerAttribute:4,componentDatatype:ComponentDatatype.FLOAT,usage:BufferUsage.STATIC_DRAW},{index:attributeLocations.packedAttribute1,componentsPerAttribute:4,componentDatatype:ComponentDatatype.FLOAT,usage:BufferUsage.STATIC_DRAW},{index:attributeLocations.color,componentsPerAttribute:4,componentDatatype:ComponentDatatype.UNSIGNED_BYTE,normalize:!0,usage:BufferUsage.STATIC_DRAW}];n&&i.push({index:attributeLocations.direction,componentsPerAttribute:2,componentDatatype:ComponentDatatype.FLOAT,vertexBuffer:getVertexBufferInstanced(e)});const r=n?t:4*t;return new VertexArrayFacade(e,i,r,n)}const writePositionScratch=new EncodedCartesian3;function writePositionAndScale(e,t,n,i){let r;const o=n[attributeLocations.positionHighAndScaleX],a=n[attributeLocations.positionLowAndScaleY],s=i.position;EncodedCartesian3.fromCartesian(s,writePositionScratch);const l=i.scale,c=writePositionScratch.high,d=writePositionScratch.low;e._instanced?(r=i._index,o(r,c.x,c.y,c.z,l.x),a(r,d.x,d.y,d.z,l.y)):(r=i._index*4,o(r+0,c.x,c.y,c.z,l.x),o(r+1,c.x,c.y,c.z,l.x),o(r+2,c.x,c.y,c.z,l.x),o(r+3,c.x,c.y,c.z,l.x),a(r+0,d.x,d.y,d.z,l.y),a(r+1,d.x,d.y,d.z,l.y),a(r+2,d.x,d.y,d.z,l.y),a(r+3,d.x,d.y,d.z,l.y))}function writePackedAttribute0(e,t,n,i){let r;const o=n[attributeLocations.packedAttribute0],a=i.show,s=i.brightness;e._instanced?(r=i._index,o(r,a,s,0,0)):(r=i._index*4,o(r+0,a,s,0,0),o(r+1,a,s,1,0),o(r+2,a,s,1,1),o(r+3,a,s,0,1))}function writePackedAttribute1(e,t,n,i){let r;const o=n[attributeLocations.packedAttribute1],a=i.maximumSize,s=i.slice;e._instanced?(r=i._index,o(r,a.x,a.y,a.z,s)):(r=i._index*4,o(r+0,a.x,a.y,a.z,s),o(r+1,a.x,a.y,a.z,s),o(r+2,a.x,a.y,a.z,s),o(r+3,a.x,a.y,a.z,s))}function writeColor(e,t,n,i){let r;const o=n[attributeLocations.color],a=i.color,s=Color.floatToByte(a.red),l=Color.floatToByte(a.green),c=Color.floatToByte(a.blue),d=Color.floatToByte(a.alpha);e._instanced?(r=i._index,o(r,s,l,c,d)):(r=i._index*4,o(r+0,s,l,c,d),o(r+1,s,l,c,d),o(r+2,s,l,c,d),o(r+3,s,l,c,d))}function writeCloud(e,t,n,i){writePositionAndScale(e,t,n,i),writePackedAttribute0(e,t,n,i),writePackedAttribute1(e,t,n,i),writeColor(e,t,n,i)}function createNoiseTexture(e,t,n,i){const r=e,o=r._textureSliceWidth,a=r._noiseTextureRows;if(o/a<1||o%a!==0)throw new DeveloperError("noiseTextureRows must evenly divide textureSliceWidth");const s=t.context;r._vaNoise=createTextureVA(s),r._spNoise=ShaderProgram.fromCache({context:s,vertexShaderSource:n,fragmentShaderSource:i,attributeLocations:{position:0}});const l=r.noiseDetail,c=r.noiseOffset;r._noiseTexture=new Texture({context:s,width:o*o/a,height:o*a,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,pixelFormat:PixelFormat.RGBA,sampler:new Sampler({wrapS:TextureWrap.REPEAT,wrapT:TextureWrap.REPEAT,minificationFilter:TextureMinificationFilter.NEAREST,magnificationFilter:TextureMagnificationFilter.NEAREST})});const d=new ComputeCommand({vertexArray:r._vaNoise,shaderProgram:r._spNoise,outputTexture:r._noiseTexture,uniformMap:{u_noiseTextureDimensions:getNoiseTextureDimensions(r),u_noiseDetail:function(){return l},u_noiseOffset:function(){return c}},persists:!1,owner:e,postExecute:function(h){r._ready=!0,r._loading=!1}});t.commandList.push(d),r._loading=!0}function createVertexArray(e,t){const n=e,i=t.context;n._createVertexArray=!1,n._vaf=n._vaf&&n._vaf.destroy();const r=e._clouds,o=r.length;if(o>0){n._vaf=createVAF(i,o,n._instanced);const a=n._vaf.writers;let s;for(s=0;s<o;++s){const l=r[s];writeCloud(e,t,a,l)}n._vaf.commit(getIndexBuffer(i))}}const scratchWriterArray=[];function updateClouds(e,t){const n=t.context,i=e,o=i._clouds.length,a=i._cloudsToUpdate,s=i._cloudsToUpdateIndex,l=i._propertiesChanged,c=scratchWriterArray;c.length=0,(l[POSITION_INDEX]||l[SCALE_INDEX])&&c.push(writePositionAndScale),(l[SHOW_INDEX]||l[BRIGHTNESS_INDEX])&&c.push(writePackedAttribute0),(l[MAXIMUM_SIZE_INDEX]||l[SLICE_INDEX])&&c.push(writePackedAttribute1),l[COLOR_INDEX]&&c.push(writeColor);const d=c.length,h=i._vaf.writers;let f,p,u;if(s/o>.1){for(f=0;f<s;++f)for(p=a[f],p._dirty=!1,u=0;u<d;++u)c[u](e,t,h,p);i._vaf.commit(getIndexBuffer(n))}else{for(f=0;f<s;++f){for(p=a[f],p._dirty=!1,u=0;u<d;++u)c[u](e,t,h,p);i._instanced?i._vaf.subCommit(p._index,1):i._vaf.subCommit(p._index*4,4)}i._vaf.endSubCommits()}i._cloudsToUpdateIndex=0}function createShaderProgram(e,t,n,i){const r=t.context,o=e,a=new ShaderSource({defines:[],sources:[n]});o._instanced&&a.defines.push("INSTANCED");const s=new ShaderSource({defines:[],sources:[i]});o.debugBillboards&&s.defines.push("DEBUG_BILLBOARDS"),o.debugEllipsoids&&s.defines.push("DEBUG_ELLIPSOIDS"),o._sp=ShaderProgram.replaceCache({context:r,shaderProgram:o._sp,vertexShaderSource:a,fragmentShaderSource:s,attributeLocations}),o._rs=RenderState.fromCache({depthTest:{enabled:!0,func:WebGLConstants.LESS},depthMask:!1,blending:BlendingState.ALPHA_BLEND}),o._spCreated=!0,o._compiledDebugBillboards=o.debugBillboards,o._compiledDebugEllipsoids=o.debugEllipsoids}function createDrawCommands(e,t){const n=e,i=t.passes,r=n._uniforms,o=t.commandList;if(i.render){const a=n._colorCommands,s=n._vaf.va,l=s.length;a.length=l;for(let c=0;c<l;c++){let d=a[c];defined(d)||(d=a[c]=new DrawCommand),d.pass=Pass.TRANSLUCENT,d.owner=e,d.uniformMap=r,d.count=s[c].indicesCount,d.vertexArray=s[c].va,d.shaderProgram=n._sp,d.renderState=n._rs,n._instanced&&(d.count=6,d.instanceCount=n._clouds.length),o.push(d)}}}CloudCollection.prototype.update=function(e){if(removeClouds(this),!this.show)return;const t=this.debugBillboards||this.debugEllipsoids;this._ready=t?!0:defined(this._noiseTexture),!this._ready&&!this._loading&&!t&&createNoiseTexture(this,e,CloudNoiseVS,CloudNoiseFS),this._instanced=e.context.instancedArrays,attributeLocations=this._instanced?attributeLocationsInstanced:attributeLocationsBatched,getIndexBuffer=this._instanced?getIndexBufferInstanced:getIndexBufferBatched;const i=this._clouds.length,r=this._cloudsToUpdate,o=this._cloudsToUpdateIndex;this._createVertexArray?createVertexArray(this,e):o>0&&updateClouds(this,e),o>i*1.5&&(r.length=i),!(!defined(this._vaf)||!defined(this._vaf.va)||!this._ready&!t)&&((!this._spCreated||this.debugBillboards!==this._compiledDebugBillboards||this.debugEllipsoids!==this._compiledDebugEllipsoids)&&createShaderProgram(this,e,CloudCollectionVS,CloudCollectionFS),createDrawCommands(this,e))};CloudCollection.prototype.isDestroyed=function(){return!1};CloudCollection.prototype.destroy=function(){return this._noiseTexture=this._noiseTexture&&this._noiseTexture.destroy(),this._sp=this._sp&&this._sp.destroy(),this._vaf=this._vaf&&this._vaf.destroy(),destroyClouds(this._clouds),destroyObject(this)};const defaultAngle=CesiumMath.toRadians(30);function ConeEmitter(e){this._angle=defaultValue(e,defaultAngle)}Object.defineProperties(ConeEmitter.prototype,{angle:{get:function(){return this._angle},set:function(e){Check.typeOf.number("value",e),this._angle=e}}});ConeEmitter.prototype.emit=function(e){const t=Math.tan(this._angle),n=CesiumMath.randomBetween(0,CesiumMath.TWO_PI),i=CesiumMath.randomBetween(0,t),r=i*Math.cos(n),o=i*Math.sin(n),a=1;e.velocity=Cartesian3.fromElements(r,o,a,e.velocity),Cartesian3.normalize(e.velocity,e.velocity),e.position=Cartesian3.clone(Cartesian3.ZERO,e.position)};function DebugAppearance(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.attributeName;let n=e.perInstanceAttribute;if(!defined(t))throw new DeveloperError("options.attributeName is required.");defined(n)||(n=!1);let i=defaultValue(e.glslDatatype,"vec3");const r=`v_${t}`;let o;if(t==="normal"||t==="tangent"||t==="bitangent")o=`vec4 getColor() { return vec4((${r} + vec3(1.0)) * 0.5, 1.0); }
`;else switch(t==="st"&&(i="vec2"),i){case"float":o=`vec4 getColor() { return vec4(vec3(${r}), 1.0); }
`;break;case"vec2":o=`vec4 getColor() { return vec4(${r}, 0.0, 1.0); }
`;break;case"vec3":o=`vec4 getColor() { return vec4(${r}, 1.0); }
`;break;case"vec4":o=`vec4 getColor() { return ${r}; }
`;break;default:throw new DeveloperError("options.glslDatatype must be float, vec2, vec3, or vec4.")}const a=`in vec3 position3DHigh;
in vec3 position3DLow;
in float batchId;
${n?"":`in ${i} ${t};
`}out ${i} ${r};
void main()
{
vec4 p = czm_translateRelativeToEye(position3DHigh, position3DLow);
${n?`${r} = czm_batchTable_${t}(batchId);
`:`${r} = ${t};
`}gl_Position = czm_modelViewProjectionRelativeToEye * p;
}`,s=`in ${i} ${r};
${o}
void main()
{
out_FragColor = getColor();
}`;this.material=void 0,this.translucent=defaultValue(e.translucent,!1),this._vertexShaderSource=defaultValue(e.vertexShaderSource,a),this._fragmentShaderSource=defaultValue(e.fragmentShaderSource,s),this._renderState=Appearance.getDefaultRenderState(!1,!1,e.renderState),this._closed=defaultValue(e.closed,!1),this._attributeName=t,this._glslDatatype=i}Object.defineProperties(DebugAppearance.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}},attributeName:{get:function(){return this._attributeName}},glslDatatype:{get:function(){return this._glslDatatype}}});DebugAppearance.prototype.getFragmentShaderSource=Appearance.prototype.getFragmentShaderSource;DebugAppearance.prototype.isTranslucent=Appearance.prototype.isTranslucent;DebugAppearance.prototype.getRenderState=Appearance.prototype.getRenderState;function DebugModelMatrixPrimitive(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this.length=defaultValue(e.length,1e7),this._length=void 0,this.width=defaultValue(e.width,2),this._width=void 0,this.show=defaultValue(e.show,!0),this.modelMatrix=Matrix4.clone(defaultValue(e.modelMatrix,Matrix4.IDENTITY)),this._modelMatrix=new Matrix4,this.id=e.id,this._id=void 0,this._primitive=void 0}DebugModelMatrixPrimitive.prototype.update=function(e){if(this.show){if(!defined(this._primitive)||!Matrix4.equals(this._modelMatrix,this.modelMatrix)||this._length!==this.length||this._width!==this.width||this._id!==this.id){this._modelMatrix=Matrix4.clone(this.modelMatrix,this._modelMatrix),this._length=this.length,this._width=this.width,this._id=this.id,defined(this._primitive)&&this._primitive.destroy(),this.modelMatrix[12]===0&&this.modelMatrix[13]===0&&this.modelMatrix[14]===0&&(this.modelMatrix[14]=.01);const t=new GeometryInstance({geometry:new PolylineGeometry({positions:[Cartesian3.ZERO,Cartesian3.UNIT_X],width:this.width,vertexFormat:PolylineColorAppearance.VERTEX_FORMAT,colors:[Color.RED,Color.RED],arcType:ArcType.NONE}),modelMatrix:Matrix4.multiplyByUniformScale(this.modelMatrix,this.length,new Matrix4),id:this.id,pickPrimitive:this}),n=new GeometryInstance({geometry:new PolylineGeometry({positions:[Cartesian3.ZERO,Cartesian3.UNIT_Y],width:this.width,vertexFormat:PolylineColorAppearance.VERTEX_FORMAT,colors:[Color.GREEN,Color.GREEN],arcType:ArcType.NONE}),modelMatrix:Matrix4.multiplyByUniformScale(this.modelMatrix,this.length,new Matrix4),id:this.id,pickPrimitive:this}),i=new GeometryInstance({geometry:new PolylineGeometry({positions:[Cartesian3.ZERO,Cartesian3.UNIT_Z],width:this.width,vertexFormat:PolylineColorAppearance.VERTEX_FORMAT,colors:[Color.BLUE,Color.BLUE],arcType:ArcType.NONE}),modelMatrix:Matrix4.multiplyByUniformScale(this.modelMatrix,this.length,new Matrix4),id:this.id,pickPrimitive:this});this._primitive=new Primitive({geometryInstances:[t,n,i],appearance:new PolylineColorAppearance,asynchronous:!1})}this._primitive.update(e)}};DebugModelMatrixPrimitive.prototype.isDestroyed=function(){return!1};DebugModelMatrixPrimitive.prototype.destroy=function(){return this._primitive=this._primitive&&this._primitive.destroy(),destroyObject(this)};function DirectionalLight(e){if(Check.typeOf.object("options",e),Check.typeOf.object("options.direction",e.direction),Cartesian3.equals(e.direction,Cartesian3.ZERO))throw new DeveloperError("options.direction cannot be zero-length");this.direction=Cartesian3.clone(e.direction),this.color=Color.clone(defaultValue(e.color,Color.WHITE)),this.intensity=defaultValue(e.intensity,1)}const EllipsoidSurfaceAppearanceFS=`in vec3 v_positionMC;
in vec3 v_positionEC;
in vec2 v_st;

void main()
{
    czm_materialInput materialInput;

    vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));
#ifdef FACE_FORWARD
    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);
#endif

    materialInput.s = v_st.s;
    materialInput.st = v_st;
    materialInput.str = vec3(v_st, 0.0);

    // Convert tangent space material normal to eye space
    materialInput.normalEC = normalEC;
    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);

    // Convert view vector to world space
    vec3 positionToEyeEC = -v_positionEC;
    materialInput.positionToEyeEC = positionToEyeEC;

    czm_material material = czm_getMaterial(materialInput);

#ifdef FLAT
    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);
#else
    out_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);
#endif
}
`,EllipsoidSurfaceAppearanceVS=`in vec3 position3DHigh;
in vec3 position3DLow;
in vec2 st;
in float batchId;

out vec3 v_positionMC;
out vec3 v_positionEC;
out vec2 v_st;

void main()
{
    vec4 p = czm_computePosition();

    v_positionMC = position3DHigh + position3DLow;           // position in model coordinates
    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates
    v_st = st;

    gl_Position = czm_modelViewProjectionRelativeToEye * p;
}
`;function EllipsoidSurfaceAppearance(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=defaultValue(e.translucent,!0),n=defaultValue(e.aboveGround,!1);this.material=defined(e.material)?e.material:Material.fromType(Material.ColorType),this.translucent=defaultValue(e.translucent,!0),this._vertexShaderSource=defaultValue(e.vertexShaderSource,EllipsoidSurfaceAppearanceVS),this._fragmentShaderSource=defaultValue(e.fragmentShaderSource,EllipsoidSurfaceAppearanceFS),this._renderState=Appearance.getDefaultRenderState(t,!n,e.renderState),this._closed=!1,this._flat=defaultValue(e.flat,!1),this._faceForward=defaultValue(e.faceForward,n),this._aboveGround=n}Object.defineProperties(EllipsoidSurfaceAppearance.prototype,{vertexShaderSource:{get:function(){return this._vertexShaderSource}},fragmentShaderSource:{get:function(){return this._fragmentShaderSource}},renderState:{get:function(){return this._renderState}},closed:{get:function(){return this._closed}},vertexFormat:{get:function(){return EllipsoidSurfaceAppearance.VERTEX_FORMAT}},flat:{get:function(){return this._flat}},faceForward:{get:function(){return this._faceForward}},aboveGround:{get:function(){return this._aboveGround}}});EllipsoidSurfaceAppearance.VERTEX_FORMAT=VertexFormat.POSITION_AND_ST;EllipsoidSurfaceAppearance.prototype.getFragmentShaderSource=Appearance.prototype.getFragmentShaderSource;EllipsoidSurfaceAppearance.prototype.isTranslucent=Appearance.prototype.isTranslucent;EllipsoidSurfaceAppearance.prototype.getRenderState=Appearance.prototype.getRenderState;function FrameRateMonitor(e){if(!defined(e)||!defined(e.scene))throw new DeveloperError("options.scene is required.");this._scene=e.scene,this.samplingWindow=defaultValue(e.samplingWindow,FrameRateMonitor.defaultSettings.samplingWindow),this.quietPeriod=defaultValue(e.quietPeriod,FrameRateMonitor.defaultSettings.quietPeriod),this.warmupPeriod=defaultValue(e.warmupPeriod,FrameRateMonitor.defaultSettings.warmupPeriod),this.minimumFrameRateDuringWarmup=defaultValue(e.minimumFrameRateDuringWarmup,FrameRateMonitor.defaultSettings.minimumFrameRateDuringWarmup),this.minimumFrameRateAfterWarmup=defaultValue(e.minimumFrameRateAfterWarmup,FrameRateMonitor.defaultSettings.minimumFrameRateAfterWarmup),this._lowFrameRate=new Event,this._nominalFrameRate=new Event,this._frameTimes=[],this._needsQuietPeriod=!0,this._quietPeriodEndTime=0,this._warmupPeriodEndTime=0,this._frameRateIsLow=!1,this._lastFramesPerSecond=void 0,this._pauseCount=0;const t=this;this._preUpdateRemoveListener=this._scene.preUpdate.addEventListener(function(r,o){update(t)}),this._hiddenPropertyName=document.hidden!==void 0?"hidden":document.mozHidden!==void 0?"mozHidden":document.msHidden!==void 0?"msHidden":document.webkitHidden!==void 0?"webkitHidden":void 0;const n=document.hidden!==void 0?"visibilitychange":document.mozHidden!==void 0?"mozvisibilitychange":document.msHidden!==void 0?"msvisibilitychange":document.webkitHidden!==void 0?"webkitvisibilitychange":void 0;function i(){visibilityChanged(t)}this._visibilityChangeRemoveListener=void 0,defined(n)&&(document.addEventListener(n,i,!1),this._visibilityChangeRemoveListener=function(){document.removeEventListener(n,i,!1)})}FrameRateMonitor.defaultSettings={samplingWindow:5,quietPeriod:2,warmupPeriod:5,minimumFrameRateDuringWarmup:4,minimumFrameRateAfterWarmup:8};FrameRateMonitor.fromScene=function(e){if(!defined(e))throw new DeveloperError("scene is required.");return(!defined(e._frameRateMonitor)||e._frameRateMonitor.isDestroyed())&&(e._frameRateMonitor=new FrameRateMonitor({scene:e})),e._frameRateMonitor};Object.defineProperties(FrameRateMonitor.prototype,{scene:{get:function(){return this._scene}},lowFrameRate:{get:function(){return this._lowFrameRate}},nominalFrameRate:{get:function(){return this._nominalFrameRate}},lastFramesPerSecond:{get:function(){return this._lastFramesPerSecond}}});FrameRateMonitor.prototype.pause=function(){++this._pauseCount,this._pauseCount===1&&(this._frameTimes.length=0,this._lastFramesPerSecond=void 0)};FrameRateMonitor.prototype.unpause=function(){--this._pauseCount,this._pauseCount<=0&&(this._pauseCount=0,this._needsQuietPeriod=!0)};FrameRateMonitor.prototype.isDestroyed=function(){return!1};FrameRateMonitor.prototype.destroy=function(){return this._preUpdateRemoveListener(),defined(this._visibilityChangeRemoveListener)&&this._visibilityChangeRemoveListener(),destroyObject(this)};function update(e,t){if(e._pauseCount>0)return;const n=getTimestamp();if(e._needsQuietPeriod)e._needsQuietPeriod=!1,e._frameTimes.length=0,e._quietPeriodEndTime=n+e.quietPeriod/TimeConstants.SECONDS_PER_MILLISECOND,e._warmupPeriodEndTime=e._quietPeriodEndTime+(e.warmupPeriod+e.samplingWindow)/TimeConstants.SECONDS_PER_MILLISECOND;else if(n>=e._quietPeriodEndTime){e._frameTimes.push(n);const i=n-e.samplingWindow/TimeConstants.SECONDS_PER_MILLISECOND;if(e._frameTimes.length>=2&&e._frameTimes[0]<=i){for(;e._frameTimes.length>=2&&e._frameTimes[1]<i;)e._frameTimes.shift();const r=(n-e._frameTimes[0])/(e._frameTimes.length-1);e._lastFramesPerSecond=1e3/r;const o=1e3/(n>e._warmupPeriodEndTime?e.minimumFrameRateAfterWarmup:e.minimumFrameRateDuringWarmup);r>o?e._frameRateIsLow||(e._frameRateIsLow=!0,e._needsQuietPeriod=!0,e.lowFrameRate.raiseEvent(e.scene,e._lastFramesPerSecond)):e._frameRateIsLow&&(e._frameRateIsLow=!1,e._needsQuietPeriod=!0,e.nominalFrameRate.raiseEvent(e.scene,e._lastFramesPerSecond))}}}function visibilityChanged(e){document[e._hiddenPropertyName]?e.pause():e.unpause()}function GoogleEarthEnterpriseDiscardPolicy(){this._image=new Image}GoogleEarthEnterpriseDiscardPolicy.prototype.isReady=function(){return!0};GoogleEarthEnterpriseDiscardPolicy.prototype.shouldDiscardImage=function(e){return e===this._image};function GoogleEarthEnterpriseImageryProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._defaultAlpha=void 0,this._defaultNightAlpha=void 0,this._defaultDayAlpha=void 0,this._defaultBrightness=void 0,this._defaultContrast=void 0,this._defaultHue=void 0,this._defaultSaturation=void 0,this._defaultGamma=void 0,this._defaultMinificationFilter=void 0,this._defaultMagnificationFilter=void 0,this._tileDiscardPolicy=e.tileDiscardPolicy,this._tilingScheme=new GeographicTilingScheme({numberOfLevelZeroTilesX:2,numberOfLevelZeroTilesY:2,rectangle:new Rectangle(-CesiumMath.PI,-CesiumMath.PI,CesiumMath.PI,CesiumMath.PI),ellipsoid:e.ellipsoid});let t=e.credit;typeof t=="string"&&(t=new Credit(t)),this._credit=t,this._tileWidth=256,this._tileHeight=256,this._maximumLevel=23,defined(this._tileDiscardPolicy)||(this._tileDiscardPolicy=new GoogleEarthEnterpriseDiscardPolicy),this._errorEvent=new Event}Object.defineProperties(GoogleEarthEnterpriseImageryProvider.prototype,{url:{get:function(){return this._metadata.url}},proxy:{get:function(){return this._metadata.proxy}},tileWidth:{get:function(){return this._tileWidth}},tileHeight:{get:function(){return this._tileHeight}},maximumLevel:{get:function(){return this._maximumLevel}},minimumLevel:{get:function(){return 0}},tilingScheme:{get:function(){return this._tilingScheme}},rectangle:{get:function(){return this._tilingScheme.rectangle}},tileDiscardPolicy:{get:function(){return this._tileDiscardPolicy}},errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){return this._credit}},hasAlphaChannel:{get:function(){return!1}}});GoogleEarthEnterpriseImageryProvider.fromMetadata=function(e,t){if(Check.defined("metadata",e),!e.imageryPresent)throw new RuntimeError(`The server ${e.url} doesn't have imagery`);const n=new GoogleEarthEnterpriseImageryProvider(t);return n._metadata=e,n};GoogleEarthEnterpriseImageryProvider.prototype.getTileCredits=function(e,t,n){const i=this._metadata,r=i.getTileInformation(e,t,n);if(defined(r)){const o=i.providers[r.imageryProvider];if(defined(o))return[o]}};GoogleEarthEnterpriseImageryProvider.prototype.requestImage=function(e,t,n,i){const r=this._tileDiscardPolicy._image,o=this._metadata,a=GoogleEarthEnterpriseMetadata.tileXYToQuadKey(e,t,n),s=o.getTileInformation(e,t,n);if(!defined(s)){if(o.isValid(a)){const c=new Request({throttle:i.throttle,throttleByServer:i.throttleByServer,type:i.type,priorityFunction:i.priorityFunction});o.populateSubtree(e,t,n,c);return}return Promise.resolve(r)}if(!s.hasImagery())return Promise.resolve(r);const l=buildImageResource(this,s,e,t,n,i).fetchArrayBuffer();if(defined(l))return l.then(function(c){decodeGoogleEarthEnterpriseData(o.key,c);let d=new Uint8Array(c),h;const f=o.protoImagery;if((!defined(f)||!f)&&(h=getImageType(d)),!defined(h)&&(!defined(f)||f)){const p=decodeEarthImageryPacket(d);h=p.imageType,d=p.imageData}return!defined(h)||!defined(d)?r:loadImageFromTypedArray({uint8Array:d,format:h,flipY:!0})})};GoogleEarthEnterpriseImageryProvider.prototype.pickFeatures=function(e,t,n,i,r){};function buildImageResource(e,t,n,i,r,o){const a=GoogleEarthEnterpriseMetadata.tileXYToQuadKey(n,i,r);let s=t.imageryVersion;return s=defined(s)&&s>0?s:1,e._metadata.resource.getDerivedResource({url:`flatfile?f1-0${a}-i.${s.toString()}`,request:o})}function getImageType(e){const t="JFIF";if(e[6]===t.charCodeAt(0)&&e[7]===t.charCodeAt(1)&&e[8]===t.charCodeAt(2)&&e[9]===t.charCodeAt(3))return"image/jpeg";const n="PNG";if(e[1]===n.charCodeAt(0)&&e[2]===n.charCodeAt(1)&&e[3]===n.charCodeAt(2))return"image/png"}function decodeEarthImageryPacket(e){const t=protobufExports.Reader.create(e),n=t.len,i={};for(;t.pos<n;){const a=t.uint32();let s;switch(a>>>3){case 1:i.imageType=t.uint32();break;case 2:i.imageData=t.bytes();break;case 3:i.alphaType=t.uint32();break;case 4:i.imageAlpha=t.bytes();break;case 5:if(s=i.copyrightIds,defined(s)||(s=i.copyrightIds=[]),(a&7)===2){const l=t.uint32()+t.pos;for(;t.pos<l;)s.push(t.uint32())}else s.push(t.uint32());break;default:t.skipType(a&7);break}}const r=i.imageType;if(defined(r))switch(r){case 0:i.imageType="image/jpeg";break;case 4:i.imageType="image/png";break;default:throw new RuntimeError("GoogleEarthEnterpriseImageryProvider: Unsupported image type.")}const o=i.alphaType;return defined(o)&&o!==0&&(console.log("GoogleEarthEnterpriseImageryProvider: External alpha not supported."),delete i.alphaType,delete i.imageAlpha),i}const defaultColor=new Color(1,1,1,.4),defaultGlowColor=new Color(0,1,0,.05),defaultBackgroundColor=new Color(0,.5,0,.2);function GridImageryProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._defaultAlpha=void 0,this._defaultNightAlpha=void 0,this._defaultDayAlpha=void 0,this._defaultBrightness=void 0,this._defaultContrast=void 0,this._defaultHue=void 0,this._defaultSaturation=void 0,this._defaultGamma=void 0,this._defaultMinificationFilter=void 0,this._defaultMagnificationFilter=void 0,this._tilingScheme=defined(e.tilingScheme)?e.tilingScheme:new GeographicTilingScheme({ellipsoid:e.ellipsoid}),this._cells=defaultValue(e.cells,8),this._color=defaultValue(e.color,defaultColor),this._glowColor=defaultValue(e.glowColor,defaultGlowColor),this._glowWidth=defaultValue(e.glowWidth,6),this._backgroundColor=defaultValue(e.backgroundColor,defaultBackgroundColor),this._errorEvent=new Event,this._tileWidth=defaultValue(e.tileWidth,256),this._tileHeight=defaultValue(e.tileHeight,256),this._canvasSize=defaultValue(e.canvasSize,256),this._canvas=this._createGridCanvas()}Object.defineProperties(GridImageryProvider.prototype,{proxy:{get:function(){}},tileWidth:{get:function(){return this._tileWidth}},tileHeight:{get:function(){return this._tileHeight}},maximumLevel:{get:function(){}},minimumLevel:{get:function(){}},tilingScheme:{get:function(){return this._tilingScheme}},rectangle:{get:function(){return this._tilingScheme.rectangle}},tileDiscardPolicy:{get:function(){}},errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){}},hasAlphaChannel:{get:function(){return!0}}});GridImageryProvider.prototype._drawGrid=function(e){const n=this._canvasSize;for(let i=0;i<=this._cells;++i){const o=1+i/this._cells*(n-1);e.moveTo(o,0),e.lineTo(o,n),e.moveTo(0,o),e.lineTo(n,o)}e.stroke()};GridImageryProvider.prototype._createGridCanvas=function(){const e=document.createElement("canvas");e.width=this._canvasSize,e.height=this._canvasSize;const t=0,n=this._canvasSize,i=e.getContext("2d"),r=this._backgroundColor.toCssColorString();i.fillStyle=r,i.fillRect(t,t,n,n);const o=this._glowColor.toCssColorString();i.strokeStyle=o,i.lineWidth=this._glowWidth,i.strokeRect(t,t,n,n),this._drawGrid(i),i.lineWidth=this._glowWidth*.5,i.strokeRect(t,t,n,n),this._drawGrid(i);const a=this._color.toCssColorString();return i.strokeStyle=a,i.lineWidth=2,i.strokeRect(t,t,n,n),i.lineWidth=1,this._drawGrid(i),e};GridImageryProvider.prototype.getTileCredits=function(e,t,n){};GridImageryProvider.prototype.requestImage=function(e,t,n,i){return Promise.resolve(this._canvas)};GridImageryProvider.prototype.pickFeatures=function(e,t,n,i,r){};function I3SDecoder(){}I3SDecoder._maxDecodingConcurrency=Math.max(FeatureDetection.hardwareConcurrency-1,1);I3SDecoder._decodeTaskProcessor=new TaskProcessor("decodeI3S",I3SDecoder._maxDecodingConcurrency);I3SDecoder._promise=void 0;async function initializeDecoder(){if(await I3SDecoder._decodeTaskProcessor.initWebAssemblyModule({wasmBinaryFile:"ThirdParty/draco_decoder.wasm"}))return I3SDecoder._decodeTaskProcessor;throw new RuntimeError("I3S decoder could not be initialized.")}I3SDecoder.decode=async function(e,t,n,i,r){return Check.typeOf.string("url",e),Check.defined("defaultGeometrySchema",t),Check.defined("geometryData",n),defined(I3SDecoder._promise)||(I3SDecoder._promise=initializeDecoder()),I3SDecoder._promise.then(function(o){const a=n._parent._data,s=n._parent._inverseRotationMatrix;let l=0,c=0,d=0;defined(a.obb)?(l=a.obb.center[0],c=a.obb.center[1],d=a.obb.center[2]):defined(a.mbs)&&(l=a.mbs[0],c=a.mbs[1],d=a.mbs[2]);const h=Matrix3.fromRotationX(-CesiumMath.PI_OVER_TWO),f=new Matrix3;Matrix3.multiply(h,s,f);const p=Cartographic.fromDegrees(l,c,d),u=Ellipsoid.WGS84.cartographicToCartesian(p),m={binaryData:n._data,featureData:defined(i)&&defined(i[0])?i[0].data:void 0,schema:t,bufferInfo:n._geometryBufferInfo,ellipsoidRadiiSquare:Ellipsoid.WGS84.radiiSquared,url:e,geoidDataList:n._dataProvider._geoidDataList,cartographicCenter:p,cartesianCenter:u,parentRotation:f,enableFeatures:n._dataProvider.showFeatures,splitGeometryByColorTransparency:n._dataProvider.adjustMaterialAlphaMode,symbologyData:r,calculateNormals:n._dataProvider.calculateNormals};return o.scheduleTask(m)})};function I3SFeature(e,t){this._parent=e,this._dataProvider=e._dataProvider,this._layer=e._layer,defined(this._parent._nodeIndex)?this._resource=this._parent._layer.resource.getDerivedResource({url:`nodes/${this._parent._data.mesh.attribute.resource}/${t}`}):this._resource=this._parent.resource.getDerivedResource({url:t})}Object.defineProperties(I3SFeature.prototype,{resource:{get:function(){return this._resource}},data:{get:function(){return this._data}}});I3SFeature.prototype.load=async function(){return this._data=await I3SDataProvider.loadJson(this._resource),this._data};function I3SField(e,t){this._storageInfo=t,this._parent=e,this._dataProvider=e._dataProvider,this._loadPromise=void 0;const n=`attributes/${t.key}/0`;defined(this._parent._nodeIndex)?this._resource=this._parent._layer.resource.getDerivedResource({url:`nodes/${this._parent._data.mesh.attribute.resource}/${n}`}):this._resource=this._parent.resource.getDerivedResource({url:n})}Object.defineProperties(I3SField.prototype,{resource:{get:function(){return this._resource}},header:{get:function(){return this._header}},values:{get:function(){if(defined(this._values)){if(defined(this._values.attributeValues))return this._values.attributeValues;if(defined(this._values.objectIds))return this._values.objectIds}return[]}},name:{get:function(){return this._storageInfo.name}}});function getNumericTypeSize(e){return e==="UInt8"||e==="Int8"?1:e==="UInt16"||e==="Int16"?2:e==="UInt32"||e==="Int32"||e==="Oid32"||e==="Float32"?4:e==="UInt64"||e==="Int64"||e==="Float64"?8:0}function getValueTypeSize(e){return e==="String"?1:getNumericTypeSize(e)}async function load(e){const t=await e._dataProvider._loadBinary(e._resource),n=new DataView(t);e._data=t,e._validateHeader(n);const i=e._parseHeader(n),r=e._getBodyOffset(i);e._validateBody(n,r),e._parseBody(n,r)}I3SField.prototype.load=function(){return defined(this._loadPromise)?this._loadPromise:(this._loadPromise=load(this).catch(function(e){console.error(e)}),this._loadPromise)};I3SField.prototype._parseValue=function(e,t,n){let i;if(t==="UInt8")i=e.getUint8(n),n+=1;else if(t==="Int8")i=e.getInt8(n),n+=1;else if(t==="UInt16")i=e.getUint16(n,!0),n+=2;else if(t==="Int16")i=e.getInt16(n,!0),n+=2;else if(t==="UInt32")i=e.getUint32(n,!0),n+=4;else if(t==="Oid32")i=e.getUint32(n,!0),n+=4;else if(t==="Int32")i=e.getInt32(n,!0),n+=4;else if(t==="UInt64"){const r=e.getUint32(n,!0),o=e.getUint32(n+4,!0);i=r+Math.pow(2,32)*o,n+=8}else if(t==="Int64"){const r=e.getUint32(n,!0),o=e.getUint32(n+4,!0);o<Math.pow(2,31)?i=r+Math.pow(2,32)*o:i=r+Math.pow(2,32)*(o-Math.pow(2,32)),n+=8}else t==="Float32"?(i=e.getFloat32(n,!0),n+=4):t==="Float64"?(i=e.getFloat64(n,!0),n+=8):t==="String"&&(i=String.fromCharCode(e.getUint8(n)),n+=1);return{value:i,offset:n}};I3SField.prototype._parseHeader=function(e){let t=0;this._header={};for(let n=0;n<this._storageInfo.header.length;n++){const i=this._storageInfo.header[n],r=this._parseValue(e,i.valueType,t);this._header[i.property]=r.value,t=r.offset}return t};I3SField.prototype._parseBody=function(e,t){this._values={};for(let n=0;n<this._storageInfo.ordering.length;n++){const i=this._storageInfo.ordering[n],r=i==="ObjectIds"?"objectIds":i,o=this._storageInfo[r];if(defined(o)){this._values[r]=[];for(let a=0;a<this._header.count;++a)if(o.valueType!=="String"){const s=this._parseValue(e,o.valueType,t);this._values[r].push(s.value),t=s.offset}else{const s=this._values.attributeByteCounts[a];let l="";for(let c=0;c<s;++c){const d=this._parseValue(e,o.valueType,t);d.value.charCodeAt(0)!==0&&(l+=d.value),t=d.offset}this._values[r].push(l)}}}};I3SField.prototype._getBodyOffset=function(e){let t=0;return defined(this._storageInfo.attributeValues)?t=getNumericTypeSize(this._storageInfo.attributeValues.valueType):defined(this._storageInfo.objectIds)&&(t=getNumericTypeSize(this._storageInfo.objectIds.valueType)),t>0?Math.ceil(e/t)*t:e};I3SField.prototype._validateHeader=function(e){let t=0;for(let n=0;n<this._storageInfo.header.length;n++){const i=this._storageInfo.header[n];t+=getValueTypeSize(i.valueType)}if(e.byteLength<t)throw new RuntimeError(`Invalid attribute buffer size (field: ${this.name}, header: ${t}, actual: ${e.byteLength})`)};I3SField.prototype._validateBody=function(e,t){if(!defined(this._header.count))throw new RuntimeError(`Invalid attribute buffer (field: ${this.name}, count is missing)`);let n;for(let i=0;i<this._storageInfo.ordering.length&&t<e.byteLength;i++){const r=this._storageInfo.ordering[i],o=r==="ObjectIds"?"objectIds":r,a=this._storageInfo[o];if(defined(a))if(a.valueType!=="String"){o==="attributeByteCounts"&&(n=t);const s=getNumericTypeSize(a.valueType);t+=s*this._header.count}else{if(!defined(n))throw new RuntimeError(`Invalid attribute buffer (field: ${this.name}, attributeByteCounts is missing)`);for(let s=0;s<this._header.count&&t<e.byteLength;++s){const l=this._parseValue(e,this._storageInfo.attributeByteCounts.valueType,n);t+=l.value,n=l.offset}}else throw new RuntimeError(`Invalid attribute buffer (field: ${this.name}, ${o} is missing)`)}if(e.byteLength<t)throw new RuntimeError(`Invalid attribute buffer size (field: ${this.name}, expected: ${t}, actual: ${e.byteLength})`)};function I3SGeometry(e,t){const n=e._dataProvider,i=e._layer;let r;defined(e._nodeIndex)?r=i.resource.getDerivedResource({url:`nodes/${e._data.mesh.geometry.resource}/${t}`}):r=e.resource.getDerivedResource({url:t}),this._parent=e,this._dataProvider=n,this._layer=i,this._resource=r,this._customAttributes=void 0}Object.defineProperties(I3SGeometry.prototype,{resource:{get:function(){return this._resource}},data:{get:function(){return this._data}},customAttributes:{get:function(){return this._customAttributes}}});I3SGeometry.prototype.load=function(){const e=this;return this._dataProvider._loadBinary(this._resource).then(function(t){return e._data=t,t})};const scratchAb=new Cartesian3,scratchAp1=new Cartesian3,scratchAp2=new Cartesian3,scratchCp1=new Cartesian3,scratchCp2=new Cartesian3;function sameSide(e,t,n,i){const r=Cartesian3.subtract(i,n,scratchAb),o=Cartesian3.cross(r,Cartesian3.subtract(e,n,scratchAp1),scratchCp1),a=Cartesian3.cross(r,Cartesian3.subtract(t,n,scratchAp2),scratchCp2);return Cartesian3.dot(o,a)>=0}const scratchV0=new Cartesian3,scratchV1=new Cartesian3,scratchV0V1=new Cartesian3,scratchV0V2=new Cartesian3,scratchCrossProd=new Cartesian3,scratchNormal=new Cartesian3,scratchV0p=new Cartesian3,scratchV1p=new Cartesian3,scratchV2p=new Cartesian3;I3SGeometry.prototype.getClosestPointIndexOnTriangle=function(e,t,n){if(defined(this._customAttributes)&&defined(this._customAttributes.positions)){const i=new Cartesian3(e,t,n);i.x-=this._customAttributes.cartesianCenter.x,i.y-=this._customAttributes.cartesianCenter.y,i.z-=this._customAttributes.cartesianCenter.z,Matrix3.multiplyByVector(this._customAttributes.parentRotation,i,i);let r=Number.MAX_VALUE,o,a,s,l;const c=this._customAttributes.positions,d=this._customAttributes.indices;let h;defined(d)?h=d.length:h=c.length/3;for(let f=0;f<h;f++){let p,u,m;defined(d)?(p=d[f],u=d[f+1],m=d[f+2]):(p=f*3,u=f*3+1,m=f*3+2);const g=Cartesian3.fromElements(c[p*3],c[p*3+1],c[p*3+2],scratchV0),_=Cartesian3.fromElements(c[u*3],c[u*3+1],c[u*3+2],scratchV1),C=new Cartesian3(c[m*3],c[m*3+1],c[m*3+2]);if(!sameSide(i,g,_,C)||!sameSide(i,_,g,C)||!sameSide(i,C,g,_))continue;const A=Cartesian3.subtract(_,g,scratchV0V1),S=Cartesian3.subtract(C,g,scratchV0V2),v=Cartesian3.cross(A,S,scratchCrossProd);if(Cartesian3.magnitude(v)===0)continue;const b=Cartesian3.normalize(v,scratchNormal),D=Cartesian3.subtract(i,g,scratchV0p),I=Math.abs(Cartesian3.dot(D,b));if(I<r){r=I,o=f;const L=Cartesian3.magnitudeSquared(Cartesian3.subtract(i,g,D)),N=Cartesian3.magnitudeSquared(Cartesian3.subtract(i,_,scratchV1p)),y=Cartesian3.magnitudeSquared(Cartesian3.subtract(i,C,scratchV2p));L<N&&L<y?(s=p,l=g,a=L):N<y?(s=u,l=_,a=N):(s=m,l=C,a=y)}}if(defined(o))return{index:s,distanceSquared:a,distance:Math.sqrt(a),queriedPosition:i,closestPosition:Cartesian3.clone(l)}}return{index:-1,distanceSquared:Number.Infinity,distance:Number.Infinity}};function convertColorFactor(e){const t=[],n=e.length;for(let i=0;i<n;i++)i<3?t.push(srgbToLinear(e[i])):t.push(e[i]);return t}I3SGeometry.prototype._generateGltf=function(e,t,n,i,r,o,a,s){let l={pbrMetallicRoughness:{metallicFactor:0},doubleSided:!0,name:"Material"},c=!1,d,h="";if(defined(this._parent._data.mesh)&&defined(this._layer._data.materialDefinitions)){const A=this._parent._data.mesh.material.definition;if(A>=0&&A<this._layer._data.materialDefinitions.length){if(d=this._layer._data.materialDefinitions[A],l=d,defined(l.pbrMetallicRoughness)&&defined(l.pbrMetallicRoughness.baseColorTexture)){c=!0,l.pbrMetallicRoughness.baseColorTexture.index=0;let S="0";if(defined(this._layer._data.textureSetDefinitions))for(let v=0;v<this._layer._data.textureSetDefinitions.length;v++){const b=this._layer._data.textureSetDefinitions[v];for(let D=0;D<b.formats.length;D++){const I=b.formats[D];if(I.format==="jpg"){S=I.name;break}}}defined(this._parent._data.mesh)&&this._parent._data.mesh.material.resource>=0&&(h=this._layer.resource.getDerivedResource({url:`nodes/${this._parent._data.mesh.material.resource}/textures/${S}`}).url)}defined(l.pbrMetallicRoughness)&&defined(l.pbrMetallicRoughness.baseColorFactor)&&(l.pbrMetallicRoughness.baseColorFactor=convertColorFactor(l.pbrMetallicRoughness.baseColorFactor)),defined(l.emissiveFactor)&&(l.emissiveFactor=convertColorFactor(l.emissiveFactor))}}else defined(this._parent._data.textureData)&&(c=!0,h=this._parent.resource.getDerivedResource({url:`${this._parent._data.textureData[0].href}`}).url,l.pbrMetallicRoughness.baseColorTexture={index:0});defined(l.alphaMode)&&(l.alphaMode=l.alphaMode.toUpperCase());let f=[],p=[],u=[];c&&(f=[{sampler:0,source:0}],p=[{uri:h}],u=[{magFilter:9729,minFilter:9986,wrapS:10497,wrapT:10497}]);const m=[],g=n.length;for(let C=0;C<g;C++){const A=n[C].primitives,S=A.length;for(let v=0;v<S;v++){const b=A[v];if(defined(b.material)){for(;b.material>=m.length;){const I=clone(l,!0);m.push(I)}const D=m[b.material];defined(b.extra)&&b.extra.isTransparent?defined(D.alphaMode)||(D.alphaMode="BLEND"):D.alphaMode==="BLEND"&&(D.alphaMode="OPAQUE")}}}return{scene:0,scenes:[{nodes:e}],nodes:t,meshes:n,buffers:i,bufferViews:r,accessors:o,materials:m,textures:f,images:p,samplers:u,asset:{version:"2.0"},extensions:a,extensionsUsed:s}};function I3SNode(e,t,n){let i,r,o,a;n?(i=0,r=e):(i=e._level+1,r=e._layer),typeof t=="number"?o=t:a=e.resource.getDerivedResource({url:`${t}/`}),this._parent=e,this._dataProvider=e._dataProvider,this._isRoot=n,this._level=i,this._layer=r,this._nodeIndex=o,this._resource=a,this._isLoading=!1,this._tile=void 0,this._data=void 0,this._geometryData=[],this._featureData=[],this._fields={},this._children=[],this._childrenReadyPromise=void 0,this._globalTransform=void 0,this._inverseGlobalTransform=void 0,this._inverseRotationMatrix=void 0,this._symbologyData=void 0}Object.defineProperties(I3SNode.prototype,{resource:{get:function(){return this._resource}},layer:{get:function(){return this._layer}},parent:{get:function(){return this._parent}},children:{get:function(){return this._children}},geometryData:{get:function(){return this._geometryData}},featureData:{get:function(){return this._featureData}},fields:{get:function(){return this._fields}},tile:{get:function(){return this._tile}},data:{get:function(){return this._data}}});I3SNode.prototype.load=async function(){const e=this;function t(){if(!e._isRoot){const r=e._create3DTileDefinition();e._tile=new Cesium3DTile(e._layer._tileset,e._dataProvider.resource,r,e._parent._tile),e._tile._i3sNode=e}}if(!defined(this._nodeIndex)){const r=await I3SDataProvider.loadJson(this._resource);e._data=r,t();return}const n=await this._layer._getNodeInNodePages(this._nodeIndex);e._data=n;let i;e._isRoot?i="nodes/root/":defined(n.mesh)&&(i=`../${n.mesh.geometry.resource}/`),defined(i)&&(e._resource=e._parent.resource.getDerivedResource({url:i})),t()};function createAndLoadField(e,t){const n=new I3SField(e,t);return e._fields[t.name]=n,n.load()}I3SNode.prototype.loadFields=function(){const e=this._layer._data.attributeStorageInfo,t=[];if(defined(e))for(let n=0;n<e.length;n++){const i=e[n],r=this._fields[i.name];defined(r)?t.push(r.load()):t.push(createAndLoadField(this,i))}return Promise.all(t)};I3SNode.prototype.loadField=function(e){Check.defined("name",e);const t=this._fields[e];if(defined(t))return t.load();const n=this._layer._data.attributeStorageInfo;if(defined(n))for(let i=0;i<n.length;i++){const r=n[i];if(r.name===e)return createAndLoadField(this,r)}return Promise.resolve()};I3SNode.prototype.getFieldsForPickedPosition=function(e){const t=this.geometryData[0];if(!defined(t.customAttributes.featureIndex))return{};const n=t.getClosestPointIndexOnTriangle(e.x,e.y,e.z);if(n.index===-1||n.index>t.customAttributes.featureIndex.length)return{};const i=t.customAttributes.featureIndex[n.index];return this.getFieldsForFeature(i)};I3SNode.prototype.getFieldsForFeature=function(e){const t={};for(const n in this.fields)if(this.fields.hasOwnProperty(n)){const i=this.fields[n];e>=0&&e<i.values.length&&(t[i.name]=i.values[e])}return t};I3SNode.prototype._loadChildren=function(){const e=this;if(defined(this._childrenReadyPromise))return this._childrenReadyPromise;const t=[];if(defined(e._data.children))for(let n=0;n<e._data.children.length;n++){const i=e._data.children[n],r=new I3SNode(e,defaultValue(i.href,i),!1);e._children.push(r),t.push(r.load())}return this._childrenReadyPromise=Promise.all(t).then(function(){for(let n=0;n<e._children.length;n++)e._tile.children.push(e._children[n]._tile)}),this._childrenReadyPromise};I3SNode.prototype._loadGeometryData=function(){const e=[];if(defined(this._data.geometryData))for(let t=0;t<this._data.geometryData.length;t++){const n=new I3SGeometry(this,this._data.geometryData[t].href);this._geometryData.push(n),e.push(n.load())}else if(defined(this._data.mesh)){const t=this._layer._findBestGeometryBuffers(this._data.mesh.geometry.definition,["position","uv0"]),n=`./geometries/${t.bufferIndex}/`,i=new I3SGeometry(this,n);i._geometryDefinitions=t.definition,i._geometryBufferInfo=t.geometryBufferInfo,this._geometryData.push(i),e.push(i.load())}return Promise.all(e)};I3SNode.prototype._loadFeatureData=function(){const e=[];if(defined(this._data.featureData))for(let t=0;t<this._data.featureData.length;t++){const n=new I3SFeature(this,this._data.featureData[t].href);this._featureData.push(n),e.push(n.load())}return Promise.all(e)};I3SNode.prototype._clearGeometryData=function(){this._geometryData=[]};I3SNode.prototype._create3DTileDefinition=function(){const e=this._data.obb,t=this._data.mbs;if(!defined(e)&&!defined(t)){console.error("Failed to load I3S node. Bounding volume is required.");return}let n;if(defined(e)?n=Cartographic.fromDegrees(e.center[0],e.center[1],e.center[2]):n=Cartographic.fromDegrees(t[0],t[1],t[2]),defined(this._dataProvider._geoidDataList)&&defined(n))for(let _=0;_<this._dataProvider._geoidDataList.length;_++){const C=this._dataProvider._geoidDataList[_],A=C.projection.project(n);if(A.x>C.nativeExtent.west&&A.x<C.nativeExtent.east&&A.y>C.nativeExtent.south&&A.y<C.nativeExtent.north){n.height+=sampleGeoid(A.x,A.y,C);break}}let i={},r,o=0;defined(e)?(i={box:[0,0,0,e.halfSize[0],0,0,0,e.halfSize[1],0,0,0,e.halfSize[2]]},o=Math.max(Math.max(this._data.obb.halfSize[0],this._data.obb.halfSize[1]),this._data.obb.halfSize[2]),r=Ellipsoid.WGS84.cartographicToCartesian(n)):(i={sphere:[0,0,0,t[3]]},r=Ellipsoid.WGS84.cartographicToCartesian(n),o=this._data.mbs[3]),o*=2;let a=1/0;if(defined(this._data.lodThreshold))if(this._layer._data.nodePages.lodSelectionMetricType==="maxScreenThresholdSQ"){const _=Math.sqrt(this._data.lodThreshold/(Math.PI*.25));a=o/_}else if(this._layer._data.nodePages.lodSelectionMetricType==="maxScreenThreshold"){const _=this._data.lodThreshold;a=o/_}else console.error("Invalid lodSelectionMetricType in Layer");else if(defined(this._data.lodSelection))for(let _=0;_<this._data.lodSelection.length;_++)this._data.lodSelection[_].metricType==="maxScreenThreshold"&&(a=o/this._data.lodSelection[_].maxError);a===1/0&&(a=1e5);const s=a*16,l=new HeadingPitchRoll(0,0,0);let c=Transforms.headingPitchRollQuaternion(r,l);defined(this._data.obb)&&(c=new Quaternion(this._data.obb.quaternion[0],this._data.obb.quaternion[1],this._data.obb.quaternion[2],this._data.obb.quaternion[3]));const d=Matrix3.fromQuaternion(c),h=Matrix3.inverse(d,new Matrix3),f=new Matrix4(d[0],d[1],d[2],0,d[3],d[4],d[5],0,d[6],d[7],d[8],0,r.x,r.y,r.z,1),p=Matrix4.inverse(f,new Matrix4),u=Matrix4.clone(f);defined(this._parent._globalTransform)&&Matrix4.multiply(f,this._parent._inverseGlobalTransform,u),this._globalTransform=f,this._inverseGlobalTransform=p,this._inverseRotationMatrix=h;const m=[];for(let _=0;_<this._children.length;_++)m.push(this._children[_]._create3DTileDefinition());return{children:m,refine:"REPLACE",boundingVolume:i,transform:[u[0],u[4],u[8],u[12],u[1],u[5],u[9],u[13],u[2],u[6],u[10],u[14],u[3],u[7],u[11],u[15]],content:{uri:defined(this._resource)?this._resource.url:void 0},geometricError:s}};I3SNode.prototype._loadSymbology=async function(){!defined(this._symbologyData)&&defined(this._layer._symbology)&&(this._symbologyData=await this._layer._symbology._getSymbology(this))};I3SNode.prototype._createContentURL=async function(){let e={scene:0,scenes:[{nodes:[0]}],nodes:[{name:"singleNode"}],meshes:[],buffers:[],bufferViews:[],accessors:[],materials:[],textures:[],images:[],samplers:[],asset:{version:"2.0"}};const t=[this._loadGeometryData()];if(this._dataProvider.legacyVersion16&&t.push(this._loadFeatureData()),await Promise.all(t),defined(this._geometryData)&&this._geometryData.length>0){this._dataProvider._applySymbology&&await this._loadSymbology();const r=this._geometryData[0].resource.url,o=this._layer._data.store.defaultGeometrySchema,a=this._geometryData[0],s=await I3SDecoder.decode(r,o,a,this._featureData[0],this._symbologyData);if(!defined(s))return;e=a._generateGltf(s.meshData.nodesInScene,s.meshData.nodes,s.meshData.meshes,s.meshData.buffers,s.meshData.bufferViews,s.meshData.accessors,s.meshData.rootExtensions,s.meshData.extensionsUsed),this._geometryData[0]._customAttributes=s.meshData._customAttributes}const n=this._dataProvider._binarizeGltf(e),i=new Blob([n],{type:"application/binary"});return URL.createObjectURL(i)};async function loadFilters(e){const t=e._layer._filters,n=[];for(let i=0;i<t.length;i++){const r=e.loadField(t[i].name);n.push(r)}return await Promise.all(n),t}function checkFeatureValue(e,t,n){if(!defined(n.values)||n.values.length===0)return!1;const i=defined(t)?t.values:[];let r;e<i.length&&(r=i[e]);let o=!1;for(let a=0;a<n.values.length;a++)if(n.values[a]===r){o=!0;break}return o}async function filterFeatures(e,t){const n=e._tile.content.batchTable;if(defined(n)&&n.featuresLength>0){n.setAllShow(!0);const i=await loadFilters(e);if(i.length>0)for(let r=0;r<n.featuresLength;r++)for(let o=0;o<i.length;o++){const a=i[o];if(!checkFeatureValue(r,e._fields[a.name],a)){n.setShow(r,!1);break}}}t.show=!0}I3SNode.prototype._filterFeatures=function(){var n,i;const e=[];for(let r=0;r<this._children.length;r++){const o=this._children[r]._filterFeatures();e.push(o)}const t=(i=(n=this._tile)==null?void 0:n.content)==null?void 0:i._model;if(defined(this._geometryData)&&this._geometryData.length>0&&defined(t)&&t.ready){t.show=!1;const r=filterFeatures(this,t);e.push(r)}return Promise.all(e)};Cesium3DTile.prototype._hookedRequestContent=Cesium3DTile.prototype.requestContent;Cesium3DTile.prototype.requestContent=function(){if(!this.tileset._isI3STileSet)return this._hookedRequestContent();if(!this._isLoading){this._isLoading=!0;const e=this;return this._i3sNode._createContentURL().then(t=>{if(!defined(t)){e._isLoading=!1;return}return e._contentResource=new Resource({url:t}),e._hookedRequestContent()}).then(t=>{const n=t==null?void 0:t._model;return defined(e._i3sNode._geometryData)&&e._i3sNode._geometryData.length>0&&defined(n)&&(n.show=!1,n.readyEvent.addEventListener(()=>{filterFeatures(e._i3sNode,n)})),e._isLoading=!1,t})}};function bilinearInterpolate(e,t,n,i,r,o){const a=n*(1-e)+i*e,s=r*(1-e)+o*e;return a*(1-t)+s*t}function sampleMap(e,t,n,i){const r=e+t*n;return i[r]}function sampleGeoid(e,t,n){const i=n.nativeExtent;let r=(e-i.west)/(i.east-i.west)*(n.width-1),o=(t-i.south)/(i.north-i.south)*(n.height-1);const a=Math.floor(r);let s=Math.floor(o);r-=a,o-=s;const l=a<n.width?a+1:a;let c=s<n.height?s+1:s;s=n.height-1-s,c=n.height-1-c;const d=sampleMap(a,s,n.width,n.buffer),h=sampleMap(l,s,n.width,n.buffer),f=sampleMap(a,c,n.width,n.buffer),p=sampleMap(l,c,n.width,n.buffer);let u=bilinearInterpolate(r,o,d,h,f,p);return u=u*n.scale+n.offset,u}Object.defineProperties(Cesium3DTile.prototype,{i3sNode:{get:function(){return this._i3sNode}}});function I3SSymbology(e){this._layer=e,this._defaultSymbology=void 0,this._valueFields=[],this._uniqueValueHash=void 0,this._classBreaksHash=void 0,this._parseLayerSymbology()}Object.defineProperties(I3SSymbology.prototype,{defaultSymbology:{get:function(){return this._defaultSymbology}}});function convertColor(e,t){const n=[];for(let i=0;i<e.length;i++){const r=Color.byteToFloat(e[i]);i<3?n.push(srgbToLinear(r)):n.push(r)}return n.length===3&&(defined(t)?n.push(1-t/100):n.push(1)),n}function parseSymbol(e,t){const n={edges:void 0,material:void 0};if(defined(e)&&defined(e.symbolLayers))for(let i=0;i<e.symbolLayers.length;i++){const r=e.symbolLayers[i];if(r.type==="Fill"){const o=r.edges,a=r.outline;if(defined(o)?(n.edges={},defined(o.color)&&(n.edges.color=convertColor(o.color,o.transparency))):defined(a)&&(n.edges={},defined(a.color)&&(n.edges.color=convertColor(a.color,a.transparency))),!t){const s=r.material;defined(s)&&(n.material={colorMixMode:s.colorMixMode},defined(s.color)&&(n.material.color=convertColor(s.color,s.transparency)))}break}}return n}function buildUniqueValueHash(e,t){if(defined(e.uniqueValueGroups)){const n={};for(let i=0;i<e.uniqueValueGroups.length;i++){const r=e.uniqueValueGroups[i].classes;if(defined(r))for(let o=0;o<r.length;o++){const a=parseSymbol(r[o].symbol,t),s=r[o].values;for(let l=0;l<s.length;l++){const c=s[l];let d=n;for(let h=0;h<c.length;h++){const f=c[h];h===c.length-1?d[f]=a:(defined(d[f])||(d[f]={}),d=d[f])}}}}return n}if(defined(e.uniqueValueInfos)){const n={};for(let i=0;i<e.uniqueValueInfos.length;i++){const r=e.uniqueValueInfos[i];n[r.value]=parseSymbol(r.symbol,t)}return n}}function buildClassBreaksHash(e,t){if(defined(e.classBreakInfos)){const n=[...e.classBreakInfos];n.sort(function(r,o){const a=defaultValue(r.classMaxValue,r.classMinValue),s=defaultValue(o.classMaxValue,o.classMinValue);return a-s});const i={ranges:[],symbols:[]};defined(e.minValue)&&(i.ranges.push(e.minValue),i.symbols.push(void 0));for(let r=0;r<n.length;r++){const o=n[r];defined(o.classMinValue)&&(i.ranges.length===0||o.classMinValue>i.ranges[i.ranges.length-1])&&(i.ranges.push(o.classMinValue),i.symbols.push(void 0)),defined(o.classMaxValue)&&(i.ranges.length===0||o.classMaxValue>i.ranges[i.ranges.length-1])&&(i.ranges.push(o.classMaxValue),i.symbols.push(parseSymbol(o.symbol,t)))}return i.symbols.push(void 0),i}}I3SSymbology.prototype._parseLayerSymbology=function(){const e=this._layer.data.drawingInfo;if(defined(e)&&defined(e.renderer)){const t=this._layer.data.cachedDrawingInfo,n=defined(t)&&t.color===!0,i=e.renderer;i.type==="simple"?this._defaultSymbology=parseSymbol(i.symbol,n):i.type==="uniqueValue"?(this._defaultSymbology=parseSymbol(i.defaultSymbol,n),this._valueFields.push(i.field1),defined(i.field2)&&this._valueFields.push(i.field2),defined(i.field3)&&this._valueFields.push(i.field3),this._uniqueValueHash=buildUniqueValueHash(i,n)):i.type==="classBreaks"&&(this._defaultSymbology=parseSymbol(i.defaultSymbol,n),this._valueFields.push(i.field),this._classBreaksHash=buildClassBreaksHash(i,n))}};function findHashForUniqueValues(e,t,n,i){const r=t[n];if(i<r.length){const o=r[i],a=e[o];return defined(a)&&++n<t.length?findHashForUniqueValues(a,t,n,i):a}}function bisect(e,t){let n=0,i=e.length;if(n<i)do{const r=n+i>>>1;e[r]<t?n=r+1:i=r}while(n<i);return n}function findHashForClassBreaks(e,t,n){const i=t[n],r=bisect(e.ranges,i);return e.symbols[r]}I3SSymbology.prototype._getSymbology=async function(e){const t={default:this._defaultSymbology};if(this._valueFields.length>0){const n=[];for(let o=0;o<this._valueFields.length;o++)n.push(e.loadField(this._valueFields[o]));await Promise.all(n);const i=[];for(let o=0;o<this._valueFields.length;o++)i.push(e.fields[this._valueFields[o]].values);let r;if(defined(this._uniqueValueHash)?r=o=>findHashForUniqueValues(this._uniqueValueHash,i,0,o):defined(this._classBreaksHash)&&(r=o=>findHashForClassBreaks(this._classBreaksHash,i[0],o)),defined(r)){const o=i[0];for(let a=0;a<o.length;a++){const s=r(a);defined(s)&&(t[a]=s)}}}return t};function I3SLayer(e,t,n){this._dataProvider=e,this._parent=n,!defined(t.href)&&defined(t.id)&&(t.href=`layers/${t.id}`);const i=this._parent.resource.getUrlComponent();let r="";i.match(/layers\/\d/)?r=`${i}`.replace(/\/+$/,""):r=`${i}`.replace(/\/?$/,"/").concat(`${t.href}`),this._version=t.store.version;const o=this._version.split(".");this._majorVersion=parseInt(o[0]),this._minorVersion=o.length>1?parseInt(o[1]):0,this._resource=new Resource({url:r}),this._resource.setQueryParameters(this._dataProvider.resource.queryParameters),this._resource.appendForwardSlash(),this._data=t,this._rootNode=void 0,this._nodePages={},this._nodePageFetches={},this._extent=void 0,this._tileset=void 0,this._geometryDefinitions=void 0,this._filters=[],this._symbology=void 0,this._computeGeometryDefinitions(!0),this._computeExtent()}Object.defineProperties(I3SLayer.prototype,{resource:{get:function(){return this._resource}},rootNode:{get:function(){return this._rootNode}},tileset:{get:function(){return this._tileset}},data:{get:function(){return this._data}},version:{get:function(){return this._version}},majorVersion:{get:function(){return this._majorVersion}},minorVersion:{get:function(){return this._minorVersion}},legacyVersion16:{get:function(){if(defined(this.version))return this.majorVersion<1||this.majorVersion===1&&this.minorVersion<=6}}});I3SLayer.prototype.load=async function(e){if(this._data.spatialReference.wkid!==4326)throw new RuntimeError(`Unsupported spatial reference: ${this._data.spatialReference.wkid}`);if(this._dataProvider.applySymbology&&(this._symbology=new I3SSymbology(this)),await this._dataProvider.loadGeoidData(),await this._loadRootNode(e),await this._create3DTileset(e),this._rootNode._tile=this._tileset._root,this._tileset._root._i3sNode=this._rootNode,this.legacyVersion16)return this._rootNode._loadChildren()};I3SLayer.prototype._computeGeometryDefinitions=function(e){if(this._geometryDefinitions=[],defined(this._data.geometryDefinitions))for(let t=0;t<this._data.geometryDefinitions.length;t++){const n=[],i=this._data.geometryDefinitions[t].geometryBuffers;for(let r=0;r<i.length;r++){const o=i[r],a=[];let s=!1;if(defined(o.compressedAttributes)&&e){s=!0;const l=o.compressedAttributes.attributes;for(let c=0;c<l.length;c++)a.push(l[c])}else for(const l in o)l!=="offset"&&a.push(l);n.push({compressed:s,attributes:a,index:i.indexOf(o)})}n.sort(function(r,o){return r.compressed&&!o.compressed?-1:!r.compressed&&o.compressed?1:r.attributes.length-o.attributes.length}),this._geometryDefinitions.push(n)}};I3SLayer.prototype._findBestGeometryBuffers=function(e,t){const n=this._geometryDefinitions[e];if(defined(n))for(let i=0;i<n.length;++i){const r=n[i];let o=!1;const a=r.attributes;for(let s=0;s<t.length;s++)if(!a.includes(t[s])){o=!0;break}if(!o)return{bufferIndex:r.index,definition:n,geometryBufferInfo:r}}return 0};I3SLayer.prototype._loadRootNode=function(e){if(defined(this._data.nodePages)){let t=0;defined(this._data.nodePages.rootIndex)&&(t=this._data.nodePages.rootIndex),this._rootNode=new I3SNode(this,t,!0)}else this._rootNode=new I3SNode(this,this._data.store.rootNode,!0);return this._rootNode.load(e)};I3SLayer.prototype._getNodeInNodePages=function(e){const t=Math.floor(e/this._data.nodePages.nodesPerPage),n=e%this._data.nodePages.nodesPerPage;return this._loadNodePage(t).then(function(i){return i.nodes[n]})};I3SLayer._fetchJson=function(e){return e.fetchJson()};I3SLayer.prototype._loadNodePage=function(e){const t=this;if(!defined(this._nodePageFetches[e])){const n=this.resource.getDerivedResource({url:`nodepages/${e}/`}),i=I3SLayer._fetchJson(n).then(function(r){return defined(r.error)&&r.error.code!==200?Promise.reject(r.error):(t._nodePages[e]=r.nodes,r)});this._nodePageFetches[e]=i}return this._nodePageFetches[e]};I3SLayer.prototype._computeExtent=function(){defined(this._data.fullExtent)?this._extent=Rectangle.fromDegrees(this._data.fullExtent.xmin,this._data.fullExtent.ymin,this._data.fullExtent.xmax,this._data.fullExtent.ymax):defined(this._data.store.extent)&&(this._extent=Rectangle.fromDegrees(this._data.store.extent[0],this._data.store.extent[1],this._data.store.extent[2],this._data.store.extent[3]))};I3SLayer.prototype._create3DTileset=async function(e){var o,a,s;const t={asset:{version:"1.0"},geometricError:Number.MAX_VALUE,root:this._rootNode._create3DTileDefinition()},n=new Blob([JSON.stringify(t)],{type:"application/json"}),i=URL.createObjectURL(n),r=(s=(a=(o=this._symbology)==null?void 0:o.defaultSymbology)==null?void 0:a.edges)==null?void 0:s.color;defined(r)&&!defined(e==null?void 0:e.outlineColor)&&(e=defined(e)?clone(e):{},e.outlineColor=Color.fromCartesian4(Cartesian4.fromArray(r))),this._tileset=await Cesium3DTileset.fromUrl(i,e),this._tileset.show=this._parent.show,this._tileset._isI3STileSet=!0,this._tileset.tileUnload.addEventListener(function(l){l._i3sNode._clearGeometryData(),URL.revokeObjectURL(l._contentResource._url),l._contentResource=l._i3sNode.resource}),this._tileset.tileVisible.addEventListener(function(l){defined(l._i3sNode)&&l._i3sNode._loadChildren()})};I3SLayer.prototype._updateVisibility=function(){defined(this._tileset)&&(this._tileset.show=this._parent.show)};I3SLayer.prototype.filterByAttributes=function(e){this._filters=defined(e)?clone(e,!0):[];const t=this._rootNode;return defined(t)?t._filterFeatures():Promise.resolve()};function I3SStatistics(e,t){this._dataProvider=e,this._resource=new Resource({url:t}),this._resource.setQueryParameters(e.resource.queryParameters),this._resource.appendForwardSlash()}Object.defineProperties(I3SStatistics.prototype,{resource:{get:function(){return this._resource}},data:{get:function(){return this._data}},names:{get:function(){const e=[],t=this._data.summary;if(defined(t))for(let n=0;n<t.length;++n)e.push(t[n].fieldName);return e}}});I3SStatistics.prototype.load=async function(){return this._data=await I3SDataProvider.loadJson(this._resource),this._data};I3SStatistics.prototype._getValues=function(e){const t=this._data.summary;if(defined(t))for(let n=0;n<t.length;++n){const i=t[n];if(i.fieldName===e)return defined(i.mostFrequentValues)?[...i.mostFrequentValues]:[]}};function I3SSublayer(e,t,n){this._dataProvider=e,this._parent=t,this._data=n,this._name=n.name,this._modelName=n.modelName,this._visibility=defaultValue(n.visibility,!0),this._resource=void 0,this._sublayers=[],this._i3sLayers=[]}Object.defineProperties(I3SSublayer.prototype,{resource:{get:function(){return this._resource}},data:{get:function(){return this._data}},name:{get:function(){return this._name}},modelName:{get:function(){return this._modelName}},sublayers:{get:function(){return this._sublayers}},visibility:{get:function(){return this._visibility},set:function(e){if(Check.defined("value",e),this._visibility!==e){this._visibility=e;for(let t=0;t<this._i3sLayers.length;t++)this._i3sLayers[t]._updateVisibility()}}},show:{get:function(){return this._visibility&&this._parent.show}}});I3SSublayer._fromData=async function(e,t,n,i){const r=new I3SSublayer(e,i,n);if(r._data.layerType==="group"){const o=r._data.sublayers;if(defined(o)){const a=[];for(let l=0;l<o.length;l++){const c=I3SSublayer._fromData(e,t,o[l],r);a.push(c)}const s=await Promise.all(a);for(let l=0;l<s.length;l++){const c=s[l];r._sublayers.push(c),r._i3sLayers.push(...c._i3sLayers)}}}else if(r._data.layerType==="3DObject"){const o=t.concat(`/sublayers/${r._data.id}`),a=new Resource({url:o});a.setQueryParameters(e.resource.queryParameters),a.appendForwardSlash(),r._resource=a;const s=await I3SDataProvider.loadJson(r._resource),l=new I3SLayer(e,s,r);r._i3sLayers.push(l)}else console.log(`${r._data.layerType} layer ${r._data.name} is skipped as not supported.`);return r};var LercDecode={exports:{}};(function(e){/* Copyright 2015-2018 Esri. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */(function(){var t=function(){var o={};o.defaultNoDataValue=-34027999387901484e22,o.decode=function(h,f){f=f||{};var p=f.encodedMaskData||f.encodedMaskData===null,u=c(h,f.inputOffset||0,p),m=f.noDataValue!==null?f.noDataValue:o.defaultNoDataValue,g=a(u,f.pixelType||Float32Array,f.encodedMaskData,m,f.returnMask),_={width:u.width,height:u.height,pixelData:g.resultPixels,minValue:g.minValue,maxValue:u.pixels.maxValue,noDataValue:m};return g.resultMask&&(_.maskData=g.resultMask),f.returnEncodedMask&&u.mask&&(_.encodedMaskData=u.mask.bitset?u.mask.bitset:null),f.returnFileInfo&&(_.fileInfo=s(u),f.computeUsedBitDepths&&(_.fileInfo.bitDepths=l(u))),_};var a=function(h,f,p,u,m){var g=0,_=h.pixels.numBlocksX,C=h.pixels.numBlocksY,A=Math.floor(h.width/_),S=Math.floor(h.height/C),v=2*h.maxZError,b=Number.MAX_VALUE,D;p=p||(h.mask?h.mask.bitset:null);var I,L;I=new f(h.width*h.height),m&&p&&(L=new Uint8Array(h.width*h.height));for(var N=new Float32Array(A*S),y,x,T=0;T<=C;T++){var E=T!==C?S:h.height%C;if(E!==0)for(var P=0;P<=_;P++){var M=P!==_?A:h.width%_;if(M!==0){var O=T*h.width*S+P*A,V=h.width-M,R=h.pixels.blocks[g],w,U,k;R.encoding<2?(R.encoding===0?w=R.rawData:(d(R.stuffedData,R.bitsPerPixel,R.numValidPixels,R.offset,v,N,h.pixels.maxValue),w=N),U=0):R.encoding===2?k=0:k=R.offset;var H;if(p)for(x=0;x<E;x++){for(O&7&&(H=p[O>>3],H<<=O&7),y=0;y<M;y++)O&7||(H=p[O>>3]),H&128?(L&&(L[O]=1),D=R.encoding<2?w[U++]:k,b=b>D?D:b,I[O++]=D):(L&&(L[O]=0),I[O++]=u),H<<=1;O+=V}else if(R.encoding<2)for(x=0;x<E;x++){for(y=0;y<M;y++)D=w[U++],b=b>D?D:b,I[O++]=D;O+=V}else for(b=b>k?k:b,x=0;x<E;x++){for(y=0;y<M;y++)I[O++]=k;O+=V}if(R.encoding===1&&U!==R.numValidPixels)throw"Block and Mask do not match";g++}}}return{resultPixels:I,resultMask:L,minValue:b}},s=function(h){return{fileIdentifierString:h.fileIdentifierString,fileVersion:h.fileVersion,imageType:h.imageType,height:h.height,width:h.width,maxZError:h.maxZError,eofOffset:h.eofOffset,mask:h.mask?{numBlocksX:h.mask.numBlocksX,numBlocksY:h.mask.numBlocksY,numBytes:h.mask.numBytes,maxValue:h.mask.maxValue}:null,pixels:{numBlocksX:h.pixels.numBlocksX,numBlocksY:h.pixels.numBlocksY,numBytes:h.pixels.numBytes,maxValue:h.pixels.maxValue,noDataValue:h.noDataValue}}},l=function(h){for(var f=h.pixels.numBlocksX*h.pixels.numBlocksY,p={},u=0;u<f;u++){var m=h.pixels.blocks[u];m.encoding===0?p.float32=!0:m.encoding===1?p[m.bitsPerPixel]=!0:p[0]=!0}return Object.keys(p)},c=function(h,f,p){var u={},m=new Uint8Array(h,f,10);if(u.fileIdentifierString=String.fromCharCode.apply(null,m),u.fileIdentifierString.trim()!=="CntZImage")throw"Unexpected file identifier string: "+u.fileIdentifierString;f+=10;var g=new DataView(h,f,24);if(u.fileVersion=g.getInt32(0,!0),u.imageType=g.getInt32(4,!0),u.height=g.getUint32(8,!0),u.width=g.getUint32(12,!0),u.maxZError=g.getFloat64(16,!0),f+=24,!p)if(g=new DataView(h,f,16),u.mask={},u.mask.numBlocksY=g.getUint32(0,!0),u.mask.numBlocksX=g.getUint32(4,!0),u.mask.numBytes=g.getUint32(8,!0),u.mask.maxValue=g.getFloat32(12,!0),f+=16,u.mask.numBytes>0){var _=new Uint8Array(Math.ceil(u.width*u.height/8));g=new DataView(h,f,u.mask.numBytes);var C=g.getInt16(0,!0),A=2,S=0;do{if(C>0)for(;C--;)_[S++]=g.getUint8(A++);else{var v=g.getUint8(A++);for(C=-C;C--;)_[S++]=v}C=g.getInt16(A,!0),A+=2}while(A<u.mask.numBytes);if(C!==-32768||S<_.length)throw"Unexpected end of mask RLE encoding";u.mask.bitset=_,f+=u.mask.numBytes}else u.mask.numBytes|u.mask.numBlocksY|u.mask.maxValue||(u.mask.bitset=new Uint8Array(Math.ceil(u.width*u.height/8)));g=new DataView(h,f,16),u.pixels={},u.pixels.numBlocksY=g.getUint32(0,!0),u.pixels.numBlocksX=g.getUint32(4,!0),u.pixels.numBytes=g.getUint32(8,!0),u.pixels.maxValue=g.getFloat32(12,!0),f+=16;var b=u.pixels.numBlocksX,D=u.pixels.numBlocksY,I=b+(u.width%b>0?1:0),L=D+(u.height%D>0?1:0);u.pixels.blocks=new Array(I*L);for(var N=0,y=0;y<L;y++)for(var x=0;x<I;x++){var T=0,E=h.byteLength-f;g=new DataView(h,f,Math.min(10,E));var P={};u.pixels.blocks[N++]=P;var M=g.getUint8(0);if(T++,P.encoding=M&63,P.encoding>3)throw"Invalid block encoding ("+P.encoding+")";if(P.encoding===2){f++;continue}if(M!==0&&M!==2){if(M>>=6,P.offsetType=M,M===2)P.offset=g.getInt8(1),T++;else if(M===1)P.offset=g.getInt16(1,!0),T+=2;else if(M===0)P.offset=g.getFloat32(1,!0),T+=4;else throw"Invalid block offset type";if(P.encoding===1)if(M=g.getUint8(T),T++,P.bitsPerPixel=M&63,M>>=6,P.numValidPixelsType=M,M===2)P.numValidPixels=g.getUint8(T),T++;else if(M===1)P.numValidPixels=g.getUint16(T,!0),T+=2;else if(M===0)P.numValidPixels=g.getUint32(T,!0),T+=4;else throw"Invalid valid pixel count type"}if(f+=T,P.encoding!==3){var O,V;if(P.encoding===0){var R=(u.pixels.numBytes-1)/4;if(R!==Math.floor(R))throw"uncompressed block has invalid length";O=new ArrayBuffer(R*4),V=new Uint8Array(O),V.set(new Uint8Array(h,f,R*4));var w=new Float32Array(O);P.rawData=w,f+=R*4}else if(P.encoding===1){var U=Math.ceil(P.numValidPixels*P.bitsPerPixel/8),k=Math.ceil(U/4);O=new ArrayBuffer(k*4),V=new Uint8Array(O),V.set(new Uint8Array(h,f,U)),P.stuffedData=new Uint32Array(O),f+=U}}}return u.eofOffset=f,u},d=function(h,f,p,u,m,g,_){var C=(1<<f)-1,A=0,S,v=0,b,D,I=Math.ceil((_-u)/m),L=h.length*4-Math.ceil(f*p/8);for(h[h.length-1]<<=8*L,S=0;S<p;S++){if(v===0&&(D=h[A++],v=32),v>=f)b=D>>>v-f&C,v-=f;else{var N=f-v;b=(D&C)<<N&C,D=h[A++],v=32-N,b+=D>>>v}g[S]=b<I?u+b*m:_}return g};return o}(),n=function(){var o={unstuff:function(c,d,h,f,p,u,m,g){var _=(1<<h)-1,C=0,A,S=0,v,b,D,I,L=c.length*4-Math.ceil(h*f/8);if(c[c.length-1]<<=8*L,p)for(A=0;A<f;A++)S===0&&(b=c[C++],S=32),S>=h?(v=b>>>S-h&_,S-=h):(D=h-S,v=(b&_)<<D&_,b=c[C++],S=32-D,v+=b>>>S),d[A]=p[v];else for(I=Math.ceil((g-u)/m),A=0;A<f;A++)S===0&&(b=c[C++],S=32),S>=h?(v=b>>>S-h&_,S-=h):(D=h-S,v=(b&_)<<D&_,b=c[C++],S=32-D,v+=b>>>S),d[A]=v<I?u+v*m:g},unstuffLUT:function(c,d,h,f,p,u){var m=(1<<d)-1,g=0,_=0,C=0,A=0,S=0,v,b=[],D=c.length*4-Math.ceil(d*h/8);c[c.length-1]<<=8*D;var I=Math.ceil((u-f)/p);for(_=0;_<h;_++)A===0&&(v=c[g++],A=32),A>=d?(S=v>>>A-d&m,A-=d):(C=d-A,S=(v&m)<<C&m,v=c[g++],A=32-C,S+=v>>>A),b[_]=S<I?f+S*p:u;return b.unshift(f),b},unstuff2:function(c,d,h,f,p,u,m,g){var _=(1<<h)-1,C=0,A,S=0,v=0,b,D,I;if(p)for(A=0;A<f;A++)S===0&&(D=c[C++],S=32,v=0),S>=h?(b=D>>>v&_,S-=h,v+=h):(I=h-S,b=D>>>v&_,D=c[C++],S=32-I,b|=(D&(1<<I)-1)<<h-I,v=I),d[A]=p[b];else{var L=Math.ceil((g-u)/m);for(A=0;A<f;A++)S===0&&(D=c[C++],S=32,v=0),S>=h?(b=D>>>v&_,S-=h,v+=h):(I=h-S,b=D>>>v&_,D=c[C++],S=32-I,b|=(D&(1<<I)-1)<<h-I,v=I),d[A]=b<L?u+b*m:g}return d},unstuffLUT2:function(c,d,h,f,p,u){var m=(1<<d)-1,g=0,_=0,C=0,A=0,S=0,v=0,b,D=[],I=Math.ceil((u-f)/p);for(_=0;_<h;_++)A===0&&(b=c[g++],A=32,v=0),A>=d?(S=b>>>v&m,A-=d,v+=d):(C=d-A,S=b>>>v&m,b=c[g++],A=32-C,S|=(b&(1<<C)-1)<<d-C,v=C),D[_]=S<I?f+S*p:u;return D.unshift(f),D},originalUnstuff:function(c,d,h,f){var p=(1<<h)-1,u=0,m,g=0,_,C,A,S=c.length*4-Math.ceil(h*f/8);for(c[c.length-1]<<=8*S,m=0;m<f;m++)g===0&&(C=c[u++],g=32),g>=h?(_=C>>>g-h&p,g-=h):(A=h-g,_=(C&p)<<A&p,C=c[u++],g=32-A,_+=C>>>g),d[m]=_;return d},originalUnstuff2:function(c,d,h,f){var p=(1<<h)-1,u=0,m,g=0,_=0,C,A,S;for(m=0;m<f;m++)g===0&&(A=c[u++],g=32,_=0),g>=h?(C=A>>>_&p,g-=h,_+=h):(S=h-g,C=A>>>_&p,A=c[u++],g=32-S,C|=(A&(1<<S)-1)<<h-S,_=S),d[m]=C;return d}},a={HUFFMAN_LUT_BITS_MAX:12,computeChecksumFletcher32:function(c){for(var d=65535,h=65535,f=c.length,p=Math.floor(f/2),u=0;p;){var m=p>=359?359:p;p-=m;do d+=c[u++]<<8,h+=d+=c[u++];while(--m);d=(d&65535)+(d>>>16),h=(h&65535)+(h>>>16)}return f&1&&(h+=d+=c[u]<<8),d=(d&65535)+(d>>>16),h=(h&65535)+(h>>>16),(h<<16|d)>>>0},readHeaderInfo:function(c,d){var h=d.ptr,f=new Uint8Array(c,h,6),p={};if(p.fileIdentifierString=String.fromCharCode.apply(null,f),p.fileIdentifierString.lastIndexOf("Lerc2",0)!==0)throw"Unexpected file identifier string (expect Lerc2 ): "+p.fileIdentifierString;h+=6;var u=new DataView(c,h,8),m=u.getInt32(0,!0);p.fileVersion=m,h+=4,m>=3&&(p.checksum=u.getUint32(4,!0),h+=4),u=new DataView(c,h,12),p.height=u.getUint32(0,!0),p.width=u.getUint32(4,!0),h+=8,m>=4?(p.numDims=u.getUint32(8,!0),h+=4):p.numDims=1,u=new DataView(c,h,40),p.numValidPixel=u.getUint32(0,!0),p.microBlockSize=u.getInt32(4,!0),p.blobSize=u.getInt32(8,!0),p.imageType=u.getInt32(12,!0),p.maxZError=u.getFloat64(16,!0),p.zMin=u.getFloat64(24,!0),p.zMax=u.getFloat64(32,!0),h+=40,d.headerInfo=p,d.ptr=h;var g,_;if(m>=3&&(_=m>=4?52:48,g=this.computeChecksumFletcher32(new Uint8Array(c,h-_,p.blobSize-14)),g!==p.checksum))throw"Checksum failed.";return!0},checkMinMaxRanges:function(c,d){var h=d.headerInfo,f=this.getDataTypeArray(h.imageType),p=h.numDims*this.getDataTypeSize(h.imageType),u=this.readSubArray(c,d.ptr,f,p),m=this.readSubArray(c,d.ptr+p,f,p);d.ptr+=2*p;var g,_=!0;for(g=0;g<h.numDims;g++)if(u[g]!==m[g]){_=!1;break}return h.minValues=u,h.maxValues=m,_},readSubArray:function(c,d,h,f){var p;if(h===Uint8Array)p=new Uint8Array(c,d,f);else{var u=new ArrayBuffer(f),m=new Uint8Array(u);m.set(new Uint8Array(c,d,f)),p=new h(u)}return p},readMask:function(c,d){var h=d.ptr,f=d.headerInfo,p=f.width*f.height,u=f.numValidPixel,m=new DataView(c,h,4),g={};if(g.numBytes=m.getUint32(0,!0),h+=4,(u===0||p===u)&&g.numBytes!==0)throw"invalid mask";var _,C;if(u===0)_=new Uint8Array(Math.ceil(p/8)),g.bitset=_,C=new Uint8Array(p),d.pixels.resultMask=C,h+=g.numBytes;else if(g.numBytes>0){_=new Uint8Array(Math.ceil(p/8)),m=new DataView(c,h,g.numBytes);var A=m.getInt16(0,!0),S=2,v=0,b=0;do{if(A>0)for(;A--;)_[v++]=m.getUint8(S++);else for(b=m.getUint8(S++),A=-A;A--;)_[v++]=b;A=m.getInt16(S,!0),S+=2}while(S<g.numBytes);if(A!==-32768||v<_.length)throw"Unexpected end of mask RLE encoding";C=new Uint8Array(p);var D=0,I=0;for(I=0;I<p;I++)I&7?(D=_[I>>3],D<<=I&7):D=_[I>>3],D&128&&(C[I]=1);d.pixels.resultMask=C,g.bitset=_,h+=g.numBytes}return d.ptr=h,d.mask=g,!0},readDataOneSweep:function(c,d,h){var f=d.ptr,p=d.headerInfo,u=p.numDims,m=p.width*p.height,g=p.imageType,_=p.numValidPixel*a.getDataTypeSize(g)*u,C,A=d.pixels.resultMask;if(h===Uint8Array)C=new Uint8Array(c,f,_);else{var S=new ArrayBuffer(_),v=new Uint8Array(S);v.set(new Uint8Array(c,f,_)),C=new h(S)}if(C.length===m*u)d.pixels.resultPixels=C;else{d.pixels.resultPixels=new h(m*u);var b=0,D=0,I=0,L=0;if(u>1)for(I=0;I<u;I++)for(L=I*m,D=0;D<m;D++)A[D]&&(d.pixels.resultPixels[L+D]=C[b++]);else for(D=0;D<m;D++)A[D]&&(d.pixels.resultPixels[D]=C[b++])}return f+=_,d.ptr=f,!0},readHuffmanTree:function(c,d){var h=this.HUFFMAN_LUT_BITS_MAX,f=new DataView(c,d.ptr,16);d.ptr+=16;var p=f.getInt32(0,!0);if(p<2)throw"unsupported Huffman version";var u=f.getInt32(4,!0),m=f.getInt32(8,!0),g=f.getInt32(12,!0);if(m>=g)return!1;var _=new Uint32Array(g-m);a.decodeBits(c,d,_);var C=[],A,S,v,b;for(A=m;A<g;A++)S=A-(A<u?0:u),C[S]={first:_[A-m],second:null};var D=c.byteLength-d.ptr,I=Math.ceil(D/4),L=new ArrayBuffer(I*4),N=new Uint8Array(L);N.set(new Uint8Array(c,d.ptr,D));var y=new Uint32Array(L),x=0,T,E=0;for(T=y[0],A=m;A<g;A++)S=A-(A<u?0:u),b=C[S].first,b>0&&(C[S].second=T<<x>>>32-b,32-x>=b?(x+=b,x===32&&(x=0,E++,T=y[E])):(x+=b-32,E++,T=y[E],C[S].second|=T>>>32-x));var P=0,M=0,O=new s;for(A=0;A<C.length;A++)C[A]!==void 0&&(P=Math.max(P,C[A].first));P>=h?M=h:M=P,P>=30&&console.log("WARning, large NUM LUT BITS IS "+P);var V=[],R,w,U,k,H,F;for(A=m;A<g;A++)if(S=A-(A<u?0:u),b=C[S].first,b>0)if(R=[b,S],b<=M)for(w=C[S].second<<M-b,U=1<<M-b,v=0;v<U;v++)V[w|v]=R;else for(w=C[S].second,F=O,k=b-1;k>=0;k--)H=w>>>k&1,H?(F.right||(F.right=new s),F=F.right):(F.left||(F.left=new s),F=F.left),k===0&&!F.val&&(F.val=R[1]);return{decodeLut:V,numBitsLUTQick:M,numBitsLUT:P,tree:O,stuffedData:y,srcPtr:E,bitPos:x}},readHuffman:function(c,d,h){var f=d.headerInfo,p=f.numDims,u=d.headerInfo.height,m=d.headerInfo.width,g=m*u,_=this.readHuffmanTree(c,d),C=_.decodeLut,A=_.tree,S=_.stuffedData,v=_.srcPtr,b=_.bitPos,D=_.numBitsLUTQick,I=_.numBitsLUT,L=d.headerInfo.imageType===0?128:0,N,y,x,T=d.pixels.resultMask,E,P,M,O,V,R,w,U=0;b>0&&(v++,b=0);var k=S[v],H=d.encodeMode===1,F=new h(g*p),G=F,B;for(B=0;B<f.numDims;B++){if(p>1&&(G=new h(F.buffer,g*B,g),U=0),d.headerInfo.numValidPixel===m*u)for(R=0,O=0;O<u;O++)for(V=0;V<m;V++,R++){if(y=0,E=k<<b>>>32-D,P=E,32-b<D&&(E|=S[v+1]>>>64-b-D,P=E),C[P])y=C[P][1],b+=C[P][0];else for(E=k<<b>>>32-I,P=E,32-b<I&&(E|=S[v+1]>>>64-b-I,P=E),N=A,w=0;w<I;w++)if(M=E>>>I-w-1&1,N=M?N.right:N.left,!(N.left||N.right)){y=N.val,b=b+w+1;break}b>=32&&(b-=32,v++,k=S[v]),x=y-L,H?(V>0?x+=U:O>0?x+=G[R-m]:x+=U,x&=255,G[R]=x,U=x):G[R]=x}else for(R=0,O=0;O<u;O++)for(V=0;V<m;V++,R++)if(T[R]){if(y=0,E=k<<b>>>32-D,P=E,32-b<D&&(E|=S[v+1]>>>64-b-D,P=E),C[P])y=C[P][1],b+=C[P][0];else for(E=k<<b>>>32-I,P=E,32-b<I&&(E|=S[v+1]>>>64-b-I,P=E),N=A,w=0;w<I;w++)if(M=E>>>I-w-1&1,N=M?N.right:N.left,!(N.left||N.right)){y=N.val,b=b+w+1;break}b>=32&&(b-=32,v++,k=S[v]),x=y-L,H?(V>0&&T[R-1]?x+=U:O>0&&T[R-m]?x+=G[R-m]:x+=U,x&=255,G[R]=x,U=x):G[R]=x}d.ptr=d.ptr+(v+1)*4+(b>0?4:0)}d.pixels.resultPixels=F},decodeBits:function(c,d,h,f,p){{var u=d.headerInfo,m=u.fileVersion,g=0,_=new DataView(c,d.ptr,5),C=_.getUint8(0);g++;var A=C>>6,S=A===0?4:3-A,v=(C&32)>0,b=C&31,D=0;if(S===1)D=_.getUint8(g),g++;else if(S===2)D=_.getUint16(g,!0),g+=2;else if(S===4)D=_.getUint32(g,!0),g+=4;else throw"Invalid valid pixel count type";var I=2*u.maxZError,L,N,y,x,T,E,P,M,O,V=u.numDims>1?u.maxValues[p]:u.zMax;if(v){for(d.counter.lut++,M=_.getUint8(g),g++,x=Math.ceil((M-1)*b/8),T=Math.ceil(x/4),N=new ArrayBuffer(T*4),y=new Uint8Array(N),d.ptr+=g,y.set(new Uint8Array(c,d.ptr,x)),P=new Uint32Array(N),d.ptr+=x,O=0;M-1>>>O;)O++;x=Math.ceil(D*O/8),T=Math.ceil(x/4),N=new ArrayBuffer(T*4),y=new Uint8Array(N),y.set(new Uint8Array(c,d.ptr,x)),L=new Uint32Array(N),d.ptr+=x,m>=3?E=o.unstuffLUT2(P,b,M-1,f,I,V):E=o.unstuffLUT(P,b,M-1,f,I,V),m>=3?o.unstuff2(L,h,O,D,E):o.unstuff(L,h,O,D,E)}else d.counter.bitstuffer++,O=b,d.ptr+=g,O>0&&(x=Math.ceil(D*O/8),T=Math.ceil(x/4),N=new ArrayBuffer(T*4),y=new Uint8Array(N),y.set(new Uint8Array(c,d.ptr,x)),L=new Uint32Array(N),d.ptr+=x,m>=3?f==null?o.originalUnstuff2(L,h,O,D):o.unstuff2(L,h,O,D,!1,f,I,V):f==null?o.originalUnstuff(L,h,O,D):o.unstuff(L,h,O,D,!1,f,I,V))}},readTiles:function(c,d,h){var f=d.headerInfo,p=f.width,u=f.height,m=f.microBlockSize,g=f.imageType,_=a.getDataTypeSize(g),C=Math.ceil(p/m),A=Math.ceil(u/m);d.pixels.numBlocksY=A,d.pixels.numBlocksX=C,d.pixels.ptr=0;var S=0,v=0,b=0,D=0,I=0,L=0,N=0,y=0,x=0,T=0,E=0,P=0,M=0,O=0,V=0,R=0,w,U,k,H,F,G,B=new h(m*m),W=u%m||m,Y=p%m||m,z,X,q=f.numDims,Q,Z=d.pixels.resultMask,K=d.pixels.resultPixels;for(b=0;b<A;b++)for(I=b!==A-1?m:W,D=0;D<C;D++)for(L=D!==C-1?m:Y,E=b*p*m+D*m,P=p-L,Q=0;Q<q;Q++){if(q>1&&(K=new h(d.pixels.resultPixels.buffer,p*u*Q*_,p*u)),N=c.byteLength-d.ptr,w=new DataView(c,d.ptr,Math.min(10,N)),U={},R=0,y=w.getUint8(0),R++,x=y>>6&255,T=y>>2&15,T!==(D*m>>3&15))throw"integrity issue";if(G=y&3,G>3)throw d.ptr+=R,"Invalid block encoding ("+G+")";if(G===2){d.counter.constant++,d.ptr+=R;continue}else if(G===0){if(d.counter.uncompressed++,d.ptr+=R,M=I*L*_,O=c.byteLength-d.ptr,M=M<O?M:O,k=new ArrayBuffer(M%_===0?M:M+_-M%_),H=new Uint8Array(k),H.set(new Uint8Array(c,d.ptr,M)),F=new h(k),V=0,Z)for(S=0;S<I;S++){for(v=0;v<L;v++)Z[E]&&(K[E]=F[V++]),E++;E+=P}else for(S=0;S<I;S++){for(v=0;v<L;v++)K[E++]=F[V++];E+=P}d.ptr+=V*_}else if(z=a.getDataTypeUsed(g,x),X=a.getOnePixel(U,R,z,w),R+=a.getDataTypeSize(z),G===3)if(d.ptr+=R,d.counter.constantoffset++,Z)for(S=0;S<I;S++){for(v=0;v<L;v++)Z[E]&&(K[E]=X),E++;E+=P}else for(S=0;S<I;S++){for(v=0;v<L;v++)K[E++]=X;E+=P}else if(d.ptr+=R,a.decodeBits(c,d,B,X,Q),R=0,Z)for(S=0;S<I;S++){for(v=0;v<L;v++)Z[E]&&(K[E]=B[R++]),E++;E+=P}else for(S=0;S<I;S++){for(v=0;v<L;v++)K[E++]=B[R++];E+=P}}},formatFileInfo:function(c){return{fileIdentifierString:c.headerInfo.fileIdentifierString,fileVersion:c.headerInfo.fileVersion,imageType:c.headerInfo.imageType,height:c.headerInfo.height,width:c.headerInfo.width,numValidPixel:c.headerInfo.numValidPixel,microBlockSize:c.headerInfo.microBlockSize,blobSize:c.headerInfo.blobSize,maxZError:c.headerInfo.maxZError,pixelType:a.getPixelType(c.headerInfo.imageType),eofOffset:c.eofOffset,mask:c.mask?{numBytes:c.mask.numBytes}:null,pixels:{numBlocksX:c.pixels.numBlocksX,numBlocksY:c.pixels.numBlocksY,maxValue:c.headerInfo.zMax,minValue:c.headerInfo.zMin,noDataValue:c.noDataValue}}},constructConstantSurface:function(c){var d=c.headerInfo.zMax,h=c.headerInfo.numDims,f=c.headerInfo.height*c.headerInfo.width,p=f*h,u=0,m=0,g=0,_=c.pixels.resultMask;if(_)if(h>1)for(u=0;u<h;u++)for(g=u*f,m=0;m<f;m++)_[m]&&(c.pixels.resultPixels[g+m]=d);else for(m=0;m<f;m++)_[m]&&(c.pixels.resultPixels[m]=d);else if(c.pixels.resultPixels.fill)c.pixels.resultPixels.fill(d);else for(m=0;m<p;m++)c.pixels.resultPixels[m]=d},getDataTypeArray:function(c){var d;switch(c){case 0:d=Int8Array;break;case 1:d=Uint8Array;break;case 2:d=Int16Array;break;case 3:d=Uint16Array;break;case 4:d=Int32Array;break;case 5:d=Uint32Array;break;case 6:d=Float32Array;break;case 7:d=Float64Array;break;default:d=Float32Array}return d},getPixelType:function(c){var d;switch(c){case 0:d="S8";break;case 1:d="U8";break;case 2:d="S16";break;case 3:d="U16";break;case 4:d="S32";break;case 5:d="U32";break;case 6:d="F32";break;case 7:d="F64";break;default:d="F32"}return d},isValidPixelValue:function(c,d){if(d==null)return!1;var h;switch(c){case 0:h=d>=-128&&d<=127;break;case 1:h=d>=0&&d<=255;break;case 2:h=d>=-32768&&d<=32767;break;case 3:h=d>=0&&d<=65536;break;case 4:h=d>=-2147483648&&d<=2147483647;break;case 5:h=d>=0&&d<=4294967296;break;case 6:h=d>=-34027999387901484e22&&d<=34027999387901484e22;break;case 7:h=d>=5e-324&&d<=17976931348623157e292;break;default:h=!1}return h},getDataTypeSize:function(c){var d=0;switch(c){case 0:case 1:d=1;break;case 2:case 3:d=2;break;case 4:case 5:case 6:d=4;break;case 7:d=8;break;default:d=c}return d},getDataTypeUsed:function(c,d){var h=c;switch(c){case 2:case 4:h=c-d;break;case 3:case 5:h=c-2*d;break;case 6:d===0?h=c:d===1?h=2:h=1;break;case 7:d===0?h=c:h=c-2*d+1;break;default:h=c;break}return h},getOnePixel:function(c,d,h,f){var p=0;switch(h){case 0:p=f.getInt8(d);break;case 1:p=f.getUint8(d);break;case 2:p=f.getInt16(d,!0);break;case 3:p=f.getUint16(d,!0);break;case 4:p=f.getInt32(d,!0);break;case 5:p=f.getUInt32(d,!0);break;case 6:p=f.getFloat32(d,!0);break;case 7:p=f.getFloat64(d,!0);break;default:throw"the decoder does not understand this pixel type"}return p}},s=function(c,d,h){this.val=c,this.left=d,this.right=h},l={decode:function(c,d){d=d||{};var h=d.noDataValue,f=0,p={};if(p.ptr=d.inputOffset||0,p.pixels={},!!a.readHeaderInfo(c,p)){var u=p.headerInfo,m=u.fileVersion,g=a.getDataTypeArray(u.imageType);a.readMask(c,p),u.numValidPixel!==u.width*u.height&&!p.pixels.resultMask&&(p.pixels.resultMask=d.maskData);var _=u.width*u.height;if(p.pixels.resultPixels=new g(_*u.numDims),p.counter={onesweep:0,uncompressed:0,lut:0,bitstuffer:0,constant:0,constantoffset:0},u.numValidPixel!==0)if(u.zMax===u.zMin)a.constructConstantSurface(p);else if(m>=4&&a.checkMinMaxRanges(c,p))a.constructConstantSurface(p);else{var C=new DataView(c,p.ptr,2),A=C.getUint8(0);if(p.ptr++,A)a.readDataOneSweep(c,p,g);else if(m>1&&u.imageType<=1&&Math.abs(u.maxZError-.5)<1e-5){var S=C.getUint8(1);if(p.ptr++,p.encodeMode=S,S>2||m<4&&S>1)throw"Invalid Huffman flag "+S;S?a.readHuffman(c,p,g):a.readTiles(c,p,g)}else a.readTiles(c,p,g)}p.eofOffset=p.ptr;var v;d.inputOffset?(v=p.headerInfo.blobSize+d.inputOffset-p.ptr,Math.abs(v)>=1&&(p.eofOffset=d.inputOffset+p.headerInfo.blobSize)):(v=p.headerInfo.blobSize-p.ptr,Math.abs(v)>=1&&(p.eofOffset=p.headerInfo.blobSize));var b={width:u.width,height:u.height,pixelData:p.pixels.resultPixels,minValue:u.zMin,maxValue:u.zMax,validPixelCount:u.numValidPixel,dimCount:u.numDims,dimStats:{minValues:u.minValues,maxValues:u.maxValues},maskData:p.pixels.resultMask};if(p.pixels.resultMask&&a.isValidPixelValue(u.imageType,h)){var D=p.pixels.resultMask;for(f=0;f<_;f++)D[f]||(b.pixelData[f]=h);b.noDataValue=h}return p.noDataValue=h,d.returnFileInfo&&(b.fileInfo=a.formatFileInfo(p)),b}},getBandCount:function(c){var d=0,h=0,f={};for(f.ptr=0,f.pixels={};h<c.byteLength-58;)a.readHeaderInfo(c,f),h+=f.headerInfo.blobSize,d++,f.ptr=h;return d}};return l}(),i=function(){var o=new ArrayBuffer(4),a=new Uint8Array(o),s=new Uint32Array(o);return s[0]=1,a[0]===1}(),r={decode:function(o,a){if(!i)throw"Big endian system is not supported.";a=a||{};var s=a.inputOffset||0,l=new Uint8Array(o,s,10),c=String.fromCharCode.apply(null,l),d,h;if(c.trim()==="CntZImage")d=t,h=1;else if(c.substring(0,5)==="Lerc2")d=n,h=2;else throw"Unexpected file identifier string: "+c;for(var f=0,p=o.byteLength-10,u,m=[],g,_,C={width:0,height:0,pixels:[],pixelType:a.pixelType,mask:null,statistics:[]};s<p;){var A=d.decode(o,{inputOffset:s,encodedMaskData:u,maskData:_,returnMask:f===0,returnEncodedMask:f===0,returnFileInfo:!0,pixelType:a.pixelType||null,noDataValue:a.noDataValue||null});s=A.fileInfo.eofOffset,f===0&&(u=A.encodedMaskData,_=A.maskData,C.width=A.width,C.height=A.height,C.dimCount=A.dimCount||1,C.pixelType=A.pixelType||A.fileInfo.pixelType,C.mask=A.maskData),h>1&&A.fileInfo.mask&&A.fileInfo.mask.numBytes>0&&m.push(A.maskData),f++,C.pixels.push(A.pixelData),C.statistics.push({minValue:A.minValue,maxValue:A.maxValue,noDataValue:A.noDataValue,dimStats:A.dimStats})}var S,v,b;if(h>1&&m.length>1){for(b=C.width*C.height,C.bandMasks=m,_=new Uint8Array(b),_.set(m[0]),S=1;S<m.length;S++)for(g=m[S],v=0;v<b;v++)_[v]=_[v]&g[v];C.maskData=_}return C}};e.exports?e.exports=r:this.Lerc=r})()})(LercDecode);var LercDecodeExports=LercDecode.exports;const Lerc=getDefaultExportFromCjs(LercDecodeExports);function I3SDataProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._name=e.name,this._show=defaultValue(e.show,!0),this._geoidTiledTerrainProvider=e.geoidTiledTerrainProvider,this._showFeatures=defaultValue(e.showFeatures,!1),this._adjustMaterialAlphaMode=defaultValue(e.adjustMaterialAlphaMode,!1),this._applySymbology=defaultValue(e.applySymbology,!1),this._calculateNormals=defaultValue(e.calculateNormals,!1),this._cesium3dTilesetOptions=defaultValue(e.cesium3dTilesetOptions,defaultValue.EMPTY_OBJECT),this._layers=[],this._sublayers=[],this._data=void 0,this._extent=void 0,this._geoidDataPromise=void 0,this._geoidDataList=void 0,this._decoderTaskProcessor=void 0,this._taskProcessorReadyPromise=void 0,this._attributeStatistics=[],this._layersExtent=[]}Object.defineProperties(I3SDataProvider.prototype,{name:{get:function(){return this._name}},show:{get:function(){return this._show},set:function(e){if(Check.defined("value",e),this._show!==e){this._show=e;for(let t=0;t<this._layers.length;t++)this._layers[t]._updateVisibility()}}},geoidTiledTerrainProvider:{get:function(){return this._geoidTiledTerrainProvider}},layers:{get:function(){return this._layers}},sublayers:{get:function(){return this._sublayers}},data:{get:function(){return this._data}},extent:{get:function(){return this._extent}},resource:{get:function(){return this._resource}},showFeatures:{get:function(){return this._showFeatures}},adjustMaterialAlphaMode:{get:function(){return this._adjustMaterialAlphaMode}},applySymbology:{get:function(){return this._applySymbology}},calculateNormals:{get:function(){return this._calculateNormals}}});I3SDataProvider.prototype.destroy=function(){for(let e=0;e<this._layers.length;e++)defined(this._layers[e]._tileset)&&this._layers[e]._tileset.destroy();return destroyObject(this)};I3SDataProvider.prototype.isDestroyed=function(){return!1};I3SDataProvider.prototype.update=function(e){for(let t=0;t<this._layers.length;t++)defined(this._layers[t]._tileset)&&this._layers[t]._tileset.update(e)};I3SDataProvider.prototype.prePassesUpdate=function(e){for(let t=0;t<this._layers.length;t++)defined(this._layers[t]._tileset)&&this._layers[t]._tileset.prePassesUpdate(e)};I3SDataProvider.prototype.postPassesUpdate=function(e){for(let t=0;t<this._layers.length;t++)defined(this._layers[t]._tileset)&&this._layers[t]._tileset.postPassesUpdate(e)};I3SDataProvider.prototype.updateForPass=function(e,t){for(let n=0;n<this._layers.length;n++)defined(this._layers[n]._tileset)&&this._layers[n]._tileset.updateForPass(e,t)};function buildLayerUrl(e,t){const n=e.resource.getUrlComponent();let i="";return n.match(/layers\/\d/)?i=`${n}`.replace(/\/+$/,""):i=`${n}`.replace(/\/?$/,"/").concat(`layers/${t}`),i}async function addLayers(e,t,n){if(t.layerType==="Building"){defined(n.showFeatures)||(e._showFeatures=!0),defined(n.adjustMaterialAlphaMode)||(e._adjustMaterialAlphaMode=!0),defined(n.applySymbology)||(e._applySymbology=!0),defined(n.calculateNormals)||(e._calculateNormals=!0);const i=buildLayerUrl(e,t.id);if(defined(t.sublayers)){const r=[];for(let a=0;a<t.sublayers.length;a++){const s=I3SSublayer._fromData(e,i,t.sublayers[a],e);r.push(s)}const o=await Promise.all(r);for(let a=0;a<o.length;a++){const s=o[a];e._sublayers.push(s),e._layers.push(...s._i3sLayers)}}if(defined(t.statisticsHRef)){const r=i.concat(`/${t.statisticsHRef}`),o=new I3SStatistics(e,r);await o.load(),e._attributeStatistics.push(o)}if(defined(t.fullExtent)){const r=Rectangle.fromDegrees(t.fullExtent.xmin,t.fullExtent.ymin,t.fullExtent.xmax,t.fullExtent.ymax);e._layersExtent.push(r)}}else if(t.layerType==="3DObject"||t.layerType==="IntegratedMesh"){!defined(n.calculateNormals)&&!defined(t.textureSetDefinitions)&&(e._calculateNormals=!0);const i=new I3SLayer(e,t,e);e._layers.push(i),defined(i._extent)&&e._layersExtent.push(i._extent)}else console.log(`${t.layerType} layer ${t.name} is skipped as not supported.`)}I3SDataProvider.fromUrl=async function(e,t){Check.defined("url",e),t=defaultValue(t,defaultValue.EMPTY_OBJECT);const n=Resource.createIfNeeded(e);n.setQueryParameters({f:"pjson"},!0);const i=await I3SDataProvider.loadJson(n),r=new I3SDataProvider(t);if(r._resource=n,r._data=i,defined(i.layers)){const a=[];for(let s=0;s<i.layers.length;s++){const l=addLayers(r,i.layers[s],t);a.push(l)}await Promise.all(a)}else await addLayers(r,i,t);r._computeExtent();const o=[];for(let a=0;a<r._layers.length;a++)o.push(r._layers[a].load(t.cesium3dTilesetOptions));return await Promise.all(o),r};I3SDataProvider._fetchJson=function(e){return e.fetchJson()};I3SDataProvider.loadJson=async function(e){const t=await I3SDataProvider._fetchJson(e);if(defined(t.error)){if(console.error("Failed to fetch I3S ",e.url),defined(t.error.message)&&console.error(t.error.message),defined(t.error.details))for(let n=0;n<t.error.details.length;n++)console.log(t.error.details[n]);throw new RuntimeError(t.error)}return t};I3SDataProvider.prototype._loadBinary=async function(e){const t=await e.fetchArrayBuffer();if(t.byteLength>0&&new Uint8Array(t)[0]===123&&new TextDecoder().decode(t).includes("404"))throw new RuntimeError(`Failed to load binary: ${e.url}`);return t};I3SDataProvider.prototype._binarizeGltf=function(e){const n=new TextEncoder().encode(JSON.stringify(e)),i=new Uint8Array(n.byteLength+20),r={magic:new Uint8Array(i.buffer,0,4),version:new Uint32Array(i.buffer,4,1),length:new Uint32Array(i.buffer,8,1),chunkLength:new Uint32Array(i.buffer,12,1),chunkType:new Uint32Array(i.buffer,16,1),chunkData:new Uint8Array(i.buffer,20,n.byteLength)};return r.magic[0]=103,r.magic[1]=108,r.magic[2]=84,r.magic[3]=70,r.version[0]=2,r.length[0]=i.byteLength,r.chunkLength[0]=n.byteLength,r.chunkType[0]=1313821514,r.chunkData.set(n),i};const scratchCartesian2=new Cartesian2;function getCoveredTiles(e,t){const n=e.tilingScheme,i=[],r={},o=e._lodCount,a=Cartographic.fromRadians(t.west,t.north),s=Cartographic.fromRadians(t.east,t.south),l=n.positionToTileXY(a,o),c=n.positionToTileXY(s,o);for(let h=l.x;h<=c.x;h++)for(let f=l.y;f<=c.y;f++){const p=Cartesian2.fromElements(h,f,scratchCartesian2),u=p.toString();if(!r.hasOwnProperty(u)){const m={x:p.x,y:p.y,level:o,tilingScheme:n,terrainProvider:e,positions:[]};r[u]=m,i.push(m)}}const d=[];for(let h=0;h<i.length;++h){const f=i[h],p=f.terrainProvider.requestTileGeometry(f.x,f.y,f.level);d.push(p)}return Promise.all(d).then(function(h){const f=[];for(let p=0;p<h.length;p++){const u={tilingScheme:n,x:i[p].x,y:i[p].y,level:i[p].level},m=h[p];let g="Geographic";n._projection instanceof WebMercatorProjection&&(g="WebMercator");const _={projectionType:g,projection:n._projection,nativeExtent:n.tileXYToNativeRectangle(u.x,u.y,u.level),height:m._height,width:m._width,scale:m._structure.heightScale,offset:m._structure.heightOffset};if(m._encoding===HeightmapEncoding$1.LERC){const C=Lerc.decode(m._buffer);_.buffer=C.pixels[0]}else _.buffer=m._buffer;f.push(_)}return f})}async function loadGeoidData(e){const t=e._geoidTiledTerrainProvider;if(defined(t))try{const n=await getCoveredTiles(t,e._extent);e._geoidDataList=n}catch{console.log("Error retrieving Geoid Terrain tiles - no geoid conversion will be performed.")}}I3SDataProvider.prototype.loadGeoidData=async function(){return defined(this._geoidDataPromise)?this._geoidDataPromise:(this._geoidDataPromise=loadGeoidData(this),this._geoidDataPromise)};I3SDataProvider.prototype._computeExtent=function(){let e;for(let t=0;t<this._layersExtent.length;t++){const n=this._layersExtent[t];defined(e)?Rectangle.union(e,n,e):e=Rectangle.clone(n)}this._extent=e};I3SDataProvider.prototype.getAttributeNames=function(){const e=[];for(let t=0;t<this._attributeStatistics.length;++t)e.push(...this._attributeStatistics[t].names);return e};I3SDataProvider.prototype.getAttributeValues=function(e){Check.defined("name",e);for(let t=0;t<this._attributeStatistics.length;++t){const n=this._attributeStatistics[t]._getValues(e);if(defined(n))return n}return[]};I3SDataProvider.prototype.filterByAttributes=function(e){const t=[];for(let n=0;n<this._layers.length;n++){const i=this._layers[n].filterByAttributes(e);t.push(i)}return Promise.all(t)};function Light(){}Object.defineProperties(Light.prototype,{color:{get:DeveloperError.throwInstantiationError},intensity:{get:DeveloperError.throwInstantiationError}});const trailingSlashRegex=/\/$/,defaultCredit$1=new Credit('&copy; <a href="https://www.mapbox.com/about/maps/">Mapbox</a> &copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> <strong><a href="https://www.mapbox.com/map-feedback/">Improve this map</a></strong>');function MapboxStyleImageryProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.styleId;if(!defined(t))throw new DeveloperError("options.styleId is required.");const n=e.accessToken;if(!defined(n))throw new DeveloperError("options.accessToken is required.");this._defaultAlpha=void 0,this._defaultNightAlpha=void 0,this._defaultDayAlpha=void 0,this._defaultBrightness=void 0,this._defaultContrast=void 0,this._defaultHue=void 0,this._defaultSaturation=void 0,this._defaultGamma=void 0,this._defaultMinificationFilter=void 0,this._defaultMagnificationFilter=void 0;const i=Resource.createIfNeeded(defaultValue(e.url,"https://api.mapbox.com/styles/v1/"));this._styleId=t,this._accessToken=n;const r=defaultValue(e.tilesize,512);this._tilesize=r;const o=defaultValue(e.username,"mapbox");this._username=o;const a=defined(e.scaleFactor)?"@2x":"";let s=i.getUrlComponent();trailingSlashRegex.test(s)||(s+="/"),s+=`${this._username}/${t}/tiles/${this._tilesize}/{z}/{x}/{y}${a}`,i.url=s,i.setQueryParameters({access_token:n});let l;defined(e.credit)?(l=e.credit,typeof l=="string"&&(l=new Credit(l))):l=defaultCredit$1,this._resource=i,this._imageryProvider=new UrlTemplateImageryProvider({url:i,credit:l,ellipsoid:e.ellipsoid,minimumLevel:e.minimumLevel,maximumLevel:e.maximumLevel,rectangle:e.rectangle})}Object.defineProperties(MapboxStyleImageryProvider.prototype,{url:{get:function(){return this._imageryProvider.url}},rectangle:{get:function(){return this._imageryProvider.rectangle}},tileWidth:{get:function(){return this._imageryProvider.tileWidth}},tileHeight:{get:function(){return this._imageryProvider.tileHeight}},maximumLevel:{get:function(){return this._imageryProvider.maximumLevel}},minimumLevel:{get:function(){return this._imageryProvider.minimumLevel}},tilingScheme:{get:function(){return this._imageryProvider.tilingScheme}},tileDiscardPolicy:{get:function(){return this._imageryProvider.tileDiscardPolicy}},errorEvent:{get:function(){return this._imageryProvider.errorEvent}},credit:{get:function(){return this._imageryProvider.credit}},proxy:{get:function(){return this._imageryProvider.proxy}},hasAlphaChannel:{get:function(){return this._imageryProvider.hasAlphaChannel}}});MapboxStyleImageryProvider.prototype.getTileCredits=function(e,t,n){};MapboxStyleImageryProvider.prototype.requestImage=function(e,t,n,i){return this._imageryProvider.requestImage(e,t,n,i)};MapboxStyleImageryProvider.prototype.pickFeatures=function(e,t,n,i,r){return this._imageryProvider.pickFeatures(e,t,n,i,r)};MapboxStyleImageryProvider._defaultCredit=defaultCredit$1;function NeverTileDiscardPolicy(e){}NeverTileDiscardPolicy.prototype.isReady=function(){return!0};NeverTileDiscardPolicy.prototype.shouldDiscardImage=function(e){return!1};const defaultCredit=new Credit("MapQuest, Open Street Map and contributors, CC-BY-SA");function OpenStreetMapImageryProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=Resource.createIfNeeded(defaultValue(e.url,"https://tile.openstreetmap.org/"));t.appendForwardSlash(),t.url+=`{z}/{x}/{y}${e.retinaTiles?"@2x":""}.${defaultValue(e.fileExtension,"png")}`;const n=new WebMercatorTilingScheme({ellipsoid:e.ellipsoid}),i=256,r=256,o=defaultValue(e.minimumLevel,0),a=e.maximumLevel,s=defaultValue(e.rectangle,n.rectangle),l=n.positionToTileXY(Rectangle.southwest(s),o),c=n.positionToTileXY(Rectangle.northeast(s),o),d=(Math.abs(c.x-l.x)+1)*(Math.abs(c.y-l.y)+1);if(d>4)throw new DeveloperError(`The rectangle and minimumLevel indicate that there are ${d} tiles at the minimum level. Imagery providers with more than four tiles at the minimum level are not supported.`);let h=defaultValue(e.credit,defaultCredit);typeof h=="string"&&(h=new Credit(h)),UrlTemplateImageryProvider.call(this,{url:t,credit:h,tilingScheme:n,tileWidth:i,tileHeight:r,minimumLevel:o,maximumLevel:a,rectangle:s})}defined(Object.create)&&(OpenStreetMapImageryProvider.prototype=Object.create(UrlTemplateImageryProvider.prototype),OpenStreetMapImageryProvider.prototype.constructor=OpenStreetMapImageryProvider);const defaultSize=new Cartesian2(1,1);function Particle(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this.mass=defaultValue(e.mass,1),this.position=Cartesian3.clone(defaultValue(e.position,Cartesian3.ZERO)),this.velocity=Cartesian3.clone(defaultValue(e.velocity,Cartesian3.ZERO)),this.life=defaultValue(e.life,Number.MAX_VALUE),this.image=e.image,this.startColor=Color.clone(defaultValue(e.startColor,Color.WHITE)),this.endColor=Color.clone(defaultValue(e.endColor,Color.WHITE)),this.startScale=defaultValue(e.startScale,1),this.endScale=defaultValue(e.endScale,1),this.imageSize=Cartesian2.clone(defaultValue(e.imageSize,defaultSize)),this._age=0,this._normalizedAge=0,this._billboard=void 0}Object.defineProperties(Particle.prototype,{age:{get:function(){return this._age}},normalizedAge:{get:function(){return this._normalizedAge}}});const deltaScratch=new Cartesian3;Particle.prototype.update=function(e,t){return Cartesian3.multiplyByScalar(this.velocity,e,deltaScratch),Cartesian3.add(this.position,deltaScratch,this.position),defined(t)&&t(this,e),this._age+=e,this.life===Number.MAX_VALUE?this._normalizedAge=0:this._normalizedAge=this._age/this.life,this._age<=this.life};function ParticleBurst(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this.time=defaultValue(e.time,0),this.minimum=defaultValue(e.minimum,0),this.maximum=defaultValue(e.maximum,50),this._complete=!1}Object.defineProperties(ParticleBurst.prototype,{complete:{get:function(){return this._complete}}});function ParticleEmitter(e){throw new DeveloperError("This type should not be instantiated directly.  Instead, use BoxEmitter, CircleEmitter, ConeEmitter or SphereEmitter.")}ParticleEmitter.prototype.emit=function(e){DeveloperError.throwInstantiationError()};const defaultImageSize=new Cartesian2(1,1);function ParticleSystem(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this.show=defaultValue(e.show,!0),this.updateCallback=e.updateCallback,this.loop=defaultValue(e.loop,!0),this.image=defaultValue(e.image,void 0);let t=e.emitter;defined(t)||(t=new CircleEmitter(.5)),this._emitter=t,this._bursts=e.bursts,this._modelMatrix=Matrix4.clone(defaultValue(e.modelMatrix,Matrix4.IDENTITY)),this._emitterModelMatrix=Matrix4.clone(defaultValue(e.emitterModelMatrix,Matrix4.IDENTITY)),this._matrixDirty=!0,this._combinedMatrix=new Matrix4,this._startColor=Color.clone(defaultValue(e.color,defaultValue(e.startColor,Color.WHITE))),this._endColor=Color.clone(defaultValue(e.color,defaultValue(e.endColor,Color.WHITE))),this._startScale=defaultValue(e.scale,defaultValue(e.startScale,1)),this._endScale=defaultValue(e.scale,defaultValue(e.endScale,1)),this._emissionRate=defaultValue(e.emissionRate,5),this._minimumSpeed=defaultValue(e.speed,defaultValue(e.minimumSpeed,1)),this._maximumSpeed=defaultValue(e.speed,defaultValue(e.maximumSpeed,1)),this._minimumParticleLife=defaultValue(e.particleLife,defaultValue(e.minimumParticleLife,5)),this._maximumParticleLife=defaultValue(e.particleLife,defaultValue(e.maximumParticleLife,5)),this._minimumMass=defaultValue(e.mass,defaultValue(e.minimumMass,1)),this._maximumMass=defaultValue(e.mass,defaultValue(e.maximumMass,1)),this._minimumImageSize=Cartesian2.clone(defaultValue(e.imageSize,defaultValue(e.minimumImageSize,defaultImageSize))),this._maximumImageSize=Cartesian2.clone(defaultValue(e.imageSize,defaultValue(e.maximumImageSize,defaultImageSize))),this._sizeInMeters=defaultValue(e.sizeInMeters,!1),this._lifetime=defaultValue(e.lifetime,Number.MAX_VALUE),this._billboardCollection=void 0,this._particles=[],this._particlePool=[],this._previousTime=void 0,this._currentTime=0,this._carryOver=0,this._complete=new Event,this._isComplete=!1,this._updateParticlePool=!0,this._particleEstimate=0}Object.defineProperties(ParticleSystem.prototype,{emitter:{get:function(){return this._emitter},set:function(e){Check.defined("value",e),this._emitter=e}},bursts:{get:function(){return this._bursts},set:function(e){this._bursts=e,this._updateParticlePool=!0}},modelMatrix:{get:function(){return this._modelMatrix},set:function(e){Check.defined("value",e),this._matrixDirty=this._matrixDirty||!Matrix4.equals(this._modelMatrix,e),Matrix4.clone(e,this._modelMatrix)}},emitterModelMatrix:{get:function(){return this._emitterModelMatrix},set:function(e){Check.defined("value",e),this._matrixDirty=this._matrixDirty||!Matrix4.equals(this._emitterModelMatrix,e),Matrix4.clone(e,this._emitterModelMatrix)}},startColor:{get:function(){return this._startColor},set:function(e){Check.defined("value",e),Color.clone(e,this._startColor)}},endColor:{get:function(){return this._endColor},set:function(e){Check.defined("value",e),Color.clone(e,this._endColor)}},startScale:{get:function(){return this._startScale},set:function(e){Check.typeOf.number.greaterThanOrEquals("value",e,0),this._startScale=e}},endScale:{get:function(){return this._endScale},set:function(e){Check.typeOf.number.greaterThanOrEquals("value",e,0),this._endScale=e}},emissionRate:{get:function(){return this._emissionRate},set:function(e){Check.typeOf.number.greaterThanOrEquals("value",e,0),this._emissionRate=e,this._updateParticlePool=!0}},minimumSpeed:{get:function(){return this._minimumSpeed},set:function(e){Check.typeOf.number.greaterThanOrEquals("value",e,0),this._minimumSpeed=e}},maximumSpeed:{get:function(){return this._maximumSpeed},set:function(e){Check.typeOf.number.greaterThanOrEquals("value",e,0),this._maximumSpeed=e}},minimumParticleLife:{get:function(){return this._minimumParticleLife},set:function(e){Check.typeOf.number.greaterThanOrEquals("value",e,0),this._minimumParticleLife=e}},maximumParticleLife:{get:function(){return this._maximumParticleLife},set:function(e){Check.typeOf.number.greaterThanOrEquals("value",e,0),this._maximumParticleLife=e,this._updateParticlePool=!0}},minimumMass:{get:function(){return this._minimumMass},set:function(e){Check.typeOf.number.greaterThanOrEquals("value",e,0),this._minimumMass=e}},maximumMass:{get:function(){return this._maximumMass},set:function(e){Check.typeOf.number.greaterThanOrEquals("value",e,0),this._maximumMass=e}},minimumImageSize:{get:function(){return this._minimumImageSize},set:function(e){Check.typeOf.object("value",e),Check.typeOf.number.greaterThanOrEquals("value.x",e.x,0),Check.typeOf.number.greaterThanOrEquals("value.y",e.y,0),this._minimumImageSize=e}},maximumImageSize:{get:function(){return this._maximumImageSize},set:function(e){Check.typeOf.object("value",e),Check.typeOf.number.greaterThanOrEquals("value.x",e.x,0),Check.typeOf.number.greaterThanOrEquals("value.y",e.y,0),this._maximumImageSize=e}},sizeInMeters:{get:function(){return this._sizeInMeters},set:function(e){Check.typeOf.bool("value",e),this._sizeInMeters=e}},lifetime:{get:function(){return this._lifetime},set:function(e){Check.typeOf.number.greaterThanOrEquals("value",e,0),this._lifetime=e}},complete:{get:function(){return this._complete}},isComplete:{get:function(){return this._isComplete}}});function updateParticlePool(e){const t=e._emissionRate,n=e._maximumParticleLife;let i=0;const r=e._bursts;if(defined(r)){const h=r.length;for(let f=0;f<h;++f)i+=r[f].maximum}const o=e._billboardCollection,a=e.image,s=Math.ceil(t*n+i),l=e._particles,c=e._particlePool,d=Math.max(s-l.length-c.length,0);for(let h=0;h<d;++h){const f=new Particle;f._billboard=o.add({image:a,show:!1}),c.push(f)}e._particleEstimate=s}function getOrCreateParticle(e){let t=e._particlePool.pop();return defined(t)||(t=new Particle),t}function addParticleToPool(e,t){e._particlePool.push(t)}function freeParticlePool(e){const t=e._particles,n=e._particlePool,i=e._billboardCollection,r=t.length,o=n.length,a=e._particleEstimate,s=o-Math.max(a-r-o,0);for(let l=s;l<o;++l){const c=n[l];i.remove(c._billboard)}n.length=s}function removeBillboard(e){defined(e._billboard)&&(e._billboard.show=!1)}function updateBillboard(e,t){let n=t._billboard;defined(n)||(n=t._billboard=e._billboardCollection.add({image:t.image})),n.width=t.imageSize.x,n.height=t.imageSize.y,n.position=t.position,n.sizeInMeters=e.sizeInMeters,n.show=!0;const i=CesiumMath.lerp(t.startColor.red,t.endColor.red,t.normalizedAge),r=CesiumMath.lerp(t.startColor.green,t.endColor.green,t.normalizedAge),o=CesiumMath.lerp(t.startColor.blue,t.endColor.blue,t.normalizedAge),a=CesiumMath.lerp(t.startColor.alpha,t.endColor.alpha,t.normalizedAge);n.color=new Color(i,r,o,a),n.scale=CesiumMath.lerp(t.startScale,t.endScale,t.normalizedAge)}function addParticle(e,t){t.startColor=Color.clone(e._startColor,t.startColor),t.endColor=Color.clone(e._endColor,t.endColor),t.startScale=e._startScale,t.endScale=e._endScale,t.image=e.image,t.life=CesiumMath.randomBetween(e._minimumParticleLife,e._maximumParticleLife),t.mass=CesiumMath.randomBetween(e._minimumMass,e._maximumMass),t.imageSize.x=CesiumMath.randomBetween(e._minimumImageSize.x,e._maximumImageSize.x),t.imageSize.y=CesiumMath.randomBetween(e._minimumImageSize.y,e._maximumImageSize.y),t._normalizedAge=0,t._age=0;const n=CesiumMath.randomBetween(e._minimumSpeed,e._maximumSpeed);Cartesian3.multiplyByScalar(t.velocity,n,t.velocity),e._particles.push(t)}function calculateNumberToEmit(e,t){if(e._isComplete)return 0;t=CesiumMath.mod(t,e._lifetime);const n=t*e._emissionRate;let i=Math.floor(n);if(e._carryOver+=n-i,e._carryOver>1&&(i++,e._carryOver-=1),defined(e.bursts)){const r=e.bursts.length;for(let o=0;o<r;o++){const a=e.bursts[o],s=e._currentTime;defined(a)&&!a._complete&&s>a.time&&(i+=CesiumMath.randomBetween(a.minimum,a.maximum),a._complete=!0)}}return i}const rotatedVelocityScratch=new Cartesian3;ParticleSystem.prototype.update=function(e){if(!this.show)return;defined(this._billboardCollection)||(this._billboardCollection=new BillboardCollection),this._updateParticlePool&&(updateParticlePool(this),this._updateParticlePool=!1);let t=0;this._previousTime&&(t=JulianDate.secondsDifference(e.time,this._previousTime)),t<0&&(t=0);const n=this._particles,i=this._emitter,r=this.updateCallback;let o,a,s=n.length;for(o=0;o<s;++o)a=n[o],a.update(t,r)?updateBillboard(this,a):(removeBillboard(a),addParticleToPool(this,a),n[o]=n[s-1],--o,--s);n.length=s;const l=calculateNumberToEmit(this,t);if(l>0&&defined(i)){this._matrixDirty&&(this._combinedMatrix=Matrix4.multiply(this.modelMatrix,this.emitterModelMatrix,this._combinedMatrix),this._matrixDirty=!1);const c=this._combinedMatrix;for(o=0;o<l;o++)a=getOrCreateParticle(this),this._emitter.emit(a),Cartesian3.add(a.position,a.velocity,rotatedVelocityScratch),Matrix4.multiplyByPoint(c,rotatedVelocityScratch,rotatedVelocityScratch),a.position=Matrix4.multiplyByPoint(c,a.position,a.position),Cartesian3.subtract(rotatedVelocityScratch,a.position,a.velocity),Cartesian3.normalize(a.velocity,a.velocity),addParticle(this,a),updateBillboard(this,a)}if(this._billboardCollection.update(e),this._previousTime=JulianDate.clone(e.time,this._previousTime),this._currentTime+=t,this._lifetime!==Number.MAX_VALUE&&this._currentTime>this._lifetime)if(this.loop){if(this._currentTime=CesiumMath.mod(this._currentTime,this._lifetime),this.bursts){const c=this.bursts.length;for(o=0;o<c;o++)this.bursts[o]._complete=!1}}else this._isComplete=!0,this._complete.raiseEvent(this);e.frameNumber%120===0&&freeParticlePool(this)};ParticleSystem.prototype.isDestroyed=function(){return!1};ParticleSystem.prototype.destroy=function(){return this._billboardCollection=this._billboardCollection&&this._billboardCollection.destroy(),destroyObject(this)};function getClipAndStyleCode(e,t,n){return Check.typeOf.string("samplerUniformName",e),Check.typeOf.string("matrixUniformName",t),Check.typeOf.string("styleUniformName",n),`    float clipDistance = clip(gl_FragCoord, ${e}, ${t}); 
    vec4 clippingPlanesEdgeColor = vec4(1.0); 
    clippingPlanesEdgeColor.rgb = ${n}.rgb; 
    float clippingPlanesEdgeWidth = ${n}.a; 
    if (clipDistance > 0.0 && clipDistance < clippingPlanesEdgeWidth) 
    { 
        out_FragColor = clippingPlanesEdgeColor;
    } 
`}const Splitter={modifyFragmentShader:function e(t){return t=ShaderSource.replaceMain(t,"czm_splitter_main"),t+=`uniform float czm_splitDirection; 
void main() 
{ 
#ifndef SHADOW_MAP
    if (czm_splitDirection < 0.0 && gl_FragCoord.x > czm_splitPosition) discard; 
    if (czm_splitDirection > 0.0 && gl_FragCoord.x < czm_splitPosition) discard; 
#endif
    czm_splitter_main(); 
} 
`,t},addUniforms:function e(t,n){n.czm_splitDirection=function(){return t.splitDirection}}},Splitter$1=Splitter,DecodingState={NEEDS_DECODE:0,DECODING:1,READY:2,FAILED:3};function PointCloud(e){Check.typeOf.object("options",e),Check.typeOf.object("options.arrayBuffer",e.arrayBuffer),this._parsedContent=void 0,this._drawCommand=void 0,this._isTranslucent=!1,this._styleTranslucent=!1,this._constantColor=Color.clone(Color.DARKGRAY),this._highlightColor=Color.clone(Color.WHITE),this._pointSize=1,this._rtcCenter=void 0,this._quantizedVolumeScale=void 0,this._quantizedVolumeOffset=void 0,this._styleableShaderAttributes=void 0,this._isQuantized=!1,this._isOctEncoded16P=!1,this._isRGB565=!1,this._hasColors=!1,this._hasNormals=!1,this._hasBatchIds=!1,this._decodingState=DecodingState.READY,this._dequantizeInShader=!0,this._isQuantizedDraco=!1,this._isOctEncodedDraco=!1,this._quantizedRange=0,this._octEncodedRange=0,this.backFaceCulling=!1,this._backFaceCulling=!1,this.normalShading=!0,this._normalShading=!0,this._opaqueRenderState=void 0,this._translucentRenderState=void 0,this._mode=void 0,this._ready=!1,this._pointsLength=0,this._geometryByteLength=0,this._vertexShaderLoaded=e.vertexShaderLoaded,this._fragmentShaderLoaded=e.fragmentShaderLoaded,this._uniformMapLoaded=e.uniformMapLoaded,this._batchTableLoaded=e.batchTableLoaded,this._pickIdLoaded=e.pickIdLoaded,this._opaquePass=defaultValue(e.opaquePass,Pass.OPAQUE),this._cull=defaultValue(e.cull,!0),this.style=void 0,this._style=void 0,this.styleDirty=!1,this.modelMatrix=Matrix4.clone(Matrix4.IDENTITY),this._modelMatrix=Matrix4.clone(Matrix4.IDENTITY),this.time=0,this.shadows=ShadowMode.ENABLED,this._boundingSphere=void 0,this.clippingPlanes=void 0,this.isClipped=!1,this.clippingPlanesDirty=!1,this.clippingPlanesOriginMatrix=void 0,this.attenuation=!1,this._attenuation=!1,this.geometricError=0,this.geometricErrorScale=1,this.maximumAttenuation=this._pointSize,this.splitDirection=defaultValue(e.splitDirection,SplitDirection.NONE),this._splittingEnabled=!1,this._error=void 0,initialize(this,e)}Object.defineProperties(PointCloud.prototype,{pointsLength:{get:function(){return this._pointsLength}},geometryByteLength:{get:function(){return this._geometryByteLength}},ready:{get:function(){return this._ready}},color:{get:function(){return Color.clone(this._highlightColor)},set:function(e){this._highlightColor=Color.clone(e,this._highlightColor)}},boundingSphere:{get:function(){if(defined(this._drawCommand))return this._drawCommand.boundingVolume},set:function(e){this._boundingSphere=BoundingSphere.clone(e,this._boundingSphere)}}});function initialize(e,t){const n=PntsParser.parse(t.arrayBuffer,t.byteOffset);if(e._parsedContent=n,e._rtcCenter=n.rtcCenter,e._hasNormals=n.hasNormals,e._hasColors=n.hasColors,e._hasBatchIds=n.hasBatchIds,e._isTranslucent=n.isTranslucent,!n.hasBatchIds&&defined(n.batchTableBinary)&&(n.styleableProperties=Cesium3DTileBatchTable.getBinaryProperties(n.pointsLength,n.batchTableJson,n.batchTableBinary)),defined(n.draco)){const s=n.draco;e._decodingState=DecodingState.NEEDS_DECODE,s.dequantizeInShader=e._dequantizeInShader}const i=n.positions;defined(i)&&(e._isQuantized=i.isQuantized,e._quantizedVolumeScale=i.quantizedVolumeScale,e._quantizedVolumeOffset=i.quantizedVolumeOffset,e._quantizedRange=i.quantizedRange);const r=n.normals;defined(r)&&(e._isOctEncoded16P=r.octEncoded);const o=n.colors;defined(o)&&(defined(o.constantColor)&&(e._constantColor=Color.clone(o.constantColor,e._constantColor),e._hasColors=!1),e._isRGB565=o.isRGB565);const a=n.batchIds;defined(n.batchIds)&&(a.name="BATCH_ID",a.semantic="BATCH_ID",a.setIndex=void 0),n.hasBatchIds&&e._batchTableLoaded(n.batchLength,n.batchTableJson,n.batchTableBinary),e._pointsLength=n.pointsLength}const scratchMin=new Cartesian3,scratchMax=new Cartesian3,scratchPosition=new Cartesian3;let randomNumberGenerator,randomValues;function getRandomValues(e){if(!defined(randomValues)){randomNumberGenerator=new MersenneTwister(0),randomValues=new Array(e);for(let t=0;t<e;++t)randomValues[t]=randomNumberGenerator.random()}return randomValues}function computeApproximateBoundingSphereFromPositions(e){const n=e.length/3,i=Math.min(n,20),r=getRandomValues(20),o=Number.MAX_VALUE,a=-Number.MAX_VALUE,s=Cartesian3.fromElements(o,o,o,scratchMin),l=Cartesian3.fromElements(a,a,a,scratchMax);for(let d=0;d<i;++d){const h=Math.floor(r[d]*n),f=Cartesian3.unpack(e,h*3,scratchPosition);Cartesian3.minimumByComponent(s,f,s),Cartesian3.maximumByComponent(l,f,l)}const c=BoundingSphere.fromCornerPoints(s,l);return c.radius+=CesiumMath.EPSILON2,c}function prepareVertexAttribute(e,t){const n=ComponentDatatype.fromTypedArray(e);return n===ComponentDatatype.INT||n===ComponentDatatype.UNSIGNED_INT||n===ComponentDatatype.DOUBLE?(oneTimeWarning("Cast pnts property to floats",`Point cloud property "${t}" will be cast to a float array because INT, UNSIGNED_INT, and DOUBLE are not valid WebGL vertex attribute types. Some precision may be lost.`),new Float32Array(e)):e}const scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier=new Cartesian4,scratchQuantizedVolumeScaleAndOctEncodedRange=new Cartesian4,scratchColor$2=new Color,positionLocation=0,colorLocation=1,normalLocation=2,batchIdLocation=3,numberOfAttributes=4,scratchClippingPlanesMatrix=new Matrix4,scratchInverseTransposeClippingPlanesMatrix=new Matrix4;function createResources(e,t){const n=t.context,i=e._parsedContent,r=e._pointsLength,o=i.positions,a=i.colors,s=i.normals,l=i.batchIds,c=i.styleableProperties,d=defined(c),h=e._isQuantized,f=e._isQuantizedDraco,p=e._isOctEncoded16P,u=e._isOctEncodedDraco,m=e._quantizedRange,g=e._octEncodedRange,_=e._isRGB565,C=e._isTranslucent,A=e._hasColors,S=e._hasNormals,v=e._hasBatchIds;let b,D;const I=[],L={};if(e._styleableShaderAttributes=L,d){let V=numberOfAttributes;for(const R in c)if(c.hasOwnProperty(R)){const w=c[R],U=prepareVertexAttribute(w.typedArray,R);b=w.componentCount,D=ComponentDatatype.fromTypedArray(U);const k=Buffer.createVertexBuffer({context:n,typedArray:U,usage:BufferUsage.STATIC_DRAW});e._geometryByteLength+=k.sizeInBytes;const H={index:V,vertexBuffer:k,componentsPerAttribute:b,componentDatatype:D,normalize:!1,offsetInBytes:0,strideInBytes:0};I.push(H),L[R]={location:V,componentCount:b},++V}}const N=Buffer.createVertexBuffer({context:n,typedArray:o.typedArray,usage:BufferUsage.STATIC_DRAW});e._geometryByteLength+=N.sizeInBytes;let y;A&&(y=Buffer.createVertexBuffer({context:n,typedArray:a.typedArray,usage:BufferUsage.STATIC_DRAW}),e._geometryByteLength+=y.sizeInBytes);let x;S&&(x=Buffer.createVertexBuffer({context:n,typedArray:s.typedArray,usage:BufferUsage.STATIC_DRAW}),e._geometryByteLength+=x.sizeInBytes);let T;v&&(l.typedArray=prepareVertexAttribute(l.typedArray,"batchIds"),T=Buffer.createVertexBuffer({context:n,typedArray:l.typedArray,usage:BufferUsage.STATIC_DRAW}),e._geometryByteLength+=T.sizeInBytes);let E=[];if(h?D=ComponentDatatype.UNSIGNED_SHORT:f?D=m<=255?ComponentDatatype.UNSIGNED_BYTE:ComponentDatatype.UNSIGNED_SHORT:D=ComponentDatatype.FLOAT,E.push({index:positionLocation,vertexBuffer:N,componentsPerAttribute:3,componentDatatype:D,normalize:!1,offsetInBytes:0,strideInBytes:0}),e._cull&&(h||f?e._boundingSphere=BoundingSphere.fromCornerPoints(Cartesian3.ZERO,e._quantizedVolumeScale):e._boundingSphere=computeApproximateBoundingSphereFromPositions(o.typedArray)),A)if(_)E.push({index:colorLocation,vertexBuffer:y,componentsPerAttribute:1,componentDatatype:ComponentDatatype.UNSIGNED_SHORT,normalize:!1,offsetInBytes:0,strideInBytes:0});else{const V=C?4:3;E.push({index:colorLocation,vertexBuffer:y,componentsPerAttribute:V,componentDatatype:ComponentDatatype.UNSIGNED_BYTE,normalize:!0,offsetInBytes:0,strideInBytes:0})}S&&(p?(b=2,D=ComponentDatatype.UNSIGNED_BYTE):u?(b=2,D=g<=255?ComponentDatatype.UNSIGNED_BYTE:ComponentDatatype.UNSIGNED_SHORT):(b=3,D=ComponentDatatype.FLOAT),E.push({index:normalLocation,vertexBuffer:x,componentsPerAttribute:b,componentDatatype:D,normalize:!1,offsetInBytes:0,strideInBytes:0})),v&&E.push({index:batchIdLocation,vertexBuffer:T,componentsPerAttribute:1,componentDatatype:ComponentDatatype.fromTypedArray(l.typedArray),normalize:!1,offsetInBytes:0,strideInBytes:0}),d&&(E=E.concat(I));const P=new VertexArray({context:n,attributes:E}),M={depthTest:{enabled:!0}},O={depthTest:{enabled:!0},depthMask:!1,blending:BlendingState.ALPHA_BLEND};e._opaquePass===Pass.CESIUM_3D_TILE&&(M.stencilTest=StencilConstants.setCesium3DTileBit(),M.stencilMask=StencilConstants.CESIUM_3D_TILE_MASK,O.stencilTest=StencilConstants.setCesium3DTileBit(),O.stencilMask=StencilConstants.CESIUM_3D_TILE_MASK),e._opaqueRenderState=RenderState.fromCache(M),e._translucentRenderState=RenderState.fromCache(O),e._drawCommand=new DrawCommand({boundingVolume:new BoundingSphere,cull:e._cull,modelMatrix:new Matrix4,primitiveType:PrimitiveType.POINTS,vertexArray:P,count:r,shaderProgram:void 0,uniformMap:void 0,renderState:C?e._translucentRenderState:e._opaqueRenderState,pass:C?Pass.TRANSLUCENT:e._opaquePass,owner:e,castShadows:!1,receiveShadows:!1,pickId:e._pickIdLoaded()})}function createUniformMap(e,t){const n=t.context,i=e._isQuantized,r=e._isQuantizedDraco,o=e._isOctEncodedDraco;let a={u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier:function(){const s=scratchPointSizeAndTimeAndGeometricErrorAndDepthMultiplier;if(s.x=e._attenuation?e.maximumAttenuation:e._pointSize,s.x*=t.pixelRatio,s.y=e.time,e._attenuation){const l=t.camera.frustum;let c;t.mode===SceneMode.SCENE2D||l instanceof OrthographicFrustum?c=Number.POSITIVE_INFINITY:c=n.drawingBufferHeight/t.camera.frustum.sseDenominator,s.z=e.geometricError*e.geometricErrorScale,s.w=c}return s},u_highlightColor:function(){return e._highlightColor},u_constantColor:function(){return e._constantColor},u_clippingPlanes:function(){const s=e.clippingPlanes;return e.isClipped?s.texture:n.defaultTexture},u_clippingPlanesEdgeStyle:function(){const s=e.clippingPlanes;if(!defined(s))return Color.TRANSPARENT;const l=Color.clone(s.edgeColor,scratchColor$2);return l.alpha=s.edgeWidth,l},u_clippingPlanesMatrix:function(){const s=e.clippingPlanes;if(!defined(s))return Matrix4.IDENTITY;const l=defaultValue(e.clippingPlanesOriginMatrix,e._modelMatrix);Matrix4.multiply(n.uniformState.view3D,l,scratchClippingPlanesMatrix);const c=Matrix4.multiply(scratchClippingPlanesMatrix,s.modelMatrix,scratchClippingPlanesMatrix);return Matrix4.inverseTranspose(c,scratchInverseTransposeClippingPlanesMatrix)}};Splitter$1.addUniforms(e,a),(i||r||o)&&(a=combine$2(a,{u_quantizedVolumeScaleAndOctEncodedRange:function(){const s=scratchQuantizedVolumeScaleAndOctEncodedRange;if(defined(e._quantizedVolumeScale)){const l=Cartesian3.clone(e._quantizedVolumeScale,s);Cartesian3.divideByScalar(l,e._quantizedRange,s)}return s.w=e._octEncodedRange,s}})),defined(e._uniformMapLoaded)&&(a=e._uniformMapLoaded(a)),e._drawCommand.uniformMap=a}function getStyleablePropertyIds(e,t){const n=/czm_3dtiles_property_(\d+)/g;let i=n.exec(e);for(;i!==null;){const r=parseInt(i[1]);t.indexOf(r)===-1&&t.push(r),i=n.exec(e)}}function getBuiltinPropertyNames(e,t){e=e.slice(e.indexOf(`
`));const n=/czm_3dtiles_builtin_property_(\w+)/g;let i=n.exec(e);for(;i!==null;){const r=i[1];t.indexOf(r)===-1&&t.push(r),i=n.exec(e)}}function getVertexAttribute(e,t){const n=e.numberOfAttributes;for(let i=0;i<n;++i){const r=e.getAttribute(i);if(r.index===t)return r}}const builtinVariableSubstitutionMap={POSITION:"czm_3dtiles_builtin_property_POSITION",POSITION_ABSOLUTE:"czm_3dtiles_builtin_property_POSITION_ABSOLUTE",COLOR:"czm_3dtiles_builtin_property_COLOR",NORMAL:"czm_3dtiles_builtin_property_NORMAL"};function createShaders(e,t,n){let i,r,o;const a=t.context,s=defined(n),l=e._isQuantized,c=e._isQuantizedDraco,d=e._isOctEncoded16P,h=e._isOctEncodedDraco,f=e._isRGB565,p=e._isTranslucent,u=e._hasColors,m=e._hasNormals,g=e._hasBatchIds,_=e._backFaceCulling,C=e._normalShading,A=e._drawCommand.vertexArray,S=e.clippingPlanes,v=e._attenuation;let b,D,I,L=p;const N=clone(builtinVariableSubstitutionMap),y={},x=e._styleableShaderAttributes;for(r in x)x.hasOwnProperty(r)&&(o=x[r],N[r]=`czm_3dtiles_property_${o.location}`,y[o.location]=o);if(s){const z={translucent:!1},X="(vec3 czm_3dtiles_builtin_property_POSITION, vec3 czm_3dtiles_builtin_property_POSITION_ABSOLUTE, vec4 czm_3dtiles_builtin_property_COLOR, vec3 czm_3dtiles_builtin_property_NORMAL)";b=n.getColorShaderFunction(`getColorFromStyle${X}`,N,z),D=n.getShowShaderFunction(`getShowFromStyle${X}`,N,z),I=n.getPointSizeShaderFunction(`getPointSizeFromStyle${X}`,N,z),defined(b)&&z.translucent&&(L=!0)}e._styleTranslucent=L;const T=defined(b),E=defined(D),P=defined(I),M=e.isClipped,O=[],V=[];T&&(getStyleablePropertyIds(b,O),getBuiltinPropertyNames(b,V)),E&&(getStyleablePropertyIds(D,O),getBuiltinPropertyNames(D,V)),P&&(getStyleablePropertyIds(I,O),getBuiltinPropertyNames(I,V));const R=V.indexOf("COLOR")>=0,w=V.indexOf("NORMAL")>=0;if(w&&!m)throw new RuntimeError("Style references the NORMAL semantic but the point cloud does not have normals");for(r in x)if(x.hasOwnProperty(r)){o=x[r];const z=O.indexOf(o.location)>=0,X=getVertexAttribute(A,o.location);X.enabled=z}const U=u&&(!T||R);if(u){const z=getVertexAttribute(A,colorLocation);z.enabled=U}const k=m&&(C||_||w);if(m){const z=getVertexAttribute(A,normalLocation);z.enabled=k}const H={a_position:positionLocation};U&&(H.a_color=colorLocation),k&&(H.a_normal=normalLocation),g&&(H.a_batchId=batchIdLocation);let F="";const G=O.length;for(i=0;i<G;++i){const z=O[i];o=y[z];const X=o.componentCount,q=`czm_3dtiles_property_${z}`;let Q;X===1?Q="float":Q=`vec${X}`,F+=`in ${Q} ${q}; 
`,H[q]=o.location}createUniformMap(e,t);let B=`in vec3 a_position; 
out vec4 v_color; 
uniform vec4 u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier; 
uniform vec4 u_constantColor; 
uniform vec4 u_highlightColor; 
`;B+=`float u_pointSize; 
float tiles3d_tileset_time; 
`,v&&(B+=`float u_geometricError; 
float u_depthMultiplier; 
`),B+=F,U&&(p?B+=`in vec4 a_color; 
`:f?B+=`in float a_color; 
const float SHIFT_RIGHT_11 = 1.0 / 2048.0; 
const float SHIFT_RIGHT_5 = 1.0 / 32.0; 
const float SHIFT_LEFT_11 = 2048.0; 
const float SHIFT_LEFT_5 = 32.0; 
const float NORMALIZE_6 = 1.0 / 64.0; 
const float NORMALIZE_5 = 1.0 / 32.0; 
`:B+=`in vec3 a_color; 
`),k&&(d||h?B+=`in vec2 a_normal; 
`:B+=`in vec3 a_normal; 
`),g&&(B+=`in float a_batchId; 
`),(l||c||h)&&(B+=`uniform vec4 u_quantizedVolumeScaleAndOctEncodedRange; 
`),T&&(B+=b),E&&(B+=D),P&&(B+=I),B+=`void main() 
{ 
    u_pointSize = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.x; 
    tiles3d_tileset_time = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.y; 
`,v&&(B+=`    u_geometricError = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.z; 
    u_depthMultiplier = u_pointSizeAndTimeAndGeometricErrorAndDepthMultiplier.w; 
`),U?p?B+=`    vec4 color = a_color; 
`:f?B+=`    float compressed = a_color; 
    float r = floor(compressed * SHIFT_RIGHT_11); 
    compressed -= r * SHIFT_LEFT_11; 
    float g = floor(compressed * SHIFT_RIGHT_5); 
    compressed -= g * SHIFT_LEFT_5; 
    float b = compressed; 
    vec3 rgb = vec3(r * NORMALIZE_5, g * NORMALIZE_6, b * NORMALIZE_5); 
    vec4 color = vec4(rgb, 1.0); 
`:B+=`    vec4 color = vec4(a_color, 1.0); 
`:B+=`    vec4 color = u_constantColor; 
`,l||c?B+=`    vec3 position = a_position * u_quantizedVolumeScaleAndOctEncodedRange.xyz; 
`:B+=`    vec3 position = a_position; 
`,B+=`    vec3 position_absolute = vec3(czm_model * vec4(position, 1.0)); 
`,k?(d?B+=`    vec3 normal = czm_octDecode(a_normal); 
`:h?B+=`    vec3 normal = czm_octDecode(a_normal, u_quantizedVolumeScaleAndOctEncodedRange.w).zxy; 
`:B+=`    vec3 normal = a_normal; 
`,B+=`    vec3 normalEC = czm_normal * normal; 
`):B+=`    vec3 normal = vec3(1.0); 
`,T&&(B+=`    color = getColorFromStyle(position, position_absolute, color, normal); 
`),E&&(B+=`    float show = float(getShowFromStyle(position, position_absolute, color, normal)); 
`),P?B+=`    gl_PointSize = getPointSizeFromStyle(position, position_absolute, color, normal) * czm_pixelRatio; 
`:v?B+=`    vec4 positionEC = czm_modelView * vec4(position, 1.0); 
    float depth = -positionEC.z; 
    gl_PointSize = min((u_geometricError / depth) * u_depthMultiplier, u_pointSize); 
`:B+=`    gl_PointSize = u_pointSize; 
`,B+=`    color = color * u_highlightColor; 
`,k&&C&&(B+=`    float diffuseStrength = czm_getLambertDiffuse(czm_lightDirectionEC, normalEC); 
    diffuseStrength = max(diffuseStrength, 0.4); 
    color.xyz *= diffuseStrength * czm_lightColor; 
`),B+=`    v_color = color; 
    gl_Position = czm_modelViewProjection * vec4(position, 1.0); 
`,k&&_&&(B+=`    float visible = step(-normalEC.z, 0.0); 
    gl_Position *= visible; 
    gl_PointSize *= visible; 
`),E&&(B+=`    gl_Position.w *= float(show); 
    gl_PointSize *= float(show); 
`),B+=`} 
`;let W=`in vec4 v_color; 
`;M&&(W+=`uniform highp sampler2D u_clippingPlanes; 
uniform mat4 u_clippingPlanesMatrix; 
uniform vec4 u_clippingPlanesEdgeStyle; 
`,W+=`
`,W+=getClippingFunction(S,a),W+=`
`),W+=`void main() 
{ 
    out_FragColor = czm_gammaCorrect(v_color); 
`,M&&(W+=getClipAndStyleCode("u_clippingPlanes","u_clippingPlanesMatrix","u_clippingPlanesEdgeStyle")),W+=`} 
`,e.splitDirection!==SplitDirection.NONE&&(W=Splitter$1.modifyFragmentShader(W)),defined(e._vertexShaderLoaded)&&(B=e._vertexShaderLoaded(B)),defined(e._fragmentShaderLoaded)&&(W=e._fragmentShaderLoaded(W));const Y=e._drawCommand;defined(Y.shaderProgram)&&Y.shaderProgram.destroy(),Y.shaderProgram=ShaderProgram.fromCache({context:a,vertexShaderSource:B,fragmentShaderSource:W,attributeLocations:H});try{Y.shaderProgram._bind()}catch{throw new RuntimeError("Error generating style shader: this may be caused by a type mismatch, index out-of-bounds, or other syntax error.")}}function decodeDraco(e,t){if(e._decodingState===DecodingState.READY)return!1;if(e._decodingState===DecodingState.NEEDS_DECODE){const n=e._parsedContent,i=n.draco,r=DracoLoader.decodePointCloud(i,t);defined(r)&&(e._decodingState=DecodingState.DECODING,r.then(function(o){e._decodingState=DecodingState.READY;const a=defined(o.POSITION)?o.POSITION.array:void 0,s=defined(o.RGB)?o.RGB.array:void 0,l=defined(o.RGBA)?o.RGBA.array:void 0,c=defined(o.NORMAL)?o.NORMAL.array:void 0,d=defined(o.BATCH_ID)?o.BATCH_ID.array:void 0,h=defined(a)&&defined(o.POSITION.data.quantization),f=defined(c)&&defined(o.NORMAL.data.quantization);if(h){const g=o.POSITION.data.quantization,_=g.range;e._quantizedVolumeScale=Cartesian3.fromElements(_,_,_),e._quantizedVolumeOffset=Cartesian3.unpack(g.minValues),e._quantizedRange=(1<<g.quantizationBits)-1,e._isQuantizedDraco=!0}f&&(e._octEncodedRange=(1<<o.NORMAL.data.quantization.quantizationBits)-1,e._isOctEncodedDraco=!0);let p=n.styleableProperties;const u=i.batchTableProperties;for(const g in u)if(u.hasOwnProperty(g)){const _=o[g];defined(p)||(p={}),p[g]={typedArray:_.array,componentCount:_.data.componentsPerAttribute}}defined(a)&&(n.positions={typedArray:a});const m=defaultValue(l,s);defined(m)&&(n.colors={typedArray:m}),defined(c)&&(n.normals={typedArray:c}),defined(d)&&(n.batchIds={typedArray:d}),n.styleableProperties=p}).catch(function(o){e._decodingState=DecodingState.FAILED,e._error=o}))}return!0}const scratchComputedTranslation=new Cartesian4,scratchScale$1=new Cartesian3;PointCloud.prototype.update=function(e){const t=e.context;if(defined(this._error)){const c=this._error;throw this._error=void 0,c}if(decodeDraco(this,t))return;let i=!1,r=!Matrix4.equals(this._modelMatrix,this.modelMatrix);if(this._mode!==e.mode&&(this._mode=e.mode,r=!0),defined(this._drawCommand)||(createResources(this,e),r=!0,i=!0,this._ready=!0,this._parsedContent=void 0),r){Matrix4.clone(this.modelMatrix,this._modelMatrix);const c=this._drawCommand.modelMatrix;if(Matrix4.clone(this._modelMatrix,c),defined(this._rtcCenter)&&Matrix4.multiplyByTranslation(c,this._rtcCenter,c),defined(this._quantizedVolumeOffset)&&Matrix4.multiplyByTranslation(c,this._quantizedVolumeOffset,c),e.mode!==SceneMode.SCENE3D){const h=e.mapProjection,f=Matrix4.getColumn(c,3,scratchComputedTranslation);Cartesian4.equals(f,Cartesian4.UNIT_W)||Transforms.basisTo2D(h,c,c)}const d=this._drawCommand.boundingVolume;if(BoundingSphere.clone(this._boundingSphere,d),this._cull){const h=d.center;Matrix4.multiplyByPoint(c,h,h);const f=Matrix4.getScale(c,scratchScale$1);d.radius*=Cartesian3.maximumComponent(f)}}this.clippingPlanesDirty&&(this.clippingPlanesDirty=!1,i=!0),this._attenuation!==this.attenuation&&(this._attenuation=this.attenuation,i=!0),this.backFaceCulling!==this._backFaceCulling&&(this._backFaceCulling=this.backFaceCulling,i=!0),this.normalShading!==this._normalShading&&(this._normalShading=this.normalShading,i=!0),(this._style!==this.style||this.styleDirty)&&(this._style=this.style,this.styleDirty=!1,i=!0);const o=this.splitDirection!==SplitDirection.NONE;this._splittingEnabled!==o&&(this._splittingEnabled=o,i=!0),i&&createShaders(this,e,this._style),this._drawCommand.castShadows=ShadowMode.castShadows(this.shadows),this._drawCommand.receiveShadows=ShadowMode.receiveShadows(this.shadows);const a=this._highlightColor.alpha<1||this._constantColor.alpha<1||this._styleTranslucent;this._drawCommand.renderState=a?this._translucentRenderState:this._opaqueRenderState,this._drawCommand.pass=a?Pass.TRANSLUCENT:this._opaquePass;const s=e.commandList,l=e.passes;(l.render||l.pick)&&s.push(this._drawCommand)};PointCloud.prototype.isDestroyed=function(){return!1};PointCloud.prototype.destroy=function(){const e=this._drawCommand;return defined(e)&&(e.vertexArray=e.vertexArray&&e.vertexArray.destroy(),e.shaderProgram=e.shaderProgram&&e.shaderProgram.destroy()),destroyObject(this)};function QuadtreeTileProvider(){DeveloperError.throwInstantiationError()}QuadtreeTileProvider.computeDefaultLevelZeroMaximumGeometricError=function(e){return e.ellipsoid.maximumRadius*2*Math.PI*.25/(65*e.getNumberOfXTilesAtLevel(0))};Object.defineProperties(QuadtreeTileProvider.prototype,{quadtree:{get:DeveloperError.throwInstantiationError,set:DeveloperError.throwInstantiationError},tilingScheme:{get:DeveloperError.throwInstantiationError},errorEvent:{get:DeveloperError.throwInstantiationError}});QuadtreeTileProvider.prototype.update=DeveloperError.throwInstantiationError;QuadtreeTileProvider.prototype.beginUpdate=DeveloperError.throwInstantiationError;QuadtreeTileProvider.prototype.endUpdate=DeveloperError.throwInstantiationError;QuadtreeTileProvider.prototype.getLevelMaximumGeometricError=DeveloperError.throwInstantiationError;QuadtreeTileProvider.prototype.loadTile=DeveloperError.throwInstantiationError;QuadtreeTileProvider.prototype.computeTileVisibility=DeveloperError.throwInstantiationError;QuadtreeTileProvider.prototype.showTileThisFrame=DeveloperError.throwInstantiationError;QuadtreeTileProvider.prototype.computeDistanceToTile=DeveloperError.throwInstantiationError;QuadtreeTileProvider.prototype.isDestroyed=DeveloperError.throwInstantiationError;QuadtreeTileProvider.prototype.destroy=DeveloperError.throwInstantiationError;function SphereEmitter(e){e=defaultValue(e,1),Check.typeOf.number.greaterThan("radius",e,0),this._radius=defaultValue(e,1)}Object.defineProperties(SphereEmitter.prototype,{radius:{get:function(){return this._radius},set:function(e){Check.typeOf.number.greaterThan("value",e,0),this._radius=e}}});SphereEmitter.prototype.emit=function(e){const t=CesiumMath.randomBetween(0,CesiumMath.TWO_PI),n=CesiumMath.randomBetween(0,CesiumMath.PI),i=CesiumMath.randomBetween(0,this._radius),r=i*Math.cos(t)*Math.sin(n),o=i*Math.sin(t)*Math.sin(n),a=i*Math.cos(n);e.position=Cartesian3.fromElements(r,o,a,e.position),e.velocity=Cartesian3.normalize(e.position,e.velocity)};function StyleExpression(){}StyleExpression.prototype.evaluate=function(e,t){DeveloperError.throwInstantiationError()};StyleExpression.prototype.evaluateColor=function(e,t){DeveloperError.throwInstantiationError()};StyleExpression.prototype.getShaderFunction=function(e,t,n,i){DeveloperError.throwInstantiationError()};StyleExpression.prototype.getVariables=function(){DeveloperError.throwInstantiationError()};function Terrain(e){Check.typeOf.object("terrainProviderPromise",e),this._ready=!1,this._provider=void 0,this._errorEvent=new Event,this._readyEvent=new Event,handlePromise(this,e)}Object.defineProperties(Terrain.prototype,{errorEvent:{get:function(){return this._errorEvent}},readyEvent:{get:function(){return this._readyEvent}},ready:{get:function(){return this._ready}},provider:{get:function(){return this._provider}}});Terrain.fromWorldTerrain=function(e){return new Terrain(createWorldTerrainAsync(e))};Terrain.fromWorldBathymetry=function(e){return new Terrain(createWorldBathymetryAsync(e))};function handleError(e,t){e.numberOfListeners>0?e.raiseEvent(t):console.error(t)}async function handlePromise(e,t){let n;try{n=await Promise.resolve(t),e._provider=n,e._ready=!0,e._readyEvent.raiseEvent(n)}catch(i){handleError(e._errorEvent,i)}}function TileBoundingVolume(){}TileBoundingVolume.prototype.boundingVolume=void 0;TileBoundingVolume.prototype.boundingSphere=void 0;TileBoundingVolume.prototype.distanceToCamera=function(e){DeveloperError.throwInstantiationError()};TileBoundingVolume.prototype.intersectPlane=function(e){DeveloperError.throwInstantiationError()};TileBoundingVolume.prototype.createDebugVolume=function(e){DeveloperError.throwInstantiationError()};function TileCoordinatesImageryProvider(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),this._tilingScheme=defined(e.tilingScheme)?e.tilingScheme:new GeographicTilingScheme({ellipsoid:e.ellipsoid}),this._color=defaultValue(e.color,Color.YELLOW),this._errorEvent=new Event,this._tileWidth=defaultValue(e.tileWidth,256),this._tileHeight=defaultValue(e.tileHeight,256),this._defaultAlpha=void 0,this._defaultNightAlpha=void 0,this._defaultDayAlpha=void 0,this._defaultBrightness=void 0,this._defaultContrast=void 0,this._defaultHue=void 0,this._defaultSaturation=void 0,this._defaultGamma=void 0,this._defaultMinificationFilter=void 0,this._defaultMagnificationFilter=void 0}Object.defineProperties(TileCoordinatesImageryProvider.prototype,{proxy:{get:function(){}},tileWidth:{get:function(){return this._tileWidth}},tileHeight:{get:function(){return this._tileHeight}},maximumLevel:{get:function(){}},minimumLevel:{get:function(){}},tilingScheme:{get:function(){return this._tilingScheme}},rectangle:{get:function(){return this._tilingScheme.rectangle}},tileDiscardPolicy:{get:function(){}},errorEvent:{get:function(){return this._errorEvent}},credit:{get:function(){}},hasAlphaChannel:{get:function(){return!0}}});TileCoordinatesImageryProvider.prototype.getTileCredits=function(e,t,n){};TileCoordinatesImageryProvider.prototype.requestImage=function(e,t,n,i){const r=document.createElement("canvas");r.width=256,r.height=256;const o=r.getContext("2d"),a=this._color.toCssColorString();return o.strokeStyle=a,o.lineWidth=2,o.strokeRect(1,1,255,255),o.font="bold 25px Arial",o.textAlign="center",o.fillStyle=a,o.fillText(`L: ${n}`,124,86),o.fillText(`X: ${e}`,124,136),o.fillText(`Y: ${t}`,124,186),Promise.resolve(r)};TileCoordinatesImageryProvider.prototype.pickFeatures=function(e,t,n,i,r){};function TileDiscardPolicy(e){DeveloperError.throwInstantiationError()}TileDiscardPolicy.prototype.isReady=DeveloperError.throwInstantiationError;TileDiscardPolicy.prototype.shouldDiscardImage=DeveloperError.throwInstantiationError;const TileState={START:0,LOADING:1,READY:2,UPSAMPLED_ONLY:3},TileState$1=Object.freeze(TileState);function TimeDynamicPointCloud(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT),Check.typeOf.object("options.clock",e.clock),Check.typeOf.object("options.intervals",e.intervals),this.show=defaultValue(e.show,!0),this.modelMatrix=Matrix4.clone(defaultValue(e.modelMatrix,Matrix4.IDENTITY)),this.shadows=defaultValue(e.shadows,ShadowMode.ENABLED),this.maximumMemoryUsage=defaultValue(e.maximumMemoryUsage,256),this.shading=new PointCloudShading(e.shading),this.style=e.style,this.frameFailed=new Event,this.frameChanged=new Event,this._clock=e.clock,this._intervals=e.intervals,this._clippingPlanes=void 0,this.clippingPlanes=e.clippingPlanes,this._pointCloudEyeDomeLighting=new PointCloudEyeDomeLighting,this._loadTimestamp=void 0,this._clippingPlanesState=0,this._styleDirty=!1,this._pickId=void 0,this._totalMemoryUsageInBytes=0,this._frames=[],this._previousInterval=void 0,this._nextInterval=void 0,this._lastRenderedFrame=void 0,this._clockMultiplier=0,this._runningSum=0,this._runningLength=0,this._runningIndex=0,this._runningSamples=new Array(5).fill(0),this._runningAverage=0}Object.defineProperties(TimeDynamicPointCloud.prototype,{clippingPlanes:{get:function(){return this._clippingPlanes},set:function(e){ClippingPlaneCollection.setOwner(e,this,"_clippingPlanes")}},totalMemoryUsageInBytes:{get:function(){return this._totalMemoryUsageInBytes}},boundingSphere:{get:function(){if(defined(this._lastRenderedFrame))return this._lastRenderedFrame.pointCloud.boundingSphere}}});function getFragmentShaderLoaded(e){return`uniform vec4 czm_pickColor;
${e}`}function getUniformMapLoaded(e){return function(t){return combine$2(t,{czm_pickColor:function(){return e._pickId.color}})}}function getPickIdLoaded(){return"czm_pickColor"}TimeDynamicPointCloud.prototype.makeStyleDirty=function(){this._styleDirty=!0};TimeDynamicPointCloud.prototype._getAverageLoadTime=function(){return this._runningLength===0?.05:this._runningAverage};const scratchDate=new JulianDate;function getClockMultiplier(e){const t=e._clock,n=t.canAnimate&&t.shouldAnimate,i=t.multiplier;return n?i:0}function getIntervalIndex(e,t){return e._intervals.indexOf(t.start)}function getNextInterval(e,t){const n=e._intervals,i=e._clock,r=getClockMultiplier(e);if(r===0)return;const o=e._getAverageLoadTime(),a=JulianDate.addSeconds(i.currentTime,o*r,scratchDate);let s=n.indexOf(a);const l=getIntervalIndex(e,t);return s===l&&(r>=0?++s:--s),n.get(s)}function getCurrentInterval(e){const t=e._intervals,i=e._clock.currentTime,r=t.indexOf(i);return t.get(r)}function reachedInterval(e,t,n){const i=getClockMultiplier(e),r=getIntervalIndex(e,t),o=getIntervalIndex(e,n);return i>=0?r>=o:r<=o}function handleFrameFailure(e,t){return function(n){const i=defined(n.message)?n.message:n.toString();e.frameFailed.numberOfListeners>0?e.frameFailed.raiseEvent({uri:t,message:i}):(console.log(`A frame failed to load: ${t}`),console.log(`Error: ${i}`))}}function requestFrame(e,t,n){const i=getIntervalIndex(e,t),r=e._frames;let o=r[i];if(!defined(o)){const a=t.data.transform,s=defined(a)?Matrix4.fromArray(a):void 0,l=t.data.uri;o={pointCloud:void 0,transform:s,timestamp:getTimestamp(),sequential:!0,ready:!1,touchedFrameNumber:n.frameNumber,uri:l},r[i]=o,Resource.fetchArrayBuffer({url:l}).then(function(c){o.pointCloud=new PointCloud({arrayBuffer:c,cull:!0,fragmentShaderLoaded:getFragmentShaderLoaded,uniformMapLoaded:getUniformMapLoaded(e),pickIdLoaded:getPickIdLoaded})}).catch(handleFrameFailure(e,l))}return o}function updateAverageLoadTime(e,t){e._runningSum+=t,e._runningSum-=e._runningSamples[e._runningIndex],e._runningSamples[e._runningIndex]=t,e._runningLength=Math.min(e._runningLength+1,e._runningSamples.length),e._runningIndex=(e._runningIndex+1)%e._runningSamples.length,e._runningAverage=e._runningSum/e._runningLength}function prepareFrame(e,t,n,i){t.touchedFrameNumber<i.frameNumber-1&&(t.sequential=!1);const r=t.pointCloud;if(defined(r)&&!t.ready){const o=i.commandList,a=o.length;if(renderFrame(e,t,n,i),r.ready&&(t.ready=!0,e._totalMemoryUsageInBytes+=r.geometryByteLength,o.length=a,t.sequential)){const s=(getTimestamp()-t.timestamp)/1e3;updateAverageLoadTime(e,s)}}t.touchedFrameNumber=i.frameNumber}const scratchModelMatrix=new Matrix4;function getGeometricError(e,t){const n=e.shading;return defined(n)&&defined(n.baseResolution)?n.baseResolution:defined(t.boundingSphere)?CesiumMath.cbrt(t.boundingSphere.volume()/t.pointsLength):0}function getMaximumAttenuation(e){const t=e.shading;return defined(t)&&defined(t.maximumAttenuation)?t.maximumAttenuation:10}const defaultShading=new PointCloudShading;function renderFrame(e,t,n,i){const r=defaultValue(e.shading,defaultShading),o=t.pointCloud,a=defaultValue(t.transform,Matrix4.IDENTITY);o.modelMatrix=Matrix4.multiplyTransformation(e.modelMatrix,a,scratchModelMatrix),o.style=e.style,o.time=n.timeSinceLoad,o.shadows=e.shadows,o.clippingPlanes=e._clippingPlanes,o.isClipped=n.isClipped,o.attenuation=r.attenuation,o.backFaceCulling=r.backFaceCulling,o.normalShading=r.normalShading,o.geometricError=getGeometricError(e,o),o.geometricErrorScale=r.geometricErrorScale,o.maximumAttenuation=getMaximumAttenuation(e);try{o.update(i)}catch(s){handleFrameFailure(e,t.uri)(s)}t.touchedFrameNumber=i.frameNumber}function loadFrame(e,t,n,i){const r=requestFrame(e,t,i);prepareFrame(e,r,n,i)}function getUnloadCondition(e){return function(t){return t.touchedFrameNumber<e.frameNumber}}function unloadFrames(e,t){const n=e._frames,i=n.length;for(let r=0;r<i;++r){const o=n[r];if(defined(o)&&(!defined(t)||t(o))){const a=o.pointCloud;o.ready&&(e._totalMemoryUsageInBytes-=a.geometryByteLength),defined(a)&&a.destroy(),o===e._lastRenderedFrame&&(e._lastRenderedFrame=void 0),n[r]=void 0}}}function getFrame(e,t){const n=getIntervalIndex(e,t),i=e._frames[n];if(defined(i)&&i.ready)return i}function updateInterval(e,t,n,i,r){return defined(n)?n.ready?!0:(loadFrame(e,t,i,r),n.ready):!1}function getNearestReadyInterval(e,t,n,i,r){let o,a,s;const l=e._intervals,c=e._frames,d=getIntervalIndex(e,n),h=getIntervalIndex(e,t);if(d>=h){for(o=d;o>=h;--o)if(a=l.get(o),s=c[o],updateInterval(e,a,s,i,r))return a}else for(o=d;o<=h;++o)if(a=l.get(o),s=c[o],updateInterval(e,a,s,i,r))return a;return t}function setFramesDirty(e,t,n){const i=e._frames,r=i.length;for(let o=0;o<r;++o){const a=i[o];defined(a)&&defined(a.pointCloud)&&(a.pointCloud.clippingPlanesDirty=t,a.pointCloud.styleDirty=n)}}const updateState={timeSinceLoad:0,isClipped:!1,clippingPlanesDirty:!1};TimeDynamicPointCloud.prototype.update=function(e){if(e.mode===SceneMode.MORPHING||!this.show)return;defined(this._pickId)||(this._pickId=e.context.createPickId({primitive:this})),defined(this._loadTimestamp)||(this._loadTimestamp=JulianDate.clone(e.time));const t=Math.max(JulianDate.secondsDifference(e.time,this._loadTimestamp)*1e3,0),n=this._clippingPlanes;let i=0,r=!1;const o=defined(n)&&n.enabled;o&&(n.update(e),i=n.clippingPlanesState),this._clippingPlanesState!==i&&(this._clippingPlanesState=i,r=!0);const a=this._styleDirty;this._styleDirty=!1,(r||a)&&setFramesDirty(this,r,a),updateState.timeSinceLoad=t,updateState.isClipped=o;const s=this.shading,l=this._pointCloudEyeDomeLighting,c=e.commandList,d=c.length;let h=this._previousInterval,f=this._nextInterval;const p=getCurrentInterval(this);if(!defined(p))return;let u=!1;const m=getClockMultiplier(this),g=m===0;m!==this._clockMultiplier&&(u=!0,this._clockMultiplier=m),(!defined(h)||g)&&(h=p),(!defined(f)||u||reachedInterval(this,p,f))&&(f=getNextInterval(this,p)),h=getNearestReadyInterval(this,h,p,updateState,e);let _=getFrame(this,h);defined(_)||(loadFrame(this,h,updateState,e),_=this._lastRenderedFrame),defined(_)&&renderFrame(this,_,updateState,e),defined(f)&&loadFrame(this,f,updateState,e);const C=this;defined(_)&&!defined(this._lastRenderedFrame)&&e.afterRender.push(function(){return!0}),defined(_)&&_!==this._lastRenderedFrame&&C.frameChanged.numberOfListeners>0&&e.afterRender.push(function(){return C.frameChanged.raiseEvent(C),!0}),this._previousInterval=h,this._nextInterval=f,this._lastRenderedFrame=_;const A=this._totalMemoryUsageInBytes,S=this.maximumMemoryUsage*1024*1024;A>S&&unloadFrames(this,getUnloadCondition(e));const b=c.length-d;defined(s)&&s.attenuation&&s.eyeDomeLighting&&b>0&&l.update(e,d,s,this.boundingSphere)};TimeDynamicPointCloud.prototype.isDestroyed=function(){return!1};TimeDynamicPointCloud.prototype.destroy=function(){return unloadFrames(this),this._clippingPlanes=this._clippingPlanes&&this._clippingPlanes.destroy(),this._pickId=this._pickId&&this._pickId.destroy(),destroyObject(this)};function ViewportQuad(e,t){this.show=!0,defined(e)||(e=new BoundingRectangle),this.rectangle=BoundingRectangle.clone(e),defined(t)||(t=Material.fromType(Material.ColorType,{color:new Color(1,1,1,1)})),this.material=t,this._material=void 0,this._overlayCommand=void 0,this._rs=void 0}ViewportQuad.prototype.update=function(e){if(!this.show)return;if(!defined(this.material))throw new DeveloperError("this.material must be defined.");if(!defined(this.rectangle))throw new DeveloperError("this.rectangle must be defined.");const t=this._rs;if((!defined(t)||!BoundingRectangle.equals(t.viewport,this.rectangle))&&(this._rs=RenderState.fromCache({blending:BlendingState.ALPHA_BLEND,viewport:this.rectangle})),e.passes.render){const i=e.context;if(this._material!==this.material||!defined(this._overlayCommand)){this._material=this.material,defined(this._overlayCommand)&&this._overlayCommand.shaderProgram.destroy();const r=new ShaderSource({sources:[this._material.shaderSource,ViewportQuadFS]});this._overlayCommand=i.createViewportQuadCommand(r,{renderState:this._rs,uniformMap:this._material._uniforms,owner:this}),this._overlayCommand.pass=Pass.OVERLAY}this._material.update(i),this._overlayCommand.renderState=this._rs,this._overlayCommand.uniformMap=this._material._uniforms,e.commandList.push(this._overlayCommand)}};ViewportQuad.prototype.isDestroyed=function(){return!1};ViewportQuad.prototype.destroy=function(){return defined(this._overlayCommand)&&(this._overlayCommand.shaderProgram=this._overlayCommand.shaderProgram&&this._overlayCommand.shaderProgram.destroy()),destroyObject(this)};function VoxelProvider(){DeveloperError.throwInstantiationError()}Object.defineProperties(VoxelProvider.prototype,{globalTransform:{get:DeveloperError.throwInstantiationError},shapeTransform:{get:DeveloperError.throwInstantiationError},shape:{get:DeveloperError.throwInstantiationError},minBounds:{get:DeveloperError.throwInstantiationError},maxBounds:{get:DeveloperError.throwInstantiationError},dimensions:{get:DeveloperError.throwInstantiationError},paddingBefore:{get:DeveloperError.throwInstantiationError},paddingAfter:{get:DeveloperError.throwInstantiationError},names:{get:DeveloperError.throwInstantiationError},types:{get:DeveloperError.throwInstantiationError},componentTypes:{get:DeveloperError.throwInstantiationError},minimumValues:{get:DeveloperError.throwInstantiationError},maximumValues:{get:DeveloperError.throwInstantiationError},maximumTileCount:{get:DeveloperError.throwInstantiationError},keyframeCount:{get:DeveloperError.throwInstantiationError},timeIntervalCollection:{get:DeveloperError.throwInstantiationError}});VoxelProvider.prototype.requestData=DeveloperError.throwInstantiationError;function VoxelShape(){DeveloperError.throwInstantiationError()}Object.defineProperties(VoxelShape.prototype,{orientedBoundingBox:{get:DeveloperError.throwInstantiationError},boundingSphere:{get:DeveloperError.throwInstantiationError},boundTransform:{get:DeveloperError.throwInstantiationError},shapeTransform:{get:DeveloperError.throwInstantiationError},shaderUniforms:{get:DeveloperError.throwInstantiationError},shaderDefines:{get:DeveloperError.throwInstantiationError},shaderMaximumIntersectionsLength:{get:DeveloperError.throwInstantiationError}});VoxelShape.prototype.update=DeveloperError.throwInstantiationError;VoxelShape.prototype.computeOrientedBoundingBoxForTile=DeveloperError.throwInstantiationError;VoxelShape.prototype.computeOrientedBoundingBoxForSample=DeveloperError.throwInstantiationError;VoxelShape.DefaultMinBounds=DeveloperError.throwInstantiationError;VoxelShape.DefaultMaxBounds=DeveloperError.throwInstantiationError;async function computeFlyToLocationForRectangle(e,t){const n=t.terrainProvider,i=t.mapProjection,r=i.ellipsoid;let o;const a=t.camera.getRectangleCameraCoordinates(e);if(t.mode===SceneMode.SCENE3D?o=r.cartesianToCartographic(a):o=i.unproject(a),!defined(n))return o;const s=n.availability;if(!defined(s)||t.mode===SceneMode.SCENE2D)return o;const l=[Rectangle.center(e),Rectangle.southeast(e),Rectangle.southwest(e),Rectangle.northeast(e),Rectangle.northwest(e)],c=await computeFlyToLocationForRectangle._sampleTerrainMostDetailed(n,l);let d=!1;const h=c.reduce(function(p,u){return defined(u.height)?(d=!0,Math.max(u.height,p)):p},-Number.MAX_VALUE),f=o;return d&&(f.height+=h),f}computeFlyToLocationForRectangle._sampleTerrainMostDetailed=sampleTerrainMostDetailed;const scratchColor$1=new Color,scratchColorAbove=new Color,scratchColorBelow=new Color,scratchColorBlend=new Color,scratchPackedFloat=new Cartesian4,scratchColorBytes=new Uint8Array(4);function lerpEntryColor(e,t,n,i){const r=t.height===n.height?0:(e-t.height)/(n.height-t.height);return Color.lerp(t.color,n.color,r,i)}function createNewEntry(e,t){return{height:e,color:Color.clone(t)}}function removeDuplicates(e){return e=e.filter(function(t,n,i){const r=n>0,o=n<i.length-1,a=r?t.height===i[n-1].height:!0,s=o?t.height===i[n+1].height:!0;return!a||!s}),e=e.filter(function(t,n,i){const r=n>0,o=n<i.length-1,a=r?Color.equals(t.color,i[n-1].color):!1,s=o?Color.equals(t.color,i[n+1].color):!1;return!a||!s}),e=e.filter(function(t,n,i){const r=n>0,o=r?Color.equals(t.color,i[n-1].color):!1,a=r?t.height===i[n-1].height:!0;return!o||!a}),e}function preprocess(e){let t,n;const i=[],r=e.length;for(t=0;t<r;t++){const o=e[t],a=o.entries,s=a.length;if(!Array.isArray(a)||s===0)throw new DeveloperError("entries must be an array with size > 0.");let l=[];for(n=0;n<s;n++){const p=a[n];if(!defined(p.height))throw new DeveloperError("entry requires a height.");if(!defined(p.color))throw new DeveloperError("entry requires a color.");const u=CesiumMath.clamp(p.height,createElevationBandMaterial._minimumHeight,createElevationBandMaterial._maximumHeight),m=Color.clone(p.color,scratchColor$1);m.red*=m.alpha,m.green*=m.alpha,m.blue*=m.alpha,l.push(createNewEntry(u,m))}let c=!0,d=!0;for(n=0;n<s-1;n++){const p=l[n+0],u=l[n+1];c=c&&p.height<=u.height,d=d&&p.height>=u.height}d?l=l.reverse():c||mergeSort(l,function(p,u){return CesiumMath.sign(p.height-u.height)});let h=defaultValue(o.extendDownwards,!1),f=defaultValue(o.extendUpwards,!1);l.length===1&&!h&&!f&&(h=!0,f=!0),h&&l.splice(0,0,createNewEntry(createElevationBandMaterial._minimumHeight,l[0].color)),f&&l.splice(l.length,0,createNewEntry(createElevationBandMaterial._maximumHeight,l[l.length-1].color)),l=removeDuplicates(l),i.push(l)}return i}function createLayeredEntries(e){const t=preprocess(e);let n=[],i=[],r;function o(c,d){n.push(createNewEntry(c,d))}function a(c,d,h){let f=Color.multiplyByScalar(h,1-d.alpha,scratchColorBlend);f=Color.add(f,d,f),o(c,f)}const s=t.length;for(r=0;r<s;r++){const c=t[r];let d=0,h=0;i=n,n=[];const f=c.length,p=i.length;for(;d<f||h<p;){const u=d<f?c[d]:void 0,m=d>0?c[d-1]:void 0,g=d<f-1?c[d+1]:void 0,_=h<p?i[h]:void 0,C=h>0?i[h-1]:void 0,A=h<p-1?i[h+1]:void 0;if(defined(u)&&defined(_)&&u.height===_.height){const S=defined(A)&&_.height===A.height,v=!defined(C),b=!defined(A),D=defined(g)&&u.height===g.height,I=!defined(m),L=!defined(g);S?D?(a(u.height,u.color,_.color),a(u.height,g.color,A.color)):I?(o(u.height,_.color),a(u.height,u.color,A.color)):L?(a(u.height,u.color,_.color),o(u.height,A.color)):(a(u.height,u.color,_.color),a(u.height,u.color,A.color)):v?D?(o(u.height,u.color),a(u.height,g.color,_.color)):L?(o(u.height,u.color),o(u.height,_.color)):(I||o(u.height,u.color),a(u.height,u.color,_.color)):b?D?(a(u.height,u.color,_.color),o(u.height,g.color)):I?(o(u.height,_.color),o(u.height,u.color)):L?a(u.height,u.color,_.color):(a(u.height,u.color,_.color),o(u.height,u.color)):D?(a(u.height,u.color,_.color),a(u.height,g.color,_.color)):I?(o(u.height,_.color),a(u.height,u.color,_.color)):L?(a(u.height,u.color,_.color),o(u.height,_.color)):a(u.height,u.color,_.color),d+=D?2:1,h+=S?2:1}else if(defined(u)&&defined(_)&&defined(C)&&u.height<_.height){const S=lerpEntryColor(u.height,C,_,scratchColorBelow);defined(m)?defined(g)?a(u.height,u.color,S):(a(u.height,u.color,S),o(u.height,S)):(o(u.height,S),a(u.height,u.color,S)),d++}else if(defined(_)&&defined(u)&&defined(m)&&_.height<u.height){const S=lerpEntryColor(_.height,m,u,scratchColorAbove);defined(C)?defined(A)?a(_.height,S,_.color):(a(_.height,S,_.color),o(_.height,S)):(o(_.height,S),a(_.height,S,_.color)),h++}else defined(u)&&(!defined(_)||u.height<_.height)?(defined(_)&&!defined(C)&&!defined(g)?(o(u.height,u.color),o(u.height,createElevationBandMaterial._emptyColor),o(_.height,createElevationBandMaterial._emptyColor)):(!defined(_)&&defined(C)&&!defined(m)&&(o(C.height,createElevationBandMaterial._emptyColor),o(u.height,createElevationBandMaterial._emptyColor)),o(u.height,u.color)),d++):defined(_)&&(!defined(u)||_.height<u.height)&&(o(_.height,_.color),h++)}}return removeDuplicates(n)}function createElevationBandMaterial(e){const{scene:t,layers:n}=defaultValue(e,defaultValue.EMPTY_OBJECT);Check.typeOf.object("options.scene",t),Check.defined("options.layers",n),Check.typeOf.number.greaterThan("options.layers.length",n.length,0);const{context:i}=t,r=createLayeredEntries(n),o=r.length;let a,s,l;if(!createElevationBandMaterial._useFloatTexture(i)){s=PixelDatatype.UNSIGNED_BYTE,l=PixelFormat.RGBA,a=new Uint8Array(o*4);for(let p=0;p<o;p++)Cartesian4.packFloat(r[p].height,scratchPackedFloat),Cartesian4.pack(scratchPackedFloat,a,p*4)}else{s=PixelDatatype.FLOAT,l=i.webgl2?PixelFormat.RED:PixelFormat.LUMINANCE,a=new Float32Array(o);for(let p=0;p<o;p++)a[p]=r[p].height}const d=Texture.create({context:i,pixelFormat:l,pixelDatatype:s,source:{arrayBufferView:a,width:o,height:1},sampler:new Sampler({wrapS:TextureWrap.CLAMP_TO_EDGE,wrapT:TextureWrap.CLAMP_TO_EDGE,minificationFilter:TextureMinificationFilter.NEAREST,magnificationFilter:TextureMagnificationFilter.NEAREST})}),h=new Uint8Array(o*4);for(let p=0;p<o;p++)r[p].color.toBytes(scratchColorBytes),h[p*4+0]=scratchColorBytes[0],h[p*4+1]=scratchColorBytes[1],h[p*4+2]=scratchColorBytes[2],h[p*4+3]=scratchColorBytes[3];const f=Texture.create({context:i,pixelFormat:PixelFormat.RGBA,pixelDatatype:PixelDatatype.UNSIGNED_BYTE,source:{arrayBufferView:h,width:o,height:1},sampler:new Sampler({wrapS:TextureWrap.CLAMP_TO_EDGE,wrapT:TextureWrap.CLAMP_TO_EDGE,minificationFilter:TextureMinificationFilter.LINEAR,magnificationFilter:TextureMagnificationFilter.LINEAR})});return Material.fromType("ElevationBand",{heights:d,colors:f})}createElevationBandMaterial._useFloatTexture=function(e){return e.floatingPointTexture};createElevationBandMaterial._maximumHeight=5906376425472;createElevationBandMaterial._minimumHeight=-5906376425472;createElevationBandMaterial._emptyColor=new Color(0,0,0,0);async function createGooglePhotorealistic3DTileset(e,t){if(t=defaultValue(t,{}),t.cacheBytes=defaultValue(t.cacheBytes,1536*1024*1024),t.maximumCacheOverflowBytes=defaultValue(t.maximumCacheOverflowBytes,1024*1024*1024),t.enableCollision=defaultValue(t.enableCollision,!0),e=defaultValue(e,GoogleMaps$1.defaultApiKey),!defined(e))return requestCachedIonTileset(t);let n;const i=GoogleMaps$1.getDefaultCredit();defined(i)&&(n=[i]);const r=new Resource({url:`${GoogleMaps$1.mapTilesApiEndpoint}3dtiles/root.json`,queryParameters:{key:e},credits:n});return Cesium3DTileset.fromUrl(r,t)}const metadataCache={};async function requestCachedIonTileset(e){let i=metadataCache[2275207];defined(i)||(i=IonResource.fromAssetId(2275207),metadataCache[2275207]=i);const r=await i;return Cesium3DTileset.fromUrl(r,e)}async function createOsmBuildingsAsync(e){const t=await Cesium3DTileset.fromIonAssetId(96188,e);e=defaultValue(e,defaultValue.EMPTY_OBJECT);let n=e.style;if(!defined(n)){const i=defaultValue(e.defaultColor,Color.WHITE).toCssColorString();n=new Cesium3DTileStyle({color:`Boolean(\${feature['cesium#color']}) ? color(\${feature['cesium#color']}) : ${i}`})}return t.style=n,t}function createTangentSpaceDebugPrimitive(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=[];let n=e.geometry;if(!defined(n))throw new DeveloperError("options.geometry is required.");(!defined(n.attributes)||!defined(n.primitiveType))&&(n=n.constructor.createGeometry(n));const i=n.attributes,r=Matrix4.clone(defaultValue(e.modelMatrix,Matrix4.IDENTITY)),o=defaultValue(e.length,1e4);if(defined(i.normal)&&t.push(new GeometryInstance({geometry:GeometryPipeline.createLineSegmentsForVectors(n,"normal",o),attributes:{color:new ColorGeometryInstanceAttribute(1,0,0,1)},modelMatrix:r})),defined(i.tangent)&&t.push(new GeometryInstance({geometry:GeometryPipeline.createLineSegmentsForVectors(n,"tangent",o),attributes:{color:new ColorGeometryInstanceAttribute(0,1,0,1)},modelMatrix:r})),defined(i.bitangent)&&t.push(new GeometryInstance({geometry:GeometryPipeline.createLineSegmentsForVectors(n,"bitangent",o),attributes:{color:new ColorGeometryInstanceAttribute(0,0,1,1)},modelMatrix:r})),t.length>0)return new Primitive({asynchronous:!1,geometryInstances:t,appearance:new PerInstanceColorAppearance({flat:!0,translucent:!1})})}const DepthViewPacked=`uniform sampler2D u_depthTexture;

in vec2 v_textureCoordinates;

void main()
{
    float z_window = czm_unpackDepth(texture(u_depthTexture, v_textureCoordinates));
    z_window = czm_reverseLogDepth(z_window);
    float n_range = czm_depthRange.near;
    float f_range = czm_depthRange.far;
    float z_ndc = (2.0 * z_window - n_range - f_range) / (f_range - n_range);
    float scale = pow(z_ndc * 0.5 + 0.5, 8.0);
    out_FragColor = vec4(mix(vec3(0.0), vec3(1.0), scale), 1.0);
}
`;function TextureUniform(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=defined(e.typedArray),n=defined(e.url);if(t===n)throw new DeveloperError("exactly one of options.typedArray, options.url must be defined");if(t&&(!defined(e.width)||!defined(e.height)))throw new DeveloperError("options.width and options.height are required when options.typedArray is defined");this.typedArray=e.typedArray,this.width=e.width,this.height=e.height,this.pixelFormat=defaultValue(e.pixelFormat,PixelFormat.RGBA),this.pixelDatatype=defaultValue(e.pixelDatatype,PixelDatatype.UNSIGNED_BYTE);let i=e.url;typeof i=="string"&&(i=Resource.createIfNeeded(i)),this.resource=i;const o=defaultValue(e.repeat,!0)?TextureWrap.REPEAT:TextureWrap.CLAMP_TO_EDGE;this.sampler=new Sampler({wrapS:o,wrapT:o,minificationFilter:e.minificationFilter,magnificationFilter:e.magnificationFilter,maximumAnisotropy:e.maximumAnisotropy})}const VaryingType={FLOAT:"float",VEC2:"vec2",VEC3:"vec3",VEC4:"vec4",MAT2:"mat2",MAT3:"mat2",MAT4:"mat4"},VaryingType$1=Object.freeze(VaryingType);function createTaskProcessorWorker(e){async function t({data:i}){const r=[],o={id:i.id,result:void 0,error:void 0};self.CESIUM_BASE_URL=i.baseUrl;try{const a=await e(i.parameters,r);o.result=a}catch(a){a instanceof Error?o.error={name:a.name,message:a.message,stack:a.stack}:o.error=a}i.canTransferArrayBuffer||(r.length=0);try{postMessage(o,r)}catch(a){o.result=void 0,o.error=`postMessage failed with error: ${formatError(a)}
  with responseMessage: ${JSON.stringify(o)}`,postMessage(o)}}function n(i){var r;postMessage({id:(r=i.data)==null?void 0:r.id,error:`postMessage failed with error: ${JSON.stringify(i)}`})}return self.onmessage=t,self.onmessageerror=n,self}var oldValue;typeof ko<"u"&&(oldValue=ko);(function(){/*!
 * Knockout JavaScript library v3.5.1
 * (c) The Knockout.js team - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */(function(){(function(e){var t=this||(0,eval)("this"),n=t.document,i=t.navigator,r=t.jQuery,o=t.JSON;r||typeof jQuery>"u"||(r=jQuery),function(a){a(t.ko={})}(function(a,s){function l(y,x){return y===null||typeof y in m?y===x:!1}function c(y,x){var T;return function(){T||(T=u.a.setTimeout(function(){T=e,y()},x))}}function d(y,x){var T;return function(){clearTimeout(T),T=u.a.setTimeout(y,x)}}function h(y,x){x&&x!=="change"?x==="beforeChange"?this.pc(y):this.gb(y,x):this.qc(y)}function f(y,x){x!==null&&x.s&&x.s()}function p(y,x){var T=this.qd,E=T[S];E.ra||(this.Qb&&this.mb[x]?(T.uc(x,y,this.mb[x]),this.mb[x]=null,--this.Qb):E.I[x]||T.uc(x,y,E.J?{da:y}:T.$c(y)),y.Ja&&y.gd())}var u=typeof a<"u"?a:{};u.b=function(y,x){for(var T=y.split("."),E=u,P=0;P<T.length-1;P++)E=E[T[P]];E[T[T.length-1]]=x},u.L=function(y,x,T){y[x]=T},u.version="3.5.1",u.b("version",u.version),u.options={deferUpdates:!1,useOnlyNativeEvents:!1,foreachHidesDestroyed:!1},u.a=function(){function y(F,G){for(var B in F)P.call(F,B)&&G(B,F[B])}function x(F,G){if(G)for(var B in G)P.call(G,B)&&(F[B]=G[B]);return F}function T(F,G){return F.__proto__=G,F}function E(F,G,B,W){var Y=F[G].match(k)||[];u.a.D(B.match(k),function(z){u.a.Na(Y,z,W)}),F[G]=Y.join(" ")}var P=Object.prototype.hasOwnProperty,M={__proto__:[]}instanceof Array,O=typeof Symbol=="function",V={},R={};V[i&&/Firefox\/2/i.test(i.userAgent)?"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"],V.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" "),y(V,function(F,G){if(G.length)for(var B=0,W=G.length;B<W;B++)R[G[B]]=F});var w={propertychange:!0},U=n&&function(){for(var F=3,G=n.createElement("div"),B=G.getElementsByTagName("i");G.innerHTML="<!--[if gt IE "+ ++F+"]><i></i><![endif]-->",B[0];);return 4<F?F:e}(),k=/\S+/g,H;return{Jc:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],D:function(F,G,B){for(var W=0,Y=F.length;W<Y;W++)G.call(B,F[W],W,F)},A:typeof Array.prototype.indexOf=="function"?function(F,G){return Array.prototype.indexOf.call(F,G)}:function(F,G){for(var B=0,W=F.length;B<W;B++)if(F[B]===G)return B;return-1},Lb:function(F,G,B){for(var W=0,Y=F.length;W<Y;W++)if(G.call(B,F[W],W,F))return F[W];return e},Pa:function(F,G){var B=u.a.A(F,G);0<B?F.splice(B,1):B===0&&F.shift()},wc:function(F){var G=[];return F&&u.a.D(F,function(B){0>u.a.A(G,B)&&G.push(B)}),G},Mb:function(F,G,B){var W=[];if(F)for(var Y=0,z=F.length;Y<z;Y++)W.push(G.call(B,F[Y],Y));return W},jb:function(F,G,B){var W=[];if(F)for(var Y=0,z=F.length;Y<z;Y++)G.call(B,F[Y],Y)&&W.push(F[Y]);return W},Nb:function(F,G){if(G instanceof Array)F.push.apply(F,G);else for(var B=0,W=G.length;B<W;B++)F.push(G[B]);return F},Na:function(F,G,B){var W=u.a.A(u.a.bc(F),G);0>W?B&&F.push(G):B||F.splice(W,1)},Ba:M,extend:x,setPrototypeOf:T,Ab:M?T:x,P:y,Ga:function(F,G,B){if(!F)return F;var W={},Y;for(Y in F)P.call(F,Y)&&(W[Y]=G.call(B,F[Y],Y,F));return W},Tb:function(F){for(;F.firstChild;)u.removeNode(F.firstChild)},Yb:function(F){F=u.a.la(F);for(var G=(F[0]&&F[0].ownerDocument||n).createElement("div"),B=0,W=F.length;B<W;B++)G.appendChild(u.oa(F[B]));return G},Ca:function(F,G){for(var B=0,W=F.length,Y=[];B<W;B++){var z=F[B].cloneNode(!0);Y.push(G?u.oa(z):z)}return Y},va:function(F,G){if(u.a.Tb(F),G)for(var B=0,W=G.length;B<W;B++)F.appendChild(G[B])},Xc:function(F,G){var B=F.nodeType?[F]:F;if(0<B.length){for(var W=B[0],Y=W.parentNode,z=0,X=G.length;z<X;z++)Y.insertBefore(G[z],W);for(z=0,X=B.length;z<X;z++)u.removeNode(B[z])}},Ua:function(F,G){if(F.length){for(G=G.nodeType===8&&G.parentNode||G;F.length&&F[0].parentNode!==G;)F.splice(0,1);for(;1<F.length&&F[F.length-1].parentNode!==G;)F.length--;if(1<F.length){var B=F[0],W=F[F.length-1];for(F.length=0;B!==W;)F.push(B),B=B.nextSibling;F.push(W)}}return F},Zc:function(F,G){7>U?F.setAttribute("selected",G):F.selected=G},Db:function(F){return F===null||F===e?"":F.trim?F.trim():F.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},Ud:function(F,G){return F=F||"",G.length>F.length?!1:F.substring(0,G.length)===G},vd:function(F,G){if(F===G)return!0;if(F.nodeType===11)return!1;if(G.contains)return G.contains(F.nodeType!==1?F.parentNode:F);if(G.compareDocumentPosition)return(G.compareDocumentPosition(F)&16)==16;for(;F&&F!=G;)F=F.parentNode;return!!F},Sb:function(F){return u.a.vd(F,F.ownerDocument.documentElement)},kd:function(F){return!!u.a.Lb(F,u.a.Sb)},R:function(F){return F&&F.tagName&&F.tagName.toLowerCase()},Ac:function(F){return u.onError?function(){try{return F.apply(this,arguments)}catch(G){throw u.onError&&u.onError(G),G}}:F},setTimeout:function(F,G){return setTimeout(u.a.Ac(F),G)},Gc:function(F){setTimeout(function(){throw u.onError&&u.onError(F),F},0)},B:function(F,G,B){var W=u.a.Ac(B);if(B=w[G],u.options.useOnlyNativeEvents||B||!r)if(B||typeof F.addEventListener!="function")if(typeof F.attachEvent<"u"){var Y=function(X){W.call(F,X)},z="on"+G;F.attachEvent(z,Y),u.a.K.za(F,function(){F.detachEvent(z,Y)})}else throw Error("Browser doesn't support addEventListener or attachEvent");else F.addEventListener(G,W,!1);else H||(H=typeof r(F).on=="function"?"on":"bind"),r(F)[H](G,W)},Fb:function(F,G){if(!F||!F.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var B;if(u.a.R(F)==="input"&&F.type&&G.toLowerCase()=="click"?(B=F.type,B=B=="checkbox"||B=="radio"):B=!1,u.options.useOnlyNativeEvents||!r||B)if(typeof n.createEvent=="function")if(typeof F.dispatchEvent=="function")B=n.createEvent(R[G]||"HTMLEvents"),B.initEvent(G,!0,!0,t,0,0,0,0,0,!1,!1,!1,!1,0,F),F.dispatchEvent(B);else throw Error("The supplied element doesn't support dispatchEvent");else if(B&&F.click)F.click();else if(typeof F.fireEvent<"u")F.fireEvent("on"+G);else throw Error("Browser doesn't support triggering events");else r(F).trigger(G)},f:function(F){return u.O(F)?F():F},bc:function(F){return u.O(F)?F.v():F},Eb:function(F,G,B){var W;G&&(typeof F.classList=="object"?(W=F.classList[B?"add":"remove"],u.a.D(G.match(k),function(Y){W.call(F.classList,Y)})):typeof F.className.baseVal=="string"?E(F.className,"baseVal",G,B):E(F,"className",G,B))},Bb:function(F,G){var B=u.a.f(G);(B===null||B===e)&&(B="");var W=u.h.firstChild(F);!W||W.nodeType!=3||u.h.nextSibling(W)?u.h.va(F,[F.ownerDocument.createTextNode(B)]):W.data=B,u.a.Ad(F)},Yc:function(F,G){if(F.name=G,7>=U)try{var B=F.name.replace(/[&<>'"]/g,function(W){return"&#"+W.charCodeAt(0)+";"});F.mergeAttributes(n.createElement("<input name='"+B+"'/>"),!1)}catch{}},Ad:function(F){9<=U&&(F=F.nodeType==1?F:F.parentNode,F.style&&(F.style.zoom=F.style.zoom))},wd:function(F){if(U){var G=F.style.width;F.style.width=0,F.style.width=G}},Pd:function(F,G){F=u.a.f(F),G=u.a.f(G);for(var B=[],W=F;W<=G;W++)B.push(W);return B},la:function(F){for(var G=[],B=0,W=F.length;B<W;B++)G.push(F[B]);return G},Da:function(F){return O?Symbol(F):F},Zd:U===6,$d:U===7,W:U,Lc:function(F,G){for(var B=u.a.la(F.getElementsByTagName("input")).concat(u.a.la(F.getElementsByTagName("textarea"))),W=typeof G=="string"?function(X){return X.name===G}:function(X){return G.test(X.name)},Y=[],z=B.length-1;0<=z;z--)W(B[z])&&Y.push(B[z]);return Y},Nd:function(F){return typeof F=="string"&&(F=u.a.Db(F))?o&&o.parse?o.parse(F):new Function("return "+F)():null},hc:function(F,G,B){if(!o||!o.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");return o.stringify(u.a.f(F),G,B)},Od:function(F,G,B){B=B||{};var W=B.params||{},Y=B.includeFields||this.Jc,z=F;if(typeof F=="object"&&u.a.R(F)==="form")for(var z=F.action,X=Y.length-1;0<=X;X--)for(var q=u.a.Lc(F,Y[X]),Q=q.length-1;0<=Q;Q--)W[q[Q].name]=q[Q].value;G=u.a.f(G);var Z=n.createElement("form");Z.style.display="none",Z.action=z,Z.method="post";for(var K in G)F=n.createElement("input"),F.type="hidden",F.name=K,F.value=u.a.hc(u.a.f(G[K])),Z.appendChild(F);y(W,function(J,se){var ae=n.createElement("input");ae.type="hidden",ae.name=J,ae.value=se,Z.appendChild(ae)}),n.body.appendChild(Z),B.submitter?B.submitter(Z):Z.submit(),setTimeout(function(){Z.parentNode.removeChild(Z)},0)}}}(),u.b("utils",u.a),u.b("utils.arrayForEach",u.a.D),u.b("utils.arrayFirst",u.a.Lb),u.b("utils.arrayFilter",u.a.jb),u.b("utils.arrayGetDistinctValues",u.a.wc),u.b("utils.arrayIndexOf",u.a.A),u.b("utils.arrayMap",u.a.Mb),u.b("utils.arrayPushAll",u.a.Nb),u.b("utils.arrayRemoveItem",u.a.Pa),u.b("utils.cloneNodes",u.a.Ca),u.b("utils.createSymbolOrString",u.a.Da),u.b("utils.extend",u.a.extend),u.b("utils.fieldsIncludedWithJsonPost",u.a.Jc),u.b("utils.getFormFields",u.a.Lc),u.b("utils.objectMap",u.a.Ga),u.b("utils.peekObservable",u.a.bc),u.b("utils.postJson",u.a.Od),u.b("utils.parseJson",u.a.Nd),u.b("utils.registerEventHandler",u.a.B),u.b("utils.stringifyJson",u.a.hc),u.b("utils.range",u.a.Pd),u.b("utils.toggleDomNodeCssClass",u.a.Eb),u.b("utils.triggerEvent",u.a.Fb),u.b("utils.unwrapObservable",u.a.f),u.b("utils.objectForEach",u.a.P),u.b("utils.addOrRemoveItem",u.a.Na),u.b("utils.setTextContent",u.a.Bb),u.b("unwrap",u.a.f),Function.prototype.bind||(Function.prototype.bind=function(y){var x=this;if(arguments.length===1)return function(){return x.apply(y,arguments)};var T=Array.prototype.slice.call(arguments,1);return function(){var E=T.slice(0);return E.push.apply(E,arguments),x.apply(y,E)}}),u.a.g=new function(){var y=0,x="__ko__"+new Date().getTime(),T={},E,P;return u.a.W?(E=function(M,O){var V=M[x];if(!V||V==="null"||!T[V]){if(!O)return e;V=M[x]="ko"+y++,T[V]={}}return T[V]},P=function(M){var O=M[x];return O?(delete T[O],M[x]=null,!0):!1}):(E=function(M,O){var V=M[x];return!V&&O&&(V=M[x]={}),V},P=function(M){return M[x]?(delete M[x],!0):!1}),{get:function(M,O){var V=E(M,!1);return V&&V[O]},set:function(M,O,V){(M=E(M,V!==e))&&(M[O]=V)},Ub:function(M,O,V){return M=E(M,!0),M[O]||(M[O]=V)},clear:P,Z:function(){return y+++x}}},u.b("utils.domData",u.a.g),u.b("utils.domData.clear",u.a.g.clear),u.a.K=new function(){function y(O,V){var R=u.a.g.get(O,E);return R===e&&V&&(R=[],u.a.g.set(O,E,R)),R}function x(O){var V=y(O,!1);if(V)for(var V=V.slice(0),R=0;R<V.length;R++)V[R](O);u.a.g.clear(O),u.a.K.cleanExternalData(O),M[O.nodeType]&&T(O.childNodes,!0)}function T(O,V){for(var R=[],w,U=0;U<O.length;U++)if((!V||O[U].nodeType===8)&&(x(R[R.length]=w=O[U]),O[U]!==w))for(;U--&&u.a.A(R,O[U])==-1;);}var E=u.a.g.Z(),P={1:!0,8:!0,9:!0},M={1:!0,9:!0};return{za:function(O,V){if(typeof V!="function")throw Error("Callback must be a function");y(O,!0).push(V)},yb:function(O,V){var R=y(O,!1);R&&(u.a.Pa(R,V),R.length==0&&u.a.g.set(O,E,e))},oa:function(O){return u.u.G(function(){P[O.nodeType]&&(x(O),M[O.nodeType]&&T(O.getElementsByTagName("*")))}),O},removeNode:function(O){u.oa(O),O.parentNode&&O.parentNode.removeChild(O)},cleanExternalData:function(O){r&&typeof r.cleanData=="function"&&r.cleanData([O])}}},u.oa=u.a.K.oa,u.removeNode=u.a.K.removeNode,u.b("cleanNode",u.oa),u.b("removeNode",u.removeNode),u.b("utils.domNodeDisposal",u.a.K),u.b("utils.domNodeDisposal.addDisposeCallback",u.a.K.za),u.b("utils.domNodeDisposal.removeDisposeCallback",u.a.K.yb),function(){var y=[0,"",""],x=[1,"<table>","</table>"],T=[3,"<table><tbody><tr>","</tr></tbody></table>"],E=[1,"<select multiple='multiple'>","</select>"],P={thead:x,tbody:x,tfoot:x,tr:[2,"<table><tbody>","</tbody></table>"],td:T,th:T,option:E,optgroup:E},M=8>=u.a.W;u.a.ua=function(O,V){var R;if(r){if(r.parseHTML)R=r.parseHTML(O,V)||[];else if((R=r.clean([O],V))&&R[0]){for(var w=R[0];w.parentNode&&w.parentNode.nodeType!==11;)w=w.parentNode;w.parentNode&&w.parentNode.removeChild(w)}}else{(R=V)||(R=n);var w=R.parentWindow||R.defaultView||t,U=u.a.Db(O).toLowerCase(),k=R.createElement("div"),H;for(H=(U=U.match(/^(?:\x3c!--.*?--\x3e\s*?)*?<([a-z]+)[\s>]/))&&P[U[1]]||y,U=H[0],H="ignored<div>"+H[1]+O+H[2]+"</div>",typeof w.innerShiv=="function"?k.appendChild(w.innerShiv(H)):(M&&R.body.appendChild(k),k.innerHTML=H,M&&k.parentNode.removeChild(k));U--;)k=k.lastChild;R=u.a.la(k.lastChild.childNodes)}return R},u.a.Md=function(O,V){var R=u.a.ua(O,V);return R.length&&R[0].parentElement||u.a.Yb(R)},u.a.fc=function(O,V){if(u.a.Tb(O),V=u.a.f(V),V!==null&&V!==e)if(typeof V!="string"&&(V=V.toString()),r)r(O).html(V);else for(var R=u.a.ua(V,O.ownerDocument),w=0;w<R.length;w++)O.appendChild(R[w])}}(),u.b("utils.parseHtmlFragment",u.a.ua),u.b("utils.setHtml",u.a.fc),u.aa=function(){function y(T,E){if(T){if(T.nodeType==8){var P=u.aa.Uc(T.nodeValue);P!=null&&E.push({ud:T,Kd:P})}else if(T.nodeType==1)for(var P=0,M=T.childNodes,O=M.length;P<O;P++)y(M[P],E)}}var x={};return{Xb:function(T){if(typeof T!="function")throw Error("You can only pass a function to ko.memoization.memoize()");var E=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);return x[E]=T,"<!--[ko_memo:"+E+"]-->"},bd:function(T,E){var P=x[T];if(P===e)throw Error("Couldn't find any memo with ID "+T+". Perhaps it's already been unmemoized.");try{return P.apply(null,E||[]),!0}finally{delete x[T]}},cd:function(T,E){var P=[];y(T,P);for(var M=0,O=P.length;M<O;M++){var V=P[M].ud,R=[V];E&&u.a.Nb(R,E),u.aa.bd(P[M].Kd,R),V.nodeValue="",V.parentNode&&V.parentNode.removeChild(V)}},Uc:function(T){return(T=T.match(/^\[ko_memo\:(.*?)\]$/))?T[1]:null}}}(),u.b("memoization",u.aa),u.b("memoization.memoize",u.aa.Xb),u.b("memoization.unmemoize",u.aa.bd),u.b("memoization.parseMemoText",u.aa.Uc),u.b("memoization.unmemoizeDomNodeAndDescendants",u.aa.cd),u.na=function(){function y(){if(P){for(var V=P,R=0,w;O<P;)if(w=E[O++]){if(O>V){if(5e3<=++R){O=P,u.a.Gc(Error("'Too much recursion' after processing "+R+" task groups."));break}V=P}try{w()}catch(U){u.a.Gc(U)}}}}function x(){y(),O=P=E.length=0}var T,E=[],P=0,M=1,O=0;return t.MutationObserver?T=function(V){var R=n.createElement("div");return new MutationObserver(V).observe(R,{attributes:!0}),function(){R.classList.toggle("foo")}}(x):T=n&&"onreadystatechange"in n.createElement("script")?function(V){var R=n.createElement("script");R.onreadystatechange=function(){R.onreadystatechange=null,n.documentElement.removeChild(R),R=null,V()},n.documentElement.appendChild(R)}:function(V){setTimeout(V,0)},{scheduler:T,zb:function(V){return P||u.na.scheduler(x),E[P++]=V,M++},cancel:function(V){V=V-(M-P),V>=O&&V<P&&(E[V]=null)},resetForTesting:function(){var V=P-O;return O=P=E.length=0,V},Sd:y}}(),u.b("tasks",u.na),u.b("tasks.schedule",u.na.zb),u.b("tasks.runEarly",u.na.Sd),u.Ta={throttle:function(y,x){y.throttleEvaluation=x;var T=null;return u.$({read:y,write:function(E){clearTimeout(T),T=u.a.setTimeout(function(){y(E)},x)}})},rateLimit:function(y,x){var T,E,P;typeof x=="number"?T=x:(T=x.timeout,E=x.method),y.Hb=!1,P=typeof E=="function"?E:E=="notifyWhenChangesStop"?d:c,y.ub(function(M){return P(M,T,x)})},deferred:function(y,x){if(x!==!0)throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");y.Hb||(y.Hb=!0,y.ub(function(T){var E,P=!1;return function(){if(!P){u.na.cancel(E),E=u.na.zb(T);try{P=!0,y.notifySubscribers(e,"dirty")}finally{P=!1}}}}))},notify:function(y,x){y.equalityComparer=x=="always"?null:l}};var m={undefined:1,boolean:1,number:1,string:1};u.b("extenders",u.Ta),u.ic=function(y,x,T){this.da=y,this.lc=x,this.mc=T,this.Ib=!1,this.fb=this.Jb=null,u.L(this,"dispose",this.s),u.L(this,"disposeWhenNodeIsRemoved",this.l)},u.ic.prototype.s=function(){this.Ib||(this.fb&&u.a.K.yb(this.Jb,this.fb),this.Ib=!0,this.mc(),this.da=this.lc=this.mc=this.Jb=this.fb=null)},u.ic.prototype.l=function(y){this.Jb=y,u.a.K.za(y,this.fb=this.s.bind(this))},u.T=function(){u.a.Ab(this,g),g.qb(this)};var g={qb:function(y){y.U={change:[]},y.sc=1},subscribe:function(y,x,T){var E=this;T=T||"change";var P=new u.ic(E,x?y.bind(x):y,function(){u.a.Pa(E.U[T],P),E.hb&&E.hb(T)});return E.Qa&&E.Qa(T),E.U[T]||(E.U[T]=[]),E.U[T].push(P),P},notifySubscribers:function(y,x){if(x=x||"change",x==="change"&&this.Gb(),this.Wa(x)){var T=x==="change"&&this.ed||this.U[x].slice(0);try{u.u.xc();for(var E=0,P;P=T[E];++E)P.Ib||P.lc(y)}finally{u.u.end()}}},ob:function(){return this.sc},Dd:function(y){return this.ob()!==y},Gb:function(){++this.sc},ub:function(y){var x=this,T=u.O(x),E,P,M,O,V;x.gb||(x.gb=x.notifySubscribers,x.notifySubscribers=h);var R=y(function(){x.Ja=!1,T&&O===x&&(O=x.nc?x.nc():x());var w=P||V&&x.sb(M,O);V=P=E=!1,w&&x.gb(M=O)});x.qc=function(w,U){U&&x.Ja||(V=!U),x.ed=x.U.change.slice(0),x.Ja=E=!0,O=w,R()},x.pc=function(w){E||(M=w,x.gb(w,"beforeChange"))},x.rc=function(){V=!0},x.gd=function(){x.sb(M,x.v(!0))&&(P=!0)}},Wa:function(y){return this.U[y]&&this.U[y].length},Bd:function(y){if(y)return this.U[y]&&this.U[y].length||0;var x=0;return u.a.P(this.U,function(T,E){T!=="dirty"&&(x+=E.length)}),x},sb:function(y,x){return!this.equalityComparer||!this.equalityComparer(y,x)},toString:function(){return"[object Object]"},extend:function(y){var x=this;return y&&u.a.P(y,function(T,E){var P=u.Ta[T];typeof P=="function"&&(x=P(x,E)||x)}),x}};u.L(g,"init",g.qb),u.L(g,"subscribe",g.subscribe),u.L(g,"extend",g.extend),u.L(g,"getSubscriptionsCount",g.Bd),u.a.Ba&&u.a.setPrototypeOf(g,Function.prototype),u.T.fn=g,u.Qc=function(y){return y!=null&&typeof y.subscribe=="function"&&typeof y.notifySubscribers=="function"},u.b("subscribable",u.T),u.b("isSubscribable",u.Qc),u.S=u.u=function(){function y(M){T.push(E),E=M}function x(){E=T.pop()}var T=[],E,P=0;return{xc:y,end:x,cc:function(M){if(E){if(!u.Qc(M))throw Error("Only subscribable things can act as dependencies");E.od.call(E.pd,M,M.fd||(M.fd=++P))}},G:function(M,O,V){try{return y(),M.apply(O,V||[])}finally{x()}},qa:function(){if(E)return E.o.qa()},Va:function(){if(E)return E.o.Va()},Ya:function(){if(E)return E.Ya},o:function(){if(E)return E.o}}}(),u.b("computedContext",u.S),u.b("computedContext.getDependenciesCount",u.S.qa),u.b("computedContext.getDependencies",u.S.Va),u.b("computedContext.isInitial",u.S.Ya),u.b("computedContext.registerDependency",u.S.cc),u.b("ignoreDependencies",u.Yd=u.u.G);var _=u.a.Da("_latestValue");u.ta=function(y){function x(){return 0<arguments.length?(x.sb(x[_],arguments[0])&&(x.ya(),x[_]=arguments[0],x.xa()),this):(u.u.cc(x),x[_])}return x[_]=y,u.a.Ba||u.a.extend(x,u.T.fn),u.T.fn.qb(x),u.a.Ab(x,C),u.options.deferUpdates&&u.Ta.deferred(x,!0),x};var C={equalityComparer:l,v:function(){return this[_]},xa:function(){this.notifySubscribers(this[_],"spectate"),this.notifySubscribers(this[_])},ya:function(){this.notifySubscribers(this[_],"beforeChange")}};u.a.Ba&&u.a.setPrototypeOf(C,u.T.fn);var A=u.ta.Ma="__ko_proto__";C[A]=u.ta,u.O=function(y){if((y=typeof y=="function"&&y[A])&&y!==C[A]&&y!==u.o.fn[A])throw Error("Invalid object that looks like an observable; possibly from another Knockout instance");return!!y},u.Za=function(y){return typeof y=="function"&&(y[A]===C[A]||y[A]===u.o.fn[A]&&y.Nc)},u.b("observable",u.ta),u.b("isObservable",u.O),u.b("isWriteableObservable",u.Za),u.b("isWritableObservable",u.Za),u.b("observable.fn",C),u.L(C,"peek",C.v),u.L(C,"valueHasMutated",C.xa),u.L(C,"valueWillMutate",C.ya),u.Ha=function(y){if(y=y||[],typeof y!="object"||!("length"in y))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");return y=u.ta(y),u.a.Ab(y,u.Ha.fn),y.extend({trackArrayChanges:!0})},u.Ha.fn={remove:function(y){for(var x=this.v(),T=[],E=typeof y!="function"||u.O(y)?function(O){return O===y}:y,P=0;P<x.length;P++){var M=x[P];if(E(M)){if(T.length===0&&this.ya(),x[P]!==M)throw Error("Array modified during remove; cannot remove item");T.push(M),x.splice(P,1),P--}}return T.length&&this.xa(),T},removeAll:function(y){if(y===e){var x=this.v(),T=x.slice(0);return this.ya(),x.splice(0,x.length),this.xa(),T}return y?this.remove(function(E){return 0<=u.a.A(y,E)}):[]},destroy:function(y){var x=this.v(),T=typeof y!="function"||u.O(y)?function(M){return M===y}:y;this.ya();for(var E=x.length-1;0<=E;E--){var P=x[E];T(P)&&(P._destroy=!0)}this.xa()},destroyAll:function(y){return y===e?this.destroy(function(){return!0}):y?this.destroy(function(x){return 0<=u.a.A(y,x)}):[]},indexOf:function(y){var x=this();return u.a.A(x,y)},replace:function(y,x){var T=this.indexOf(y);0<=T&&(this.ya(),this.v()[T]=x,this.xa())},sorted:function(y){var x=this().slice(0);return y?x.sort(y):x.sort()},reversed:function(){return this().slice(0).reverse()}},u.a.Ba&&u.a.setPrototypeOf(u.Ha.fn,u.ta.fn),u.a.D("pop push reverse shift sort splice unshift".split(" "),function(y){u.Ha.fn[y]=function(){var x=this.v();this.ya(),this.zc(x,y,arguments);var T=x[y].apply(x,arguments);return this.xa(),T===x?this:T}}),u.a.D(["slice"],function(y){u.Ha.fn[y]=function(){var x=this();return x[y].apply(x,arguments)}}),u.Pc=function(y){return u.O(y)&&typeof y.remove=="function"&&typeof y.push=="function"},u.b("observableArray",u.Ha),u.b("isObservableArray",u.Pc),u.Ta.trackArrayChanges=function(y,x){function T(){function k(){if(V){var H=[].concat(y.v()||[]),F;y.Wa("arrayChange")&&((!P||1<V)&&(P=u.a.Pb(R,H,y.Ob)),F=P),R=H,P=null,V=0,F&&F.length&&y.notifySubscribers(F,"arrayChange")}}E?k():(E=!0,O=y.subscribe(function(){++V},null,"spectate"),R=[].concat(y.v()||[]),P=null,M=y.subscribe(k))}if(y.Ob={},x&&typeof x=="object"&&u.a.extend(y.Ob,x),y.Ob.sparse=!0,!y.zc){var E=!1,P=null,M,O,V=0,R,w=y.Qa,U=y.hb;y.Qa=function(k){w&&w.call(y,k),k==="arrayChange"&&T()},y.hb=function(k){U&&U.call(y,k),k!=="arrayChange"||y.Wa("arrayChange")||(M&&M.s(),O&&O.s(),O=M=null,E=!1,R=e)},y.zc=function(k,H,F){function G(Z,K,J){return B[B.length]={status:Z,value:K,index:J}}if(E&&!V){var B=[],W=k.length,Y=F.length,z=0;switch(H){case"push":z=W;case"unshift":for(H=0;H<Y;H++)G("added",F[H],z+H);break;case"pop":z=W-1;case"shift":W&&G("deleted",k[z],z);break;case"splice":H=Math.min(Math.max(0,0>F[0]?W+F[0]:F[0]),W);for(var W=Y===1?W:Math.min(H+(F[1]||0),W),Y=H+Y-2,z=Math.max(W,Y),X=[],q=[],Q=2;H<z;++H,++Q)H<W&&q.push(G("deleted",k[H],H)),H<Y&&X.push(G("added",F[Q],H));u.a.Kc(q,X);break;default:return}P=B}}}};var S=u.a.Da("_state");u.o=u.$=function(y,x,T){function E(){if(0<arguments.length){if(typeof P=="function")P.apply(M.nb,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");return this}return M.ra||u.u.cc(E),(M.ka||M.J&&E.Xa())&&E.ha(),M.X}if(typeof y=="object"?T=y:(T=T||{},y&&(T.read=y)),typeof T.read!="function")throw Error("Pass a function that returns the value of the ko.computed");var P=T.write,M={X:e,sa:!0,ka:!0,rb:!1,jc:!1,ra:!1,wb:!1,J:!1,Wc:T.read,nb:x||T.owner,l:T.disposeWhenNodeIsRemoved||T.l||null,Sa:T.disposeWhen||T.Sa,Rb:null,I:{},V:0,Ic:null};return E[S]=M,E.Nc=typeof P=="function",u.a.Ba||u.a.extend(E,u.T.fn),u.T.fn.qb(E),u.a.Ab(E,v),T.pure?(M.wb=!0,M.J=!0,u.a.extend(E,b)):T.deferEvaluation&&u.a.extend(E,D),u.options.deferUpdates&&u.Ta.deferred(E,!0),M.l&&(M.jc=!0,M.l.nodeType||(M.l=null)),M.J||T.deferEvaluation||E.ha(),M.l&&E.ja()&&u.a.K.za(M.l,M.Rb=function(){E.s()}),E};var v={equalityComparer:l,qa:function(){return this[S].V},Va:function(){var y=[];return u.a.P(this[S].I,function(x,T){y[T.Ka]=T.da}),y},Vb:function(y){if(!this[S].V)return!1;var x=this.Va();return u.a.A(x,y)!==-1?!0:!!u.a.Lb(x,function(T){return T.Vb&&T.Vb(y)})},uc:function(y,x,T){if(this[S].wb&&x===this)throw Error("A 'pure' computed must not be called recursively");this[S].I[y]=T,T.Ka=this[S].V++,T.La=x.ob()},Xa:function(){var y,x,T=this[S].I;for(y in T)if(Object.prototype.hasOwnProperty.call(T,y)&&(x=T[y],this.Ia&&x.da.Ja||x.da.Dd(x.La)))return!0},Jd:function(){this.Ia&&!this[S].rb&&this.Ia(!1)},ja:function(){var y=this[S];return y.ka||0<y.V},Rd:function(){this.Ja?this[S].ka&&(this[S].sa=!0):this.Hc()},$c:function(y){if(y.Hb){var x=y.subscribe(this.Jd,this,"dirty"),T=y.subscribe(this.Rd,this);return{da:y,s:function(){x.s(),T.s()}}}return y.subscribe(this.Hc,this)},Hc:function(){var y=this,x=y.throttleEvaluation;x&&0<=x?(clearTimeout(this[S].Ic),this[S].Ic=u.a.setTimeout(function(){y.ha(!0)},x)):y.Ia?y.Ia(!0):y.ha(!0)},ha:function(y){var x=this[S],T=x.Sa,E=!1;if(!x.rb&&!x.ra){if(x.l&&!u.a.Sb(x.l)||T&&T()){if(!x.jc){this.s();return}}else x.jc=!1;x.rb=!0;try{E=this.zd(y)}finally{x.rb=!1}return E}},zd:function(y){var x=this[S],E=!1,T=x.wb?e:!x.V,E={qd:this,mb:x.I,Qb:x.V};u.u.xc({pd:E,od:p,o:this,Ya:T}),x.I={},x.V=0;var P=this.yd(x,E);return x.V?E=this.sb(x.X,P):(this.s(),E=!0),E&&(x.J?this.Gb():this.notifySubscribers(x.X,"beforeChange"),x.X=P,this.notifySubscribers(x.X,"spectate"),!x.J&&y&&this.notifySubscribers(x.X),this.rc&&this.rc()),T&&this.notifySubscribers(x.X,"awake"),E},yd:function(y,x){try{var T=y.Wc;return y.nb?T.call(y.nb):T()}finally{u.u.end(),x.Qb&&!y.J&&u.a.P(x.mb,f),y.sa=y.ka=!1}},v:function(y){var x=this[S];return(x.ka&&(y||!x.V)||x.J&&this.Xa())&&this.ha(),x.X},ub:function(y){u.T.fn.ub.call(this,y),this.nc=function(){return this[S].J||(this[S].sa?this.ha():this[S].ka=!1),this[S].X},this.Ia=function(x){this.pc(this[S].X),this[S].ka=!0,x&&(this[S].sa=!0),this.qc(this,!x)}},s:function(){var y=this[S];!y.J&&y.I&&u.a.P(y.I,function(x,T){T.s&&T.s()}),y.l&&y.Rb&&u.a.K.yb(y.l,y.Rb),y.I=e,y.V=0,y.ra=!0,y.sa=!1,y.ka=!1,y.J=!1,y.l=e,y.Sa=e,y.Wc=e,this.Nc||(y.nb=e)}},b={Qa:function(y){var x=this,T=x[S];if(!T.ra&&T.J&&y=="change"){if(T.J=!1,T.sa||x.Xa())T.I=null,T.V=0,x.ha()&&x.Gb();else{var E=[];u.a.P(T.I,function(P,M){E[M.Ka]=P}),u.a.D(E,function(P,M){var O=T.I[P],V=x.$c(O.da);V.Ka=M,V.La=O.La,T.I[P]=V}),x.Xa()&&x.ha()&&x.Gb()}T.ra||x.notifySubscribers(T.X,"awake")}},hb:function(y){var x=this[S];x.ra||y!="change"||this.Wa("change")||(u.a.P(x.I,function(T,E){E.s&&(x.I[T]={da:E.da,Ka:E.Ka,La:E.La},E.s())}),x.J=!0,this.notifySubscribers(e,"asleep"))},ob:function(){var y=this[S];return y.J&&(y.sa||this.Xa())&&this.ha(),u.T.fn.ob.call(this)}},D={Qa:function(y){y!="change"&&y!="beforeChange"||this.v()}};u.a.Ba&&u.a.setPrototypeOf(v,u.T.fn);var I=u.ta.Ma;v[I]=u.o,u.Oc=function(y){return typeof y=="function"&&y[I]===v[I]},u.Fd=function(y){return u.Oc(y)&&y[S]&&y[S].wb},u.b("computed",u.o),u.b("dependentObservable",u.o),u.b("isComputed",u.Oc),u.b("isPureComputed",u.Fd),u.b("computed.fn",v),u.L(v,"peek",v.v),u.L(v,"dispose",v.s),u.L(v,"isActive",v.ja),u.L(v,"getDependenciesCount",v.qa),u.L(v,"getDependencies",v.Va),u.xb=function(y,x){return typeof y=="function"?u.o(y,x,{pure:!0}):(y=u.a.extend({},y),y.pure=!0,u.o(y,x))},u.b("pureComputed",u.xb),function(){function y(E,P,M){if(M=M||new T,E=P(E),typeof E!="object"||E===null||E===e||E instanceof RegExp||E instanceof Date||E instanceof String||E instanceof Number||E instanceof Boolean)return E;var O=E instanceof Array?[]:{};return M.save(E,O),x(E,function(V){var R=P(E[V]);switch(typeof R){case"boolean":case"number":case"string":case"function":O[V]=R;break;case"object":case"undefined":var w=M.get(R);O[V]=w!==e?w:y(R,P,M)}}),O}function x(E,P){if(E instanceof Array){for(var M=0;M<E.length;M++)P(M);typeof E.toJSON=="function"&&P("toJSON")}else for(M in E)P(M)}function T(){this.keys=[],this.values=[]}u.ad=function(E){if(arguments.length==0)throw Error("When calling ko.toJS, pass the object you want to convert.");return y(E,function(P){for(var M=0;u.O(P)&&10>M;M++)P=P();return P})},u.toJSON=function(E,P,M){return E=u.ad(E),u.a.hc(E,P,M)},T.prototype={constructor:T,save:function(E,P){var M=u.a.A(this.keys,E);0<=M?this.values[M]=P:(this.keys.push(E),this.values.push(P))},get:function(E){return E=u.a.A(this.keys,E),0<=E?this.values[E]:e}}}(),u.b("toJS",u.ad),u.b("toJSON",u.toJSON),u.Wd=function(y,x,T){function E(P){var M=u.xb(y,T).extend({ma:"always"}),O=M.subscribe(function(V){V&&(O.s(),P(V))});return M.notifySubscribers(M.v()),O}return typeof Promise!="function"||x?E(x.bind(T)):new Promise(E)},u.b("when",u.Wd),function(){u.w={M:function(y){switch(u.a.R(y)){case"option":return y.__ko__hasDomDataOptionValue__===!0?u.a.g.get(y,u.c.options.$b):7>=u.a.W?y.getAttributeNode("value")&&y.getAttributeNode("value").specified?y.value:y.text:y.value;case"select":return 0<=y.selectedIndex?u.w.M(y.options[y.selectedIndex]):e;default:return y.value}},cb:function(y,x,T){switch(u.a.R(y)){case"option":typeof x=="string"?(u.a.g.set(y,u.c.options.$b,e),"__ko__hasDomDataOptionValue__"in y&&delete y.__ko__hasDomDataOptionValue__,y.value=x):(u.a.g.set(y,u.c.options.$b,x),y.__ko__hasDomDataOptionValue__=!0,y.value=typeof x=="number"?x:"");break;case"select":(x===""||x===null)&&(x=e);for(var E=-1,P=0,M=y.options.length,O;P<M;++P)if(O=u.w.M(y.options[P]),O==x||O===""&&x===e){E=P;break}(T||0<=E||x===e&&1<y.size)&&(y.selectedIndex=E,u.a.W===6&&u.a.setTimeout(function(){y.selectedIndex=E},0));break;default:(x===null||x===e)&&(x=""),y.value=x}}}}(),u.b("selectExtensions",u.w),u.b("selectExtensions.readValue",u.w.M),u.b("selectExtensions.writeValue",u.w.cb),u.m=function(){function y(V){V=u.a.Db(V),V.charCodeAt(0)===123&&(V=V.slice(1,-1)),V+=`
,`;var R=[],w=V.match(E),U,k=[],H=0;if(1<w.length){for(var F=0,G;G=w[F];++F){var B=G.charCodeAt(0);if(B===44){if(0>=H){R.push(U&&k.length?{key:U,value:k.join("")}:{unknown:U||k.join("")}),U=H=0,k=[];continue}}else if(B===58){if(!H&&!U&&k.length===1){U=k.pop();continue}}else{if(B===47&&1<G.length&&(G.charCodeAt(1)===47||G.charCodeAt(1)===42))continue;B===47&&F&&1<G.length?(B=w[F-1].match(P))&&!M[B[0]]&&(V=V.substr(V.indexOf(G)+1),w=V.match(E),F=-1,G="/"):B===40||B===123||B===91?++H:B===41||B===125||B===93?--H:U||k.length||B!==34&&B!==39||(G=G.slice(1,-1))}k.push(G)}if(0<H)throw Error("Unbalanced parentheses, braces, or brackets")}return R}var x=["true","false","null","undefined"],T=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,E=RegExp(`"(?:\\\\.|[^"])*"|'(?:\\\\.|[^'])*'|\`(?:\\\\.|[^\`])*\`|/\\*(?:[^*]|\\*+[^*/])*\\*+/|//.*
|/(?:\\\\.|[^/])+/w*|[^\\s:,/][^,"'\`{}()/:[\\]]*[^\\s,"'\`{}()/:[\\]]|[^\\s]`,"g"),P=/[\])"'A-Za-z0-9_$]+$/,M={in:1,return:1,typeof:1},O={};return{Ra:[],wa:O,ac:y,vb:function(V,R){function w(B,W){var Y;if(!F){var z=u.getBindingHandler(B);if(z&&z.preprocess&&!(W=z.preprocess(W,B,w)))return;(z=O[B])&&(Y=W,0<=u.a.A(x,Y)?Y=!1:(z=Y.match(T),Y=z===null?!1:z[1]?"Object("+z[1]+")"+z[2]:Y),z=Y),z&&k.push("'"+(typeof O[B]=="string"?O[B]:B)+"':function(_z){"+Y+"=_z}")}H&&(W="function(){return "+W+" }"),U.push("'"+B+"':"+W)}R=R||{};var U=[],k=[],H=R.valueAccessors,F=R.bindingParams,G=typeof V=="string"?y(V):V;return u.a.D(G,function(B){w(B.key||B.unknown,B.value)}),k.length&&w("_ko_property_writers","{"+k.join(",")+" }"),U.join(",")},Id:function(V,R){for(var w=0;w<V.length;w++)if(V[w].key==R)return!0;return!1},eb:function(V,R,w,U,k){V&&u.O(V)?!u.Za(V)||k&&V.v()===U||V(U):(V=R.get("_ko_property_writers"))&&V[w]&&V[w](U)}}}(),u.b("expressionRewriting",u.m),u.b("expressionRewriting.bindingRewriteValidators",u.m.Ra),u.b("expressionRewriting.parseObjectLiteral",u.m.ac),u.b("expressionRewriting.preProcessBindings",u.m.vb),u.b("expressionRewriting._twoWayBindings",u.m.wa),u.b("jsonExpressionRewriting",u.m),u.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",u.m.vb),function(){function y(w){return w.nodeType==8&&M.test(P?w.text:w.nodeValue)}function x(w){return w.nodeType==8&&O.test(P?w.text:w.nodeValue)}function T(w,U){for(var k=w,H=1,F=[];k=k.nextSibling;){if(x(k)&&(u.a.g.set(k,R,!0),H--,H===0))return F;F.push(k),y(k)&&H++}if(!U)throw Error("Cannot find closing comment tag to match: "+w.nodeValue);return null}function E(w,U){var k=T(w,U);return k?0<k.length?k[k.length-1].nextSibling:w.nextSibling:null}var P=n&&n.createComment("test").text==="<!--test-->",M=P?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,O=P?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,V={ul:!0,ol:!0},R="__ko_matchedEndComment__";u.h={ea:{},childNodes:function(w){return y(w)?T(w):w.childNodes},Ea:function(w){if(y(w)){w=u.h.childNodes(w);for(var U=0,k=w.length;U<k;U++)u.removeNode(w[U])}else u.a.Tb(w)},va:function(w,U){if(y(w)){u.h.Ea(w);for(var k=w.nextSibling,H=0,F=U.length;H<F;H++)k.parentNode.insertBefore(U[H],k)}else u.a.va(w,U)},Vc:function(w,U){var k;y(w)?(k=w.nextSibling,w=w.parentNode):k=w.firstChild,k?U!==k&&w.insertBefore(U,k):w.appendChild(U)},Wb:function(w,U,k){k?(k=k.nextSibling,y(w)&&(w=w.parentNode),k?U!==k&&w.insertBefore(U,k):w.appendChild(U)):u.h.Vc(w,U)},firstChild:function(w){if(y(w))return!w.nextSibling||x(w.nextSibling)?null:w.nextSibling;if(w.firstChild&&x(w.firstChild))throw Error("Found invalid end comment, as the first child of "+w);return w.firstChild},nextSibling:function(w){if(y(w)&&(w=E(w)),w.nextSibling&&x(w.nextSibling)){var U=w.nextSibling;if(x(U)&&!u.a.g.get(U,R))throw Error("Found end comment without a matching opening comment, as child of "+w);return null}return w.nextSibling},Cd:y,Vd:function(w){return(w=(P?w.text:w.nodeValue).match(M))?w[1]:null},Sc:function(w){if(V[u.a.R(w)]){var U=w.firstChild;if(U)do if(U.nodeType===1){var k;k=U.firstChild;var H=null;if(k)do if(H)H.push(k);else if(y(k)){var F=E(k,!0);F?k=F:H=[k]}else x(k)&&(H=[k]);while(k=k.nextSibling);if(k=H)for(H=U.nextSibling,F=0;F<k.length;F++)H?w.insertBefore(k[F],H):w.appendChild(k[F])}while(U=U.nextSibling)}}}}(),u.b("virtualElements",u.h),u.b("virtualElements.allowedBindings",u.h.ea),u.b("virtualElements.emptyNode",u.h.Ea),u.b("virtualElements.insertAfter",u.h.Wb),u.b("virtualElements.prepend",u.h.Vc),u.b("virtualElements.setDomNodeChildren",u.h.va),function(){u.ga=function(){this.nd={}},u.a.extend(u.ga.prototype,{nodeHasBindings:function(y){switch(y.nodeType){case 1:return y.getAttribute("data-bind")!=null||u.j.getComponentNameForNode(y);case 8:return u.h.Cd(y);default:return!1}},getBindings:function(y,x){var T=this.getBindingsString(y,x),T=T?this.parseBindingsString(T,x,y):null;return u.j.tc(T,y,x,!1)},getBindingAccessors:function(y,x){var T=this.getBindingsString(y,x),T=T?this.parseBindingsString(T,x,y,{valueAccessors:!0}):null;return u.j.tc(T,y,x,!0)},getBindingsString:function(y){switch(y.nodeType){case 1:return y.getAttribute("data-bind");case 8:return u.h.Vd(y);default:return null}},parseBindingsString:function(y,x,T,E){try{var P=this.nd,M=y+(E&&E.valueAccessors||""),O;if(!(O=P[M])){var V,R="with($context){with($data||{}){return{"+u.m.vb(y,E)+"}}}";V=new Function("$context","$element",R),O=P[M]=V}return O(x,T)}catch(w){throw w.message=`Unable to parse bindings.
Bindings value: `+y+`
Message: `+w.message,w}}}),u.ga.instance=new u.ga}(),u.b("bindingProvider",u.ga),function(){function y(z){var X=(z=u.a.g.get(z,Y))&&z.N;X&&(z.N=null,X.Tc())}function x(z,X,q){this.node=z,this.yc=X,this.kb=[],this.H=!1,X.N||u.a.K.za(z,y),q&&q.N&&(q.N.kb.push(z),this.Kb=q)}function T(z){return function(){return z}}function E(z){return z()}function P(z){return u.a.Ga(u.u.G(z),function(X,q){return function(){return z()[q]}})}function M(z,X,q){return typeof z=="function"?P(z.bind(null,X,q)):u.a.Ga(z,T)}function O(z,X){return P(this.getBindings.bind(this,z,X))}function V(z,X){var q=u.h.firstChild(X);if(q){var Q,Z=u.ga.instance,K=Z.preprocessNode;if(K){for(;Q=q;)q=u.h.nextSibling(Q),K.call(Z,Q);q=u.h.firstChild(X)}for(;Q=q;)q=u.h.nextSibling(Q),R(z,Q)}u.i.ma(X,u.i.H)}function R(z,X){var q=z,Q=X.nodeType===1;Q&&u.h.Sc(X),(Q||u.ga.instance.nodeHasBindings(X))&&(q=U(X,null,z).bindingContextForDescendants),q&&!B[u.a.R(X)]&&V(q,X)}function w(z){var X=[],q={},Q=[];return u.a.P(z,function Z(K){if(!q[K]){var J=u.getBindingHandler(K);J&&(J.after&&(Q.push(K),u.a.D(J.after,function(se){if(z[se]){if(u.a.A(Q,se)!==-1)throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+Q.join(", "));Z(se)}}),Q.length--),X.push({key:K,Mc:J})),q[K]=!0}}),X}function U(z,X,q){var Q=u.a.g.Ub(z,Y,{}),Z=Q.hd;if(!X){if(Z)throw Error("You cannot apply bindings multiple times to the same element.");Q.hd=!0}Z||(Q.context=q),Q.Zb||(Q.Zb={});var K;if(X&&typeof X!="function")K=X;else{var J=u.ga.instance,se=J.getBindingAccessors||O,ae=u.$(function(){return(K=X?X(q,z):se.call(J,z,q))&&(q[H]&&q[H](),q[G]&&q[G]()),K},null,{l:z});K&&ae.ja()||(ae=null)}var te=q,ee;if(K){var ce=function(){return u.a.Ga(ae?ae():K,E)},re=ae?function(ne){return function(){return E(ae()[ne])}}:function(ne){return K[ne]};ce.get=function(ne){return K[ne]&&E(re(ne))},ce.has=function(ne){return ne in K},u.i.H in K&&u.i.subscribe(z,u.i.H,function(){var ne=(0,K[u.i.H])();if(ne){var le=u.h.childNodes(z);le.length&&ne(le,u.Ec(le[0]))}}),u.i.pa in K&&(te=u.i.Cb(z,q),u.i.subscribe(z,u.i.pa,function(){var ne=(0,K[u.i.pa])();ne&&u.h.firstChild(z)&&ne(z)})),Q=w(K),u.a.D(Q,function(ne){var le=ne.Mc.init,$=ne.Mc.update,j=ne.key;if(z.nodeType===8&&!u.h.ea[j])throw Error("The binding '"+j+"' cannot be used with virtual elements");try{typeof le=="function"&&u.u.G(function(){var oe=le(z,re(j),ce,te.$data,te);if(oe&&oe.controlsDescendantBindings){if(ee!==e)throw Error("Multiple bindings ("+ee+" and "+j+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");ee=j}}),typeof $=="function"&&u.$(function(){$(z,re(j),ce,te.$data,te)},null,{l:z})}catch(oe){throw oe.message='Unable to process binding "'+j+": "+K[j]+`"
Message: `+oe.message,oe}})}return Q=ee===e,{shouldBindDescendants:Q,bindingContextForDescendants:Q&&te}}function k(z,X){return z&&z instanceof u.fa?z:new u.fa(z,e,e,X)}var H=u.a.Da("_subscribable"),F=u.a.Da("_ancestorBindingInfo"),G=u.a.Da("_dataDependency");u.c={};var B={script:!0,textarea:!0,template:!0};u.getBindingHandler=function(z){return u.c[z]};var W={};u.fa=function(z,X,q,Q,Z){function K(){var re=te?ae():ae,ne=u.a.f(re);return X?(u.a.extend(J,X),F in X&&(J[F]=X[F])):(J.$parents=[],J.$root=ne,J.ko=u),J[H]=ee,se?ne=J.$data:(J.$rawData=re,J.$data=ne),q&&(J[q]=ne),Q&&Q(J,X,ne),X&&X[H]&&!u.S.o().Vb(X[H])&&X[H](),ce&&(J[G]=ce),J.$data}var J=this,se=z===W,ae=se?e:z,te=typeof ae=="function"&&!u.O(ae),ee,ce=Z&&Z.dataDependency;Z&&Z.exportDependencies?K():(ee=u.xb(K),ee.v(),ee.ja()?ee.equalityComparer=null:J[H]=e)},u.fa.prototype.createChildContext=function(z,X,q,Q){if(!Q&&X&&typeof X=="object"&&(Q=X,X=Q.as,q=Q.extend),X&&Q&&Q.noChildContext){var Z=typeof z=="function"&&!u.O(z);return new u.fa(W,this,null,function(K){q&&q(K),K[X]=Z?z():z},Q)}return new u.fa(z,this,X,function(K,J){K.$parentContext=J,K.$parent=J.$data,K.$parents=(J.$parents||[]).slice(0),K.$parents.unshift(K.$parent),q&&q(K)},Q)},u.fa.prototype.extend=function(z,X){return new u.fa(W,this,null,function(q){u.a.extend(q,typeof z=="function"?z(q):z)},X)};var Y=u.a.g.Z();x.prototype.Tc=function(){this.Kb&&this.Kb.N&&this.Kb.N.sd(this.node)},x.prototype.sd=function(z){u.a.Pa(this.kb,z),!this.kb.length&&this.H&&this.Cc()},x.prototype.Cc=function(){this.H=!0,this.yc.N&&!this.kb.length&&(this.yc.N=null,u.a.K.yb(this.node,y),u.i.ma(this.node,u.i.pa),this.Tc())},u.i={H:"childrenComplete",pa:"descendantsComplete",subscribe:function(z,X,q,Q,Z){var K=u.a.g.Ub(z,Y,{});return K.Fa||(K.Fa=new u.T),Z&&Z.notifyImmediately&&K.Zb[X]&&u.u.G(q,Q,[z]),K.Fa.subscribe(q,Q,X)},ma:function(z,X){var q=u.a.g.get(z,Y);if(q&&(q.Zb[X]=!0,q.Fa&&q.Fa.notifySubscribers(z,X),X==u.i.H)){if(q.N)q.N.Cc();else if(q.N===e&&q.Fa&&q.Fa.Wa(u.i.pa))throw Error("descendantsComplete event not supported for bindings on this node")}},Cb:function(z,X){var q=u.a.g.Ub(z,Y,{});return q.N||(q.N=new x(z,q,X[F])),X[F]==q?X:X.extend(function(Q){Q[F]=q})}},u.Td=function(z){return(z=u.a.g.get(z,Y))&&z.context},u.ib=function(z,X,q){return z.nodeType===1&&u.h.Sc(z),U(z,X,k(q))},u.ld=function(z,X,q){return q=k(q),u.ib(z,M(X,q,z),q)},u.Oa=function(z,X){X.nodeType!==1&&X.nodeType!==8||V(k(z),X)},u.vc=function(z,X,q){if(!r&&t.jQuery&&(r=t.jQuery),2>arguments.length){if(X=n.body,!X)throw Error("ko.applyBindings: could not find document.body; has the document been loaded?")}else if(!X||X.nodeType!==1&&X.nodeType!==8)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");R(k(z,q),X)},u.Dc=function(z){return!z||z.nodeType!==1&&z.nodeType!==8?e:u.Td(z)},u.Ec=function(z){return(z=u.Dc(z))?z.$data:e},u.b("bindingHandlers",u.c),u.b("bindingEvent",u.i),u.b("bindingEvent.subscribe",u.i.subscribe),u.b("bindingEvent.startPossiblyAsyncContentBinding",u.i.Cb),u.b("applyBindings",u.vc),u.b("applyBindingsToDescendants",u.Oa),u.b("applyBindingAccessorsToNode",u.ib),u.b("applyBindingsToNode",u.ld),u.b("contextFor",u.Dc),u.b("dataFor",u.Ec)}(),function(y){function x(O,V){var R=Object.prototype.hasOwnProperty.call(P,O)?P[O]:y,w;R?R.subscribe(V):(R=P[O]=new u.T,R.subscribe(V),T(O,function(U,k){var H=!(!k||!k.synchronous);M[O]={definition:U,Gd:H},delete P[O],w||H?R.notifySubscribers(U):u.na.zb(function(){R.notifySubscribers(U)})}),w=!0)}function T(O,V){E("getConfig",[O],function(R){R?E("loadComponent",[O,R],function(w){V(w,R)}):V(null,null)})}function E(O,V,R,w){w||(w=u.j.loaders.slice(0));var U=w.shift();if(U){var k=U[O];if(k){var H=!1;if(k.apply(U,V.concat(function(F){H?R(null):F!==null?R(F):E(O,V,R,w)}))!==y&&(H=!0,!U.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.")}else E(O,V,R,w)}else R(null)}var P={},M={};u.j={get:function(O,V){var R=Object.prototype.hasOwnProperty.call(M,O)?M[O]:y;R?R.Gd?u.u.G(function(){V(R.definition)}):u.na.zb(function(){V(R.definition)}):x(O,V)},Bc:function(O){delete M[O]},oc:E},u.j.loaders=[],u.b("components",u.j),u.b("components.get",u.j.get),u.b("components.clearCachedDefinition",u.j.Bc)}(),function(){function y(R,w,U,k){function H(){--G===0&&k(F)}var F={},G=2,B=U.template;U=U.viewModel,B?P(w,B,function(W){u.j.oc("loadTemplate",[R,W],function(Y){F.template=Y,H()})}):H(),U?P(w,U,function(W){u.j.oc("loadViewModel",[R,W],function(Y){F[V]=Y,H()})}):H()}function x(R,w,U){if(typeof w=="function")U(function(H){return new w(H)});else if(typeof w[V]=="function")U(w[V]);else if("instance"in w){var k=w.instance;U(function(){return k})}else"viewModel"in w?x(R,w.viewModel,U):R("Unknown viewModel value: "+w)}function T(R){switch(u.a.R(R)){case"script":return u.a.ua(R.text);case"textarea":return u.a.ua(R.value);case"template":if(E(R.content))return u.a.Ca(R.content.childNodes)}return u.a.Ca(R.childNodes)}function E(R){return t.DocumentFragment?R instanceof DocumentFragment:R&&R.nodeType===11}function P(R,w,U){typeof w.require=="string"?s||t.require?(s||t.require)([w.require],function(k){k&&typeof k=="object"&&k.Xd&&k.default&&(k=k.default),U(k)}):R("Uses require, but no AMD loader is present"):U(w)}function M(R){return function(w){throw Error("Component '"+R+"': "+w)}}var O={};u.j.register=function(R,w){if(!w)throw Error("Invalid configuration for "+R);if(u.j.tb(R))throw Error("Component "+R+" is already registered");O[R]=w},u.j.tb=function(R){return Object.prototype.hasOwnProperty.call(O,R)},u.j.unregister=function(R){delete O[R],u.j.Bc(R)},u.j.Fc={getConfig:function(R,w){w(u.j.tb(R)?O[R]:null)},loadComponent:function(R,w,U){var k=M(R);P(k,w,function(H){y(R,k,H,U)})},loadTemplate:function(R,w,U){if(R=M(R),typeof w=="string")U(u.a.ua(w));else if(w instanceof Array)U(w);else if(E(w))U(u.a.la(w.childNodes));else if(w.element)if(w=w.element,t.HTMLElement?w instanceof HTMLElement:w&&w.tagName&&w.nodeType===1)U(T(w));else if(typeof w=="string"){var k=n.getElementById(w);k?U(T(k)):R("Cannot find element with ID "+w)}else R("Unknown element type: "+w);else R("Unknown template value: "+w)},loadViewModel:function(R,w,U){x(M(R),w,U)}};var V="createViewModel";u.b("components.register",u.j.register),u.b("components.isRegistered",u.j.tb),u.b("components.unregister",u.j.unregister),u.b("components.defaultLoader",u.j.Fc),u.j.loaders.push(u.j.Fc),u.j.dd=O}(),function(){function y(T,E){var P=T.getAttribute("params");if(P){var P=x.parseBindingsString(P,E,T,{valueAccessors:!0,bindingParams:!0}),P=u.a.Ga(P,function(V){return u.o(V,null,{l:T})}),M=u.a.Ga(P,function(V){var R=V.v();return V.ja()?u.o({read:function(){return u.a.f(V())},write:u.Za(R)&&function(w){V()(w)},l:T}):R});return Object.prototype.hasOwnProperty.call(M,"$raw")||(M.$raw=P),M}return{$raw:{}}}u.j.getComponentNameForNode=function(T){var E=u.a.R(T);if(u.j.tb(E)&&(E.indexOf("-")!=-1||""+T=="[object HTMLUnknownElement]"||8>=u.a.W&&T.tagName===E))return E},u.j.tc=function(T,E,P,M){if(E.nodeType===1){var O=u.j.getComponentNameForNode(E);if(O){if(T=T||{},T.component)throw Error('Cannot use the "component" binding on a custom element matching a component');var V={name:O,params:y(E,P)};T.component=M?function(){return V}:V}}return T};var x=new u.ga;9>u.a.W&&(u.j.register=function(T){return function(E){return T.apply(this,arguments)}}(u.j.register),n.createDocumentFragment=function(T){return function(){var E=T();return u.j.dd,E}}(n.createDocumentFragment))}(),function(){function y(E,P,M){if(P=P.template,!P)throw Error("Component '"+E+"' has no template");E=u.a.Ca(P),u.h.va(M,E)}function x(E,P,M){var O=E.createViewModel;return O?O.call(E,P,M):P}var T=0;u.c.component={init:function(E,P,M,O,V){function R(){var F=w&&w.dispose;typeof F=="function"&&F.call(w),k&&k.s(),U=w=k=null}var w,U,k,H=u.a.la(u.h.childNodes(E));return u.h.Ea(E),u.a.K.za(E,R),u.o(function(){var F=u.a.f(P()),G,B;if(typeof F=="string"?G=F:(G=u.a.f(F.name),B=u.a.f(F.params)),!G)throw Error("No component name specified");var W=u.i.Cb(E,V),Y=U=++T;u.j.get(G,function(z){if(U===Y){if(R(),!z)throw Error("Unknown component '"+G+"'");y(G,z,E);var X=x(z,B,{element:E,templateNodes:H});z=W.createChildContext(X,{extend:function(q){q.$component=X,q.$componentTemplateNodes=H}}),X&&X.koDescendantsComplete&&(k=u.i.subscribe(E,u.i.pa,X.koDescendantsComplete,X)),w=X,u.Oa(z,E)}})},null,{l:E}),{controlsDescendantBindings:!0}}},u.h.ea.component=!0}();var L={class:"className",for:"htmlFor"};u.c.attr={update:function(y,x){var T=u.a.f(x())||{};u.a.P(T,function(E,P){P=u.a.f(P);var M=E.indexOf(":"),M="lookupNamespaceURI"in y&&0<M&&y.lookupNamespaceURI(E.substr(0,M)),O=P===!1||P===null||P===e;O?M?y.removeAttributeNS(M,E):y.removeAttribute(E):P=P.toString(),8>=u.a.W&&E in L?(E=L[E],O?y.removeAttribute(E):y[E]=P):O||(M?y.setAttributeNS(M,E,P):y.setAttribute(E,P)),E==="name"&&u.a.Yc(y,O?"":P)})}},function(){u.c.checked={after:["value","attr"],init:function(y,x,T){function E(){var F=y.checked,G=M();if(!u.S.Ya()&&(F||!V&&!u.S.qa())){var B=u.u.G(x);if(w){var W=U?B.v():B,Y=H;H=G,Y!==G?F&&(u.a.Na(W,G,!0),u.a.Na(W,Y,!1)):u.a.Na(W,G,F),U&&u.Za(B)&&B(W)}else O&&(G===e?G=F:F||(G=e)),u.m.eb(B,T,"checked",G,!0)}}function P(){var F=u.a.f(x()),G=M();w?(y.checked=0<=u.a.A(F,G),H=G):y.checked=O&&G===e?!!F:M()===F}var M=u.xb(function(){if(T.has("checkedValue"))return u.a.f(T.get("checkedValue"));if(k)return T.has("value")?u.a.f(T.get("value")):y.value}),O=y.type=="checkbox",V=y.type=="radio";if(O||V){var R=x(),w=O&&u.a.f(R)instanceof Array,U=!(w&&R.push&&R.splice),k=V||w,H=w?M():e;V&&!y.name&&u.c.uniqueName.init(y,function(){return!0}),u.o(E,null,{l:y}),u.a.B(y,"click",E),u.o(P,null,{l:y}),R=e}}},u.m.wa.checked=!0,u.c.checkedValue={update:function(y,x){y.value=u.a.f(x())}}}(),u.c.class={update:function(y,x){var T=u.a.Db(u.a.f(x()));u.a.Eb(y,y.__ko__cssValue,!1),y.__ko__cssValue=T,u.a.Eb(y,T,!0)}},u.c.css={update:function(y,x){var T=u.a.f(x());T!==null&&typeof T=="object"?u.a.P(T,function(E,P){P=u.a.f(P),u.a.Eb(y,E,P)}):u.c.class.update(y,x)}},u.c.enable={update:function(y,x){var T=u.a.f(x());T&&y.disabled?y.removeAttribute("disabled"):T||y.disabled||(y.disabled=!0)}},u.c.disable={update:function(y,x){u.c.enable.update(y,function(){return!u.a.f(x())})}},u.c.event={init:function(y,x,T,E,P){var M=x()||{};u.a.P(M,function(O){typeof O=="string"&&u.a.B(y,O,function(V){var R,w=x()[O];if(w){try{var U=u.a.la(arguments);E=P.$data,U.unshift(E),R=w.apply(E,U)}finally{R!==!0&&(V.preventDefault?V.preventDefault():V.returnValue=!1)}T.get(O+"Bubble")===!1&&(V.cancelBubble=!0,V.stopPropagation&&V.stopPropagation())}})})}},u.c.foreach={Rc:function(y){return function(){var x=y(),T=u.a.bc(x);return!T||typeof T.length=="number"?{foreach:x,templateEngine:u.ba.Ma}:(u.a.f(x),{foreach:T.data,as:T.as,noChildContext:T.noChildContext,includeDestroyed:T.includeDestroyed,afterAdd:T.afterAdd,beforeRemove:T.beforeRemove,afterRender:T.afterRender,beforeMove:T.beforeMove,afterMove:T.afterMove,templateEngine:u.ba.Ma})}},init:function(y,x){return u.c.template.init(y,u.c.foreach.Rc(x))},update:function(y,x,T,E,P){return u.c.template.update(y,u.c.foreach.Rc(x),T,E,P)}},u.m.Ra.foreach=!1,u.h.ea.foreach=!0,u.c.hasfocus={init:function(y,x,T){function E(O){y.__ko_hasfocusUpdating=!0;var V=y.ownerDocument;if("activeElement"in V){var R;try{R=V.activeElement}catch{R=V.body}O=R===y}V=x(),u.m.eb(V,T,"hasfocus",O,!0),y.__ko_hasfocusLastValue=O,y.__ko_hasfocusUpdating=!1}var P=E.bind(null,!0),M=E.bind(null,!1);u.a.B(y,"focus",P),u.a.B(y,"focusin",P),u.a.B(y,"blur",M),u.a.B(y,"focusout",M),y.__ko_hasfocusLastValue=!1},update:function(y,x){var T=!!u.a.f(x());y.__ko_hasfocusUpdating||y.__ko_hasfocusLastValue===T||(T?y.focus():y.blur(),!T&&y.__ko_hasfocusLastValue&&y.ownerDocument.body.focus(),u.u.G(u.a.Fb,null,[y,T?"focusin":"focusout"]))}},u.m.wa.hasfocus=!0,u.c.hasFocus=u.c.hasfocus,u.m.wa.hasFocus="hasfocus",u.c.html={init:function(){return{controlsDescendantBindings:!0}},update:function(y,x){u.a.fc(y,x())}},function(){function y(x,T,E){u.c[x]={init:function(P,M,O,V,R){var w,U,k={},H,F,G;if(T){V=O.get("as");var B=O.get("noChildContext");G=!(V&&B),k={as:V,noChildContext:B,exportDependencies:G}}return F=(H=O.get("completeOn")=="render")||O.has(u.i.pa),u.o(function(){var W=u.a.f(M()),Y=!E!=!W,z=!U,X;(G||Y!==w)&&(F&&(R=u.i.Cb(P,R)),Y&&((!T||G)&&(k.dataDependency=u.S.o()),X=T?R.createChildContext(typeof W=="function"?W:M,k):u.S.qa()?R.extend(null,k):R),z&&u.S.qa()&&(U=u.a.Ca(u.h.childNodes(P),!0)),Y?(z||u.h.va(P,u.a.Ca(U)),u.Oa(X,P)):(u.h.Ea(P),H||u.i.ma(P,u.i.H)),w=Y)},null,{l:P}),{controlsDescendantBindings:!0}}},u.m.Ra[x]=!1,u.h.ea[x]=!0}y("if"),y("ifnot",!1,!0),y("with",!0)}(),u.c.let={init:function(y,x,T,E,P){return x=P.extend(x),u.Oa(x,y),{controlsDescendantBindings:!0}}},u.h.ea.let=!0;var N={};u.c.options={init:function(y){if(u.a.R(y)!=="select")throw Error("options binding applies only to SELECT elements");for(;0<y.length;)y.remove(0);return{controlsDescendantBindings:!0}},update:function(y,x,T){function E(){return u.a.jb(y.options,function(B){return B.selected})}function P(B,W,Y){var z=typeof W;return z=="function"?W(B):z=="string"?B[W]:Y}function M(B,W){if(F&&w)u.i.ma(y,u.i.H);else if(H.length){var Y=0<=u.a.A(H,u.w.M(W[0]));u.a.Zc(W[0],Y),F&&!Y&&u.u.G(u.a.Fb,null,[y,"change"])}}var O=y.multiple,V=y.length!=0&&O?y.scrollTop:null,R=u.a.f(x()),w=T.get("valueAllowUnset")&&T.has("value"),U=T.get("optionsIncludeDestroyed");x={};var k,H=[];w||(O?H=u.a.Mb(E(),u.w.M):0<=y.selectedIndex&&H.push(u.w.M(y.options[y.selectedIndex]))),R&&(typeof R.length>"u"&&(R=[R]),k=u.a.jb(R,function(B){return U||B===e||B===null||!u.a.f(B._destroy)}),T.has("optionsCaption")&&(R=u.a.f(T.get("optionsCaption")),R!==null&&R!==e&&k.unshift(N)));var F=!1;if(x.beforeRemove=function(B){y.removeChild(B)},R=M,T.has("optionsAfterRender")&&typeof T.get("optionsAfterRender")=="function"&&(R=function(B,W){M(0,W),u.u.G(T.get("optionsAfterRender"),null,[W[0],B!==N?B:e])}),u.a.ec(y,k,function(B,W,Y){return Y.length&&(H=!w&&Y[0].selected?[u.w.M(Y[0])]:[],F=!0),W=y.ownerDocument.createElement("option"),B===N?(u.a.Bb(W,T.get("optionsCaption")),u.w.cb(W,e)):(Y=P(B,T.get("optionsValue"),B),u.w.cb(W,u.a.f(Y)),B=P(B,T.get("optionsText"),Y),u.a.Bb(W,B)),[W]},x,R),!w){var G;O?G=H.length&&E().length<H.length:G=H.length&&0<=y.selectedIndex?u.w.M(y.options[y.selectedIndex])!==H[0]:H.length||0<=y.selectedIndex,G&&u.u.G(u.a.Fb,null,[y,"change"])}(w||u.S.Ya())&&u.i.ma(y,u.i.H),u.a.wd(y),V&&20<Math.abs(V-y.scrollTop)&&(y.scrollTop=V)}},u.c.options.$b=u.a.g.Z(),u.c.selectedOptions={init:function(y,x,T){function E(){var O=x(),V=[];u.a.D(y.getElementsByTagName("option"),function(R){R.selected&&V.push(u.w.M(R))}),u.m.eb(O,T,"selectedOptions",V)}function P(){var O=u.a.f(x()),V=y.scrollTop;O&&typeof O.length=="number"&&u.a.D(y.getElementsByTagName("option"),function(R){var w=0<=u.a.A(O,u.w.M(R));R.selected!=w&&u.a.Zc(R,w)}),y.scrollTop=V}if(u.a.R(y)!="select")throw Error("selectedOptions binding applies only to SELECT elements");var M;u.i.subscribe(y,u.i.H,function(){M?E():(u.a.B(y,"change",E),M=u.o(P,null,{l:y}))},null,{notifyImmediately:!0})},update:function(){}},u.m.wa.selectedOptions=!0,u.c.style={update:function(y,x){var T=u.a.f(x()||{});u.a.P(T,function(E,P){if(P=u.a.f(P),(P===null||P===e||P===!1)&&(P=""),r)r(y).css(E,P);else if(/^--/.test(E))y.style.setProperty(E,P);else{E=E.replace(/-(\w)/g,function(O,V){return V.toUpperCase()});var M=y.style[E];y.style[E]=P,P===M||y.style[E]!=M||isNaN(P)||(y.style[E]=P+"px")}})}},u.c.submit={init:function(y,x,T,E,P){if(typeof x()!="function")throw Error("The value for a submit binding must be a function");u.a.B(y,"submit",function(M){var O,V=x();try{O=V.call(P.$data,y)}finally{O!==!0&&(M.preventDefault?M.preventDefault():M.returnValue=!1)}})}},u.c.text={init:function(){return{controlsDescendantBindings:!0}},update:function(y,x){u.a.Bb(y,x())}},u.h.ea.text=!0,function(){if(t&&t.navigator){var y=function(k){if(k)return parseFloat(k[1])},x=t.navigator.userAgent,T,E,P,M,O;(T=t.opera&&t.opera.version&&parseInt(t.opera.version()))||(O=y(x.match(/Edge\/([^ ]+)$/)))||y(x.match(/Chrome\/([^ ]+)/))||(E=y(x.match(/Version\/([^ ]+) Safari/)))||(P=y(x.match(/Firefox\/([^ ]+)/)))||(M=u.a.W||y(x.match(/MSIE ([^ ]+)/)))||(M=y(x.match(/rv:([^ )]+)/)))}if(8<=M&&10>M)var V=u.a.g.Z(),R=u.a.g.Z(),w=function(k){var H=this.activeElement;(H=H&&u.a.g.get(H,R))&&H(k)},U=function(k,H){var F=k.ownerDocument;u.a.g.get(F,V)||(u.a.g.set(F,V,!0),u.a.B(F,"selectionchange",w)),u.a.g.set(k,R,H)};u.c.textInput={init:function(k,H,F){function G(K,J){u.a.B(k,K,J)}function B(){var K=u.a.f(H());(K===null||K===e)&&(K=""),q!==e&&K===q?u.a.setTimeout(B,4):k.value!==K&&(Z=!0,k.value=K,Z=!1,z=k.value)}function W(){X||(q=k.value,X=u.a.setTimeout(Y,4))}function Y(){clearTimeout(X),q=X=e;var K=k.value;z!==K&&(z=K,u.m.eb(H(),F,"textInput",K))}var z=k.value,X,q,Q=u.a.W==9?W:Y,Z=!1;M&&G("keypress",Y),11>M&&G("propertychange",function(K){Z||K.propertyName!=="value"||Q()}),M==8&&(G("keyup",Y),G("keydown",Y)),U&&(U(k,Q),G("dragend",W)),(!M||9<=M)&&G("input",Q),5>E&&u.a.R(k)==="textarea"?(G("keydown",W),G("paste",W),G("cut",W)):11>T?G("keydown",W):4>P?(G("DOMAutoComplete",Y),G("dragdrop",Y),G("drop",Y)):O&&k.type==="number"&&G("keydown",W),G("change",Y),G("blur",Y),u.o(B,null,{l:k})}},u.m.wa.textInput=!0,u.c.textinput={preprocess:function(k,H,F){F("textInput",k)}}}(),u.c.uniqueName={init:function(y,x){if(x()){var T="ko_unique_"+ ++u.c.uniqueName.rd;u.a.Yc(y,T)}}},u.c.uniqueName.rd=0,u.c.using={init:function(y,x,T,E,P){var M;return T.has("as")&&(M={as:T.get("as"),noChildContext:T.get("noChildContext")}),x=P.createChildContext(x,M),u.Oa(x,y),{controlsDescendantBindings:!0}}},u.h.ea.using=!0,u.c.value={init:function(y,x,T){var E=u.a.R(y),P=E=="input";if(!P||y.type!="checkbox"&&y.type!="radio"){var M=[],O=T.get("valueUpdate"),V=!1,R=null;O&&(typeof O=="string"?M=[O]:M=u.a.wc(O),u.a.Pa(M,"change"));var w=function(){R=null,V=!1;var H=x(),F=u.w.M(y);u.m.eb(H,T,"value",F)};!u.a.W||!P||y.type!="text"||y.autocomplete=="off"||y.form&&y.form.autocomplete=="off"||u.a.A(M,"propertychange")!=-1||(u.a.B(y,"propertychange",function(){V=!0}),u.a.B(y,"focus",function(){V=!1}),u.a.B(y,"blur",function(){V&&w()})),u.a.D(M,function(H){var F=w;u.a.Ud(H,"after")&&(F=function(){R=u.w.M(y),u.a.setTimeout(w,0)},H=H.substring(5)),u.a.B(y,H,F)});var U;if(U=P&&y.type=="file"?function(){var H=u.a.f(x());H===null||H===e||H===""?y.value="":u.u.G(w)}:function(){var H=u.a.f(x()),F=u.w.M(y);R!==null&&H===R?u.a.setTimeout(U,0):(H!==F||F===e)&&(E==="select"?(F=T.get("valueAllowUnset"),u.w.cb(y,H,F),F||H===u.w.M(y)||u.u.G(w)):u.w.cb(y,H))},E==="select"){var k;u.i.subscribe(y,u.i.H,function(){k?T.get("valueAllowUnset")?U():w():(u.a.B(y,"change",w),k=u.o(U,null,{l:y}))},null,{notifyImmediately:!0})}else u.a.B(y,"change",w),u.o(U,null,{l:y})}else u.ib(y,{checkedValue:x})},update:function(){}},u.m.wa.value=!0,u.c.visible={update:function(y,x){var T=u.a.f(x()),E=y.style.display!="none";T&&!E?y.style.display="":!T&&E&&(y.style.display="none")}},u.c.hidden={update:function(y,x){u.c.visible.update(y,function(){return!u.a.f(x())})}},function(y){u.c[y]={init:function(x,T,E,P,M){return u.c.event.init.call(this,x,function(){var O={};return O[y]=T(),O},E,P,M)}}}("click"),u.ca=function(){},u.ca.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource")},u.ca.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock")},u.ca.prototype.makeTemplateSource=function(y,x){if(typeof y=="string"){x=x||n;var T=x.getElementById(y);if(!T)throw Error("Cannot find template with ID "+y);return new u.C.F(T)}if(y.nodeType==1||y.nodeType==8)return new u.C.ia(y);throw Error("Unknown template type: "+y)},u.ca.prototype.renderTemplate=function(y,x,T,E){return y=this.makeTemplateSource(y,E),this.renderTemplateSource(y,x,T,E)},u.ca.prototype.isTemplateRewritten=function(y,x){return this.allowTemplateRewriting===!1?!0:this.makeTemplateSource(y,x).data("isRewritten")},u.ca.prototype.rewriteTemplate=function(y,x,T){y=this.makeTemplateSource(y,T),x=x(y.text()),y.text(x),y.data("isRewritten",!0)},u.b("templateEngine",u.ca),u.kc=function(){function y(E,P,M,O){E=u.m.ac(E);for(var V=u.m.Ra,R=0;R<E.length;R++){var w=E[R].key;if(Object.prototype.hasOwnProperty.call(V,w)){var U=V[w];if(typeof U=="function"){if(w=U(E[R].value))throw Error(w)}else if(!U)throw Error("This template engine does not support the '"+w+"' binding within its templates")}}return M="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+u.m.vb(E,{valueAccessors:!0})+" } })()},'"+M.toLowerCase()+"')",O.createJavaScriptEvaluatorBlock(M)+P}var x=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,T=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{xd:function(E,P,M){P.isTemplateRewritten(E,M)||P.rewriteTemplate(E,function(O){return u.kc.Ld(O,P)},M)},Ld:function(E,P){return E.replace(x,function(M,O,V,R,w){return y(w,O,V,P)}).replace(T,function(M,O){return y(O,"<!-- ko -->","#comment",P)})},md:function(E,P){return u.aa.Xb(function(M,O){var V=M.nextSibling;V&&V.nodeName.toLowerCase()===P&&u.ib(V,E,O)})}}}(),u.b("__tr_ambtns",u.kc.md),function(){u.C={},u.C.F=function(T){if(this.F=T){var E=u.a.R(T);this.ab=E==="script"?1:E==="textarea"?2:E=="template"&&T.content&&T.content.nodeType===11?3:4}},u.C.F.prototype.text=function(){var T=this.ab===1?"text":this.ab===2?"value":"innerHTML";if(arguments.length==0)return this.F[T];var E=arguments[0];T==="innerHTML"?u.a.fc(this.F,E):this.F[T]=E};var y=u.a.g.Z()+"_";u.C.F.prototype.data=function(T){if(arguments.length===1)return u.a.g.get(this.F,y+T);u.a.g.set(this.F,y+T,arguments[1])};var x=u.a.g.Z();u.C.F.prototype.nodes=function(){var T=this.F;if(arguments.length==0){var E=u.a.g.get(T,x)||{},P=E.lb||(this.ab===3?T.content:this.ab===4?T:e);if(!P||E.jd){var M=this.text();M&&M!==E.bb&&(P=u.a.Md(M,T.ownerDocument),u.a.g.set(T,x,{lb:P,bb:M,jd:!0}))}return P}E=arguments[0],this.ab!==e&&this.text(""),u.a.g.set(T,x,{lb:E})},u.C.ia=function(T){this.F=T},u.C.ia.prototype=new u.C.F,u.C.ia.prototype.constructor=u.C.ia,u.C.ia.prototype.text=function(){if(arguments.length==0){var T=u.a.g.get(this.F,x)||{};return T.bb===e&&T.lb&&(T.bb=T.lb.innerHTML),T.bb}u.a.g.set(this.F,x,{bb:arguments[0]})},u.b("templateSources",u.C),u.b("templateSources.domElement",u.C.F),u.b("templateSources.anonymousTemplate",u.C.ia)}(),function(){function y(R,w,U){var k;for(w=u.h.nextSibling(w);R&&(k=R)!==w;)R=u.h.nextSibling(k),U(k,R)}function x(R,w){if(R.length){var U=R[0],k=R[R.length-1],H=U.parentNode,F=u.ga.instance,G=F.preprocessNode;if(G){if(y(U,k,function(B,W){var Y=B.previousSibling,z=G.call(F,B);z&&(B===U&&(U=z[0]||W),B===k&&(k=z[z.length-1]||Y))}),R.length=0,!U)return;U===k?R.push(U):(R.push(U,k),u.a.Ua(R,H))}y(U,k,function(B){B.nodeType!==1&&B.nodeType!==8||u.vc(w,B)}),y(U,k,function(B){B.nodeType!==1&&B.nodeType!==8||u.aa.cd(B,[w])}),u.a.Ua(R,H)}}function T(R){return R.nodeType?R:0<R.length?R[0]:null}function E(R,w,U,k,H){H=H||{};var F=(R&&T(R)||U||{}).ownerDocument,G=H.templateEngine||M;if(u.kc.xd(U,G,F),U=G.renderTemplate(U,k,H,F),typeof U.length!="number"||0<U.length&&typeof U[0].nodeType!="number")throw Error("Template engine must return an array of DOM nodes");switch(F=!1,w){case"replaceChildren":u.h.va(R,U),F=!0;break;case"replaceNode":u.a.Xc(R,U),F=!0;break;case"ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+w)}return F&&(x(U,k),H.afterRender&&u.u.G(H.afterRender,null,[U,k[H.as||"$data"]]),w=="replaceChildren"&&u.i.ma(R,u.i.H)),U}function P(R,w,U){return u.O(R)?R():typeof R=="function"?R(w,U):R}var M;u.gc=function(R){if(R!=e&&!(R instanceof u.ca))throw Error("templateEngine must inherit from ko.templateEngine");M=R},u.dc=function(R,w,U,k,H){if(U=U||{},(U.templateEngine||M)==e)throw Error("Set a template engine before calling renderTemplate");if(H=H||"replaceChildren",k){var F=T(k);return u.$(function(){var B=w&&w instanceof u.fa?w:new u.fa(w,null,null,null,{exportDependencies:!0}),G=P(R,B.$data,B),B=E(k,H,G,B,U);H=="replaceNode"&&(k=B,F=T(k))},null,{Sa:function(){return!F||!u.a.Sb(F)},l:F&&H=="replaceNode"?F.parentNode:F})}return u.aa.Xb(function(G){u.dc(R,w,U,G,"replaceNode")})},u.Qd=function(R,w,U,k,H){function F(q,Q){u.u.G(u.a.ec,null,[k,q,B,U,G,Q]),u.i.ma(k,u.i.H)}function G(q,Q){x(Q,W),U.afterRender&&U.afterRender(Q,q),W=null}function B(q,Q){W=H.createChildContext(q,{as:Y,noChildContext:U.noChildContext,extend:function(K){K.$index=Q,Y&&(K[Y+"Index"]=Q)}});var Z=P(R,q,W);return E(k,"ignoreTargetNode",Z,W,U)}var W,Y=U.as,z=U.includeDestroyed===!1||u.options.foreachHidesDestroyed&&!U.includeDestroyed;if(z||U.beforeRemove||!u.Pc(w))return u.$(function(){var q=u.a.f(w)||[];typeof q.length>"u"&&(q=[q]),z&&(q=u.a.jb(q,function(Q){return Q===e||Q===null||!u.a.f(Q._destroy)})),F(q)},null,{l:k});F(w.v());var X=w.subscribe(function(q){F(w(),q)},null,"arrayChange");return X.l(k),X};var O=u.a.g.Z(),V=u.a.g.Z();u.c.template={init:function(R,w){var U=u.a.f(w());if(typeof U=="string"||"name"in U)u.h.Ea(R);else if("nodes"in U){if(U=U.nodes||[],u.O(U))throw Error('The "nodes" option must be a plain, non-observable array.');var k=U[0]&&U[0].parentNode;k&&u.a.g.get(k,V)||(k=u.a.Yb(U),u.a.g.set(k,V,!0)),new u.C.ia(R).nodes(k)}else if(U=u.h.childNodes(R),0<U.length)k=u.a.Yb(U),new u.C.ia(R).nodes(k);else throw Error("Anonymous template defined, but no template content was provided");return{controlsDescendantBindings:!0}},update:function(R,w,U,k,H){var F=w();w=u.a.f(F),U=!0,k=null,typeof w=="string"?w={}:(F="name"in w?w.name:R,"if"in w&&(U=u.a.f(w.if)),U&&"ifnot"in w&&(U=!u.a.f(w.ifnot)),U&&!F&&(U=!1)),"foreach"in w?k=u.Qd(F,U&&w.foreach||[],w,R,H):U?(U=H,"data"in w&&(U=H.createChildContext(w.data,{as:w.as,noChildContext:w.noChildContext,exportDependencies:!0})),k=u.dc(F,U,w,R)):u.h.Ea(R),H=k,(w=u.a.g.get(R,O))&&typeof w.s=="function"&&w.s(),u.a.g.set(R,O,!H||H.ja&&!H.ja()?e:H)}},u.m.Ra.template=function(R){return R=u.m.ac(R),R.length==1&&R[0].unknown||u.m.Id(R,"name")?null:"This template engine does not support anonymous templates nested within its templates"},u.h.ea.template=!0}(),u.b("setTemplateEngine",u.gc),u.b("renderTemplate",u.dc),u.a.Kc=function(y,x,T){if(y.length&&x.length){var E,P,M,O,V;for(E=P=0;(!T||E<T)&&(O=y[P]);++P){for(M=0;V=x[M];++M)if(O.value===V.value){O.moved=V.index,V.moved=O.index,x.splice(M,1),E=M=0;break}E+=M}}},u.a.Pb=function(){function y(x,T,E,P,M){var O=Math.min,V=Math.max,R=[],w,U=x.length,k,H=T.length,F=H-U||1,G=U+H+1,B,W,Y;for(w=0;w<=U;w++)for(W=B,R.push(B=[]),Y=O(H,w+F),k=V(0,w-1);k<=Y;k++)B[k]=k?w?x[w-1]===T[k-1]?W[k-1]:O(W[k]||G,B[k-1]||G)+1:k+1:w+1;for(O=[],V=[],F=[],w=U,k=H;w||k;)H=R[w][k]-1,k&&H===R[w][k-1]?V.push(O[O.length]={status:E,value:T[--k],index:k}):w&&H===R[w-1][k]?F.push(O[O.length]={status:P,value:x[--w],index:w}):(--k,--w,M.sparse||O.push({status:"retained",value:T[k]}));return u.a.Kc(F,V,!M.dontLimitMoves&&10*U),O.reverse()}return function(x,T,E){return E=typeof E=="boolean"?{dontLimitMoves:E}:E||{},x=x||[],T=T||[],x.length<T.length?y(x,T,"added","deleted",E):y(T,x,"deleted","added",E)}}(),u.b("utils.compareArrays",u.a.Pb),function(){function y(E,P,M,O,V){var R=[],w=u.$(function(){var U=P(M,V,u.a.Ua(R,E))||[];0<R.length&&(u.a.Xc(R,U),O&&u.u.G(O,null,[M,U,V])),R.length=0,u.a.Nb(R,U)},null,{l:E,Sa:function(){return!u.a.kd(R)}});return{Y:R,$:w.ja()?w:e}}var x=u.a.g.Z(),T=u.a.g.Z();u.a.ec=function(E,P,M,O,V,R){function w(ne){Z={Aa:ne,pb:u.ta(W++)},G.push(Z),F||Q.push(Z)}function U(ne){Z=H[ne],W!==Z.pb.v()&&q.push(Z),Z.pb(W++),u.a.Ua(Z.Y,E),G.push(Z)}function k(ne,le){if(ne)for(var $=0,j=le.length;$<j;$++)u.a.D(le[$].Y,function(oe){ne(oe,$,le[$].Aa)})}P=P||[],typeof P.length>"u"&&(P=[P]),O=O||{};var H=u.a.g.get(E,x),F=!H,G=[],B=0,W=0,Y=[],z=[],X=[],q=[],Q=[],Z,K=0;if(F)u.a.D(P,w);else{if(!R||H&&H._countWaitingForRemove){var J=u.a.Mb(H,function(ne){return ne.Aa});R=u.a.Pb(J,P,{dontLimitMoves:O.dontLimitMoves,sparse:!0})}for(var J=0,se,ae,te;se=R[J];J++)switch(ae=se.moved,te=se.index,se.status){case"deleted":for(;B<te;)U(B++);ae===e&&(Z=H[B],Z.$&&(Z.$.s(),Z.$=e),u.a.Ua(Z.Y,E).length&&(O.beforeRemove&&(G.push(Z),K++,Z.Aa===T?Z=null:X.push(Z)),Z&&Y.push.apply(Y,Z.Y))),B++;break;case"added":for(;W<te;)U(B++);ae!==e?(z.push(G.length),U(ae)):w(se.value)}for(;W<P.length;)U(B++);G._countWaitingForRemove=K}u.a.g.set(E,x,G),k(O.beforeMove,q),u.a.D(Y,O.beforeRemove?u.oa:u.removeNode);var ee,ce,re;try{re=E.ownerDocument.activeElement}catch{}if(z.length)for(;(J=z.shift())!=e;){for(Z=G[J],ee=e;J;)if((ce=G[--J].Y)&&ce.length){ee=ce[ce.length-1];break}for(P=0;B=Z.Y[P];ee=B,P++)u.h.Wb(E,B,ee)}for(J=0;Z=G[J];J++){for(Z.Y||u.a.extend(Z,y(E,M,Z.Aa,V,Z.pb)),P=0;B=Z.Y[P];ee=B,P++)u.h.Wb(E,B,ee);!Z.Ed&&V&&(V(Z.Aa,Z.Y,Z.pb),Z.Ed=!0,ee=Z.Y[Z.Y.length-1])}for(re&&E.ownerDocument.activeElement!=re&&re.focus(),k(O.beforeRemove,X),J=0;J<X.length;++J)X[J].Aa=T;k(O.afterMove,q),k(O.afterAdd,Q)}}(),u.b("utils.setDomNodeChildrenFromArrayMapping",u.a.ec),u.ba=function(){this.allowTemplateRewriting=!1},u.ba.prototype=new u.ca,u.ba.prototype.constructor=u.ba,u.ba.prototype.renderTemplateSource=function(y,x,T,E){return(x=!(9>u.a.W)&&y.nodes?y.nodes():null)?u.a.la(x.cloneNode(!0).childNodes):(y=y.text(),u.a.ua(y,E))},u.ba.Ma=new u.ba,u.gc(u.ba.Ma),u.b("nativeTemplateEngine",u.ba),function(){u.$a=function(){var x=this.Hd=function(){if(!r||!r.tmpl)return 0;try{if(0<=r.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch{}return 1}();this.renderTemplateSource=function(T,E,P,M){if(M=M||n,P=P||{},2>x)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var O=T.data("precompiled");return O||(O=T.text()||"",O=r.template(null,"{{ko_with $item.koBindingContext}}"+O+"{{/ko_with}}"),T.data("precompiled",O)),T=[E.$data],E=r.extend({koBindingContext:E},P.templateOptions),E=r.tmpl(O,T,E),E.appendTo(M.createElement("div")),r.fragments={},E},this.createJavaScriptEvaluatorBlock=function(T){return"{{ko_code ((function() { return "+T+" })()) }}"},this.addTemplate=function(T,E){n.write("<script type='text/html' id='"+T+"'>"+E+"<\/script>")},0<x&&(r.tmpl.tag.ko_code={open:"__.push($1 || '');"},r.tmpl.tag.ko_with={open:"with($1) {",close:"} "})},u.$a.prototype=new u.ca,u.$a.prototype.constructor=u.$a;var y=new u.$a;0<y.Hd&&u.gc(y),u.b("jqueryTmplTemplateEngine",u.$a)}()})})()})()})();var knockout=ko;typeof window<"u"?(ko=window.ko,typeof oldValue<"u"?window.ko=oldValue:delete window.ko):(ko=global.ko,typeof oldValue<"u"?global.ko=oldValue:delete global.ko);/**
 * @license
 * Knockout ES5 plugin - https://github.com/SteveSanderson/knockout-es5
 * Copyright (c) Steve Sanderson
 * MIT license
 */var OBSERVABLES_PROPERTY="__knockoutObservables",SUBSCRIBABLE_PROPERTY="__knockoutSubscribable";function track(e,t){if(!e)throw new Error("When calling ko.track, you must pass an object as the first parameter.");var n=this,i=getAllObservablesForObject(e,!0);return t=t||Object.getOwnPropertyNames(e),t.forEach(function(r){if(!(r===OBSERVABLES_PROPERTY||r===SUBSCRIBABLE_PROPERTY)&&!(r in i)){var o=e[r],a=o instanceof Array,s=n.isObservable(o)?o:a?n.observableArray(o):n.observable(o);Object.defineProperty(e,r,{configurable:!0,enumerable:!0,get:s,set:n.isWriteableObservable(s)?s:void 0}),i[r]=s,a&&notifyWhenPresentOrFutureArrayValuesMutate(n,s)}}),e}function getAllObservablesForObject(e,t){var n=e[OBSERVABLES_PROPERTY];return!n&&t&&(n={},Object.defineProperty(e,OBSERVABLES_PROPERTY,{value:n})),n}function defineComputedProperty(e,t,n){var i=this,r={owner:e,deferEvaluation:!0};if(typeof n=="function")r.read=n;else{if("value"in n)throw new Error('For ko.defineProperty, you must not specify a "value" for the property. You must provide a "get" function.');if(typeof n.get!="function")throw new Error('For ko.defineProperty, the third parameter must be either an evaluator function, or an options object containing a function called "get".');r.read=n.get,r.write=n.set}return e[t]=i.computed(r),track.call(i,e,[t]),e}function notifyWhenPresentOrFutureArrayValuesMutate(e,t){var n=null;e.computed(function(){n&&(n.dispose(),n=null);var i=t();i instanceof Array&&(n=startWatchingArrayInstance(e,t,i))})}function startWatchingArrayInstance(e,t,n){var i=getSubscribableForArray(e,n);return i.subscribe(t)}function getSubscribableForArray(e,t){var n=t[SUBSCRIBABLE_PROPERTY];if(!n){n=new e.subscribable,Object.defineProperty(t,SUBSCRIBABLE_PROPERTY,{value:n});var i={};wrapStandardArrayMutators(t,n,i),addKnockoutArrayMutators(e,t,n,i)}return n}function wrapStandardArrayMutators(e,t,n){["pop","push","reverse","shift","sort","splice","unshift"].forEach(function(i){var r=e[i];e[i]=function(){var o=r.apply(this,arguments);return n.pause!==!0&&t.notifySubscribers(this),o}})}function addKnockoutArrayMutators(e,t,n,i){["remove","removeAll","destroy","destroyAll","replace"].forEach(function(r){Object.defineProperty(t,r,{enumerable:!1,value:function(){var o;i.pause=!0;try{o=e.observableArray.fn[r].apply(e.observableArray(t),arguments)}finally{i.pause=!1}return n.notifySubscribers(t),o}})})}function getObservable(e,t){if(!e)return null;var n=getAllObservablesForObject(e,!1);return n&&n[t]||null}function valueHasMutated(e,t){var n=getObservable(e,t);n&&n.valueHasMutated()}function attachToKo(e){e.track=track,e.getObservable=getObservable,e.valueHasMutated=valueHasMutated,e.defineProperty=defineComputedProperty}const knockout_es5={attachToKo},svgNS$1="http://www.w3.org/2000/svg",svgClassName="cesium-svgPath-svg",SvgPathBindingHandler={register:function(e){e.bindingHandlers.cesiumSvgPath={init:function(t,n){const i=document.createElementNS(svgNS$1,"svg:svg");i.setAttribute("class",svgClassName);const r=document.createElementNS(svgNS$1,"path");return i.appendChild(r),e.virtualElements.setDomNodeChildren(t,[i]),e.computed({read:function(){const o=e.unwrap(n());r.setAttribute("d",e.unwrap(o.path));const a=e.unwrap(o.width),s=e.unwrap(o.height);i.setAttribute("width",a),i.setAttribute("height",s),i.setAttribute("viewBox",`0 0 ${a} ${s}`),o.css&&i.setAttribute("class",`${svgClassName} ${e.unwrap(o.css)}`)},disposeWhenNodeIsRemoved:t}),{controlsDescendantBindings:!0}}},e.virtualElements.allowedBindings.cesiumSvgPath=!0}},SvgPathBindingHandler$1=SvgPathBindingHandler;knockout_es5.attachToKo(knockout);SvgPathBindingHandler$1.register(knockout);function ClockViewModel(e){defined(e)||(e=new Clock),this._clock=e,this._eventHelper=new EventHelper,this._eventHelper.add(e.onTick,this.synchronize,this),this.systemTime=knockout.observable(JulianDate.now()),this.systemTime.equalityComparer=JulianDate.equals,this.startTime=knockout.observable(e.startTime),this.startTime.equalityComparer=JulianDate.equals,this.startTime.subscribe(function(t){e.startTime=t,this.synchronize()},this),this.stopTime=knockout.observable(e.stopTime),this.stopTime.equalityComparer=JulianDate.equals,this.stopTime.subscribe(function(t){e.stopTime=t,this.synchronize()},this),this.currentTime=knockout.observable(e.currentTime),this.currentTime.equalityComparer=JulianDate.equals,this.currentTime.subscribe(function(t){e.currentTime=t,this.synchronize()},this),this.multiplier=knockout.observable(e.multiplier),this.multiplier.subscribe(function(t){e.multiplier=t,this.synchronize()},this),this.clockStep=knockout.observable(e.clockStep),this.clockStep.subscribe(function(t){e.clockStep=t,this.synchronize()},this),this.clockRange=knockout.observable(e.clockRange),this.clockRange.subscribe(function(t){e.clockRange=t,this.synchronize()},this),this.canAnimate=knockout.observable(e.canAnimate),this.canAnimate.subscribe(function(t){e.canAnimate=t,this.synchronize()},this),this.shouldAnimate=knockout.observable(e.shouldAnimate),this.shouldAnimate.subscribe(function(t){e.shouldAnimate=t,this.synchronize()},this),knockout.track(this,["systemTime","startTime","stopTime","currentTime","multiplier","clockStep","clockRange","canAnimate","shouldAnimate"])}Object.defineProperties(ClockViewModel.prototype,{clock:{get:function(){return this._clock}}});ClockViewModel.prototype.synchronize=function(){const e=this._clock;this.systemTime=JulianDate.now(),this.startTime=e.startTime,this.stopTime=e.stopTime,this.currentTime=e.currentTime,this.multiplier=e.multiplier,this.clockStep=e.clockStep,this.clockRange=e.clockRange,this.canAnimate=e.canAnimate,this.shouldAnimate=e.shouldAnimate};ClockViewModel.prototype.isDestroyed=function(){return!1};ClockViewModel.prototype.destroy=function(){this._eventHelper.removeAll(),destroyObject(this)};function Command(){this.canExecute=void 0,this.beforeExecute=void 0,this.afterExecute=void 0,DeveloperError.throwInstantiationError()}const InspectorShared={};InspectorShared.createCheckbox=function(e,t,n){Check.typeOf.string("labelText",e),Check.typeOf.string("checkedBinding",t);const i=document.createElement("div"),r=document.createElement("label"),o=document.createElement("input");o.type="checkbox";let a=`checked: ${t}`;return defined(n)&&(a+=`, enable: ${n}`),o.setAttribute("data-bind",a),r.appendChild(o),r.appendChild(document.createTextNode(e)),i.appendChild(r),i};InspectorShared.createSection=function(e,t,n,i){Check.defined("panel",e),Check.typeOf.string("headerText",t),Check.typeOf.string("sectionVisibleBinding",n),Check.typeOf.string("toggleSectionVisibilityBinding",i);const r=document.createElement("div");r.className="cesium-cesiumInspector-section",r.setAttribute("data-bind",`css: { "cesium-cesiumInspector-section-collapsed": !${n} }`),e.appendChild(r);const o=document.createElement("h3");o.className="cesium-cesiumInspector-sectionHeader",o.appendChild(document.createTextNode(t)),o.setAttribute("data-bind",`click: ${i}`),r.appendChild(o);const a=document.createElement("div");return a.className="cesium-cesiumInspector-sectionContent",r.appendChild(a),a};InspectorShared.createRangeInput=function(e,t,n,i,r,o){Check.typeOf.string("rangeText",e),Check.typeOf.string("sliderValueBinding",t),Check.typeOf.number("min",n),Check.typeOf.number("max",i),o=defaultValue(o,t);const a=document.createElement("input");a.setAttribute("data-bind",`value: ${o}`),a.type="number";const s=document.createElement("input");s.type="range",s.min=n,s.max=i,s.step=defaultValue(r,"any"),s.setAttribute("data-bind",`valueUpdate: "input", value: ${t}`);const l=document.createElement("div");l.appendChild(s);const c=document.createElement("div");return c.className="cesium-cesiumInspector-slider",c.appendChild(document.createTextNode(e)),c.appendChild(a),c.appendChild(l),c};InspectorShared.createButton=function(e,t,n){Check.typeOf.string("buttonText",e),Check.typeOf.string("clickedBinding",t);const i=document.createElement("button");i.type="button",i.textContent=e,i.className="cesium-cesiumInspector-pickButton";let r=`click: ${t}`;return defined(n)&&(r+=`, css: {"cesium-cesiumInspector-pickButtonHighlight" : ${n}}`),i.setAttribute("data-bind",r),i};const InspectorShared$1=InspectorShared;function ToggleButtonViewModel(e,t){if(!defined(e))throw new DeveloperError("command is required.");this._command=e,t=defaultValue(t,defaultValue.EMPTY_OBJECT),this.toggled=defaultValue(t.toggled,!1),this.tooltip=defaultValue(t.tooltip,""),knockout.track(this,["toggled","tooltip"])}Object.defineProperties(ToggleButtonViewModel.prototype,{command:{get:function(){return this._command}}});function createCommand(e,t){if(!defined(e))throw new DeveloperError("func is required.");t=defaultValue(t,!0);const n=new Event,i=new Event;function r(){if(!r.canExecute)throw new DeveloperError("Cannot execute command, canExecute is false.");const o={args:arguments,cancel:!1};let a;return n.raiseEvent(o),o.cancel||(a=e.apply(null,arguments),i.raiseEvent(a)),a}return r.canExecute=t,knockout.track(r,["canExecute"]),Object.defineProperties(r,{beforeExecute:{value:n},afterExecute:{value:i}}),r}function subscribeAndEvaluate(e,t,n,i,r){return n.call(i,e[t]),knockout.getObservable(e,t).subscribe(n,i,r)}const svgNS="http://www.w3.org/2000/svg",xlinkNS="http://www.w3.org/1999/xlink";let widgetForDrag;const gradientEnabledColor0=Color.fromCssColorString("rgba(247,250,255,0.384)"),gradientEnabledColor1=Color.fromCssColorString("rgba(143,191,255,0.216)"),gradientEnabledColor2=Color.fromCssColorString("rgba(153,197,255,0.098)"),gradientEnabledColor3=Color.fromCssColorString("rgba(255,255,255,0.086)"),gradientDisabledColor0=Color.fromCssColorString("rgba(255,255,255,0.267)"),gradientDisabledColor1=Color.fromCssColorString("rgba(255,255,255,0)"),gradientKnobColor=Color.fromCssColorString("rgba(66,67,68,0.3)"),gradientPointerColor=Color.fromCssColorString("rgba(0,0,0,0.5)");function getElementColor(e){return Color.fromCssColorString(window.getComputedStyle(e).getPropertyValue("color"))}const svgIconsById={animation_pathReset:{tagName:"path",transform:"translate(16,16) scale(0.85) translate(-16,-16)",d:"M24.316,5.318,9.833,13.682,9.833,5.5,5.5,5.5,5.5,25.5,9.833,25.5,9.833,17.318,24.316,25.682z"},animation_pathPause:{tagName:"path",transform:"translate(16,16) scale(0.85) translate(-16,-16)",d:"M13,5.5,7.5,5.5,7.5,25.5,13,25.5zM24.5,5.5,19,5.5,19,25.5,24.5,25.5z"},animation_pathPlay:{tagName:"path",transform:"translate(16,16) scale(0.85) translate(-16,-16)",d:"M6.684,25.682L24.316,15.5L6.684,5.318V25.682z"},animation_pathPlayReverse:{tagName:"path",transform:"translate(16,16) scale(-0.85,0.85) translate(-16,-16)",d:"M6.684,25.682L24.316,15.5L6.684,5.318V25.682z"},animation_pathLoop:{tagName:"path",transform:"translate(16,16) scale(0.85) translate(-16,-16)",d:"M24.249,15.499c-0.009,4.832-3.918,8.741-8.75,8.75c-2.515,0-4.768-1.064-6.365-2.763l2.068-1.442l-7.901-3.703l0.744,8.694l2.193-1.529c2.244,2.594,5.562,4.242,9.26,4.242c6.767,0,12.249-5.482,12.249-12.249H24.249zM15.499,6.75c2.516,0,4.769,1.065,6.367,2.764l-2.068,1.443l7.901,3.701l-0.746-8.693l-2.192,1.529c-2.245-2.594-5.562-4.245-9.262-4.245C8.734,3.25,3.25,8.734,3.249,15.499H6.75C6.758,10.668,10.668,6.758,15.499,6.75z"},animation_pathClock:{tagName:"path",transform:"translate(16,16) scale(0.85) translate(-16,-15.5)",d:"M15.5,2.374C8.251,2.375,2.376,8.251,2.374,15.5C2.376,22.748,8.251,28.623,15.5,28.627c7.249-0.004,13.124-5.879,13.125-13.127C28.624,8.251,22.749,2.375,15.5,2.374zM15.5,25.623C9.909,25.615,5.385,21.09,5.375,15.5C5.385,9.909,9.909,5.384,15.5,5.374c5.59,0.01,10.115,4.535,10.124,10.125C25.615,21.09,21.091,25.615,15.5,25.623zM8.625,15.5c-0.001-0.552-0.448-0.999-1.001-1c-0.553,0-1,0.448-1,1c0,0.553,0.449,1,1,1C8.176,16.5,8.624,16.053,8.625,15.5zM8.179,18.572c-0.478,0.277-0.642,0.889-0.365,1.367c0.275,0.479,0.889,0.641,1.365,0.365c0.479-0.275,0.643-0.887,0.367-1.367C9.27,18.461,8.658,18.297,8.179,18.572zM9.18,10.696c-0.479-0.276-1.09-0.112-1.366,0.366s-0.111,1.09,0.365,1.366c0.479,0.276,1.09,0.113,1.367-0.366C9.821,11.584,9.657,10.973,9.18,10.696zM22.822,12.428c0.478-0.275,0.643-0.888,0.366-1.366c-0.275-0.478-0.89-0.642-1.366-0.366c-0.479,0.278-0.642,0.89-0.366,1.367C21.732,12.54,22.344,12.705,22.822,12.428zM12.062,21.455c-0.478-0.275-1.089-0.111-1.366,0.367c-0.275,0.479-0.111,1.09,0.366,1.365c0.478,0.277,1.091,0.111,1.365-0.365C12.704,22.344,12.54,21.732,12.062,21.455zM12.062,9.545c0.479-0.276,0.642-0.888,0.366-1.366c-0.276-0.478-0.888-0.642-1.366-0.366s-0.642,0.888-0.366,1.366C10.973,9.658,11.584,9.822,12.062,9.545zM22.823,18.572c-0.48-0.275-1.092-0.111-1.367,0.365c-0.275,0.479-0.112,1.092,0.367,1.367c0.477,0.275,1.089,0.113,1.365-0.365C23.464,19.461,23.3,18.848,22.823,18.572zM19.938,7.813c-0.477-0.276-1.091-0.111-1.365,0.366c-0.275,0.48-0.111,1.091,0.366,1.367s1.089,0.112,1.366-0.366C20.581,8.702,20.418,8.089,19.938,7.813zM23.378,14.5c-0.554,0.002-1.001,0.45-1.001,1c0.001,0.552,0.448,1,1.001,1c0.551,0,1-0.447,1-1C24.378,14.949,23.929,14.5,23.378,14.5zM15.501,6.624c-0.552,0-1,0.448-1,1l-0.466,7.343l-3.004,1.96c-0.478,0.277-0.642,0.889-0.365,1.365c0.275,0.479,0.889,0.643,1.365,0.367l3.305-1.676C15.39,16.99,15.444,17,15.501,17c0.828,0,1.5-0.671,1.5-1.5l-0.5-7.876C16.501,7.072,16.053,6.624,15.501,6.624zM15.501,22.377c-0.552,0-1,0.447-1,1s0.448,1,1,1s1-0.447,1-1S16.053,22.377,15.501,22.377zM18.939,21.455c-0.479,0.277-0.643,0.889-0.366,1.367c0.275,0.477,0.888,0.643,1.366,0.365c0.478-0.275,0.642-0.889,0.366-1.365C20.028,21.344,19.417,21.18,18.939,21.455z"},animation_pathWingButton:{tagName:"path",d:"m 4.5,0.5 c -2.216,0 -4,1.784 -4,4 l 0,24 c 0,2.216 1.784,4 4,4 l 13.71875,0 C 22.478584,27.272785 27.273681,22.511272 32.5,18.25 l 0,-13.75 c 0,-2.216 -1.784,-4 -4,-4 l -24,0 z"},animation_pathPointer:{tagName:"path",d:"M-15,-65,-15,-55,15,-55,15,-65,0,-95z"},animation_pathSwooshFX:{tagName:"path",d:"m 85,0 c 0,16.617 -4.813944,35.356 -13.131081,48.4508 h 6.099803 c 8.317138,-13.0948 13.13322,-28.5955 13.13322,-45.2124 0,-46.94483 -38.402714,-85.00262 -85.7743869,-85.00262 -1.0218522,0 -2.0373001,0.0241 -3.0506131,0.0589 45.958443,1.59437 82.723058,35.77285 82.723058,81.70532 z"}};function svgFromObject(e){const t=document.createElementNS(svgNS,e.tagName);for(const n in e)if(e.hasOwnProperty(n)&&n!=="tagName")if(n==="children"){const i=e.children.length;for(let r=0;r<i;++r)t.appendChild(svgFromObject(e.children[r]))}else n.indexOf("xlink:")===0?t.setAttributeNS(xlinkNS,n.substring(6),e[n]):n==="textContent"?t.textContent=e[n]:t.setAttribute(n,e[n]);return t}function svgText(e,t,n){const i=document.createElementNS(svgNS,"text");i.setAttribute("x",e),i.setAttribute("y",t),i.setAttribute("class","cesium-animation-svgText");const r=document.createElementNS(svgNS,"tspan");return r.textContent=n,i.appendChild(r),i}function setShuttleRingPointer(e,t,n){e.setAttribute("transform",`translate(100,100) rotate(${n})`),t.setAttribute("transform",`rotate(${n})`)}const makeColorStringScratch=new Color;function makeColorString(e,t){const n=t.alpha,i=1-n;return makeColorStringScratch.red=e.red*i+t.red*n,makeColorStringScratch.green=e.green*i+t.green*n,makeColorStringScratch.blue=e.blue*i+t.blue*n,makeColorStringScratch.toCssColorString()}function rectButton(e,t,n){const i=svgIconsById[n],r={tagName:"g",class:"cesium-animation-rectButton",transform:`translate(${e},${t})`,children:[{tagName:"rect",class:"cesium-animation-buttonGlow",width:32,height:32,rx:2,ry:2},{tagName:"rect",class:"cesium-animation-buttonMain",width:32,height:32,rx:4,ry:4},{class:"cesium-animation-buttonPath",id:n,tagName:i.tagName,transform:i.transform,d:i.d},{tagName:"title",textContent:""}]};return svgFromObject(r)}function wingButton(e,t,n){const i=svgIconsById[n],r=svgIconsById.animation_pathWingButton,o={tagName:"g",class:"cesium-animation-rectButton",transform:`translate(${e},${t})`,children:[{class:"cesium-animation-buttonGlow",id:"animation_pathWingButton",tagName:r.tagName,d:r.d},{class:"cesium-animation-buttonMain",id:"animation_pathWingButton",tagName:r.tagName,d:r.d},{class:"cesium-animation-buttonPath",id:n,tagName:i.tagName,transform:i.transform,d:i.d},{tagName:"title",textContent:""}]};return svgFromObject(o)}function setShuttleRingFromMouseOrTouch(e,t){const n=e._viewModel,i=n.shuttleRingDragging;if(!(i&&widgetForDrag!==e))if(t.type==="mousedown"||i&&t.type==="mousemove"||t.type==="touchstart"&&t.touches.length===1||i&&t.type==="touchmove"&&t.touches.length===1){const r=e._centerX,o=e._centerY,s=e._svgNode.getBoundingClientRect();let l,c;if(t.type==="touchstart"||t.type==="touchmove"?(l=t.touches[0].clientX,c=t.touches[0].clientY):(l=t.clientX,c=t.clientY),!i&&(l>s.right||l<s.left||c<s.top||c>s.bottom))return;const d=e._shuttleRingPointer.getBoundingClientRect(),h=l-r-s.left,f=c-o-s.top;let p=Math.atan2(f,h)*180/Math.PI+90;p>180&&(p-=360);const u=n.shuttleRingAngle;i||l<d.right&&l>d.left&&c>d.top&&c<d.bottom?(widgetForDrag=e,n.shuttleRingDragging=!0,n.shuttleRingAngle=p):p<u?n.slower():p>u&&n.faster(),t.preventDefault()}else e===widgetForDrag&&(widgetForDrag=void 0),n.shuttleRingDragging=!1}function SvgButton(e,t){this._viewModel=t,this.svgElement=e,this._enabled=void 0,this._toggled=void 0;const n=this;this._clickFunction=function(){const i=n._viewModel.command;i.canExecute&&i()},e.addEventListener("click",this._clickFunction,!0),this._subscriptions=[subscribeAndEvaluate(t,"toggled",this.setToggled,this),subscribeAndEvaluate(t,"tooltip",this.setTooltip,this),subscribeAndEvaluate(t.command,"canExecute",this.setEnabled,this)]}SvgButton.prototype.destroy=function(){this.svgElement.removeEventListener("click",this._clickFunction,!0);const e=this._subscriptions;for(let t=0,n=e.length;t<n;t++)e[t].dispose();destroyObject(this)};SvgButton.prototype.isDestroyed=function(){return!1};SvgButton.prototype.setEnabled=function(e){if(this._enabled!==e){if(this._enabled=e,!e){this.svgElement.setAttribute("class","cesium-animation-buttonDisabled");return}if(this._toggled){this.svgElement.setAttribute("class","cesium-animation-rectButton cesium-animation-buttonToggled");return}this.svgElement.setAttribute("class","cesium-animation-rectButton")}};SvgButton.prototype.setToggled=function(e){this._toggled!==e&&(this._toggled=e,this._enabled&&(e?this.svgElement.setAttribute("class","cesium-animation-rectButton cesium-animation-buttonToggled"):this.svgElement.setAttribute("class","cesium-animation-rectButton")))};SvgButton.prototype.setTooltip=function(e){this.svgElement.getElementsByTagName("title")[0].textContent=e};function Animation(e,t){if(!defined(e))throw new DeveloperError("container is required.");if(!defined(t))throw new DeveloperError("viewModel is required.");e=getElement(e),this._viewModel=t,this._container=e,this._centerX=0,this._centerY=0,this._defsElement=void 0,this._svgNode=void 0,this._topG=void 0,this._lastHeight=void 0,this._lastWidth=void 0;const n=e.ownerDocument,i=document.createElement("style");i.textContent=".cesium-animation-rectButton .cesium-animation-buttonGlow { filter: url(#animation_blurred); }.cesium-animation-rectButton .cesium-animation-buttonMain { fill: url(#animation_buttonNormal); }.cesium-animation-buttonToggled .cesium-animation-buttonMain { fill: url(#animation_buttonToggled); }.cesium-animation-rectButton:hover .cesium-animation-buttonMain { fill: url(#animation_buttonHovered); }.cesium-animation-buttonDisabled .cesium-animation-buttonMain { fill: url(#animation_buttonDisabled); }.cesium-animation-shuttleRingG .cesium-animation-shuttleRingSwoosh { fill: url(#animation_shuttleRingSwooshGradient); }.cesium-animation-shuttleRingG:hover .cesium-animation-shuttleRingSwoosh { fill: url(#animation_shuttleRingSwooshHovered); }.cesium-animation-shuttleRingPointer { fill: url(#animation_shuttleRingPointerGradient); }.cesium-animation-shuttleRingPausePointer { fill: url(#animation_shuttleRingPointerPaused); }.cesium-animation-knobOuter { fill: url(#animation_knobOuter); }.cesium-animation-knobInner { fill: url(#animation_knobInner); }",n.head.insertBefore(i,n.head.childNodes[0]);const r=document.createElement("div");r.className="cesium-animation-theme",r.innerHTML='<div class="cesium-animation-themeNormal"></div><div class="cesium-animation-themeHover"></div><div class="cesium-animation-themeSelect"></div><div class="cesium-animation-themeDisabled"></div><div class="cesium-animation-themeKnob"></div><div class="cesium-animation-themePointer"></div><div class="cesium-animation-themeSwoosh"></div><div class="cesium-animation-themeSwooshHover"></div>',this._theme=r,this._themeNormal=r.childNodes[0],this._themeHover=r.childNodes[1],this._themeSelect=r.childNodes[2],this._themeDisabled=r.childNodes[3],this._themeKnob=r.childNodes[4],this._themePointer=r.childNodes[5],this._themeSwoosh=r.childNodes[6],this._themeSwooshHover=r.childNodes[7];const o=document.createElementNS(svgNS,"svg:svg");this._svgNode=o,o.setAttributeNS("http://www.w3.org/2000/xmlns/","xmlns:xlink",xlinkNS);const a=document.createElementNS(svgNS,"g");this._topG=a,this._realtimeSVG=new SvgButton(wingButton(3,4,"animation_pathClock"),t.playRealtimeViewModel),this._playReverseSVG=new SvgButton(rectButton(44,99,"animation_pathPlayReverse"),t.playReverseViewModel),this._playForwardSVG=new SvgButton(rectButton(124,99,"animation_pathPlay"),t.playForwardViewModel),this._pauseSVG=new SvgButton(rectButton(84,99,"animation_pathPause"),t.pauseViewModel);const s=document.createElementNS(svgNS,"g");s.appendChild(this._realtimeSVG.svgElement),s.appendChild(this._playReverseSVG.svgElement),s.appendChild(this._playForwardSVG.svgElement),s.appendChild(this._pauseSVG.svgElement);const l=svgFromObject({tagName:"circle",class:"cesium-animation-shuttleRingBack",cx:100,cy:100,r:99});this._shuttleRingBackPanel=l;const c=svgIconsById.animation_pathSwooshFX,d=svgIconsById.animation_pathPointer,h=svgFromObject({tagName:"g",class:"cesium-animation-shuttleRingSwoosh",children:[{tagName:c.tagName,transform:"translate(100,97) scale(-1,1)",id:"animation_pathSwooshFX",d:c.d},{tagName:c.tagName,transform:"translate(100,97)",id:"animation_pathSwooshFX",d:c.d},{tagName:"line",x1:100,y1:8,x2:100,y2:22}]});this._shuttleRingSwooshG=h,this._shuttleRingPointer=svgFromObject({class:"cesium-animation-shuttleRingPointer",id:"animation_pathPointer",tagName:d.tagName,d:d.d});const f=svgFromObject({tagName:"g",transform:"translate(100,100)"});this._knobOuter=svgFromObject({tagName:"circle",class:"cesium-animation-knobOuter",cx:0,cy:0,r:71});const p=61,u=svgFromObject({tagName:"circle",class:"cesium-animation-knobInner",cx:0,cy:0,r:p});this._knobDate=svgText(0,-24,""),this._knobTime=svgText(0,-7,""),this._knobStatus=svgText(0,-41,"");const m=svgFromObject({tagName:"circle",class:"cesium-animation-blank",cx:0,cy:0,r:p}),g=document.createElementNS(svgNS,"g");g.setAttribute("class","cesium-animation-shuttleRingG"),e.appendChild(r),a.appendChild(g),a.appendChild(f),a.appendChild(s),g.appendChild(l),g.appendChild(h),g.appendChild(this._shuttleRingPointer),f.appendChild(this._knobOuter),f.appendChild(u),f.appendChild(this._knobDate),f.appendChild(this._knobTime),f.appendChild(this._knobStatus),f.appendChild(m),o.appendChild(a),e.appendChild(o);const _=this;function C(D){setShuttleRingFromMouseOrTouch(_,D)}this._mouseCallback=C,l.addEventListener("mousedown",C,!0),l.addEventListener("touchstart",C,!0),h.addEventListener("mousedown",C,!0),h.addEventListener("touchstart",C,!0),n.addEventListener("mousemove",C,!0),n.addEventListener("touchmove",C,!0),n.addEventListener("mouseup",C,!0),n.addEventListener("touchend",C,!0),n.addEventListener("touchcancel",C,!0),this._shuttleRingPointer.addEventListener("mousedown",C,!0),this._shuttleRingPointer.addEventListener("touchstart",C,!0),this._knobOuter.addEventListener("mousedown",C,!0),this._knobOuter.addEventListener("touchstart",C,!0);const A=this._knobTime.childNodes[0],S=this._knobDate.childNodes[0],v=this._knobStatus.childNodes[0];let b;this._subscriptions=[subscribeAndEvaluate(t.pauseViewModel,"toggled",function(D){b!==D&&(b=D,b?_._shuttleRingPointer.setAttribute("class","cesium-animation-shuttleRingPausePointer"):_._shuttleRingPointer.setAttribute("class","cesium-animation-shuttleRingPointer"))}),subscribeAndEvaluate(t,"shuttleRingAngle",function(D){setShuttleRingPointer(_._shuttleRingPointer,_._knobOuter,D)}),subscribeAndEvaluate(t,"dateLabel",function(D){S.textContent!==D&&(S.textContent=D)}),subscribeAndEvaluate(t,"timeLabel",function(D){A.textContent!==D&&(A.textContent=D)}),subscribeAndEvaluate(t,"multiplierLabel",function(D){v.textContent!==D&&(v.textContent=D)})],this.applyThemeChanges(),this.resize()}Object.defineProperties(Animation.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});Animation.prototype.isDestroyed=function(){return!1};Animation.prototype.destroy=function(){defined(this._observer)&&(this._observer.disconnect(),this._observer=void 0);const e=this._container.ownerDocument,t=this._mouseCallback;this._shuttleRingBackPanel.removeEventListener("mousedown",t,!0),this._shuttleRingBackPanel.removeEventListener("touchstart",t,!0),this._shuttleRingSwooshG.removeEventListener("mousedown",t,!0),this._shuttleRingSwooshG.removeEventListener("touchstart",t,!0),e.removeEventListener("mousemove",t,!0),e.removeEventListener("touchmove",t,!0),e.removeEventListener("mouseup",t,!0),e.removeEventListener("touchend",t,!0),e.removeEventListener("touchcancel",t,!0),this._shuttleRingPointer.removeEventListener("mousedown",t,!0),this._shuttleRingPointer.removeEventListener("touchstart",t,!0),this._knobOuter.removeEventListener("mousedown",t,!0),this._knobOuter.removeEventListener("touchstart",t,!0),this._container.removeChild(this._svgNode),this._container.removeChild(this._theme),this._realtimeSVG.destroy(),this._playReverseSVG.destroy(),this._playForwardSVG.destroy(),this._pauseSVG.destroy();const n=this._subscriptions;for(let i=0,r=n.length;i<r;i++)n[i].dispose();return destroyObject(this)};Animation.prototype.resize=function(){const e=this._container.clientWidth,t=this._container.clientHeight;if(e===this._lastWidth&&t===this._lastHeight)return;const n=this._svgNode,i=200,r=132;let o=e,a=t;e===0&&t===0?(o=i,a=r):e===0?(a=t,o=i*(t/r)):t===0&&(o=e,a=r*(e/i));const s=o/i,l=a/r;n.style.cssText=`width: ${o}px; height: ${a}px; position: absolute; bottom: 0; left: 0; overflow: hidden;`,n.setAttribute("width",o),n.setAttribute("height",a),n.setAttribute("viewBox",`0 0 ${o} ${a}`),this._topG.setAttribute("transform",`scale(${s},${l})`),this._centerX=Math.max(1,100*s),this._centerY=Math.max(1,100*l),this._lastHeight=e,this._lastWidth=t};Animation.prototype.applyThemeChanges=function(){const e=this._container.ownerDocument;if(!e.body.contains(this._container)){if(defined(this._observer))return;const d=this;d._observer=new MutationObserver(function(){e.body.contains(d._container)&&(d._observer.disconnect(),d._observer=void 0,d.applyThemeChanges())}),d._observer.observe(e,{childList:!0,subtree:!0});return}const t=getElementColor(this._themeNormal),n=getElementColor(this._themeHover),i=getElementColor(this._themeSelect),r=getElementColor(this._themeDisabled),o=getElementColor(this._themeKnob),a=getElementColor(this._themePointer),s=getElementColor(this._themeSwoosh),l=getElementColor(this._themeSwooshHover),c=svgFromObject({tagName:"defs",children:[{id:"animation_buttonNormal",tagName:"linearGradient",x1:"50%",y1:"0%",x2:"50%",y2:"100%",children:[{tagName:"stop",offset:"0%","stop-color":makeColorString(t,gradientEnabledColor0)},{tagName:"stop",offset:"12%","stop-color":makeColorString(t,gradientEnabledColor1)},{tagName:"stop",offset:"46%","stop-color":makeColorString(t,gradientEnabledColor2)},{tagName:"stop",offset:"81%","stop-color":makeColorString(t,gradientEnabledColor3)}]},{id:"animation_buttonHovered",tagName:"linearGradient",x1:"50%",y1:"0%",x2:"50%",y2:"100%",children:[{tagName:"stop",offset:"0%","stop-color":makeColorString(n,gradientEnabledColor0)},{tagName:"stop",offset:"12%","stop-color":makeColorString(n,gradientEnabledColor1)},{tagName:"stop",offset:"46%","stop-color":makeColorString(n,gradientEnabledColor2)},{tagName:"stop",offset:"81%","stop-color":makeColorString(n,gradientEnabledColor3)}]},{id:"animation_buttonToggled",tagName:"linearGradient",x1:"50%",y1:"0%",x2:"50%",y2:"100%",children:[{tagName:"stop",offset:"0%","stop-color":makeColorString(i,gradientEnabledColor0)},{tagName:"stop",offset:"12%","stop-color":makeColorString(i,gradientEnabledColor1)},{tagName:"stop",offset:"46%","stop-color":makeColorString(i,gradientEnabledColor2)},{tagName:"stop",offset:"81%","stop-color":makeColorString(i,gradientEnabledColor3)}]},{id:"animation_buttonDisabled",tagName:"linearGradient",x1:"50%",y1:"0%",x2:"50%",y2:"100%",children:[{tagName:"stop",offset:"0%","stop-color":makeColorString(r,gradientDisabledColor0)},{tagName:"stop",offset:"75%","stop-color":makeColorString(r,gradientDisabledColor1)}]},{id:"animation_blurred",tagName:"filter",width:"200%",height:"200%",x:"-50%",y:"-50%",children:[{tagName:"feGaussianBlur",stdDeviation:4,in:"SourceGraphic"}]},{id:"animation_shuttleRingSwooshGradient",tagName:"linearGradient",x1:"50%",y1:"0%",x2:"50%",y2:"100%",children:[{tagName:"stop",offset:"0%","stop-opacity":.2,"stop-color":s.toCssColorString()},{tagName:"stop",offset:"85%","stop-opacity":.85,"stop-color":s.toCssColorString()},{tagName:"stop",offset:"95%","stop-opacity":.05,"stop-color":s.toCssColorString()}]},{id:"animation_shuttleRingSwooshHovered",tagName:"linearGradient",x1:"50%",y1:"0%",x2:"50%",y2:"100%",children:[{tagName:"stop",offset:"0%","stop-opacity":.2,"stop-color":l.toCssColorString()},{tagName:"stop",offset:"85%","stop-opacity":.85,"stop-color":l.toCssColorString()},{tagName:"stop",offset:"95%","stop-opacity":.05,"stop-color":l.toCssColorString()}]},{id:"animation_shuttleRingPointerGradient",tagName:"linearGradient",x1:"0%",y1:"50%",x2:"100%",y2:"50%",children:[{tagName:"stop",offset:"0%","stop-color":a.toCssColorString()},{tagName:"stop",offset:"40%","stop-color":a.toCssColorString()},{tagName:"stop",offset:"60%","stop-color":makeColorString(a,gradientPointerColor)},{tagName:"stop",offset:"100%","stop-color":makeColorString(a,gradientPointerColor)}]},{id:"animation_shuttleRingPointerPaused",tagName:"linearGradient",x1:"0%",y1:"50%",x2:"100%",y2:"50%",children:[{tagName:"stop",offset:"0%","stop-color":"#CCC"},{tagName:"stop",offset:"40%","stop-color":"#CCC"},{tagName:"stop",offset:"60%","stop-color":"#555"},{tagName:"stop",offset:"100%","stop-color":"#555"}]},{id:"animation_knobOuter",tagName:"linearGradient",x1:"20%",y1:"0%",x2:"90%",y2:"100%",children:[{tagName:"stop",offset:"5%","stop-color":makeColorString(o,gradientEnabledColor0)},{tagName:"stop",offset:"60%","stop-color":makeColorString(o,gradientKnobColor)},{tagName:"stop",offset:"85%","stop-color":makeColorString(o,gradientEnabledColor1)}]},{id:"animation_knobInner",tagName:"linearGradient",x1:"20%",y1:"0%",x2:"90%",y2:"100%",children:[{tagName:"stop",offset:"5%","stop-color":makeColorString(o,gradientKnobColor)},{tagName:"stop",offset:"60%","stop-color":makeColorString(o,gradientEnabledColor0)},{tagName:"stop",offset:"85%","stop-color":makeColorString(o,gradientEnabledColor3)}]}]});defined(this._defsElement)?this._svgNode.replaceChild(c,this._defsElement):this._svgNode.appendChild(c),this._defsElement=c};const monthNames=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],realtimeShuttleRingAngle=15,maxShuttleRingAngle=105;function numberComparator(e,t){return e-t}function getTypicalMultiplierIndex(e,t){const n=binarySearch(t,e,numberComparator);return n<0?~n:n}function angleToMultiplier(e,t){if(Math.abs(e)<=realtimeShuttleRingAngle)return e/realtimeShuttleRingAngle;const n=realtimeShuttleRingAngle,i=maxShuttleRingAngle;let r;const o=0;let a;return e>0?(r=Math.log(t[t.length-1]),a=(r-o)/(i-n),Math.exp(o+a*(e-n))):(r=Math.log(-t[0]),a=(r-o)/(i-n),-Math.exp(o+a*(Math.abs(e)-n)))}function multiplierToAngle(e,t,n){if(n.clockStep===ClockStep$1.SYSTEM_CLOCK)return realtimeShuttleRingAngle;if(Math.abs(e)<=1)return e*realtimeShuttleRingAngle;const i=t[t.length-1];e>i?e=i:e<-i&&(e=-i);const r=realtimeShuttleRingAngle,o=maxShuttleRingAngle;let a;const s=0;let l;return e>0?(a=Math.log(i),l=(a-s)/(o-r),(Math.log(e)-s)/l+r):(a=Math.log(-t[0]),l=(a-s)/(o-r),-((Math.log(Math.abs(e))-s)/l+r))}function AnimationViewModel(e){if(!defined(e))throw new DeveloperError("clockViewModel is required.");const t=this;this._clockViewModel=e,this._allShuttleRingTicks=[],this._dateFormatter=AnimationViewModel.defaultDateFormatter,this._timeFormatter=AnimationViewModel.defaultTimeFormatter,this.shuttleRingDragging=!1,this.snapToTicks=!1,knockout.track(this,["_allShuttleRingTicks","_dateFormatter","_timeFormatter","shuttleRingDragging","snapToTicks"]),this._sortedFilteredPositiveTicks=[],this.setShuttleRingTicks(AnimationViewModel.defaultTicks),this.timeLabel=void 0,knockout.defineProperty(this,"timeLabel",function(){return t._timeFormatter(t._clockViewModel.currentTime,t)}),this.dateLabel=void 0,knockout.defineProperty(this,"dateLabel",function(){return t._dateFormatter(t._clockViewModel.currentTime,t)}),this.multiplierLabel=void 0,knockout.defineProperty(this,"multiplierLabel",function(){const a=t._clockViewModel;if(a.clockStep===ClockStep$1.SYSTEM_CLOCK)return"Today";const s=a.multiplier;return s%1===0?`${s.toFixed(0)}x`:`${s.toFixed(3).replace(/0{0,3}$/,"")}x`}),this.shuttleRingAngle=void 0,knockout.defineProperty(this,"shuttleRingAngle",{get:function(){return multiplierToAngle(e.multiplier,t._allShuttleRingTicks,e)},set:function(a){a=Math.max(Math.min(a,maxShuttleRingAngle),-maxShuttleRingAngle);const s=t._allShuttleRingTicks,l=t._clockViewModel;if(l.clockStep=ClockStep$1.SYSTEM_CLOCK_MULTIPLIER,Math.abs(a)===maxShuttleRingAngle){l.multiplier=a>0?s[s.length-1]:s[0];return}let c=angleToMultiplier(a,s);if(t.snapToTicks)c=s[getTypicalMultiplierIndex(c,s)];else if(c!==0){const d=Math.abs(c);if(d>100){const h=d.toFixed(0).length-2,f=Math.pow(10,h);c=Math.round(c/f)*f|0}else d>realtimeShuttleRingAngle?c=Math.round(c):d>1?c=+c.toFixed(1):d>0&&(c=+c.toFixed(2))}l.multiplier=c}}),this._canAnimate=void 0,knockout.defineProperty(this,"_canAnimate",function(){const a=t._clockViewModel,s=a.clockRange;if(t.shuttleRingDragging||s===ClockRange$1.UNBOUNDED)return!0;const l=a.multiplier,c=a.currentTime,d=a.startTime;let h=!1;if(s===ClockRange$1.LOOP_STOP)h=JulianDate.greaterThan(c,d)||c.equals(d)&&l>0;else{const f=a.stopTime;h=JulianDate.greaterThan(c,d)&&JulianDate.lessThan(c,f)||c.equals(d)&&l>0||c.equals(f)&&l<0}return h||(a.shouldAnimate=!1),h}),this._isSystemTimeAvailable=void 0,knockout.defineProperty(this,"_isSystemTimeAvailable",function(){const a=t._clockViewModel;if(a.clockRange===ClockRange$1.UNBOUNDED)return!0;const l=a.systemTime;return JulianDate.greaterThanOrEquals(l,a.startTime)&&JulianDate.lessThanOrEquals(l,a.stopTime)}),this._isAnimating=void 0,knockout.defineProperty(this,"_isAnimating",function(){return t._clockViewModel.shouldAnimate&&(t._canAnimate||t.shuttleRingDragging)});const n=createCommand(function(){const a=t._clockViewModel;a.shouldAnimate?a.shouldAnimate=!1:t._canAnimate&&(a.shouldAnimate=!0)});this._pauseViewModel=new ToggleButtonViewModel(n,{toggled:knockout.computed(function(){return!t._isAnimating}),tooltip:"Pause"});const i=createCommand(function(){const a=t._clockViewModel,s=a.multiplier;s>0&&(a.multiplier=-s),a.shouldAnimate=!0});this._playReverseViewModel=new ToggleButtonViewModel(i,{toggled:knockout.computed(function(){return t._isAnimating&&e.multiplier<0}),tooltip:"Play Reverse"});const r=createCommand(function(){const a=t._clockViewModel,s=a.multiplier;s<0&&(a.multiplier=-s),a.shouldAnimate=!0});this._playForwardViewModel=new ToggleButtonViewModel(r,{toggled:knockout.computed(function(){return t._isAnimating&&e.multiplier>0&&e.clockStep!==ClockStep$1.SYSTEM_CLOCK}),tooltip:"Play Forward"});const o=createCommand(function(){t._clockViewModel.clockStep=ClockStep$1.SYSTEM_CLOCK},knockout.getObservable(this,"_isSystemTimeAvailable"));this._playRealtimeViewModel=new ToggleButtonViewModel(o,{toggled:knockout.computed(function(){return e.clockStep===ClockStep$1.SYSTEM_CLOCK}),tooltip:knockout.computed(function(){return t._isSystemTimeAvailable?"Today (real-time)":"Current time not in range"})}),this._slower=createCommand(function(){const a=t._clockViewModel,s=t._allShuttleRingTicks,l=a.multiplier,c=getTypicalMultiplierIndex(l,s)-1;c>=0&&(a.multiplier=s[c])}),this._faster=createCommand(function(){const a=t._clockViewModel,s=t._allShuttleRingTicks,l=a.multiplier,c=getTypicalMultiplierIndex(l,s)+1;c<s.length&&(a.multiplier=s[c])})}AnimationViewModel.defaultDateFormatter=function(e,t){const n=JulianDate.toGregorianDate(e);return`${monthNames[n.month-1]} ${n.day} ${n.year}`};AnimationViewModel.defaultTicks=[.001,.002,.005,.01,.02,.05,.1,.25,.5,1,2,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,21600,43200,86400,172800,345600,604800];AnimationViewModel.defaultTimeFormatter=function(e,t){const n=JulianDate.toGregorianDate(e),i=Math.round(n.millisecond);return Math.abs(t._clockViewModel.multiplier)<1?`${n.hour.toString().padStart(2,"0")}:${n.minute.toString().padStart(2,"0")}:${n.second.toString().padStart(2,"0")}.${i.toString().padStart(3,"0")}`:`${n.hour.toString().padStart(2,"0")}:${n.minute.toString().padStart(2,"0")}:${n.second.toString().padStart(2,"0")} UTC`};AnimationViewModel.prototype.getShuttleRingTicks=function(){return this._sortedFilteredPositiveTicks.slice(0)};AnimationViewModel.prototype.setShuttleRingTicks=function(e){if(!defined(e))throw new DeveloperError("positiveTicks is required.");let t,n,i;const r={},o=this._sortedFilteredPositiveTicks;for(o.length=0,t=0,n=e.length;t<n;++t)i=e[t],r.hasOwnProperty(i)||(r[i]=!0,o.push(i));o.sort(numberComparator);const a=[];for(n=o.length,t=n-1;t>=0;--t)i=o[t],i!==0&&a.push(-i);Array.prototype.push.apply(a,o),this._allShuttleRingTicks=a};Object.defineProperties(AnimationViewModel.prototype,{slower:{get:function(){return this._slower}},faster:{get:function(){return this._faster}},clockViewModel:{get:function(){return this._clockViewModel}},pauseViewModel:{get:function(){return this._pauseViewModel}},playReverseViewModel:{get:function(){return this._playReverseViewModel}},playForwardViewModel:{get:function(){return this._playForwardViewModel}},playRealtimeViewModel:{get:function(){return this._playRealtimeViewModel}},dateFormatter:{get:function(){return this._dateFormatter},set:function(e){if(typeof e!="function")throw new DeveloperError("dateFormatter must be a function");this._dateFormatter=e}},timeFormatter:{get:function(){return this._timeFormatter},set:function(e){if(typeof e!="function")throw new DeveloperError("timeFormatter must be a function");this._timeFormatter=e}}});AnimationViewModel._maxShuttleRingAngle=maxShuttleRingAngle;AnimationViewModel._realtimeShuttleRingAngle=realtimeShuttleRingAngle;function BaseLayerPickerViewModel(e){e=defaultValue(e,defaultValue.EMPTY_OBJECT);const t=e.globe,n=defaultValue(e.imageryProviderViewModels,[]),i=defaultValue(e.terrainProviderViewModels,[]);if(!defined(t))throw new DeveloperError("globe is required");this._globe=t,this.imageryProviderViewModels=n.slice(0),this.terrainProviderViewModels=i.slice(0),this.dropDownVisible=!1,knockout.track(this,["imageryProviderViewModels","terrainProviderViewModels","dropDownVisible"]);const r=knockout.getObservable(this,"imageryProviderViewModels"),o=knockout.pureComputed(function(){const h=r(),f={};let p;for(p=0;p<h.length;p++){const g=h[p],_=g.category;defined(f[_])?f[_].push(g):f[_]=[g]}const u=Object.keys(f),m=[];for(p=0;p<u.length;p++){const g=u[p];m.push({name:g,providers:f[g]})}return m});this._imageryProviders=o;const a=knockout.getObservable(this,"terrainProviderViewModels"),s=knockout.pureComputed(function(){const h=a(),f={};let p;for(p=0;p<h.length;p++){const g=h[p],_=g.category;defined(f[_])?f[_].push(g):f[_]=[g]}const u=Object.keys(f),m=[];for(p=0;p<u.length;p++){const g=u[p];m.push({name:g,providers:f[g]})}return m});this._terrainProviders=s,this.buttonTooltip=void 0,knockout.defineProperty(this,"buttonTooltip",function(){const h=this.selectedImagery,f=this.selectedTerrain,p=defined(h)?h.name:void 0,u=defined(f)?f.name:void 0;return defined(p)&&defined(u)?`${p}
${u}`:defined(p)?p:u}),this.buttonImageUrl=void 0,knockout.defineProperty(this,"buttonImageUrl",function(){const h=this.selectedImagery;if(defined(h))return h.iconUrl}),this.selectedImagery=void 0;const l=knockout.observable();this._currentImageryLayers=[],knockout.defineProperty(this,"selectedImagery",{get:function(){return l()},set:function(h){if(l()===h){this.dropDownVisible=!1;return}let f;const p=this._currentImageryLayers,u=p.length,m=this._globe.imageryLayers;let g=!1;for(f=0;f<u;f++){const _=m.length;for(let C=0;C<_;C++){const A=m.get(C);if(A===p[f]){m.remove(A),g=!0;break}}}if(defined(h)){const _=h.creationCommand();if(Array.isArray(_)){const C=_.length;for(this._currentImageryLayers=[],f=C-1;f>=0;f--){const A=ImageryLayer.fromProviderAsync(_[f]);m.add(A,0),this._currentImageryLayers.push(A)}}else{this._currentImageryLayers=[];const C=ImageryLayer.fromProviderAsync(_);if(C.name=h.name,g)m.add(C,0);else{const A=m.get(0);defined(A)&&m.remove(A),m.add(C,0)}this._currentImageryLayers.push(C)}}l(h),this.dropDownVisible=!1}}),this.selectedTerrain=void 0;const c=knockout.observable();knockout.defineProperty(this,"selectedTerrain",{get:function(){return c()},set:function(h){if(c()===h){this.dropDownVisible=!1;return}let f;if(defined(h)&&(f=h.creationCommand()),defined(f)&&!defined(f.then))this._globe.depthTestAgainstTerrain=!(f instanceof EllipsoidTerrainProvider),this._globe.terrainProvider=f;else if(defined(f)){let p=!1;const u=this._globe.terrainProviderChanged.addEventListener(()=>{p=!0,u()}),g=new Terrain(f).readyEvent.addEventListener(_=>{p||(this._globe.depthTestAgainstTerrain=!(_ instanceof EllipsoidTerrainProvider),this._globe.terrainProvider=_,g())})}c(h),this.dropDownVisible=!1}});const d=this;this._toggleDropDown=createCommand(function(){d.dropDownVisible=!d.dropDownVisible}),this.selectedImagery=defaultValue(e.selectedImageryProviderViewModel,n[0]),this.selectedTerrain=e.selectedTerrainProviderViewModel}Object.defineProperties(BaseLayerPickerViewModel.prototype,{toggleDropDown:{get:function(){return this._toggleDropDown}},globe:{get:function(){return this._globe}}});function BaseLayerPicker(e,t){if(!defined(e))throw new DeveloperError("container is required.");e=getElement(e);const n=new BaseLayerPickerViewModel(t),i=document.createElement("button");i.type="button",i.className="cesium-button cesium-toolbar-button",i.setAttribute("data-bind","attr: { title: buttonTooltip },click: toggleDropDown"),e.appendChild(i);const r=document.createElement("img");r.setAttribute("draggable","false"),r.className="cesium-baseLayerPicker-selected",r.setAttribute("data-bind","attr: { src: buttonImageUrl }, visible: !!buttonImageUrl"),i.appendChild(r);const o=document.createElement("div");o.className="cesium-baseLayerPicker-dropDown",o.setAttribute("data-bind",'css: { "cesium-baseLayerPicker-dropDown-visible" : dropDownVisible }'),e.appendChild(o);const a=document.createElement("div");a.className="cesium-baseLayerPicker-sectionTitle",a.setAttribute("data-bind","visible: imageryProviderViewModels.length > 0"),a.innerHTML="Imagery",o.appendChild(a);const s=document.createElement("div");s.className="cesium-baseLayerPicker-section",s.setAttribute("data-bind","foreach: _imageryProviders"),o.appendChild(s);const l=document.createElement("div");l.className="cesium-baseLayerPicker-category",s.appendChild(l);const c=document.createElement("div");c.className="cesium-baseLayerPicker-categoryTitle",c.setAttribute("data-bind","text: name"),l.appendChild(c);const d=document.createElement("div");d.className="cesium-baseLayerPicker-choices",d.setAttribute("data-bind","foreach: providers"),l.appendChild(d);const h=document.createElement("div");h.className="cesium-baseLayerPicker-item",h.setAttribute("data-bind",'css: { "cesium-baseLayerPicker-selectedItem" : $data === $parents[1].selectedImagery },attr: { title: tooltip },visible: creationCommand.canExecute,click: function($data) { $parents[1].selectedImagery = $data; }'),d.appendChild(h);const f=document.createElement("img");f.className="cesium-baseLayerPicker-itemIcon",f.setAttribute("data-bind","attr: { src: iconUrl }"),f.setAttribute("draggable","false"),h.appendChild(f);const p=document.createElement("div");p.className="cesium-baseLayerPicker-itemLabel",p.setAttribute("data-bind","text: name"),h.appendChild(p);const u=document.createElement("div");u.className="cesium-baseLayerPicker-sectionTitle",u.setAttribute("data-bind","visible: terrainProviderViewModels.length > 0"),u.innerHTML="Terrain",o.appendChild(u);const m=document.createElement("div");m.className="cesium-baseLayerPicker-section",m.setAttribute("data-bind","foreach: _terrainProviders"),o.appendChild(m);const g=document.createElement("div");g.className="cesium-baseLayerPicker-category",m.appendChild(g);const _=document.createElement("div");_.className="cesium-baseLayerPicker-categoryTitle",_.setAttribute("data-bind","text: name"),g.appendChild(_);const C=document.createElement("div");C.className="cesium-baseLayerPicker-choices",C.setAttribute("data-bind","foreach: providers"),g.appendChild(C);const A=document.createElement("div");A.className="cesium-baseLayerPicker-item",A.setAttribute("data-bind",'css: { "cesium-baseLayerPicker-selectedItem" : $data === $parents[1].selectedTerrain },attr: { title: tooltip },visible: creationCommand.canExecute,click: function($data) { $parents[1].selectedTerrain = $data; }'),C.appendChild(A);const S=document.createElement("img");S.className="cesium-baseLayerPicker-itemIcon",S.setAttribute("data-bind","attr: { src: iconUrl }"),S.setAttribute("draggable","false"),A.appendChild(S);const v=document.createElement("div");v.className="cesium-baseLayerPicker-itemLabel",v.setAttribute("data-bind","text: name"),A.appendChild(v),knockout.applyBindings(n,i),knockout.applyBindings(n,o),this._viewModel=n,this._container=e,this._element=i,this._dropPanel=o,this._closeDropDown=function(b){i.contains(b.target)||o.contains(b.target)||(n.dropDownVisible=!1)},FeatureDetection.supportsPointerEvents()?document.addEventListener("pointerdown",this._closeDropDown,!0):(document.addEventListener("mousedown",this._closeDropDown,!0),document.addEventListener("touchstart",this._closeDropDown,!0))}Object.defineProperties(BaseLayerPicker.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});BaseLayerPicker.prototype.isDestroyed=function(){return!1};BaseLayerPicker.prototype.destroy=function(){return FeatureDetection.supportsPointerEvents()?document.removeEventListener("pointerdown",this._closeDropDown,!0):(document.removeEventListener("mousedown",this._closeDropDown,!0),document.removeEventListener("touchstart",this._closeDropDown,!0)),knockout.cleanNode(this._element),knockout.cleanNode(this._dropPanel),this._container.removeChild(this._element),this._container.removeChild(this._dropPanel),destroyObject(this)};function ProviderViewModel(e){if(!defined(e.name))throw new DeveloperError("options.name is required.");if(!defined(e.tooltip))throw new DeveloperError("options.tooltip is required.");if(!defined(e.iconUrl))throw new DeveloperError("options.iconUrl is required.");if(typeof e.creationFunction!="function")throw new DeveloperError("options.creationFunction is required.");let t=e.creationFunction;defined(t.canExecute)||(t=createCommand(t)),this._creationCommand=t,this.name=e.name,this.tooltip=e.tooltip,this.iconUrl=e.iconUrl,this._category=defaultValue(e.category,""),knockout.track(this,["name","tooltip","iconUrl"])}Object.defineProperties(ProviderViewModel.prototype,{creationCommand:{get:function(){return this._creationCommand}},category:{get:function(){return this._category}}});function createDefaultImageryProviderViewModels(){const e=[],t=devicePixelRatio>=2;return e.push(new ProviderViewModel({name:"Bing Maps Aerial",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/bingAerial.png"),tooltip:"Bing Maps aerial imagery, provided by Cesium ion",category:"Cesium ion",creationFunction:function(){return createWorldImageryAsync({style:IonWorldImageryStyle.AERIAL})}})),e.push(new ProviderViewModel({name:"Bing Maps Aerial with Labels",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/bingAerialLabels.png"),tooltip:"Bing Maps aerial imagery with labels, provided by Cesium ion",category:"Cesium ion",creationFunction:function(){return createWorldImageryAsync({style:IonWorldImageryStyle.AERIAL_WITH_LABELS})}})),e.push(new ProviderViewModel({name:"Bing Maps Roads",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/bingRoads.png"),tooltip:"Bing Maps standard road maps, provided by Cesium ion",category:"Cesium ion",creationFunction:function(){return createWorldImageryAsync({style:IonWorldImageryStyle.ROAD})}})),e.push(new ProviderViewModel({name:"ArcGIS World Imagery",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/ArcGisMapServiceWorldImagery.png"),tooltip:`ArcGIS World Imagery provides one meter or better satellite and aerial imagery in many parts of the world and lower resolution satellite imagery worldwide. The map includes 15m TerraColor imagery at small and mid-scales (~1:591M down to ~1:288k) for the world. The map features Maxar imagery at 0.3m resolution for select metropolitan areas around the world, 0.5m resolution across the United States and parts of Western Europe, and 1m resolution imagery across the rest of the world. In addition to commercial sources, the World Imagery map features high-resolution aerial photography contributed by the GIS User Community. This imagery ranges from 0.3m to 0.03m resolution (down to ~1:280 nin select communities). For more information on this map, including the terms of use, visit us online at 
https://www.arcgis.com/home/item.html?id=10df2279f9684e4a9f6a7f08febac2a9`,category:"Other",creationFunction:function(){return ArcGisMapServerImageryProvider.fromBasemapType(ArcGisBaseMapType.SATELLITE,{enablePickFeatures:!1})}})),e.push(new ProviderViewModel({name:"ArcGIS World Hillshade",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/ArcGisMapServiceWorldHillshade.png"),tooltip:`ArcGIS World Hillshade map portrays elevation as an artistic hillshade. This map is designed to be used as a backdrop for topographical, soil, hydro, landcover or other outdoor recreational maps. The map was compiled from a variety of sources from several data providers. The basemap has global coverage down to a scale of ~1:72k. In select areas of the United States and Europe, coverage is available down to ~1:9k. For more information on this map, including the terms of use, visit us online at 
https://www.arcgis.com/home/item.html?id=1b243539f4514b6ba35e7d995890db1d`,category:"Other",creationFunction:function(){return ArcGisMapServerImageryProvider.fromBasemapType(ArcGisBaseMapType.HILLSHADE,{enablePickFeatures:!1})}})),e.push(new ProviderViewModel({name:"Esri World Ocean",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/ArcGisMapServiceWorldOcean.png"),tooltip:`ArcGIS World Ocean map is designed to be used as a base map by marine GIS professionals and as a reference map by anyone interested in ocean data.  The base map features marine bathymetry. Land features include inland waters and roads overlaid on land cover and shaded relief imagery. The map was compiled from a variety of best available sources from several data providers, including General Bathymetric Chart of the Oceans GEBCO_08 Grid, National Oceanic and Atmospheric Administration (NOAA), and National Geographic, Garmin, HERE, Geonames.org, and Esri, and various other contributors. The base map currently provides coverage for the world down to a scale of ~1:577k, and coverage down to 1:72k in US coastal areas, and various other areas. Coverage down to ~ 1:9k is available limited areas based on regional hydrographic survey data. The base map was designed and developed by Esri. For more information on this map, including our terms of use, visit us online at 
https://www.arcgis.com/home/item.html?id=1e126e7520f9466c9ca28b8f28b5e500`,category:"Other",creationFunction:function(){return ArcGisMapServerImageryProvider.fromBasemapType(ArcGisBaseMapType.OCEANS,{enablePickFeatures:!1})}})),e.push(new ProviderViewModel({name:"OpenStreetMap",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/openStreetMap.png"),tooltip:`OpenStreetMap (OSM) is a collaborative project to create a free editable map of the world.
http://www.openstreetmap.org`,category:"Other",creationFunction:function(){return new OpenStreetMapImageryProvider({url:"https://tile.openstreetmap.org/"})}})),e.push(new ProviderViewModel({name:"Stadia x Stamen Watercolor",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/stamenWatercolor.png"),tooltip:`Based on the original basemaps created for the Knight Foundation and reminiscent of hand drawn maps, the watercolor maps from Stamen Design apply raster effect area washes and organic edges over a paper texture to add warm pop to any map.
https://docs.stadiamaps.com/map-styles/stamen-watercolor/`,category:"Other",creationFunction:function(){return new OpenStreetMapImageryProvider({url:"https://tiles.stadiamaps.com/tiles/stamen_watercolor/",fileExtension:"jpg",credit:`&copy; <a href="https://stamen.com/" target="_blank">Stamen Design</a>
           &copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a>
           &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a>
           &copy; <a href="https://www.openstreetmap.org/about/" target="_blank">OpenStreetMap contributors</a>`})}})),e.push(new ProviderViewModel({name:"Stadia x Stamen Toner",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/stamenToner.png"),tooltip:`Based on the original basemaps created for the Knight Foundation and the most popular of the excellent styles from Stamen Design, these high-contrast B+W (black and white) maps are the perfect backdrop for your colorful and eye-catching overlays.
https://docs.stadiamaps.com/map-styles/stamen-toner/`,category:"Other",creationFunction:function(){return new OpenStreetMapImageryProvider({url:"https://tiles.stadiamaps.com/tiles/stamen_toner/",retinaTiles:t,credit:`&copy; <a href="https://stamen.com/" target="_blank">Stamen Design</a>
            &copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a>
            &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a>
            &copy; <a href="https://www.openstreetmap.org/about/" target="_blank">OpenStreetMap contributors</a>`})}})),e.push(new ProviderViewModel({name:"Stadia Alidade Smooth",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/stadiaAlidadeSmooth.png"),tooltip:`Stadia's custom Alidade Smooth style is designed for maps that use a lot of markers or overlays. It features a muted color scheme and fewer points of interest to allow your added data to shine.
https://docs.stadiamaps.com/map-styles/alidade-smooth/`,category:"Other",creationFunction:function(){return new OpenStreetMapImageryProvider({url:"https://tiles.stadiamaps.com/tiles/alidade_smooth/",retinaTiles:t,credit:`&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a>
            &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a>
            &copy; <a href="https://www.openstreetmap.org/about/" target="_blank">OpenStreetMap contributors</a>`})}})),e.push(new ProviderViewModel({name:"Stadia Alidade Smooth Dark",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/stadiaAlidadeSmoothDark.png"),tooltip:`Stadia Alidade Smooth Dark, like its lighter cousin, is also designed to stay out of the way. It just flips the dark mode switch on the color scheme. With the lights out, your data can now literally shine.
https://docs.stadiamaps.com/map-styles/alidade-smooth-dark/`,category:"Other",creationFunction:function(){return new OpenStreetMapImageryProvider({url:"https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/",retinaTiles:t,credit:`&copy; <a href="https://www.stadiamaps.com/" target="_blank">Stadia Maps</a>
            &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a>
            &copy; <a href="https://www.openstreetmap.org/about/" target="_blank">OpenStreetMap contributors</a>`})}})),e.push(new ProviderViewModel({name:"Sentinel-2",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/sentinel-2.png"),tooltip:"Sentinel-2 cloudless by EOX IT Services GmbH (Contains modified Copernicus Sentinel data 2016 and 2017).",category:"Cesium ion",creationFunction:function(){return IonImageryProvider.fromAssetId(3954)}})),e.push(new ProviderViewModel({name:"Blue Marble",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/blueMarble.png"),tooltip:"Blue Marble Next Generation July, 2004 imagery from NASA.",category:"Cesium ion",creationFunction:function(){return IonImageryProvider.fromAssetId(3845)}})),e.push(new ProviderViewModel({name:"Earth at night",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/earthAtNight.png"),tooltip:"The Earth at night, also known as The Black Marble, is a 500 meter resolution global composite imagery layer released by NASA.",category:"Cesium ion",creationFunction:function(){return IonImageryProvider.fromAssetId(3812)}})),e.push(new ProviderViewModel({name:"Natural EarthII",iconUrl:buildModuleUrl("Widgets/Images/ImageryProviders/naturalEarthII.png"),tooltip:`Natural Earth II, darkened for contrast.
http://www.naturalearthdata.com/`,category:"Cesium ion",creationFunction:function(){return TileMapServiceImageryProvider.fromUrl(buildModuleUrl("Assets/Textures/NaturalEarthII"))}})),e}function createDefaultTerrainProviderViewModels(){const e=[];return e.push(new ProviderViewModel({name:"WGS84 Ellipsoid",iconUrl:buildModuleUrl("Widgets/Images/TerrainProviders/Ellipsoid.png"),tooltip:"WGS84 standard ellipsoid, also known as EPSG:4326",category:"Cesium ion",creationFunction:function(){return new EllipsoidTerrainProvider({ellipsoid:Ellipsoid.WGS84})}})),e.push(new ProviderViewModel({name:"Cesium World Terrain",iconUrl:buildModuleUrl("Widgets/Images/TerrainProviders/CesiumWorldTerrain.png"),tooltip:"High-resolution global terrain tileset curated from several datasources and hosted by Cesium ion",category:"Cesium ion",creationFunction:function(){return createWorldTerrainAsync({requestWaterMask:!0,requestVertexNormals:!0})}})),e}function frustumStatisticsToString(e){let t;if(defined(e)){t="Command Statistics";const n=e.commandsInFrustums;for(const i in n)if(n.hasOwnProperty(i)){let r=parseInt(i,10),o;if(r===7)o="1, 2 and 3";else{const a=[];for(let s=2;s>=0;s--){const l=Math.pow(2,s);r>=l&&(a.push(s+1),r-=l)}o=a.reverse().join(" and ")}t+=`<br>&nbsp;&nbsp;&nbsp;&nbsp;${n[i]} in frustum ${o}`}t+=`<br>Total: ${e.totalCommands}`}return t}function boundDepthFrustum(e,t,n){let i=Math.min(n,t);return i=Math.max(i,e),i}const scratchPickRay=new Ray,scratchPickCartesian=new Cartesian3;function CesiumInspectorViewModel(e,t){if(!defined(e))throw new DeveloperError("scene is required");if(!defined(t))throw new DeveloperError("performanceContainer is required");const n=this,i=e.canvas,r=new ScreenSpaceEventHandler(i);this._eventHandler=r,this._scene=e,this._canvas=i,this._primitive=void 0,this._tile=void 0,this._modelMatrixPrimitive=void 0,this._performanceDisplay=void 0,this._performanceContainer=t;const o=this._scene.globe;o.depthTestAgainstTerrain=!0,this.frustums=!1,this.frustumPlanes=!1,this.performance=!1,this.shaderCacheText="",this.primitiveBoundingSphere=!1,this.primitiveReferenceFrame=!1,this.filterPrimitive=!1,this.tileBoundingSphere=!1,this.filterTile=!1,this.wireframe=!1,this.depthFrustum=1,this._numberOfFrustums=1,this.suspendUpdates=!1,this.tileCoordinates=!1,this.frustumStatisticText=!1,this.tileText="",this.hasPickedPrimitive=!1,this.hasPickedTile=!1,this.pickPrimitiveActive=!1,this.pickTileActive=!1,this.dropDownVisible=!0,this.generalVisible=!0,this.primitivesVisible=!1,this.terrainVisible=!1,this.depthFrustumText="",knockout.track(this,["frustums","frustumPlanes","performance","shaderCacheText","primitiveBoundingSphere","primitiveReferenceFrame","filterPrimitive","tileBoundingSphere","filterTile","wireframe","depthFrustum","suspendUpdates","tileCoordinates","frustumStatisticText","tileText","hasPickedPrimitive","hasPickedTile","pickPrimitiveActive","pickTileActive","dropDownVisible","generalVisible","primitivesVisible","terrainVisible","depthFrustumText"]),this._toggleDropDown=createCommand(function(){n.dropDownVisible=!n.dropDownVisible}),this._toggleGeneral=createCommand(function(){n.generalVisible=!n.generalVisible}),this._togglePrimitives=createCommand(function(){n.primitivesVisible=!n.primitivesVisible}),this._toggleTerrain=createCommand(function(){n.terrainVisible=!n.terrainVisible}),this._frustumsSubscription=knockout.getObservable(this,"frustums").subscribe(function(c){n._scene.debugShowFrustums=c,n._scene.requestRender()}),this._frustumPlanesSubscription=knockout.getObservable(this,"frustumPlanes").subscribe(function(c){n._scene.debugShowFrustumPlanes=c,n._scene.requestRender()}),this._performanceSubscription=knockout.getObservable(this,"performance").subscribe(function(c){c?n._performanceDisplay=new PerformanceDisplay({container:n._performanceContainer}):n._performanceContainer.innerHTML=""}),this._showPrimitiveBoundingSphere=createCommand(function(){return n._primitive.debugShowBoundingVolume=n.primitiveBoundingSphere,n._scene.requestRender(),!0}),this._primitiveBoundingSphereSubscription=knockout.getObservable(this,"primitiveBoundingSphere").subscribe(function(){n._showPrimitiveBoundingSphere()}),this._showPrimitiveReferenceFrame=createCommand(function(){if(n.primitiveReferenceFrame){const c=n._primitive.modelMatrix;n._modelMatrixPrimitive=new DebugModelMatrixPrimitive({modelMatrix:c}),n._scene.primitives.add(n._modelMatrixPrimitive)}else defined(n._modelMatrixPrimitive)&&(n._scene.primitives.remove(n._modelMatrixPrimitive),n._modelMatrixPrimitive=void 0);return n._scene.requestRender(),!0}),this._primitiveReferenceFrameSubscription=knockout.getObservable(this,"primitiveReferenceFrame").subscribe(function(){n._showPrimitiveReferenceFrame()}),this._doFilterPrimitive=createCommand(function(){return n.filterPrimitive?n._scene.debugCommandFilter=function(c){return defined(n._modelMatrixPrimitive)&&c.owner===n._modelMatrixPrimitive._primitive?!0:defined(n._primitive)?c.owner===n._primitive||c.owner===n._primitive._billboardCollection||c.owner.primitive===n._primitive:!1}:n._scene.debugCommandFilter=void 0,!0}),this._filterPrimitiveSubscription=knockout.getObservable(this,"filterPrimitive").subscribe(function(){n._doFilterPrimitive(),n._scene.requestRender()}),this._wireframeSubscription=knockout.getObservable(this,"wireframe").subscribe(function(c){o._surface.tileProvider._debug.wireframe=c,n._scene.requestRender()}),this._depthFrustumSubscription=knockout.getObservable(this,"depthFrustum").subscribe(function(c){n._scene.debugShowDepthFrustum=c,n._scene.requestRender()}),this._incrementDepthFrustum=createCommand(function(){const c=n.depthFrustum+1;return n.depthFrustum=boundDepthFrustum(1,n._numberOfFrustums,c),n._scene.requestRender(),!0}),this._decrementDepthFrustum=createCommand(function(){const c=n.depthFrustum-1;return n.depthFrustum=boundDepthFrustum(1,n._numberOfFrustums,c),n._scene.requestRender(),!0}),this._suspendUpdatesSubscription=knockout.getObservable(this,"suspendUpdates").subscribe(function(c){o._surface._debug.suspendLodUpdate=c,c||(n.filterTile=!1)});let a;this._showTileCoordinates=createCommand(function(){return n.tileCoordinates&&!defined(a)?a=e.imageryLayers.addImageryProvider(new TileCoordinatesImageryProvider({tilingScheme:e.terrainProvider.tilingScheme})):!n.tileCoordinates&&defined(a)&&(e.imageryLayers.remove(a),a=void 0),!0}),this._tileCoordinatesSubscription=knockout.getObservable(this,"tileCoordinates").subscribe(function(){n._showTileCoordinates(),n._scene.requestRender()}),this._tileBoundingSphereSubscription=knockout.getObservable(this,"tileBoundingSphere").subscribe(function(){n._showTileBoundingSphere(),n._scene.requestRender()}),this._showTileBoundingSphere=createCommand(function(){return n.tileBoundingSphere?o._surface.tileProvider._debug.boundingSphereTile=n._tile:o._surface.tileProvider._debug.boundingSphereTile=void 0,n._scene.requestRender(),!0}),this._doFilterTile=createCommand(function(){return n.filterTile?(n.suspendUpdates=!0,o._surface._tilesToRender=[],defined(n._tile)&&n._tile.renderable&&o._surface._tilesToRender.push(n._tile)):n.suspendUpdates=!1,!0}),this._filterTileSubscription=knockout.getObservable(this,"filterTile").subscribe(function(){n.doFilterTile(),n._scene.requestRender()});function s(c){const d=n._scene.pick({x:c.position.x,y:c.position.y});defined(d)&&(n.primitive=defined(d.collection)?d.collection:d.primitive),n._scene.requestRender(),n.pickPrimitiveActive=!1}this._pickPrimitive=createCommand(function(){n.pickPrimitiveActive=!n.pickPrimitiveActive}),this._pickPrimitiveActiveSubscription=knockout.getObservable(this,"pickPrimitiveActive").subscribe(function(c){c?r.setInputAction(s,ScreenSpaceEventType.LEFT_CLICK):r.removeInputAction(ScreenSpaceEventType.LEFT_CLICK)});function l(c){let d;const h=o.ellipsoid,f=n._scene.camera.getPickRay(c.position,scratchPickRay),p=o.pick(f,n._scene,scratchPickCartesian);if(defined(p)){const u=h.cartesianToCartographic(p),m=o._surface.tileProvider._tilesToRenderByTextureCount;for(let g=0;!d&&g<m.length;++g){const _=m[g];if(defined(_))for(let C=0;!d&&C<_.length;++C){const A=_[C];Rectangle.contains(A.rectangle,u)&&(d=A)}}}n.tile=d,n.pickTileActive=!1}this._pickTile=createCommand(function(){n.pickTileActive=!n.pickTileActive}),this._pickTileActiveSubscription=knockout.getObservable(this,"pickTileActive").subscribe(function(c){c?r.setInputAction(l,ScreenSpaceEventType.LEFT_CLICK):r.removeInputAction(ScreenSpaceEventType.LEFT_CLICK)}),this._removePostRenderEvent=e.postRender.addEventListener(function(){n._update()})}Object.defineProperties(CesiumInspectorViewModel.prototype,{scene:{get:function(){return this._scene}},performanceContainer:{get:function(){return this._performanceContainer}},toggleDropDown:{get:function(){return this._toggleDropDown}},showPrimitiveBoundingSphere:{get:function(){return this._showPrimitiveBoundingSphere}},showPrimitiveReferenceFrame:{get:function(){return this._showPrimitiveReferenceFrame}},doFilterPrimitive:{get:function(){return this._doFilterPrimitive}},incrementDepthFrustum:{get:function(){return this._incrementDepthFrustum}},decrementDepthFrustum:{get:function(){return this._decrementDepthFrustum}},showTileCoordinates:{get:function(){return this._showTileCoordinates}},showTileBoundingSphere:{get:function(){return this._showTileBoundingSphere}},doFilterTile:{get:function(){return this._doFilterTile}},toggleGeneral:{get:function(){return this._toggleGeneral}},togglePrimitives:{get:function(){return this._togglePrimitives}},toggleTerrain:{get:function(){return this._toggleTerrain}},pickPrimitive:{get:function(){return this._pickPrimitive}},pickTile:{get:function(){return this._pickTile}},selectParent:{get:function(){const e=this;return createCommand(function(){e.tile=e.tile.parent})}},selectNW:{get:function(){const e=this;return createCommand(function(){e.tile=e.tile.northwestChild})}},selectNE:{get:function(){const e=this;return createCommand(function(){e.tile=e.tile.northeastChild})}},selectSW:{get:function(){const e=this;return createCommand(function(){e.tile=e.tile.southwestChild})}},selectSE:{get:function(){const e=this;return createCommand(function(){e.tile=e.tile.southeastChild})}},primitive:{get:function(){return this._primitive},set:function(e){const t=this._primitive;e!==t&&(this.hasPickedPrimitive=!0,defined(t)&&(t.debugShowBoundingVolume=!1),this._scene.debugCommandFilter=void 0,defined(this._modelMatrixPrimitive)&&(this._scene.primitives.remove(this._modelMatrixPrimitive),this._modelMatrixPrimitive=void 0),this._primitive=e,e.show=!1,setTimeout(function(){e.show=!0},50),this.showPrimitiveBoundingSphere(),this.showPrimitiveReferenceFrame(),this.doFilterPrimitive())}},tile:{get:function(){return this._tile},set:function(e){if(defined(e)){this.hasPickedTile=!0;const t=this._tile;if(e!==t){this.tileText=`L: ${e.level} X: ${e.x} Y: ${e.y}`,this.tileText+=`<br>SW corner: ${e.rectangle.west}, ${e.rectangle.south}`,this.tileText+=`<br>NE corner: ${e.rectangle.east}, ${e.rectangle.north}`;const n=e.data;defined(n)&&defined(n.tileBoundingRegion)?this.tileText+=`<br>Min: ${n.tileBoundingRegion.minimumHeight} Max: ${n.tileBoundingRegion.maximumHeight}`:this.tileText+="<br>(Tile is not loaded)"}this._tile=e,this.showTileBoundingSphere(),this.doFilterTile()}else this.hasPickedTile=!1,this._tile=void 0}}});CesiumInspectorViewModel.prototype._update=function(){this.frustums&&(this.frustumStatisticText=frustumStatisticsToString(this._scene.debugFrustumStatistics));const e=this._scene.numberOfFrustums;this._numberOfFrustums=e,this.depthFrustum=boundDepthFrustum(1,e,this.depthFrustum),this.depthFrustumText=`${this.depthFrustum} of ${e}`,this.performance&&this._performanceDisplay.update(),this.primitiveReferenceFrame&&(this._modelMatrixPrimitive.modelMatrix=this._primitive.modelMatrix),this.shaderCacheText=`Cached shaders: ${this._scene.context.shaderCache.numberOfShaders}`};CesiumInspectorViewModel.prototype.isDestroyed=function(){return!1};CesiumInspectorViewModel.prototype.destroy=function(){return this._eventHandler.destroy(),this._removePostRenderEvent(),this._frustumsSubscription.dispose(),this._frustumPlanesSubscription.dispose(),this._performanceSubscription.dispose(),this._primitiveBoundingSphereSubscription.dispose(),this._primitiveReferenceFrameSubscription.dispose(),this._filterPrimitiveSubscription.dispose(),this._wireframeSubscription.dispose(),this._depthFrustumSubscription.dispose(),this._suspendUpdatesSubscription.dispose(),this._tileCoordinatesSubscription.dispose(),this._tileBoundingSphereSubscription.dispose(),this._filterTileSubscription.dispose(),this._pickPrimitiveActiveSubscription.dispose(),this._pickTileActiveSubscription.dispose(),destroyObject(this)};function CesiumInspector(e,t){if(!defined(e))throw new DeveloperError("container is required.");if(!defined(t))throw new DeveloperError("scene is required.");e=getElement(e);const n=document.createElement("div"),i=new CesiumInspectorViewModel(t,n);this._viewModel=i,this._container=e;const r=document.createElement("div");this._element=r;const o=document.createElement("div");o.textContent="Cesium Inspector",o.className="cesium-cesiumInspector-button",o.setAttribute("data-bind","click: toggleDropDown"),r.appendChild(o),r.className="cesium-cesiumInspector",r.setAttribute("data-bind",'css: { "cesium-cesiumInspector-visible" : dropDownVisible, "cesium-cesiumInspector-hidden" : !dropDownVisible }'),e.appendChild(this._element);const a=document.createElement("div");a.className="cesium-cesiumInspector-dropDown",r.appendChild(a);const s=InspectorShared$1.createSection,l=InspectorShared$1.createCheckbox,c=s(a,"General","generalVisible","toggleGeneral"),d=l("Show Frustums","frustums"),h=document.createElement("div");h.className="cesium-cesiumInspector-frustumStatistics",h.setAttribute("data-bind","visible: frustums, html: frustumStatisticText"),d.appendChild(h),c.appendChild(d),c.appendChild(l("Show Frustum Planes","frustumPlanes")),c.appendChild(l("Performance Display","performance")),n.className="cesium-cesiumInspector-performanceDisplay",c.appendChild(n);const f=document.createElement("div");f.className="cesium-cesiumInspector-shaderCache",f.setAttribute("data-bind","html: shaderCacheText"),c.appendChild(f);const p=document.createElement("div");c.appendChild(p);const u=document.createElement("span");u.setAttribute("data-bind",'html: "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frustum:"'),p.appendChild(u);const m=document.createElement("span");m.setAttribute("data-bind","text: depthFrustumText"),p.appendChild(m);const g=document.createElement("input");g.type="button",g.value="-",g.className="cesium-cesiumInspector-pickButton",g.setAttribute("data-bind","click: decrementDepthFrustum"),p.appendChild(g);const _=document.createElement("input");_.type="button",_.value="+",_.className="cesium-cesiumInspector-pickButton",_.setAttribute("data-bind","click: incrementDepthFrustum"),p.appendChild(_);const C=s(a,"Primitives","primitivesVisible","togglePrimitives"),A=document.createElement("div");A.className="cesium-cesiumInspector-pickSection",C.appendChild(A);const S=document.createElement("input");S.type="button",S.value="Pick a primitive",S.className="cesium-cesiumInspector-pickButton",S.setAttribute("data-bind",'css: {"cesium-cesiumInspector-pickButtonHighlight" : pickPrimitiveActive}, click: pickPrimitive');let v=document.createElement("div");v.className="cesium-cesiumInspector-center",v.appendChild(S),A.appendChild(v),A.appendChild(l("Show bounding sphere","primitiveBoundingSphere","hasPickedPrimitive")),A.appendChild(l("Show reference frame","primitiveReferenceFrame","hasPickedPrimitive")),this._primitiveOnly=l("Show only selected","filterPrimitive","hasPickedPrimitive"),A.appendChild(this._primitiveOnly);const b=s(a,"Terrain","terrainVisible","toggleTerrain"),D=document.createElement("div");D.className="cesium-cesiumInspector-pickSection",b.appendChild(D);const I=document.createElement("input");I.type="button",I.value="Pick a tile",I.className="cesium-cesiumInspector-pickButton",I.setAttribute("data-bind",'css: {"cesium-cesiumInspector-pickButtonHighlight" : pickTileActive}, click: pickTile'),v=document.createElement("div"),v.appendChild(I),v.className="cesium-cesiumInspector-center",D.appendChild(v);const L=document.createElement("div");D.appendChild(L);const N=document.createElement("input");N.type="button",N.value="Parent",N.className="cesium-cesiumInspector-pickButton",N.setAttribute("data-bind","click: selectParent");const y=document.createElement("input");y.type="button",y.value="NW",y.className="cesium-cesiumInspector-pickButton",y.setAttribute("data-bind","click: selectNW");const x=document.createElement("input");x.type="button",x.value="NE",x.className="cesium-cesiumInspector-pickButton",x.setAttribute("data-bind","click: selectNE");const T=document.createElement("input");T.type="button",T.value="SW",T.className="cesium-cesiumInspector-pickButton",T.setAttribute("data-bind","click: selectSW");const E=document.createElement("input");E.type="button",E.value="SE",E.className="cesium-cesiumInspector-pickButton",E.setAttribute("data-bind","click: selectSE");const P=document.createElement("div");P.className="cesium-cesiumInspector-tileText",L.className="cesium-cesiumInspector-frustumStatistics",L.appendChild(P),L.setAttribute("data-bind","visible: hasPickedTile"),P.setAttribute("data-bind","html: tileText");const M=document.createElement("div");M.className="cesium-cesiumInspector-relativeText",M.textContent="Select relative:",L.appendChild(M);const O=document.createElement("table"),V=document.createElement("tr"),R=document.createElement("tr"),w=document.createElement("td");w.appendChild(N);const U=document.createElement("td");U.appendChild(y);const k=document.createElement("td");k.appendChild(x),V.appendChild(w),V.appendChild(U),V.appendChild(k);const H=document.createElement("td"),F=document.createElement("td");F.appendChild(T);const G=document.createElement("td");G.appendChild(E),R.appendChild(H),R.appendChild(F),R.appendChild(G),O.appendChild(V),O.appendChild(R),L.appendChild(O),D.appendChild(l("Show bounding volume","tileBoundingSphere","hasPickedTile")),D.appendChild(l("Show only selected","filterTile","hasPickedTile")),b.appendChild(l("Wireframe","wireframe")),b.appendChild(l("Suspend LOD update","suspendUpdates")),b.appendChild(l("Show tile coordinates","tileCoordinates")),knockout.applyBindings(i,this._element)}Object.defineProperties(CesiumInspector.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});CesiumInspector.prototype.isDestroyed=function(){return!1};CesiumInspector.prototype.destroy=function(){return knockout.cleanNode(this._element),this._container.removeChild(this._element),this.viewModel.destroy(),destroyObject(this)};function getPickTileset(e){return function(t){const n=e._scene.pick(t.position);defined(n)&&n.primitive instanceof Cesium3DTileset&&(e.tileset=n.primitive),e.pickActive=!1}}function selectTilesetOnHover(e,t){t?e._eventHandler.setInputAction(function(n){const i=e._scene.pick(n.endPosition);defined(i)&&i.primitive instanceof Cesium3DTileset&&(e.tileset=i.primitive)},ScreenSpaceEventType.MOUSE_MOVE):(e._eventHandler.removeInputAction(ScreenSpaceEventType.MOUSE_MOVE),e.picking=e.picking)}const stringOptions={maximumFractionDigits:3};function formatMemoryString(e){const t=e/1048576;return t<1?t.toLocaleString(void 0,stringOptions):Math.round(t).toLocaleString()}function getStatistics(e,t){if(!defined(e))return"";const n=t?e._statisticsPerPass[Cesium3DTilePass.PICK]:e._statisticsPerPass[Cesium3DTilePass.RENDER];let i='<ul class="cesium-cesiumInspector-statistics">';return i+=`<li><strong>Visited: </strong>${n.visited.toLocaleString()}</li><li><strong>Selected: </strong>${n.selected.toLocaleString()}</li><li><strong>Commands: </strong>${n.numberOfCommands.toLocaleString()}</li>`,i+="</ul>",t||(i+='<ul class="cesium-cesiumInspector-statistics">',i+=`<li><strong>Requests: </strong>${n.numberOfPendingRequests.toLocaleString()}</li><li><strong>Attempted: </strong>${n.numberOfAttemptedRequests.toLocaleString()}</li><li><strong>Processing: </strong>${n.numberOfTilesProcessing.toLocaleString()}</li><li><strong>Content Ready: </strong>${n.numberOfTilesWithContentReady.toLocaleString()}</li><li><strong>Total: </strong>${n.numberOfTilesTotal.toLocaleString()}</li>`,i+="</ul>",i+='<ul class="cesium-cesiumInspector-statistics">',i+=`<li><strong>Features Selected: </strong>${n.numberOfFeaturesSelected.toLocaleString()}</li><li><strong>Features Loaded: </strong>${n.numberOfFeaturesLoaded.toLocaleString()}</li><li><strong>Points Selected: </strong>${n.numberOfPointsSelected.toLocaleString()}</li><li><strong>Points Loaded: </strong>${n.numberOfPointsLoaded.toLocaleString()}</li><li><strong>Triangles Selected: </strong>${n.numberOfTrianglesSelected.toLocaleString()}</li>`,i+="</ul>",i+='<ul class="cesium-cesiumInspector-statistics">',i+=`<li><strong>Tiles styled: </strong>${n.numberOfTilesStyled.toLocaleString()}</li><li><strong>Features styled: </strong>${n.numberOfFeaturesStyled.toLocaleString()}</li>`,i+="</ul>",i+='<ul class="cesium-cesiumInspector-statistics">',i+=`<li><strong>Children Union Culled: </strong>${n.numberOfTilesCulledWithChildrenUnion.toLocaleString()}</li>`,i+="</ul>",i+='<ul class="cesium-cesiumInspector-statistics">',i+=`<li><strong>Geometry Memory (MB): </strong>${formatMemoryString(n.geometryByteLength)}</li><li><strong>Texture Memory (MB): </strong>${formatMemoryString(n.texturesByteLength)}</li><li><strong>Batch Table Memory (MB): </strong>${formatMemoryString(n.batchTableByteLength)}</li>`,i+="</ul>"),i}function getResourceCacheStatistics(){const e=ResourceCache.statistics;return`
  <ul class="cesium-cesiumInspector-statistics">
    <li><strong>Geometry Memory (MB): </strong>${formatMemoryString(e.geometryByteLength)}</li>
    <li><strong>Texture Memory (MB): </strong>${formatMemoryString(e.texturesByteLength)}</li>
  </ul>
  `}const colorBlendModes=[{text:"Highlight",value:Cesium3DTileColorBlendMode.HIGHLIGHT},{text:"Replace",value:Cesium3DTileColorBlendMode.REPLACE},{text:"Mix",value:Cesium3DTileColorBlendMode.MIX}],highlightColor=new Color(1,1,0,.4),scratchColor=new Color,oldColor=new Color;function Cesium3DTilesInspectorViewModel(e,t){Check.typeOf.object("scene",e),Check.typeOf.object("performanceContainer",t);const n=this,i=e.canvas;this._eventHandler=new ScreenSpaceEventHandler(i),this._scene=e,this._performanceContainer=t,this._canvas=i,this._performanceDisplay=new PerformanceDisplay({container:t}),this._statisticsText="",this._pickStatisticsText="",this._resourceCacheStatisticsText="",this._editorError="",this.performance=!1,this.showStatistics=!0,this.showPickStatistics=!0,this.showResourceCacheStatistics=!1,this.inspectorVisible=!0,this.tilesetVisible=!1,this.displayVisible=!1,this.updateVisible=!1,this.loggingVisible=!1,this.styleVisible=!1,this.tileDebugLabelsVisible=!1,this.optimizationVisible=!1,this.styleString="{}",this.hasEnabledWireframe=!1,this._tileset=void 0,this._feature=void 0,this._tile=void 0,knockout.track(this,["performance","inspectorVisible","_statisticsText","_pickStatisticsText","_resourceCacheStatisticsText","_editorError","showPickStatistics","showStatistics","showResourceCacheStatistics","tilesetVisible","displayVisible","updateVisible","loggingVisible","styleVisible","optimizationVisible","tileDebugLabelsVisible","styleString","_feature","_tile","_tileset","hasEnabledWireframe"]),this._properties=knockout.observable({}),this.properties=[],knockout.defineProperty(this,"properties",function(){const w=[],U=n._properties();for(const k in U)U.hasOwnProperty(k)&&w.push(k);return w});const r=knockout.observable();knockout.defineProperty(this,"dynamicScreenSpaceError",{get:function(){return r()},set:function(w){r(w),defined(n._tileset)&&(n._tileset.dynamicScreenSpaceError=w)}}),this.dynamicScreenSpaceError=!1;const o=knockout.observable();knockout.defineProperty(this,"colorBlendMode",{get:function(){return o()},set:function(w){o(w),defined(n._tileset)&&(n._tileset.colorBlendMode=w,n._scene.requestRender())}}),this.colorBlendMode=Cesium3DTileColorBlendMode.HIGHLIGHT;const a=knockout.observable(),s=knockout.observable();knockout.defineProperty(this,"picking",{get:function(){return s()},set:function(w){s(w),w?n._eventHandler.setInputAction(function(U){const k=e.pick(U.endPosition);if(k instanceof Cesium3DTileFeature?(n.feature=k,n.tile=k.content.tile):defined(k)&&defined(k.content)?(n.feature=void 0,n.tile=k.content.tile):(n.feature=void 0,n.tile=void 0),!!defined(n._tileset)){if(a&&defined(k)&&defined(k.content)){let H;e.pickPositionSupported&&(H=e.pickPosition(U.endPosition),defined(H)&&(n._tileset.debugPickPosition=H)),n._tileset.debugPickedTile=k.content.tile}else n._tileset.debugPickedTile=void 0;n._scene.requestRender()}},ScreenSpaceEventType.MOUSE_MOVE):(n.feature=void 0,n.tile=void 0,n._eventHandler.removeInputAction(ScreenSpaceEventType.MOUSE_MOVE))}}),this.picking=!0;const l=knockout.observable();knockout.defineProperty(this,"colorize",{get:function(){return l()},set:function(w){l(w),defined(n._tileset)&&(n._tileset.debugColorizeTiles=w,n._scene.requestRender())}}),this.colorize=!1;const c=knockout.observable();knockout.defineProperty(this,"wireframe",{get:function(){return c()},set:function(w){c(w),defined(n._tileset)&&(n._tileset.debugWireframe=w,n._scene.requestRender())}}),this.wireframe=!1;const d=knockout.observable();knockout.defineProperty(this,"showBoundingVolumes",{get:function(){return d()},set:function(w){d(w),defined(n._tileset)&&(n._tileset.debugShowBoundingVolume=w,n._scene.requestRender())}}),this.showBoundingVolumes=!1;const h=knockout.observable();knockout.defineProperty(this,"showContentBoundingVolumes",{get:function(){return h()},set:function(w){h(w),defined(n._tileset)&&(n._tileset.debugShowContentBoundingVolume=w,n._scene.requestRender())}}),this.showContentBoundingVolumes=!1;const f=knockout.observable();knockout.defineProperty(this,"showRequestVolumes",{get:function(){return f()},set:function(w){f(w),defined(n._tileset)&&(n._tileset.debugShowViewerRequestVolume=w,n._scene.requestRender())}}),this.showRequestVolumes=!1;const p=knockout.observable();knockout.defineProperty(this,"freezeFrame",{get:function(){return p()},set:function(w){p(w),defined(n._tileset)&&(n._tileset.debugFreezeFrame=w,n._scene.debugShowFrustumPlanes=w,n._scene.requestRender())}}),this.freezeFrame=!1,knockout.defineProperty(this,"showOnlyPickedTileDebugLabel",{get:function(){return a()},set:function(w){a(w),defined(n._tileset)&&(n._tileset.debugPickedTileLabelOnly=w,n._scene.requestRender())}}),this.showOnlyPickedTileDebugLabel=!1;const u=knockout.observable();knockout.defineProperty(this,"showGeometricError",{get:function(){return u()},set:function(w){u(w),defined(n._tileset)&&(n._tileset.debugShowGeometricError=w,n._scene.requestRender())}}),this.showGeometricError=!1;const m=knockout.observable();knockout.defineProperty(this,"showRenderingStatistics",{get:function(){return m()},set:function(w){m(w),defined(n._tileset)&&(n._tileset.debugShowRenderingStatistics=w,n._scene.requestRender())}}),this.showRenderingStatistics=!1;const g=knockout.observable();knockout.defineProperty(this,"showMemoryUsage",{get:function(){return g()},set:function(w){g(w),defined(n._tileset)&&(n._tileset.debugShowMemoryUsage=w,n._scene.requestRender())}}),this.showMemoryUsage=!1;const _=knockout.observable();knockout.defineProperty(this,"showUrl",{get:function(){return _()},set:function(w){_(w),defined(n._tileset)&&(n._tileset.debugShowUrl=w,n._scene.requestRender())}}),this.showUrl=!1;const C=knockout.observable();knockout.defineProperty(this,"maximumScreenSpaceError",{get:function(){return C()},set:function(w){w=Number(w),isNaN(w)||(C(w),defined(n._tileset)&&(n._tileset.maximumScreenSpaceError=w))}}),this.maximumScreenSpaceError=16;const A=knockout.observable();knockout.defineProperty(this,"dynamicScreenSpaceErrorDensity",{get:function(){return A()},set:function(w){w=Number(w),isNaN(w)||(A(w),defined(n._tileset)&&(n._tileset.dynamicScreenSpaceErrorDensity=w))}}),this.dynamicScreenSpaceErrorDensity=2e-4,this.dynamicScreenSpaceErrorDensitySliderValue=void 0,knockout.defineProperty(this,"dynamicScreenSpaceErrorDensitySliderValue",{get:function(){return Math.pow(A(),1/6)},set:function(w){const U=Math.pow(w,6);A(U),defined(n._tileset)&&(n._tileset.dynamicScreenSpaceErrorDensity=U)}});const S=knockout.observable();knockout.defineProperty(this,"dynamicScreenSpaceErrorFactor",{get:function(){return S()},set:function(w){w=Number(w),isNaN(w)||(S(w),defined(n._tileset)&&(n._tileset.dynamicScreenSpaceErrorFactor=w))}}),this.dynamicScreenSpaceErrorFactor=24;const v=getPickTileset(this),b=knockout.observable();knockout.defineProperty(this,"pickActive",{get:function(){return b()},set:function(w){b(w),w?n._eventHandler.setInputAction(v,ScreenSpaceEventType.LEFT_CLICK):n._eventHandler.removeInputAction(ScreenSpaceEventType.LEFT_CLICK)}});const D=knockout.observable();knockout.defineProperty(this,"pointCloudShading",{get:function(){return D()},set:function(w){D(w),defined(n._tileset)&&(n._tileset.pointCloudShading.attenuation=w)}}),this.pointCloudShading=!1;const I=knockout.observable();knockout.defineProperty(this,"geometricErrorScale",{get:function(){return I()},set:function(w){w=Number(w),isNaN(w)||(I(w),defined(n._tileset)&&(n._tileset.pointCloudShading.geometricErrorScale=w))}}),this.geometricErrorScale=1;const L=knockout.observable();knockout.defineProperty(this,"maximumAttenuation",{get:function(){return L()},set:function(w){w=Number(w),isNaN(w)||(L(w),defined(n._tileset)&&(n._tileset.pointCloudShading.maximumAttenuation=w===0?void 0:w))}}),this.maximumAttenuation=0;const N=knockout.observable();knockout.defineProperty(this,"baseResolution",{get:function(){return N()},set:function(w){w=Number(w),isNaN(w)||(N(w),defined(n._tileset)&&(n._tileset.pointCloudShading.baseResolution=w===0?void 0:w))}}),this.baseResolution=0;const y=knockout.observable();knockout.defineProperty(this,"eyeDomeLighting",{get:function(){return y()},set:function(w){y(w),defined(n._tileset)&&(n._tileset.pointCloudShading.eyeDomeLighting=w)}}),this.eyeDomeLighting=!1;const x=knockout.observable();knockout.defineProperty(this,"eyeDomeLightingStrength",{get:function(){return x()},set:function(w){w=Number(w),isNaN(w)||(x(w),defined(n._tileset)&&(n._tileset.pointCloudShading.eyeDomeLightingStrength=w))}}),this.eyeDomeLightingStrength=1;const T=knockout.observable();knockout.defineProperty(this,"eyeDomeLightingRadius",{get:function(){return T()},set:function(w){w=Number(w),isNaN(w)||(T(w),defined(n._tileset)&&(n._tileset.pointCloudShading.eyeDomeLightingRadius=w))}}),this.eyeDomeLightingRadius=1,this.pickActive=!1;const E=knockout.observable();knockout.defineProperty(this,"skipLevelOfDetail",{get:function(){return E()},set:function(w){E(w),defined(n._tileset)&&(n._tileset.skipLevelOfDetail=w)}}),this.skipLevelOfDetail=!0;const P=knockout.observable();knockout.defineProperty(this,"skipScreenSpaceErrorFactor",{get:function(){return P()},set:function(w){w=Number(w),isNaN(w)||(P(w),defined(n._tileset)&&(n._tileset.skipScreenSpaceErrorFactor=w))}}),this.skipScreenSpaceErrorFactor=16;const M=knockout.observable();knockout.defineProperty(this,"baseScreenSpaceError",{get:function(){return M()},set:function(w){w=Number(w),isNaN(w)||(M(w),defined(n._tileset)&&(n._tileset.baseScreenSpaceError=w))}}),this.baseScreenSpaceError=1024;const O=knockout.observable();knockout.defineProperty(this,"skipLevels",{get:function(){return O()},set:function(w){w=Number(w),isNaN(w)||(O(w),defined(n._tileset)&&(n._tileset.skipLevels=w))}}),this.skipLevels=1;const V=knockout.observable();knockout.defineProperty(this,"immediatelyLoadDesiredLevelOfDetail",{get:function(){return V()},set:function(w){V(w),defined(n._tileset)&&(n._tileset.immediatelyLoadDesiredLevelOfDetail=w)}}),this.immediatelyLoadDesiredLevelOfDetail=!1;const R=knockout.observable();knockout.defineProperty(this,"loadSiblings",{get:function(){return R()},set:function(w){R(w),defined(n._tileset)&&(n._tileset.loadSiblings=w)}}),this.loadSiblings=!1,this._style=void 0,this._shouldStyle=!1,this._definedProperties=["properties","dynamicScreenSpaceError","colorBlendMode","picking","colorize","wireframe","showBoundingVolumes","showContentBoundingVolumes","showRequestVolumes","freezeFrame","maximumScreenSpaceError","dynamicScreenSpaceErrorDensity","baseScreenSpaceError","skipScreenSpaceErrorFactor","skipLevelOfDetail","skipLevels","immediatelyLoadDesiredLevelOfDetail","loadSiblings","dynamicScreenSpaceErrorDensitySliderValue","dynamicScreenSpaceErrorFactor","pickActive","showOnlyPickedTileDebugLabel","showGeometricError","showRenderingStatistics","showMemoryUsage","showUrl","pointCloudShading","geometricErrorScale","maximumAttenuation","baseResolution","eyeDomeLighting","eyeDomeLightingStrength","eyeDomeLightingRadius"],this._removePostRenderEvent=e.postRender.addEventListener(function(){n._update()}),defined(this._tileset)||selectTilesetOnHover(this,!0)}Object.defineProperties(Cesium3DTilesInspectorViewModel.prototype,{scene:{get:function(){return this._scene}},performanceContainer:{get:function(){return this._performanceContainer}},statisticsText:{get:function(){return this._statisticsText}},pickStatisticsText:{get:function(){return this._pickStatisticsText}},resourceCacheStatisticsText:{get:function(){return this._resourceCacheStatisticsText}},colorBlendModes:{get:function(){return colorBlendModes}},editorError:{get:function(){return this._editorError}},tileset:{get:function(){return this._tileset},set:function(e){if(this._tileset=e,this._style=void 0,this.styleString="{}",this.feature=void 0,this.tile=void 0,defined(e)){this._properties(e.properties);const t=["colorize","wireframe","showBoundingVolumes","showContentBoundingVolumes","showRequestVolumes","freezeFrame","showOnlyPickedTileDebugLabel","showGeometricError","showRenderingStatistics","showMemoryUsage","showUrl"],n=t.length;for(let r=0;r<n;++r){const o=t[r];this[o]=this[o]}this.maximumScreenSpaceError=e.maximumScreenSpaceError,this.dynamicScreenSpaceError=e.dynamicScreenSpaceError,this.dynamicScreenSpaceErrorDensity=e.dynamicScreenSpaceErrorDensity,this.dynamicScreenSpaceErrorFactor=e.dynamicScreenSpaceErrorFactor,this.colorBlendMode=e.colorBlendMode,this.skipLevelOfDetail=e.skipLevelOfDetail,this.skipScreenSpaceErrorFactor=e.skipScreenSpaceErrorFactor,this.baseScreenSpaceError=e.baseScreenSpaceError,this.skipLevels=e.skipLevels,this.immediatelyLoadDesiredLevelOfDetail=e.immediatelyLoadDesiredLevelOfDetail,this.loadSiblings=e.loadSiblings,this.hasEnabledWireframe=e._enableDebugWireframe;const i=e.pointCloudShading;this.pointCloudShading=i.attenuation,this.geometricErrorScale=i.geometricErrorScale,this.maximumAttenuation=i.maximumAttenuation?i.maximumAttenuation:0,this.baseResolution=i.baseResolution?i.baseResolution:0,this.eyeDomeLighting=i.eyeDomeLighting,this.eyeDomeLightingStrength=i.eyeDomeLightingStrength,this.eyeDomeLightingRadius=i.eyeDomeLightingRadius,this._scene.requestRender()}else this._properties({});this._statisticsText=getStatistics(e,!1),this._pickStatisticsText=getStatistics(e,!0),this._resourceCacheStatisticsText=getResourceCacheStatistics(),selectTilesetOnHover(this,!1)}},feature:{get:function(){return this._feature},set:function(e){if(this._feature===e)return;const t=this._feature;defined(t)&&!t.content.isDestroyed()&&(!this.colorize&&defined(this._style)?t.color=defined(this._style.color)?this._style.color.evaluateColor(t,scratchColor):Color.WHITE:t.color=oldColor,this._scene.requestRender()),defined(e)&&(Color.clone(e.color,oldColor),e.color=highlightColor,this._scene.requestRender()),this._feature=e}},tile:{get:function(){return this._tile},set:function(e){if(this._tile===e)return;const t=this._tile;defined(t)&&!t.isDestroyed()&&!hasFeatures(t.content)&&(t.color=oldColor,this._scene.requestRender()),defined(e)&&!hasFeatures(e.content)&&(Color.clone(e.color,oldColor),e.color=highlightColor,this._scene.requestRender()),this._tile=e}}});function hasFeatures(e){if(!defined(e))return!1;if(e.featuresLength>0)return!0;const t=e.innerContents;if(defined(t)){const n=t.length;for(let i=0;i<n;++i)if(!hasFeatures(t[i]))return!1;return!0}return!1}Cesium3DTilesInspectorViewModel.prototype.togglePickTileset=function(){this.pickActive=!this.pickActive};Cesium3DTilesInspectorViewModel.prototype.toggleInspector=function(){this.inspectorVisible=!this.inspectorVisible};Cesium3DTilesInspectorViewModel.prototype.toggleTileset=function(){this.tilesetVisible=!this.tilesetVisible};Cesium3DTilesInspectorViewModel.prototype.toggleDisplay=function(){this.displayVisible=!this.displayVisible};Cesium3DTilesInspectorViewModel.prototype.toggleUpdate=function(){this.updateVisible=!this.updateVisible};Cesium3DTilesInspectorViewModel.prototype.toggleLogging=function(){this.loggingVisible=!this.loggingVisible};Cesium3DTilesInspectorViewModel.prototype.toggleStyle=function(){this.styleVisible=!this.styleVisible};Cesium3DTilesInspectorViewModel.prototype.toggleTileDebugLabels=function(){this.tileDebugLabelsVisible=!this.tileDebugLabelsVisible};Cesium3DTilesInspectorViewModel.prototype.toggleOptimization=function(){this.optimizationVisible=!this.optimizationVisible};Cesium3DTilesInspectorViewModel.prototype.trimTilesCache=function(){defined(this._tileset)&&this._tileset.trimLoadedTiles()};Cesium3DTilesInspectorViewModel.prototype.compileStyle=function(){const e=this._tileset;if(!(!defined(e)||this.styleString===JSON.stringify(e.style))){this._editorError="";try{this.styleString.length===0&&(this.styleString="{}"),this._style=new Cesium3DTileStyle(JSON.parse(this.styleString)),this._shouldStyle=!0,this._scene.requestRender()}catch(t){this._editorError=t.toString()}this.feature=this._feature,this.tile=this._tile}};Cesium3DTilesInspectorViewModel.prototype.styleEditorKeyPress=function(e,t){if(t.keyCode===9){t.preventDefault();const n=t.target,i=n.selectionStart,r=n.selectionEnd;let o=r;const s=n.value.slice(i,r).split(`
`),l=s.length;let c;if(t.shiftKey)for(c=0;c<l;++c)s[c][0]===" "&&(s[c][1]===" "?(s[c]=s[c].substr(2),o-=2):(s[c]=s[c].substr(1),o-=1));else for(c=0;c<l;++c)s[c]=`  ${s[c]}`,o+=2;const d=s.join(`
`);n.value=n.value.slice(0,i)+d+n.value.slice(r),n.selectionStart=i!==r?i:o,n.selectionEnd=o}else t.ctrlKey&&(t.keyCode===10||t.keyCode===13)&&this.compileStyle();return!0};Cesium3DTilesInspectorViewModel.prototype._update=function(){const e=this._tileset;if(this.performance&&this._performanceDisplay.update(),defined(e)){if(e.isDestroyed()){this.tile=void 0,this.feature=void 0,this.tileset=void 0;return}const t=e.style;this._style!==e.style&&(this._shouldStyle?(e.style=this._style,this._shouldStyle=!1):(this._style=t,this.styleString=JSON.stringify(t.style,null,"  ")))}this.showStatistics&&(this._statisticsText=getStatistics(e,!1),this._pickStatisticsText=getStatistics(e,!0),this._resourceCacheStatisticsText=getResourceCacheStatistics())};Cesium3DTilesInspectorViewModel.prototype.isDestroyed=function(){return!1};Cesium3DTilesInspectorViewModel.prototype.destroy=function(){this._eventHandler.destroy(),this._removePostRenderEvent();const e=this;return this._definedProperties.forEach(function(t){knockout.getObservable(e,t).dispose()}),destroyObject(this)};Cesium3DTilesInspectorViewModel.getStatistics=getStatistics;function Cesium3DTilesInspector(e,t){Check.defined("container",e),Check.typeOf.object("scene",t),e=getElement(e);const n=document.createElement("div"),i=document.createElement("div");i.setAttribute("data-bind","visible: performance");const r=new Cesium3DTilesInspectorViewModel(t,i);this._viewModel=r,this._container=e,this._element=n;const o=document.createElement("div");o.textContent="3D Tiles Inspector",o.className="cesium-cesiumInspector-button",o.setAttribute("data-bind","click: toggleInspector"),n.appendChild(o),n.className="cesium-cesiumInspector cesium-3DTilesInspector",n.setAttribute("data-bind",'css: { "cesium-cesiumInspector-visible" : inspectorVisible, "cesium-cesiumInspector-hidden" : !inspectorVisible}'),e.appendChild(n);const a=document.createElement("div");a.className="cesium-cesiumInspector-dropDown",n.appendChild(a);const s=InspectorShared$1.createSection,l=InspectorShared$1.createCheckbox,c=InspectorShared$1.createRangeInput,d=InspectorShared$1.createButton,h=s(a,"Tileset","tilesetVisible","toggleTileset"),f=s(a,"Display","displayVisible","toggleDisplay"),p=s(a,"Update","updateVisible","toggleUpdate"),u=s(a,"Logging","loggingVisible","toggleLogging"),m=s(a,"Tile Debug Labels","tileDebugLabelsVisible","toggleTileDebugLabels"),g=s(a,"Style","styleVisible","toggleStyle"),_=s(a,"Optimization","optimizationVisible","toggleOptimization"),C=document.createElement("div");C.className="field-group";const A=document.createElement("label");A.className="field-label",A.appendChild(document.createTextNode("Properties: "));const S=document.createElement("div");S.setAttribute("data-bind","text: properties"),C.appendChild(A),C.appendChild(S),h.appendChild(C),h.appendChild(d("Pick Tileset","togglePickTileset","pickActive")),h.appendChild(d("Trim Tiles Cache","trimTilesCache")),h.appendChild(l("Enable Picking","picking")),f.appendChild(l("Colorize","colorize"));const v=f.appendChild(l("Wireframe","wireframe","_tileset === undefined || hasEnabledWireframe")),b=document.createElement("p");b.setAttribute("data-bind","visible: _tileset !== undefined && !hasEnabledWireframe"),b.setAttribute("class","cesium-3DTilesInspector-disabledElementsInfo"),b.innerText="Set enableDebugWireframe to true in the tileset constructor to enable this option.",v.appendChild(b),f.appendChild(l("Bounding Volumes","showBoundingVolumes")),f.appendChild(l("Content Volumes","showContentBoundingVolumes")),f.appendChild(l("Request Volumes","showRequestVolumes")),f.appendChild(l("Point Cloud Shading","pointCloudShading"));const D=document.createElement("div");D.setAttribute("data-bind","visible: pointCloudShading"),D.appendChild(c("Geometric Error Scale","geometricErrorScale",0,2,.01)),D.appendChild(c("Maximum Attenuation","maximumAttenuation",0,32,1)),D.appendChild(c("Base Resolution","baseResolution",0,1,.01)),D.appendChild(l("Eye Dome Lighting (EDL)","eyeDomeLighting")),f.appendChild(D);const I=document.createElement("div");I.setAttribute("data-bind","visible: eyeDomeLighting"),I.appendChild(c("EDL Strength","eyeDomeLightingStrength",0,2,.1)),I.appendChild(c("EDL Radius","eyeDomeLightingRadius",0,4,.1)),D.appendChild(I),p.appendChild(l("Freeze Frame","freezeFrame")),p.appendChild(l("Dynamic Screen Space Error","dynamicScreenSpaceError"));const L=document.createElement("div");L.appendChild(c("Maximum Screen Space Error","maximumScreenSpaceError",0,128,1)),p.appendChild(L);const N=document.createElement("div");N.setAttribute("data-bind","visible: dynamicScreenSpaceError"),N.appendChild(c("Screen Space Error Density","dynamicScreenSpaceErrorDensitySliderValue",0,1,.005,"dynamicScreenSpaceErrorDensity")),N.appendChild(c("Screen Space Error Factor","dynamicScreenSpaceErrorFactor",1,32,.1)),p.appendChild(N),u.appendChild(l("Performance","performance")),u.appendChild(i),u.appendChild(l("Statistics","showStatistics"));const y=document.createElement("div");y.className="cesium-3dTilesInspector-statistics",y.setAttribute("data-bind","html: statisticsText, visible: showStatistics"),u.appendChild(y),u.appendChild(l("Pick Statistics","showPickStatistics"));const x=document.createElement("div");x.className="cesium-3dTilesInspector-statistics",x.setAttribute("data-bind","html: pickStatisticsText, visible: showPickStatistics"),u.appendChild(x),u.appendChild(l("Resource Cache Statistics","showResourceCacheStatistics"));const T=document.createElement("div");T.className="cesium-3dTilesInspector-statistics",T.setAttribute("data-bind","html: resourceCacheStatisticsText, visible: showResourceCacheStatistics"),u.appendChild(T);const E=document.createElement("div");g.appendChild(E),E.appendChild(document.createTextNode("Color Blend Mode: "));const P=document.createElement("select");P.setAttribute("data-bind",'options: colorBlendModes, optionsText: "text", optionsValue: "value", value: colorBlendMode'),E.appendChild(P);const M=document.createElement("textarea");M.setAttribute("data-bind","textInput: styleString, event: { keydown: styleEditorKeyPress }"),E.className="cesium-cesiumInspector-styleEditor",E.appendChild(M);const O=d("Compile (Ctrl+Enter)","compileStyle");E.appendChild(O);const V=document.createElement("div");V.className="cesium-cesiumInspector-error",V.setAttribute("data-bind","text: editorError"),E.appendChild(V),m.appendChild(l("Show Picked Only","showOnlyPickedTileDebugLabel")),m.appendChild(l("Geometric Error","showGeometricError")),m.appendChild(l("Rendering Statistics","showRenderingStatistics")),m.appendChild(l("Memory Usage (MB)","showMemoryUsage")),m.appendChild(l("Url","showUrl")),_.appendChild(l("Skip Tile LODs","skipLevelOfDetail"));const R=document.createElement("div");R.appendChild(c("Skip SSE Factor","skipScreenSpaceErrorFactor",1,50,1)),_.appendChild(R);const w=document.createElement("div");w.appendChild(c("SSE before skipping LOD","baseScreenSpaceError",0,4096,1)),_.appendChild(w);const U=document.createElement("div");U.appendChild(c("Min. levels to skip","skipLevels",0,10,1)),_.appendChild(U),_.appendChild(l("Load only tiles that meet the max SSE.","immediatelyLoadDesiredLevelOfDetail")),_.appendChild(l("Load siblings of visible tiles","loadSiblings")),knockout.applyBindings(r,n)}Object.defineProperties(Cesium3DTilesInspector.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});Cesium3DTilesInspector.prototype.isDestroyed=function(){return!1};Cesium3DTilesInspector.prototype.destroy=function(){return knockout.cleanNode(this._element),this._container.removeChild(this._element),this.viewModel.destroy(),destroyObject(this)};function FullscreenButtonViewModel(e,t){defined(t)||(t=document.body),t=getElement(t);const n=this,i=knockout.observable(Fullscreen.fullscreen),r=knockout.observable(Fullscreen.enabled),o=t.ownerDocument;this.isFullscreen=void 0,knockout.defineProperty(this,"isFullscreen",{get:function(){return i()}}),this.isFullscreenEnabled=void 0,knockout.defineProperty(this,"isFullscreenEnabled",{get:function(){return r()},set:function(a){r(a&&Fullscreen.enabled)}}),this.tooltip=void 0,knockout.defineProperty(this,"tooltip",function(){return this.isFullscreenEnabled?i()?"Exit full screen":"Full screen":"Full screen unavailable"}),this._command=createCommand(function(){Fullscreen.fullscreen?Fullscreen.exitFullscreen():Fullscreen.requestFullscreen(n._fullscreenElement)},knockout.getObservable(this,"isFullscreenEnabled")),this._fullscreenElement=defaultValue(getElement(e),o.body),this._callback=function(){i(Fullscreen.fullscreen)},o.addEventListener(Fullscreen.changeEventName,this._callback)}Object.defineProperties(FullscreenButtonViewModel.prototype,{fullscreenElement:{get:function(){return this._fullscreenElement},set:function(e){if(!(e instanceof Element))throw new DeveloperError("value must be a valid Element.");this._fullscreenElement=e}},command:{get:function(){return this._command}}});FullscreenButtonViewModel.prototype.isDestroyed=function(){return!1};FullscreenButtonViewModel.prototype.destroy=function(){document.removeEventListener(Fullscreen.changeEventName,this._callback),destroyObject(this)};const enterFullScreenPath="M 83.96875 17.5625 L 83.96875 17.59375 L 76.65625 24.875 L 97.09375 24.96875 L 76.09375 45.96875 L 81.9375 51.8125 L 102.78125 30.9375 L 102.875 51.15625 L 110.15625 43.875 L 110.1875 17.59375 L 83.96875 17.5625 z M 44.125 17.59375 L 17.90625 17.625 L 17.9375 43.90625 L 25.21875 51.1875 L 25.3125 30.96875 L 46.15625 51.8125 L 52 45.96875 L 31 25 L 51.4375 24.90625 L 44.125 17.59375 z M 46.0625 76.03125 L 25.1875 96.875 L 25.09375 76.65625 L 17.8125 83.9375 L 17.8125 110.21875 L 44 110.25 L 51.3125 102.9375 L 30.90625 102.84375 L 51.875 81.875 L 46.0625 76.03125 z M 82 76.15625 L 76.15625 82 L 97.15625 103 L 76.71875 103.0625 L 84.03125 110.375 L 110.25 110.34375 L 110.21875 84.0625 L 102.9375 76.8125 L 102.84375 97 L 82 76.15625 z",exitFullScreenPath="M 104.34375 17.5625 L 83.5 38.4375 L 83.40625 18.21875 L 76.125 25.5 L 76.09375 51.78125 L 102.3125 51.8125 L 102.3125 51.78125 L 109.625 44.5 L 89.1875 44.40625 L 110.1875 23.40625 L 104.34375 17.5625 z M 23.75 17.59375 L 17.90625 23.4375 L 38.90625 44.4375 L 18.5 44.53125 L 25.78125 51.8125 L 52 51.78125 L 51.96875 25.53125 L 44.6875 18.25 L 44.625 38.46875 L 23.75 17.59375 z M 25.6875 76.03125 L 18.375 83.3125 L 38.78125 83.40625 L 17.8125 104.40625 L 23.625 110.25 L 44.5 89.375 L 44.59375 109.59375 L 51.875 102.3125 L 51.875 76.0625 L 25.6875 76.03125 z M 102.375 76.15625 L 76.15625 76.1875 L 76.1875 102.4375 L 83.46875 109.71875 L 83.5625 89.53125 L 104.40625 110.375 L 110.25 104.53125 L 89.25 83.53125 L 109.6875 83.46875 L 102.375 76.15625 z";function FullscreenButton(e,t){if(!defined(e))throw new DeveloperError("container is required.");e=getElement(e);const n=new FullscreenButtonViewModel(t,e);n._exitFullScreenPath=exitFullScreenPath,n._enterFullScreenPath=enterFullScreenPath;const i=document.createElement("button");i.type="button",i.className="cesium-button cesium-fullscreenButton",i.setAttribute("data-bind","attr: { title: tooltip },click: command,enable: isFullscreenEnabled,cesiumSvgPath: { path: isFullscreen ? _exitFullScreenPath : _enterFullScreenPath, width: 128, height: 128 }"),e.appendChild(i),knockout.applyBindings(n,i),this._container=e,this._viewModel=n,this._element=i}Object.defineProperties(FullscreenButton.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});FullscreenButton.prototype.isDestroyed=function(){return!1};FullscreenButton.prototype.destroy=function(){return this._viewModel.destroy(),knockout.cleanNode(this._element),this._container.removeChild(this._element),destroyObject(this)};function HomeButtonViewModel(e,t){if(!defined(e))throw new DeveloperError("scene is required.");this._scene=e,this._duration=t;const n=this;this._command=createCommand(function(){n._scene.camera.flyHome(n._duration)}),this.tooltip="View Home",knockout.track(this,["tooltip"])}Object.defineProperties(HomeButtonViewModel.prototype,{scene:{get:function(){return this._scene}},command:{get:function(){return this._command}},duration:{get:function(){return this._duration},set:function(e){if(defined(e)&&e<0)throw new DeveloperError("value must be positive.");this._duration=e}}});function HomeButton(e,t,n){if(!defined(e))throw new DeveloperError("container is required.");e=getElement(e);const i=new HomeButtonViewModel(t,n);i._svgPath="M14,4l-10,8.75h20l-4.25-3.7188v-4.6562h-2.812v2.1875l-2.938-2.5625zm-7.0938,9.906v10.094h14.094v-10.094h-14.094zm2.1876,2.313h3.3122v4.25h-3.3122v-4.25zm5.8442,1.281h3.406v6.438h-3.406v-6.438z";const r=document.createElement("button");r.type="button",r.className="cesium-button cesium-toolbar-button cesium-home-button",r.setAttribute("data-bind","attr: { title: tooltip },click: command,cesiumSvgPath: { path: _svgPath, width: 28, height: 28 }"),e.appendChild(r),knockout.applyBindings(i,r),this._container=e,this._viewModel=i,this._element=r}Object.defineProperties(HomeButton.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});HomeButton.prototype.isDestroyed=function(){return!1};HomeButton.prototype.destroy=function(){return knockout.cleanNode(this._element),this._container.removeChild(this._element),destroyObject(this)};const DEFAULT_HEIGHT=1e3;function GeocoderViewModel(e){if(!defined(e)||!defined(e.scene))throw new DeveloperError("options.scene is required.");defined(e.geocoderServices)?this._geocoderServices=e.geocoderServices:this._geocoderServices=[new IonGeocoderService({scene:e.scene})],this._viewContainer=e.container,this._scene=e.scene,this._flightDuration=e.flightDuration,this._searchText="",this._isSearchInProgress=!1,this._wasGeocodeCancelled=!1,this._previousCredits=[],this._complete=new Event,this._suggestions=[],this._selectedSuggestion=void 0,this._showSuggestions=!0,this._handleArrowDown=handleArrowDown,this._handleArrowUp=handleArrowUp;const t=this;this._suggestionsVisible=knockout.pureComputed(function(){const r=knockout.getObservable(t,"_suggestions")().length>0,o=knockout.getObservable(t,"_showSuggestions")();return r&&o}),this._searchCommand=createCommand(function(i){if(i=defaultValue(i,GeocodeType$1.SEARCH),t._focusTextbox=!1,defined(t._selectedSuggestion))return t.activateSuggestion(t._selectedSuggestion),!1;if(t.hideSuggestions(),t.isSearchInProgress)cancelGeocode(t);else return geocode(t,t._geocoderServices,i)}),this.deselectSuggestion=function(){t._selectedSuggestion=void 0},this.handleKeyDown=function(i,r){const o=r.key==="ArrowDown"||r.key==="Down"||r.keyCode===40,a=r.key==="ArrowUp"||r.key==="Up"||r.keyCode===38;return(o||a)&&r.preventDefault(),!0},this.handleKeyUp=function(i,r){const o=r.key==="ArrowDown"||r.key==="Down"||r.keyCode===40,a=r.key==="ArrowUp"||r.key==="Up"||r.keyCode===38,s=r.key==="Enter"||r.keyCode===13;return a?handleArrowUp(t):o?handleArrowDown(t):s&&t._searchCommand(),!0},this.activateSuggestion=function(i){t.hideSuggestions(),t._searchText=i.displayName;const r=i.destination;clearSuggestions(t),t.destinationFound(t,r)},this.hideSuggestions=function(){t._showSuggestions=!1,t._selectedSuggestion=void 0},this.showSuggestions=function(){t._showSuggestions=!0},this.handleMouseover=function(i,r){i!==t._selectedSuggestion&&(t._selectedSuggestion=i)},this.keepExpanded=!1,this.autoComplete=defaultValue(e.autocomplete,!0),this.destinationFound=defaultValue(e.destinationFound,GeocoderViewModel.flyToDestination),this._focusTextbox=!1,knockout.track(this,["_searchText","_isSearchInProgress","keepExpanded","_suggestions","_selectedSuggestion","_showSuggestions","_focusTextbox"]);const n=knockout.getObservable(this,"_searchText");n.extend({rateLimit:{timeout:500}}),this._suggestionSubscription=n.subscribe(function(){GeocoderViewModel._updateSearchSuggestions(t)}),this.isSearchInProgress=void 0,knockout.defineProperty(this,"isSearchInProgress",{get:function(){return this._isSearchInProgress}}),this.searchText=void 0,knockout.defineProperty(this,"searchText",{get:function(){return this.isSearchInProgress?"Searching...":this._searchText},set:function(i){if(typeof i!="string")throw new DeveloperError("value must be a valid string.");this._searchText=i}}),this.flightDuration=void 0,knockout.defineProperty(this,"flightDuration",{get:function(){return this._flightDuration},set:function(i){if(defined(i)&&i<0)throw new DeveloperError("value must be positive.");this._flightDuration=i}})}Object.defineProperties(GeocoderViewModel.prototype,{complete:{get:function(){return this._complete}},scene:{get:function(){return this._scene}},search:{get:function(){return this._searchCommand}},selectedSuggestion:{get:function(){return this._selectedSuggestion}},suggestions:{get:function(){return this._suggestions}}});GeocoderViewModel.prototype.destroy=function(){this._suggestionSubscription.dispose()};function handleArrowUp(e){if(e._suggestions.length===0)return;const t=e._suggestions.indexOf(e._selectedSuggestion);if(t===-1||t===0){e._selectedSuggestion=void 0;return}const n=t-1;e._selectedSuggestion=e._suggestions[n],GeocoderViewModel._adjustSuggestionsScroll(e,n)}function handleArrowDown(e){if(e._suggestions.length===0)return;const t=e._suggestions.length,i=(e._suggestions.indexOf(e._selectedSuggestion)+1)%t;e._selectedSuggestion=e._suggestions[i],GeocoderViewModel._adjustSuggestionsScroll(e,i)}function computeFlyToLocationForCartographic(e,t){const n=defined(t)?t.availability:void 0;return defined(n)?sampleTerrainMostDetailed(t,[e]).then(function(i){return e=i[0],e.height+=DEFAULT_HEIGHT,e}):(e.height+=DEFAULT_HEIGHT,Promise.resolve(e))}function flyToDestination(e,t){const n=e._scene,i=n.ellipsoid,r=n.camera,o=n.terrainProvider;let a=t,s;return t instanceof Rectangle?CesiumMath.equalsEpsilon(t.south,t.north,CesiumMath.EPSILON7)&&CesiumMath.equalsEpsilon(t.east,t.west,CesiumMath.EPSILON7)?t=Rectangle.center(t):s=computeFlyToLocationForRectangle(t,n):t=i.cartesianToCartographic(t),defined(s)||(s=computeFlyToLocationForCartographic(t,o)),s.then(function(l){a=i.cartographicToCartesian(l)}).finally(function(){r.flyTo({destination:a,complete:function(){e._complete.raiseEvent()},duration:e._flightDuration,endTransform:Matrix4.IDENTITY})})}async function attemptGeocode(e,t,n){try{return{state:"fulfilled",value:await e.geocode(t,n),credits:e.credit}}catch(i){return{state:"rejected",reason:i}}}async function geocode(e,t,n){const i=e._searchText;if(hasOnlyWhitespace(i)){e.showSuggestions();return}e._isSearchInProgress=!0,e._wasGeocodeCancelled=!1;let r,o;for(r=0;r<t.length;r++){if(e._wasGeocodeCancelled)return;if(o=await attemptGeocode(t[r],i,n),defined(o)&&o.state==="fulfilled"&&o.value.length>0)break}if(e._wasGeocodeCancelled)return;e._isSearchInProgress=!1,clearCredits(e);const a=o.value;if(o.state==="fulfilled"&&defined(a)&&a.length>0){e._searchText=a[0].displayName,e.destinationFound(e,a[0].destination);const s=updateCredits(e,GeocoderService.getCreditsFromResult(a[0]));defined(s)||updateCredit(e,t[r].credit);return}e._searchText=`${i} (not found)`}function updateCredit(e,t){defined(t)&&!e._scene.isDestroyed()&&!e._scene.frameState.creditDisplay.isDestroyed()&&(e._scene.frameState.creditDisplay.addStaticCredit(t),e._previousCredits.push(t))}function updateCredits(e,t){return defined(t)&&t.forEach(n=>updateCredit(e,n)),t}function clearCredits(e){!e._scene.isDestroyed()&&!e._scene.frameState.creditDisplay.isDestroyed()&&e._previousCredits.forEach(t=>{e._scene.frameState.creditDisplay.removeStaticCredit(t)}),e._previousCredits.length=0}function adjustSuggestionsScroll(e,t){const n=getElement(e._viewContainer),i=n.getElementsByClassName("search-results")[0],o=n.getElementsByTagName("li")[t];if(t===0){i.scrollTop=0;return}const a=o.offsetTop;a+o.clientHeight>i.clientHeight?i.scrollTop=a+o.clientHeight:a<i.scrollTop&&(i.scrollTop=a)}function cancelGeocode(e){e._isSearchInProgress&&(e._isSearchInProgress=!1,e._wasGeocodeCancelled=!0)}function hasOnlyWhitespace(e){return/^\s*$/.test(e)}function clearSuggestions(e){knockout.getObservable(e,"_suggestions").removeAll()}async function updateSearchSuggestions(e){if(!e.autoComplete)return;const t=e._searchText;if(clearSuggestions(e),clearCredits(e),!hasOnlyWhitespace(t))for(const n of e._geocoderServices){const i=await n.geocode(t,GeocodeType$1.AUTOCOMPLETE);if(e._suggestions=e._suggestions.concat(i),i.length>0){let r=!0;i.forEach(o=>{const a=GeocoderService.getCreditsFromResult(o);r=r&&!defined(a),updateCredits(e,a)}),r&&updateCredit(e,n.credit)}if(e._suggestions.length>=5)return}}GeocoderViewModel.flyToDestination=flyToDestination;GeocoderViewModel._updateSearchSuggestions=updateSearchSuggestions;GeocoderViewModel._adjustSuggestionsScroll=adjustSuggestionsScroll;GeocoderViewModel.prototype.isDestroyed=function(){return!1};GeocoderViewModel.prototype.destroy=function(){return clearCredits(this),destroyObject(this)};const startSearchPath="M29.772,26.433l-7.126-7.126c0.96-1.583,1.523-3.435,1.524-5.421C24.169,8.093,19.478,3.401,13.688,3.399C7.897,3.401,3.204,8.093,3.204,13.885c0,5.789,4.693,10.481,10.484,10.481c1.987,0,3.839-0.563,5.422-1.523l7.128,7.127L29.772,26.433zM7.203,13.885c0.006-3.582,2.903-6.478,6.484-6.486c3.579,0.008,6.478,2.904,6.484,6.486c-0.007,3.58-2.905,6.476-6.484,6.484C10.106,20.361,7.209,17.465,7.203,13.885z",stopSearchPath="M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z";function Geocoder(e){if(!defined(e)||!defined(e.container))throw new DeveloperError("options.container is required.");if(!defined(e.scene))throw new DeveloperError("options.scene is required.");const t=getElement(e.container),n=new GeocoderViewModel(e);n._startSearchPath=startSearchPath,n._stopSearchPath=stopSearchPath;const i=document.createElement("form");i.setAttribute("data-bind","submit: search");const r=document.createElement("input");r.type="search",r.className="cesium-geocoder-input",r.setAttribute("placeholder","Enter an address or landmark..."),r.setAttribute("data-bind",'textInput: searchText,disable: isSearchInProgress,event: { keyup: handleKeyUp, keydown: handleKeyDown, mouseover: deselectSuggestion },css: { "cesium-geocoder-input-wide" : keepExpanded || searchText.length > 0 },hasFocus: _focusTextbox'),this._onTextBoxFocus=function(){setTimeout(function(){r.select()},0)},r.addEventListener("focus",this._onTextBoxFocus,!1),i.appendChild(r),this._textBox=r;const o=document.createElement("span");o.className="cesium-geocoder-searchButton",o.setAttribute("data-bind","click: search,cesiumSvgPath: { path: isSearchInProgress ? _stopSearchPath : _startSearchPath, width: 32, height: 32 }"),i.appendChild(o),t.appendChild(i);const a=document.createElement("div");a.className="search-results",a.setAttribute("data-bind","visible: _suggestionsVisible");const s=document.createElement("ul");s.setAttribute("data-bind","foreach: _suggestions");const l=document.createElement("li");s.appendChild(l),l.setAttribute("data-bind","text: $data.displayName, click: $parent.activateSuggestion, event: { mouseover: $parent.handleMouseover}, css: { active: $data === $parent._selectedSuggestion }"),a.appendChild(s),t.appendChild(a),knockout.applyBindings(n,i),knockout.applyBindings(n,a),this._container=t,this._searchSuggestionsContainer=a,this._viewModel=n,this._form=i,this._onInputBegin=function(c){let d=c.target;typeof c.composedPath=="function"&&(d=c.composedPath()[0]),t.contains(d)||(n._focusTextbox=!1,n.hideSuggestions())},this._onInputEnd=function(c){n._focusTextbox=!0,n.showSuggestions()},FeatureDetection.supportsPointerEvents()?(document.addEventListener("pointerdown",this._onInputBegin,!0),t.addEventListener("pointerup",this._onInputEnd,!0),t.addEventListener("pointercancel",this._onInputEnd,!0)):(document.addEventListener("mousedown",this._onInputBegin,!0),t.addEventListener("mouseup",this._onInputEnd,!0),document.addEventListener("touchstart",this._onInputBegin,!0),t.addEventListener("touchend",this._onInputEnd,!0),t.addEventListener("touchcancel",this._onInputEnd,!0))}Object.defineProperties(Geocoder.prototype,{container:{get:function(){return this._container}},searchSuggestionsContainer:{get:function(){return this._searchSuggestionsContainer}},viewModel:{get:function(){return this._viewModel}}});Geocoder.prototype.isDestroyed=function(){return!1};Geocoder.prototype.destroy=function(){const e=this._container;return FeatureDetection.supportsPointerEvents()?(document.removeEventListener("pointerdown",this._onInputBegin,!0),e.removeEventListener("pointerup",this._onInputEnd,!0)):(document.removeEventListener("mousedown",this._onInputBegin,!0),e.removeEventListener("mouseup",this._onInputEnd,!0),document.removeEventListener("touchstart",this._onInputBegin,!0),e.removeEventListener("touchend",this._onInputEnd,!0)),this._viewModel.destroy(),knockout.cleanNode(this._form),knockout.cleanNode(this._searchSuggestionsContainer),e.removeChild(this._form),e.removeChild(this._searchSuggestionsContainer),this._textBox.removeEventListener("focus",this._onTextBoxFocus,!1),destroyObject(this)};function expandItemsHandler(e,t){t.currentTarget.parentElement.parentElement.querySelector(`#${e.name}-expander`).classList.toggle("active"),t.currentTarget.textContent=t.currentTarget.textContent==="+"?"-":"+"}function trackSublayer(e,t){knockout.track(e);for(let n=0;n<e.sublayers.length;n++)trackSublayer(e.sublayers[n])}function isFullModel(e){return e.modelName==="FullModel"}function isOverview(e){return e.modelName==="Overview"}function isTopLayer(e){return isOverview(e)||isFullModel(e)}function addTopLayer(e,t){if(isTopLayer(e)){e.visibility=!1;for(let i=0;i<e.sublayers.length;i++)e.sublayers[i].visibility=!0;const n={name:e.name,modelName:e.modelName,disable:knockout.observable(!1),index:t.sublayers.length};return t.topLayers.push(n),t.sublayers.push(e),n}}function handleTopLayerSelector(e,t){if(isTopLayer(e)){t.sublayers.forEach(i=>i.visibility=!1),t.sublayers[e.index].visibility=!0;const n=document.getElementById("bsl-wrapper");isFullModel(e)?(t.currentLevel=t.selectedLevel,n.style.display="block"):(t.selectedLevel=t.currentLevel,t.currentLevel="All",n.style.display="none")}}async function setLevels(e,t){try{const n=e.getAttributeNames();for(let i=0;i<n.length;i++)if(n[i]==="BldgLevel"){const r=e.getAttributeValues(n[i]);for(let o=0;o<r.length;o++)t.push(r[o])}t.sort((i,r)=>i-r),t.unshift("All")}catch(n){console.log(`There was an error getting attributes: ${n}`)}}function I3SBuildingSceneLayerExplorerViewModel(e){const t=this;this.levels=[],this.viewModel={sublayers:[],levels:this.levels,currentLevel:knockout.observable(),selectedLevel:"All",topLayers:[{name:"Select a layer to explore...",disable:knockout.observable(!0),index:-1}],currentLayer:knockout.observable(),expandClickHandler:expandItemsHandler,setOptionDisable:function(i,r){knockout.applyBindingsToNode(i,{disable:r.disable},r)},defaultLayer:void 0},this.viewModel.currentLayer.subscribe(function(i){handleTopLayerSelector(i,t.viewModel)});const n=e.sublayers;for(let i=0;i<n.length;i++){trackSublayer(n[i],this.viewModel);const r=addTopLayer(n[i],this.viewModel);defined(r)&&(isOverview(r)||!defined(this.viewModel.defaultLayer)&&isFullModel(r))&&(this.viewModel.defaultLayer=r)}if(this.viewModel.topLayers.length===1&&n.length>0){e.show=!1;const i={name:"Full Model",modelName:"FullModel",visibility:e.show,sublayers:e.sublayers};this.viewModel.defaultLayer=addTopLayer(i,this.viewModel),this.viewModel.currentLayer.subscribe(function(r){e.show=isFullModel(r)})}else this.viewModel.topLayers.length===1&&(this.viewModel.topLayers[0].name="Building layers not found");return setLevels(e,this.levels),this.viewModel.currentLevel.subscribe(function(i){i!=="All"?e.filterByAttributes([{name:"BldgLevel",values:[i]}]):e.filterByAttributes()}),this.viewModel}function I3SBuildingSceneLayerExplorer(e,t){const n=document.getElementById(e);Check.defined("container",n),Check.defined("i3sProvider",t);const i=document.createElement("div");i.classList.add("cesium-viewer-i3s-explorer"),i.innerHTML=`
        <h3>Building explorer</h3>
        <select
          data-bind="options: topLayers, optionsText: 'name', optionsAfterRender: setOptionDisable, value: currentLayer"
        ></select>
        <div id="bsl-wrapper">
          <h3>Select Level</h3>
          <select data-bind="options: levels, value: currentLevel"></select>
          <h3>Disciplines & Categories</h3>
          <ul class="layersList" data-bind="foreach: sublayers">
            <ul class="layersList" data-bind="foreach: sublayers.sort(function (l, r) { return l.name.localeCompare(r.name) })">
              <li>
                <div class="li-wrapper">
                  <span
                    class="expandItem"
                    data-bind="click: $root.expandClickHandler"
                    >+</span
                  >
                  <input
                    type="checkbox"
                    data-bind="checked: visibility, valueUpdate: 'input', attr: { id: name}"
                  />
                  <label data-bind="attr: { for: name}">
                    <span data-bind="text: name"></span>
                  </label>
                </div>
                <ul class="nested" data-bind="attr: { id: name + '-expander'}">
                  <li data-bind="foreach: sublayers.sort(function (l, r) { return l.name.localeCompare(r.name) })">
                    <div class="li-wrapper">
                      <input
                        type="checkbox"
                        data-bind="checked: visibility, valueUpdate: 'input', attr: { id: name}"
                      />
                      <label data-bind="attr: { for: name}">
                        <span data-bind="text: name"></span>
                      </label>
                    </div>
                  </li>
                </ul>
              </li>
            </ul>
          </ul>
        </div>`,n.appendChild(i);const r=new I3SBuildingSceneLayerExplorerViewModel(t);knockout.track(r),knockout.applyBindings(r,n),defined(r.defaultLayer)&&(r.currentLayer=r.defaultLayer)}const cameraEnabledPath="M 13.84375 7.03125 C 11.412798 7.03125 9.46875 8.975298 9.46875 11.40625 L 9.46875 11.59375 L 2.53125 7.21875 L 2.53125 24.0625 L 9.46875 19.6875 C 9.4853444 22.104033 11.423165 24.0625 13.84375 24.0625 L 25.875 24.0625 C 28.305952 24.0625 30.28125 22.087202 30.28125 19.65625 L 30.28125 11.40625 C 30.28125 8.975298 28.305952 7.03125 25.875 7.03125 L 13.84375 7.03125 z",cameraDisabledPath="M 27.34375 1.65625 L 5.28125 27.9375 L 8.09375 30.3125 L 30.15625 4.03125 L 27.34375 1.65625 z M 13.84375 7.03125 C 11.412798 7.03125 9.46875 8.975298 9.46875 11.40625 L 9.46875 11.59375 L 2.53125 7.21875 L 2.53125 24.0625 L 9.46875 19.6875 C 9.4724893 20.232036 9.5676108 20.7379 9.75 21.21875 L 21.65625 7.03125 L 13.84375 7.03125 z M 28.21875 7.71875 L 14.53125 24.0625 L 25.875 24.0625 C 28.305952 24.0625 30.28125 22.087202 30.28125 19.65625 L 30.28125 11.40625 C 30.28125 9.8371439 29.456025 8.4902779 28.21875 7.71875 z";function InfoBoxViewModel(){this._cameraClicked=new Event,this._closeClicked=new Event,this.maxHeight=500,this.enableCamera=!1,this.isCameraTracking=!1,this.showInfo=!1,this.titleText="",this.description="",knockout.track(this,["showInfo","titleText","description","maxHeight","enableCamera","isCameraTracking"]),this._loadingIndicatorHtml='<div class="cesium-infoBox-loadingContainer"><span class="cesium-infoBox-loading"></span></div>',this.cameraIconPath=void 0,knockout.defineProperty(this,"cameraIconPath",{get:function(){return!this.enableCamera||this.isCameraTracking?cameraDisabledPath:cameraEnabledPath}}),knockout.defineProperty(this,"_bodyless",{get:function(){return!defined(this.description)||this.description.length===0}})}InfoBoxViewModel.prototype.maxHeightOffset=function(e){return`${this.maxHeight-e}px`};Object.defineProperties(InfoBoxViewModel.prototype,{cameraClicked:{get:function(){return this._cameraClicked}},closeClicked:{get:function(){return this._closeClicked}}});function InfoBox(e){Check.defined("container",e),e=getElement(e);const t=document.createElement("div");t.className="cesium-infoBox",t.setAttribute("data-bind",'css: { "cesium-infoBox-visible" : showInfo, "cesium-infoBox-bodyless" : _bodyless }'),e.appendChild(t);const n=document.createElement("div");n.className="cesium-infoBox-title",n.setAttribute("data-bind","text: titleText"),t.appendChild(n);const i=document.createElement("button");i.type="button",i.className="cesium-button cesium-infoBox-camera",i.setAttribute("data-bind",'attr: { title: "Focus camera on object" },click: function () { cameraClicked.raiseEvent(this); },enable: enableCamera,cesiumSvgPath: { path: cameraIconPath, width: 32, height: 32 }'),t.appendChild(i);const r=document.createElement("button");r.type="button",r.className="cesium-infoBox-close",r.setAttribute("data-bind","click: function () { closeClicked.raiseEvent(this); }"),r.innerHTML="&times;",t.appendChild(r);const o=document.createElement("iframe");o.className="cesium-infoBox-iframe",o.setAttribute("sandbox","allow-same-origin allow-popups allow-forms"),o.setAttribute("data-bind","style : { maxHeight : maxHeightOffset(40) }"),o.setAttribute("allowfullscreen",!0),t.appendChild(o);const a=new InfoBoxViewModel;knockout.applyBindings(a,t),this._container=e,this._element=t,this._frame=o,this._viewModel=a,this._descriptionSubscription=void 0;const s=this;o.addEventListener("load",function(){const l=o.contentDocument,c=l.createElement("link");c.href=buildModuleUrl("Widgets/InfoBox/InfoBoxDescription.css"),c.rel="stylesheet",c.type="text/css";const d=l.createElement("div");d.className="cesium-infoBox-description",l.head.appendChild(c),l.body.appendChild(d),s._descriptionSubscription=subscribeAndEvaluate(a,"description",function(h){o.style.height="5px",d.innerHTML=h;let f=null;const p=d.firstElementChild;if(p!==null&&d.childNodes.length===1){const m=window.getComputedStyle(p);if(m!==null){const g=m["background-color"],_=Color.fromCssColorString(g);defined(_)&&_.alpha!==0&&(f=m["background-color"])}}t.style["background-color"]=f;const u=d.getBoundingClientRect().height;o.style.height=`${u}px`})}),o.setAttribute("src","about:blank")}Object.defineProperties(InfoBox.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}},frame:{get:function(){return this._frame}}});InfoBox.prototype.isDestroyed=function(){return!1};InfoBox.prototype.destroy=function(){const e=this._container;return knockout.cleanNode(this._element),e.removeChild(this._element),defined(this._descriptionSubscription)&&this._descriptionSubscription.dispose(),destroyObject(this)};function NavigationHelpButtonViewModel(){this.showInstructions=!1;const e=this;this._command=createCommand(function(){e.showInstructions=!e.showInstructions}),this._showClick=createCommand(function(){e._touch=!1}),this._showTouch=createCommand(function(){e._touch=!0}),this._touch=!1,this.tooltip="Navigation Instructions",knockout.track(this,["tooltip","showInstructions","_touch"])}Object.defineProperties(NavigationHelpButtonViewModel.prototype,{command:{get:function(){return this._command}},showClick:{get:function(){return this._showClick}},showTouch:{get:function(){return this._showTouch}}});function NavigationHelpButton(e){if(!defined(e)||!defined(e.container))throw new DeveloperError("options.container is required.");const t=getElement(e.container),n=new NavigationHelpButtonViewModel,i=defaultValue(e.instructionsInitiallyVisible,!1);n.showInstructions=i,n._svgPath="M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466z M17.328,24.371h-2.707v-2.596h2.707V24.371zM17.328,19.003v0.858h-2.707v-1.057c0-3.19,3.63-3.696,3.63-5.963c0-1.034-0.924-1.826-2.134-1.826c-1.254,0-2.354,0.924-2.354,0.924l-1.541-1.915c0,0,1.519-1.584,4.137-1.584c2.487,0,4.796,1.54,4.796,4.136C21.156,16.208,17.328,16.627,17.328,19.003z";const r=document.createElement("span");r.className="cesium-navigationHelpButton-wrapper",t.appendChild(r);const o=document.createElement("button");o.type="button",o.className="cesium-button cesium-toolbar-button cesium-navigation-help-button",o.setAttribute("data-bind","attr: { title: tooltip },click: command,cesiumSvgPath: { path: _svgPath, width: 32, height: 32 }"),r.appendChild(o);const a=document.createElement("div");a.className="cesium-navigation-help",a.setAttribute("data-bind",'css: { "cesium-navigation-help-visible" : showInstructions}'),r.appendChild(a);const s=document.createElement("button");s.type="button",s.className="cesium-navigation-button cesium-navigation-button-left",s.setAttribute("data-bind",'click: showClick, css: {"cesium-navigation-button-selected": !_touch, "cesium-navigation-button-unselected": _touch}');const l=document.createElement("img");l.src=buildModuleUrl("Widgets/Images/NavigationHelp/Mouse.svg"),l.className="cesium-navigation-button-icon",l.style.width="25px",l.style.height="25px",s.appendChild(l),s.appendChild(document.createTextNode("Mouse"));const c=document.createElement("button");c.type="button",c.className="cesium-navigation-button cesium-navigation-button-right",c.setAttribute("data-bind",'click: showTouch, css: {"cesium-navigation-button-selected": _touch, "cesium-navigation-button-unselected": !_touch}');const d=document.createElement("img");d.src=buildModuleUrl("Widgets/Images/NavigationHelp/Touch.svg"),d.className="cesium-navigation-button-icon",d.style.width="25px",d.style.height="25px",c.appendChild(d),c.appendChild(document.createTextNode("Touch")),a.appendChild(s),a.appendChild(c);const h=document.createElement("div");h.className="cesium-click-navigation-help cesium-navigation-help-instructions",h.setAttribute("data-bind",'css: { "cesium-click-navigation-help-visible" : !_touch}'),h.innerHTML=`            <table>                <tr>                    <td><img src="${buildModuleUrl("Widgets/Images/NavigationHelp/MouseLeft.svg")}" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-pan">Pan view</div>                        <div class="cesium-navigation-help-details">Left click + drag</div>                    </td>                </tr>                <tr>                    <td><img src="${buildModuleUrl("Widgets/Images/NavigationHelp/MouseRight.svg")}" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-zoom">Zoom view</div>                        <div class="cesium-navigation-help-details">Right click + drag, or</div>                        <div class="cesium-navigation-help-details">Mouse wheel scroll</div>                    </td>                </tr>                <tr>                    <td><img src="${buildModuleUrl("Widgets/Images/NavigationHelp/MouseMiddle.svg")}" width="48" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-rotate">Rotate view</div>                        <div class="cesium-navigation-help-details">Middle click + drag, or</div>                        <div class="cesium-navigation-help-details">CTRL + Left/Right click + drag</div>                    </td>                </tr>            </table>`,a.appendChild(h);const f=document.createElement("div");f.className="cesium-touch-navigation-help cesium-navigation-help-instructions",f.setAttribute("data-bind",'css: { "cesium-touch-navigation-help-visible" : _touch}'),f.innerHTML=`            <table>                <tr>                    <td><img src="${buildModuleUrl("Widgets/Images/NavigationHelp/TouchDrag.svg")}" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-pan">Pan view</div>                        <div class="cesium-navigation-help-details">One finger drag</div>                    </td>                </tr>                <tr>                    <td><img src="${buildModuleUrl("Widgets/Images/NavigationHelp/TouchZoom.svg")}" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-zoom">Zoom view</div>                        <div class="cesium-navigation-help-details">Two finger pinch</div>                    </td>                </tr>                <tr>                    <td><img src="${buildModuleUrl("Widgets/Images/NavigationHelp/TouchTilt.svg")}" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-rotate">Tilt view</div>                        <div class="cesium-navigation-help-details">Two finger drag, same direction</div>                    </td>                </tr>                <tr>                    <td><img src="${buildModuleUrl("Widgets/Images/NavigationHelp/TouchRotate.svg")}" width="70" height="48" /></td>                    <td>                        <div class="cesium-navigation-help-tilt">Rotate view</div>                        <div class="cesium-navigation-help-details">Two finger drag, opposite direction</div>                    </td>                </tr>            </table>`,a.appendChild(f),knockout.applyBindings(n,r),this._container=t,this._viewModel=n,this._wrapper=r,this._closeInstructions=function(p){r.contains(p.target)||(n.showInstructions=!1)},FeatureDetection.supportsPointerEvents()?document.addEventListener("pointerdown",this._closeInstructions,!0):(document.addEventListener("mousedown",this._closeInstructions,!0),document.addEventListener("touchstart",this._closeInstructions,!0))}Object.defineProperties(NavigationHelpButton.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});NavigationHelpButton.prototype.isDestroyed=function(){return!1};NavigationHelpButton.prototype.destroy=function(){return FeatureDetection.supportsPointerEvents()?document.removeEventListener("pointerdown",this._closeInstructions,!0):(document.removeEventListener("mousedown",this._closeInstructions,!0),document.removeEventListener("touchstart",this._closeInstructions,!0)),knockout.cleanNode(this._wrapper),this._container.removeChild(this._wrapper),destroyObject(this)};function PerformanceWatchdogViewModel(e){if(!defined(e)||!defined(e.scene))throw new DeveloperError("options.scene is required.");this._scene=e.scene,this.lowFrameRateMessage=defaultValue(e.lowFrameRateMessage,"This application appears to be performing poorly on your system.  Please try using a different web browser or updating your video drivers."),this.lowFrameRateMessageDismissed=!1,this.showingLowFrameRateMessage=!1,knockout.track(this,["lowFrameRateMessage","lowFrameRateMessageDismissed","showingLowFrameRateMessage"]);const t=this;this._dismissMessage=createCommand(function(){t.showingLowFrameRateMessage=!1,t.lowFrameRateMessageDismissed=!0});const n=FrameRateMonitor.fromScene(e.scene);this._unsubscribeLowFrameRate=n.lowFrameRate.addEventListener(function(){t.lowFrameRateMessageDismissed||(t.showingLowFrameRateMessage=!0)}),this._unsubscribeNominalFrameRate=n.nominalFrameRate.addEventListener(function(){t.showingLowFrameRateMessage=!1})}Object.defineProperties(PerformanceWatchdogViewModel.prototype,{scene:{get:function(){return this._scene}},dismissMessage:{get:function(){return this._dismissMessage}}});PerformanceWatchdogViewModel.prototype.destroy=function(){return this._unsubscribeLowFrameRate(),this._unsubscribeNominalFrameRate(),destroyObject(this)};function PerformanceWatchdog(e){if(!defined(e)||!defined(e.container))throw new DeveloperError("options.container is required.");if(!defined(e.scene))throw new DeveloperError("options.scene is required.");const t=getElement(e.container),n=new PerformanceWatchdogViewModel(e),i=document.createElement("div");i.className="cesium-performance-watchdog-message-area",i.setAttribute("data-bind","visible: showingLowFrameRateMessage");const r=document.createElement("button");r.setAttribute("type","button"),r.className="cesium-performance-watchdog-message-dismiss",r.innerHTML="&times;",r.setAttribute("data-bind","click: dismissMessage"),i.appendChild(r);const o=document.createElement("div");o.className="cesium-performance-watchdog-message",o.setAttribute("data-bind","html: lowFrameRateMessage"),i.appendChild(o),t.appendChild(i),knockout.applyBindings(n,i),this._container=t,this._viewModel=n,this._element=i}Object.defineProperties(PerformanceWatchdog.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});PerformanceWatchdog.prototype.isDestroyed=function(){return!1};PerformanceWatchdog.prototype.destroy=function(){return this._viewModel.destroy(),knockout.cleanNode(this._element),this._container.removeChild(this._element),destroyObject(this)};function ProjectionPickerViewModel(e){if(!defined(e))throw new DeveloperError("scene is required.");this._scene=e,this._orthographic=e.camera.frustum instanceof OrthographicFrustum,this._flightInProgress=!1,this.dropDownVisible=!1,this.tooltipPerspective="Perspective Projection",this.tooltipOrthographic="Orthographic Projection",this.selectedTooltip=void 0,this.sceneMode=e.mode,knockout.track(this,["_orthographic","_flightInProgress","sceneMode","dropDownVisible","tooltipPerspective","tooltipOrthographic"]);const t=this;knockout.defineProperty(this,"selectedTooltip",function(){return t._orthographic?t.tooltipOrthographic:t.tooltipPerspective}),this._toggleDropDown=createCommand(function(){t.sceneMode===SceneMode.SCENE2D||t._flightInProgress||(t.dropDownVisible=!t.dropDownVisible)}),this._eventHelper=new EventHelper,this._eventHelper.add(e.morphComplete,function(n,i,r,o){t.sceneMode=r,t._orthographic=r===SceneMode.SCENE2D||t._scene.camera.frustum instanceof OrthographicFrustum}),this._eventHelper.add(e.preRender,function(){t._flightInProgress=defined(e.camera._currentFlight)}),this._switchToPerspective=createCommand(function(){t.sceneMode!==SceneMode.SCENE2D&&(t._scene.camera.switchToPerspectiveFrustum(),t._orthographic=!1,t.dropDownVisible=!1)}),this._switchToOrthographic=createCommand(function(){t.sceneMode!==SceneMode.SCENE2D&&(t._scene.camera.switchToOrthographicFrustum(),t._orthographic=!0,t.dropDownVisible=!1)}),this._sceneMode=SceneMode}Object.defineProperties(ProjectionPickerViewModel.prototype,{scene:{get:function(){return this._scene}},toggleDropDown:{get:function(){return this._toggleDropDown}},switchToPerspective:{get:function(){return this._switchToPerspective}},switchToOrthographic:{get:function(){return this._switchToOrthographic}},isOrthographicProjection:{get:function(){return this._orthographic}}});ProjectionPickerViewModel.prototype.isDestroyed=function(){return!1};ProjectionPickerViewModel.prototype.destroy=function(){this._eventHelper.removeAll(),destroyObject(this)};const perspectivePath="M 28.15625,10.4375 9.125,13.21875 13.75,43.25 41.75,55.09375 50.8125,37 54.5,11.9375 z m 0.125,3 19.976451,0.394265 L 43.03125,16.875 22.6875,14.28125 z M 50.971746,15.705477 47.90625,36.03125 42.53125,46 44.84375,19.3125 z M 12.625,16.03125 l 29.15625,3.6875 -2.65625,31 L 16.4375,41.125 z",orthographicPath="m 31.560594,6.5254438 -20.75,12.4687502 0.1875,24.5625 22.28125,11.8125 19.5,-12 0.65625,-0.375 0,-0.75 0.0312,-23.21875 z m 0.0625,3.125 16.65625,9.5000002 -16.125,10.28125 -17.34375,-9.71875 z m 18.96875,11.1875002 0.15625,20.65625 -17.46875,10.59375 0.15625,-20.28125 z m -37.0625,1.25 17.21875,9.625 -0.15625,19.21875 -16.9375,-9 z";function ProjectionPicker(e,t){if(!defined(e))throw new DeveloperError("container is required.");if(!defined(t))throw new DeveloperError("scene is required.");e=getElement(e);const n=new ProjectionPickerViewModel(t);n._perspectivePath=perspectivePath,n._orthographicPath=orthographicPath;const i=document.createElement("span");i.className="cesium-projectionPicker-wrapper cesium-toolbar-button",e.appendChild(i);const r=document.createElement("button");r.type="button",r.className="cesium-button cesium-toolbar-button",r.setAttribute("data-bind",'css: { "cesium-projectionPicker-buttonPerspective": !_orthographic,       "cesium-projectionPicker-buttonOrthographic": _orthographic,       "cesium-button-disabled" : sceneMode === _sceneMode.SCENE2D || _flightInProgress,        "cesium-projectionPicker-selected": dropDownVisible },attr: { title: selectedTooltip },click: toggleDropDown'),r.innerHTML='<!-- ko cesiumSvgPath: { path: _perspectivePath, width: 64, height: 64, css: "cesium-projectionPicker-iconPerspective" } --><!-- /ko --><!-- ko cesiumSvgPath: { path: _orthographicPath, width: 64, height: 64, css: "cesium-projectionPicker-iconOrthographic" } --><!-- /ko -->',i.appendChild(r);const o=document.createElement("button");o.type="button",o.className="cesium-button cesium-toolbar-button cesium-projectionPicker-dropDown-icon",o.setAttribute("data-bind",'css: { "cesium-projectionPicker-visible" : (dropDownVisible && _orthographic),       "cesium-projectionPicker-none" : !_orthographic,       "cesium-projectionPicker-hidden" : !dropDownVisible },attr: { title: tooltipPerspective },click: switchToPerspective,cesiumSvgPath: { path: _perspectivePath, width: 64, height: 64 }'),i.appendChild(o);const a=document.createElement("button");a.type="button",a.className="cesium-button cesium-toolbar-button cesium-projectionPicker-dropDown-icon",a.setAttribute("data-bind",'css: { "cesium-projectionPicker-visible" : (dropDownVisible && !_orthographic),       "cesium-projectionPicker-none" : _orthographic,       "cesium-projectionPicker-hidden" : !dropDownVisible},attr: { title: tooltipOrthographic },click: switchToOrthographic,cesiumSvgPath: { path: _orthographicPath, width: 64, height: 64 }'),i.appendChild(a),knockout.applyBindings(n,i),this._viewModel=n,this._container=e,this._wrapper=i,this._closeDropDown=function(s){i.contains(s.target)||(n.dropDownVisible=!1)},FeatureDetection.supportsPointerEvents()?document.addEventListener("pointerdown",this._closeDropDown,!0):(document.addEventListener("mousedown",this._closeDropDown,!0),document.addEventListener("touchstart",this._closeDropDown,!0))}Object.defineProperties(ProjectionPicker.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});ProjectionPicker.prototype.isDestroyed=function(){return!1};ProjectionPicker.prototype.destroy=function(){return this._viewModel.destroy(),FeatureDetection.supportsPointerEvents()?document.removeEventListener("pointerdown",this._closeDropDown,!0):(document.removeEventListener("mousedown",this._closeDropDown,!0),document.removeEventListener("touchstart",this._closeDropDown,!0)),knockout.cleanNode(this._wrapper),this._container.removeChild(this._wrapper),destroyObject(this)};function SceneModePickerViewModel(e,t){if(!defined(e))throw new DeveloperError("scene is required.");this._scene=e;const n=this,i=function(r,o,a,s){n.sceneMode=a,n.dropDownVisible=!1};this._eventHelper=new EventHelper,this._eventHelper.add(e.morphStart,i),this._duration=defaultValue(t,2),this.sceneMode=e.mode,this.dropDownVisible=!1,this.tooltip2D="2D",this.tooltip3D="3D",this.tooltipColumbusView="Columbus View",knockout.track(this,["sceneMode","dropDownVisible","tooltip2D","tooltip3D","tooltipColumbusView"]),this.selectedTooltip=void 0,knockout.defineProperty(this,"selectedTooltip",function(){const r=n.sceneMode;return r===SceneMode.SCENE2D?n.tooltip2D:r===SceneMode.SCENE3D?n.tooltip3D:n.tooltipColumbusView}),this._toggleDropDown=createCommand(function(){n.dropDownVisible=!n.dropDownVisible}),this._morphTo2D=createCommand(function(){e.morphTo2D(n._duration)}),this._morphTo3D=createCommand(function(){e.morphTo3D(n._duration)}),this._morphToColumbusView=createCommand(function(){e.morphToColumbusView(n._duration)}),this._sceneMode=SceneMode}Object.defineProperties(SceneModePickerViewModel.prototype,{scene:{get:function(){return this._scene}},duration:{get:function(){return this._duration},set:function(e){if(e<0)throw new DeveloperError("duration value must be positive.");this._duration=e}},toggleDropDown:{get:function(){return this._toggleDropDown}},morphTo2D:{get:function(){return this._morphTo2D}},morphTo3D:{get:function(){return this._morphTo3D}},morphToColumbusView:{get:function(){return this._morphToColumbusView}}});SceneModePickerViewModel.prototype.isDestroyed=function(){return!1};SceneModePickerViewModel.prototype.destroy=function(){this._eventHelper.removeAll(),destroyObject(this)};const globePath="m 32.401392,4.9330437 c -7.087603,0 -14.096095,2.884602 -19.10793,7.8946843 -5.0118352,5.010083 -7.9296167,11.987468 -7.9296167,19.072999 0,7.085531 2.9177815,14.097848 7.9296167,19.107931 4.837653,4.835961 11.541408,7.631372 18.374354,7.82482 0.05712,0.01231 0.454119,0.139729 0.454119,0.139729 l 0.03493,-0.104797 c 0.08246,7.84e-4 0.162033,0.03493 0.244525,0.03493 0.08304,0 0.161515,-0.03414 0.244526,-0.03493 l 0.03493,0.104797 c 0,0 0.309474,-0.129487 0.349323,-0.139729 6.867765,-0.168094 13.582903,-2.965206 18.444218,-7.82482 2.558195,-2.5573 4.551081,-5.638134 5.903547,-8.977584 1.297191,-3.202966 2.02607,-6.661489 2.02607,-10.130347 0,-6.237309 -2.366261,-12.31219 -6.322734,-17.116794 -0.0034,-0.02316 0.0049,-0.04488 0,-0.06986 -0.01733,-0.08745 -0.104529,-0.278855 -0.104797,-0.279458 -5.31e-4,-0.0012 -0.522988,-0.628147 -0.523984,-0.62878         -3.47e-4,-2.2e-4 -0.133444,-0.03532 -0.244525,-0.06987 C 51.944299,13.447603 51.751076,13.104317 51.474391,12.827728 46.462556,7.8176457 39.488996,4.9330437 32.401392,4.9330437 z m -2.130866,3.5281554 0.104797,9.6762289 c -4.111695,-0.08361 -7.109829,-0.423664 -9.257041,-0.943171 1.198093,-2.269271 2.524531,-4.124404 3.91241,-5.414496 2.167498,-2.0147811 3.950145,-2.8540169 5.239834,-3.3185619 z m 2.794579,0 c 1.280302,0.4754953 3.022186,1.3285948 5.065173,3.2486979 1.424667,1.338973 2.788862,3.303645 3.982275,5.728886 -2.29082,0.403367 -5.381258,0.621049 -8.942651,0.698645 L 33.065105,8.4611991 z m 5.728886,0.2445256 c 4.004072,1.1230822 7.793098,3.1481363 10.724195,6.0782083 0.03468,0.03466 0.07033,0.06991 0.104797,0.104797 -0.45375,0.313891 -0.923054,0.663002 -1.956205,1.082899 -0.647388,0.263114 -1.906242,0.477396 -2.829511,0.733577 -1.382296,-2.988132         -3.027146,-5.368585 -4.785716,-7.0213781 -0.422866,-0.397432 -0.835818,-0.6453247 -1.25756,-0.9781032 z m -15.33525,0.7685092 c -0.106753,0.09503 -0.207753,0.145402 -0.31439,0.244526 -1.684973,1.5662541 -3.298068,3.8232211 -4.680919,6.5672591 -0.343797,-0.14942 -1.035052,-0.273198 -1.292493,-0.419186 -0.956528,-0.542427 -1.362964,-1.022024 -1.537018,-1.292493 -0.0241,-0.03745 -0.01868,-0.0401 -0.03493,-0.06986 2.250095,-2.163342 4.948824,-3.869984 7.859752,-5.0302421 z m -9.641296,7.0912431 c 0.464973,0.571618 0.937729,1.169056 1.956205,1.746612 0.349907,0.198425 1.107143,0.335404 1.537018,0.523983 -1.20166,3.172984 -1.998037,7.051901 -2.165798,11.772162 C 14.256557,30.361384 12.934823,30.161483 12.280427,29.90959 10.644437,29.279855 9.6888882,28.674891 9.1714586,28.267775 8.6540289,27.860658 8.6474751,27.778724 8.6474751,27.778724 l -0.069864,0.03493 C 9.3100294,23.691285         11.163248,19.798527 13.817445,16.565477 z m 37.552149,0.523984 c 2.548924,3.289983 4.265057,7.202594 4.890513,11.318043 -0.650428,0.410896 -1.756876,1.001936 -3.563088,1.606882 -1.171552,0.392383 -3.163859,0.759153 -4.960377,1.117832 -0.04367,-4.752703 -0.784809,-8.591423 -1.88634,-11.807094 0.917574,-0.263678 2.170552,-0.486495 2.864443,-0.76851 1.274693,-0.518066 2.003942,-1.001558 2.654849,-1.467153 z m -31.439008,2.619917 c 2.487341,0.672766 5.775813,1.137775 10.479669,1.222628 l 0.104797,10.689263 0,0.03493 0,0.733577 c -5.435005,-0.09059 -9.512219,-0.519044 -12.610536,-1.117831 0.106127,-4.776683 0.879334,-8.55791 2.02607,-11.562569 z m 23.264866,0.31439 c 1.073459,3.067541 1.833795,6.821314 1.816476,11.702298 -3.054474,0.423245 -7.062018,0.648559 -11.702298,0.698644 l 0,-0.838373 -0.104796,-10.654331 c 4.082416,-0.0864 7.404468,-0.403886 9.990618,-0.908238 z         M 8.2632205,30.922625 c 0.7558676,0.510548 1.5529563,1.013339 3.0041715,1.57195 0.937518,0.360875 2.612202,0.647642 3.91241,0.978102 0.112814,3.85566 0.703989,7.107756 1.606883,9.920754 -1.147172,-0.324262 -2.644553,-0.640648 -3.423359,-0.978102 -1.516688,-0.657177 -2.386627,-1.287332 -2.864443,-1.71168 -0.477816,-0.424347 -0.489051,-0.489051 -0.489051,-0.489051 L 9.8002387,40.319395 C 8.791691,37.621767 8.1584238,34.769583 8.1584238,31.900727 c 0,-0.330153 0.090589,-0.648169 0.1047967,-0.978102 z m 48.2763445,0.419186 c 0.0047,0.188973 0.06986,0.36991 0.06986,0.558916 0,2.938869 -0.620228,5.873558 -1.676747,8.628261 -0.07435,0.07583 -0.06552,0.07411 -0.454119,0.349323 -0.606965,0.429857 -1.631665,1.042044 -3.318562,1.676747 -1.208528,0.454713 -3.204964,0.850894 -5.135038,1.25756 0.84593,-2.765726 1.41808,-6.005357 1.606883,-9.815957 2.232369,-0.413371 4.483758,-0.840201         5.938479,-1.327425 1.410632,-0.472457 2.153108,-0.89469 2.96924,-1.327425 z m -38.530252,2.864443 c 3.208141,0.56697 7.372279,0.898588 12.575603,0.978103 l 0.174662,9.885821 c -4.392517,-0.06139 -8.106722,-0.320566 -10.863925,-0.803441 -1.051954,-2.664695 -1.692909,-6.043794 -1.88634,-10.060483 z m 26.793022,0.31439 c -0.246298,3.923551 -0.877762,7.263679 -1.816476,9.885822 -2.561957,0.361954 -5.766249,0.560708 -9.431703,0.62878 l -0.174661,-9.815957 c 4.491734,-0.04969 8.334769,-0.293032 11.42284,-0.698645 z M 12.035901,44.860585 c 0.09977,0.04523 0.105535,0.09465 0.209594,0.139729 1.337656,0.579602 3.441099,1.058072 5.589157,1.537018 1.545042,3.399208 3.548524,5.969402 5.589157,7.789888 -3.034411,-1.215537 -5.871615,-3.007978 -8.174142,-5.309699 -1.245911,-1.245475 -2.271794,-2.662961 -3.213766,-4.156936 z m 40.69605,0 c -0.941972,1.493975 -1.967855,2.911461         -3.213765,4.156936 -2.74253,2.741571 -6.244106,4.696717 -9.955686,5.868615 0.261347,-0.241079 0.507495,-0.394491 0.768509,-0.663713 1.674841,-1.727516 3.320792,-4.181056 4.645987,-7.265904 2.962447,-0.503021 5.408965,-1.122293 7.161107,-1.781544 0.284034,-0.106865 0.337297,-0.207323 0.593848,-0.31439 z m -31.404076,2.305527 c 2.645807,0.376448 5.701178,0.649995 9.466635,0.698645 l 0.139729,7.789888 c -1.38739,-0.480844 -3.316218,-1.29837 -5.659022,-3.388427 -1.388822,-1.238993 -2.743668,-3.0113 -3.947342,-5.100106 z m 20.365491,0.104797 c -1.04872,2.041937 -2.174337,3.779068 -3.353494,4.995309 -1.853177,1.911459 -3.425515,2.82679 -4.611055,3.353494 l -0.139729,-7.789887 c 3.13091,-0.05714 5.728238,-0.278725 8.104278,-0.558916 z",flatMapPath="m 2.9825053,17.550598 0,1.368113 0,26.267766 0,1.368113 1.36811,0 54.9981397,0 1.36811,0 0,-1.368113 0,-26.267766 0,-1.368113 -1.36811,0 -54.9981397,0 -1.36811,0 z m 2.73623,2.736226 10.3292497,0 0,10.466063 -10.3292497,0 0,-10.466063 z m 13.0654697,0 11.69737,0 0,10.466063 -11.69737,0 0,-10.466063 z m 14.43359,0 11.69737,0 0,10.466063 -11.69737,0 0,-10.466063 z m 14.43359,0 10.32926,0 0,10.466063 -10.32926,0 0,-10.466063 z m -41.9326497,13.202288 10.3292497,0 0,10.329252 -10.3292497,0 0,-10.329252 z m 13.0654697,0 11.69737,0 0,10.329252 -11.69737,0 0,-10.329252 z m 14.43359,0 11.69737,0 0,10.329252 -11.69737,0 0,-10.329252 z m 14.43359,0 10.32926,0 0,10.329252 -10.32926,0 0,-10.329252 z",columbusViewPath="m 14.723969,17.675598 -0.340489,0.817175 -11.1680536,26.183638 -0.817175,1.872692 2.076986,0 54.7506996,0 2.07698,0 -0.81717,-1.872692 -11.16805,-26.183638 -0.34049,-0.817175 -0.91933,0 -32.414586,0 -0.919322,0 z m 1.838643,2.723916 6.196908,0 -2.928209,10.418977 -7.729111,0 4.460412,-10.418977 z m 9.02297,0 4.903049,0 0,10.418977 -7.831258,0 2.928209,-10.418977 z m 7.626964,0 5.584031,0 2.62176,10.418977 -8.205791,0 0,-10.418977 z m 8.410081,0 5.51593,0 4.46042,10.418977 -7.38863,0 -2.58772,-10.418977 z m -30.678091,13.142892 8.103649,0 -2.89416,10.282782 -9.6018026,0 4.3923136,-10.282782 z m 10.929711,0 8.614384,0 0,10.282782 -11.508544,0 2.89416,-10.282782 z m 11.338299,0 8.852721,0 2.58772,10.282782 -11.440441,0 0,-10.282782 z m 11.678781,0 7.86531,0 4.39231,10.282782 -9.6699,0 -2.58772,-10.282782 z";function SceneModePicker(e,t,n){if(!defined(e))throw new DeveloperError("container is required.");if(!defined(t))throw new DeveloperError("scene is required.");e=getElement(e);const i=new SceneModePickerViewModel(t,n);i._globePath=globePath,i._flatMapPath=flatMapPath,i._columbusViewPath=columbusViewPath;const r=document.createElement("span");r.className="cesium-sceneModePicker-wrapper cesium-toolbar-button",e.appendChild(r);const o=document.createElement("button");o.type="button",o.className="cesium-button cesium-toolbar-button",o.setAttribute("data-bind",'css: { "cesium-sceneModePicker-button2D": sceneMode === _sceneMode.SCENE2D,       "cesium-sceneModePicker-button3D": sceneMode === _sceneMode.SCENE3D,       "cesium-sceneModePicker-buttonColumbusView": sceneMode === _sceneMode.COLUMBUS_VIEW,       "cesium-sceneModePicker-selected": dropDownVisible },attr: { title: selectedTooltip },click: toggleDropDown'),o.innerHTML='<!-- ko cesiumSvgPath: { path: _globePath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-icon3D" } --><!-- /ko --><!-- ko cesiumSvgPath: { path: _flatMapPath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-icon2D" } --><!-- /ko --><!-- ko cesiumSvgPath: { path: _columbusViewPath, width: 64, height: 64, css: "cesium-sceneModePicker-slide-svg cesium-sceneModePicker-iconColumbusView" } --><!-- /ko -->',r.appendChild(o);const a=document.createElement("button");a.type="button",a.className="cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon",a.setAttribute("data-bind",'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.SCENE3D)) || (!dropDownVisible && (sceneMode === _sceneMode.SCENE3D)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.SCENE3D,       "cesium-sceneModePicker-hidden" : !dropDownVisible },attr: { title: tooltip3D },click: morphTo3D,cesiumSvgPath: { path: _globePath, width: 64, height: 64 }'),r.appendChild(a);const s=document.createElement("button");s.type="button",s.className="cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon",s.setAttribute("data-bind",'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.SCENE2D)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.SCENE2D,       "cesium-sceneModePicker-hidden" : !dropDownVisible },attr: { title: tooltip2D },click: morphTo2D,cesiumSvgPath: { path: _flatMapPath, width: 64, height: 64 }'),r.appendChild(s);const l=document.createElement("button");l.type="button",l.className="cesium-button cesium-toolbar-button cesium-sceneModePicker-dropDown-icon",l.setAttribute("data-bind",'css: { "cesium-sceneModePicker-visible" : (dropDownVisible && (sceneMode !== _sceneMode.COLUMBUS_VIEW)) || (!dropDownVisible && (sceneMode === _sceneMode.COLUMBUS_VIEW)),       "cesium-sceneModePicker-none" : sceneMode === _sceneMode.COLUMBUS_VIEW,       "cesium-sceneModePicker-hidden" : !dropDownVisible},attr: { title: tooltipColumbusView },click: morphToColumbusView,cesiumSvgPath: { path: _columbusViewPath, width: 64, height: 64 }'),r.appendChild(l),knockout.applyBindings(i,r),this._viewModel=i,this._container=e,this._wrapper=r,this._closeDropDown=function(c){r.contains(c.target)||(i.dropDownVisible=!1)},FeatureDetection.supportsPointerEvents()?document.addEventListener("pointerdown",this._closeDropDown,!0):(document.addEventListener("mousedown",this._closeDropDown,!0),document.addEventListener("touchstart",this._closeDropDown,!0))}Object.defineProperties(SceneModePicker.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});SceneModePicker.prototype.isDestroyed=function(){return!1};SceneModePicker.prototype.destroy=function(){return this._viewModel.destroy(),FeatureDetection.supportsPointerEvents()?document.removeEventListener("pointerdown",this._closeDropDown,!0):(document.removeEventListener("mousedown",this._closeDropDown,!0),document.removeEventListener("touchstart",this._closeDropDown,!0)),knockout.cleanNode(this._wrapper),this._container.removeChild(this._wrapper),destroyObject(this)};const screenSpacePos=new Cartesian2,offScreen="-1000px";function SelectionIndicatorViewModel(e,t,n){if(!defined(e))throw new DeveloperError("scene is required.");if(!defined(t))throw new DeveloperError("selectionIndicatorElement is required.");if(!defined(n))throw new DeveloperError("container is required.");this._scene=e,this._screenPositionX=offScreen,this._screenPositionY=offScreen,this._tweens=e.tweens,this._container=defaultValue(n,document.body),this._selectionIndicatorElement=t,this._scale=1,this.position=void 0,this.showSelection=!1,knockout.track(this,["position","_screenPositionX","_screenPositionY","_scale","showSelection"]),this.isVisible=void 0,knockout.defineProperty(this,"isVisible",{get:function(){return this.showSelection&&defined(this.position)}}),knockout.defineProperty(this,"_transform",{get:function(){return`scale(${this._scale})`}}),this.computeScreenSpacePosition=function(i,r){return SceneTransforms.worldToWindowCoordinates(e,i,r)}}SelectionIndicatorViewModel.prototype.update=function(){if(this.showSelection&&defined(this.position)){const e=this.computeScreenSpacePosition(this.position,screenSpacePos);if(!defined(e))this._screenPositionX=offScreen,this._screenPositionY=offScreen;else{const t=this._container,n=t.parentNode.clientWidth,i=t.parentNode.clientHeight,r=this._selectionIndicatorElement.clientWidth,o=r*.5;e.x=Math.min(Math.max(e.x,-r),n+r)-o,e.y=Math.min(Math.max(e.y,-r),i+r)-o,this._screenPositionX=`${Math.floor(e.x+.25)}px`,this._screenPositionY=`${Math.floor(e.y+.25)}px`}}};SelectionIndicatorViewModel.prototype.animateAppear=function(){this._tweens.addProperty({object:this,property:"_scale",startValue:2,stopValue:1,duration:.8,easingFunction:EasingFunction$1.EXPONENTIAL_OUT})};SelectionIndicatorViewModel.prototype.animateDepart=function(){this._tweens.addProperty({object:this,property:"_scale",startValue:this._scale,stopValue:1.5,duration:.8,easingFunction:EasingFunction$1.EXPONENTIAL_OUT})};Object.defineProperties(SelectionIndicatorViewModel.prototype,{container:{get:function(){return this._container}},selectionIndicatorElement:{get:function(){return this._selectionIndicatorElement}},scene:{get:function(){return this._scene}}});function SelectionIndicator(e,t){if(!defined(e))throw new DeveloperError("container is required.");e=getElement(e),this._container=e;const n=document.createElement("div");n.className="cesium-selection-wrapper",n.setAttribute("data-bind",'style: { "top" : _screenPositionY, "left" : _screenPositionX },css: { "cesium-selection-wrapper-visible" : isVisible }'),e.appendChild(n),this._element=n;const i="http://www.w3.org/2000/svg",r="M -34 -34 L -34 -11.25 L -30 -15.25 L -30 -30 L -15.25 -30 L -11.25 -34 L -34 -34 z M 11.25 -34 L 15.25 -30 L 30 -30 L 30 -15.25 L 34 -11.25 L 34 -34 L 11.25 -34 z M -34 11.25 L -34 34 L -11.25 34 L -15.25 30 L -30 30 L -30 15.25 L -34 11.25 z M 34 11.25 L 30 15.25 L 30 30 L 15.25 30 L 11.25 34 L 34 34 L 34 11.25 z",o=document.createElementNS(i,"svg:svg");o.setAttribute("width",160),o.setAttribute("height",160),o.setAttribute("viewBox","0 0 160 160");const a=document.createElementNS(i,"g");a.setAttribute("transform","translate(80,80)"),o.appendChild(a);const s=document.createElementNS(i,"path");s.setAttribute("data-bind","attr: { transform: _transform }"),s.setAttribute("d",r),a.appendChild(s),n.appendChild(o);const l=new SelectionIndicatorViewModel(t,this._element,this._container);this._viewModel=l,knockout.applyBindings(this._viewModel,this._element)}Object.defineProperties(SelectionIndicator.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});SelectionIndicator.prototype.isDestroyed=function(){return!1};SelectionIndicator.prototype.destroy=function(){const e=this._container;return knockout.cleanNode(this._element),e.removeChild(this._element),destroyObject(this)};function TimelineHighlightRange(e,t,n){this._color=e,this._height=t,this._base=defaultValue(n,0)}TimelineHighlightRange.prototype.getHeight=function(){return this._height};TimelineHighlightRange.prototype.getBase=function(){return this._base};TimelineHighlightRange.prototype.getStartTime=function(){return this._start};TimelineHighlightRange.prototype.getStopTime=function(){return this._stop};TimelineHighlightRange.prototype.setRange=function(e,t){this._start=e,this._stop=t};TimelineHighlightRange.prototype.render=function(e){let t="";if(this._start&&this._stop&&this._color){const n=JulianDate.secondsDifference(this._start,e.epochJulian);let i=Math.round(e.timeBarWidth*e.getAlpha(n));const r=JulianDate.secondsDifference(this._stop,e.epochJulian);let o=Math.round(e.timeBarWidth*e.getAlpha(r))-i;i<0&&(o+=i,i=0),i+o>e.timeBarWidth&&(o=e.timeBarWidth-i),o>0&&(t=`<span class="cesium-timeline-highlight" style="left: ${i.toString()}px; width: ${o.toString()}px; bottom: ${this._base.toString()}px; height: ${this._height}px; background-color: ${this._color};"></span>`)}return t};function TimelineTrack(e,t,n,i){this.interval=e,this.height=t,this.color=n||new Color(.5,.5,.5,1),this.backgroundColor=i||new Color(0,0,0,0)}TimelineTrack.prototype.render=function(e,t){const n=this.interval.start,i=this.interval.stop,r=t.startJulian,o=JulianDate.addSeconds(t.startJulian,t.duration,new JulianDate);if(JulianDate.lessThan(n,r)&&JulianDate.greaterThan(i,o))e.fillStyle=this.color.toCssColorString(),e.fillRect(0,t.y,t.timeBarWidth,this.height);else if(JulianDate.lessThanOrEquals(n,o)&&JulianDate.greaterThanOrEquals(i,r)){let a,s,l;for(a=0;a<t.timeBarWidth;++a){const c=JulianDate.addSeconds(t.startJulian,a/t.timeBarWidth*t.duration,new JulianDate);!defined(s)&&JulianDate.greaterThanOrEquals(c,n)?s=a:!defined(l)&&JulianDate.greaterThanOrEquals(c,i)&&(l=a)}e.fillStyle=this.backgroundColor.toCssColorString(),e.fillRect(0,t.y,t.timeBarWidth,this.height),defined(s)&&(defined(l)||(l=t.timeBarWidth),e.fillStyle=this.color.toCssColorString(),e.fillRect(s,t.y,Math.max(l-s,1),this.height))}};let timelineWheelDelta=1e12;const timelineMouseMode={none:0,scrub:1,slide:2,zoom:3,touchOnly:4},timelineTouchMode={none:0,scrub:1,slideZoom:2,singleTap:3,ignore:4},timelineTicScales=[.001,.002,.005,.01,.02,.05,.1,.25,.5,1,2,5,10,15,30,60,120,300,600,900,1800,3600,7200,14400,21600,43200,86400,172800,345600,604800,1296e3,2592e3,5184e3,7776e3,15552e3,31536e3,63072e3,126144e3,15768e4,31536e4,63072e4,126144e4,15768e5,31536e5,63072e5,126144e5,15768e6,31536e6],timelineMonthNames=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function Timeline(e,t){if(!defined(e))throw new DeveloperError("container is required.");if(!defined(t))throw new DeveloperError("clock is required.");e=getElement(e);const n=e.ownerDocument;this.container=e;const i=n.createElement("div");i.className="cesium-timeline-main",e.appendChild(i),this._topDiv=i,this._endJulian=void 0,this._epochJulian=void 0,this._lastXPos=void 0,this._scrubElement=void 0,this._startJulian=void 0,this._timeBarSecondsSpan=void 0,this._clock=t,this._scrubJulian=t.currentTime,this._mainTicSpan=-1,this._mouseMode=timelineMouseMode.none,this._touchMode=timelineTouchMode.none,this._touchState={centerX:0,spanX:0},this._mouseX=0,this._timelineDrag=0,this._timelineDragLocation=void 0,this._lastHeight=void 0,this._lastWidth=void 0,this._topDiv.innerHTML='<div class="cesium-timeline-bar"></div><div class="cesium-timeline-trackContainer"><canvas class="cesium-timeline-tracks" width="10" height="1"></canvas></div><div class="cesium-timeline-needle"></div><span class="cesium-timeline-ruler"></span>',this._timeBarEle=this._topDiv.childNodes[0],this._trackContainer=this._topDiv.childNodes[1],this._trackListEle=this._topDiv.childNodes[1].childNodes[0],this._needleEle=this._topDiv.childNodes[2],this._rulerEle=this._topDiv.childNodes[3],this._context=this._trackListEle.getContext("2d"),this._trackList=[],this._highlightRanges=[],this.zoomTo(t.startTime,t.stopTime),this._onMouseDown=createMouseDownCallback(this),this._onMouseUp=createMouseUpCallback(this),this._onMouseMove=createMouseMoveCallback(this),this._onMouseWheel=createMouseWheelCallback(this),this._onTouchStart=createTouchStartCallback(this),this._onTouchMove=createTouchMoveCallback(this),this._onTouchEnd=createTouchEndCallback(this);const r=this._timeBarEle;n.addEventListener("mouseup",this._onMouseUp,!1),n.addEventListener("mousemove",this._onMouseMove,!1),r.addEventListener("mousedown",this._onMouseDown,!1),r.addEventListener("DOMMouseScroll",this._onMouseWheel,!1),r.addEventListener("mousewheel",this._onMouseWheel,!1),r.addEventListener("touchstart",this._onTouchStart,!1),r.addEventListener("touchmove",this._onTouchMove,!1),r.addEventListener("touchend",this._onTouchEnd,!1),r.addEventListener("touchcancel",this._onTouchEnd,!1),this._topDiv.oncontextmenu=function(){return!1},t.onTick.addEventListener(this.updateFromClock,this),this.updateFromClock()}Timeline.prototype.addEventListener=function(e,t,n){this._topDiv.addEventListener(e,t,n)};Timeline.prototype.removeEventListener=function(e,t,n){this._topDiv.removeEventListener(e,t,n)};Timeline.prototype.isDestroyed=function(){return!1};Timeline.prototype.destroy=function(){this._clock.onTick.removeEventListener(this.updateFromClock,this);const e=this.container.ownerDocument;e.removeEventListener("mouseup",this._onMouseUp,!1),e.removeEventListener("mousemove",this._onMouseMove,!1);const t=this._timeBarEle;t.removeEventListener("mousedown",this._onMouseDown,!1),t.removeEventListener("DOMMouseScroll",this._onMouseWheel,!1),t.removeEventListener("mousewheel",this._onMouseWheel,!1),t.removeEventListener("touchstart",this._onTouchStart,!1),t.removeEventListener("touchmove",this._onTouchMove,!1),t.removeEventListener("touchend",this._onTouchEnd,!1),t.removeEventListener("touchcancel",this._onTouchEnd,!1),this.container.removeChild(this._topDiv),destroyObject(this)};Timeline.prototype.addHighlightRange=function(e,t,n){const i=new TimelineHighlightRange(e,t,n);return this._highlightRanges.push(i),this.resize(),i};Timeline.prototype.addTrack=function(e,t,n,i){const r=new TimelineTrack(e,t,n,i);return this._trackList.push(r),this._lastHeight=void 0,this.resize(),r};Timeline.prototype.zoomTo=function(e,t){if(!defined(e))throw new DeveloperError("startTime is required.");if(!defined(t))throw new DeveloperError("stopTime is required");if(JulianDate.lessThanOrEquals(t,e))throw new DeveloperError("Start time must come before end time.");if(this._startJulian=e,this._endJulian=t,this._timeBarSecondsSpan=JulianDate.secondsDifference(t,e),this._clock&&this._clock.clockRange!==ClockRange$1.UNBOUNDED){const i=this._clock.startTime,r=this._clock.stopTime,o=JulianDate.secondsDifference(r,i),a=JulianDate.secondsDifference(i,this._startJulian),s=JulianDate.secondsDifference(r,this._endJulian);this._timeBarSecondsSpan>=o?(this._timeBarSecondsSpan=o,this._startJulian=this._clock.startTime,this._endJulian=this._clock.stopTime):a>0?(this._endJulian=JulianDate.addSeconds(this._endJulian,a,new JulianDate),this._startJulian=i,this._timeBarSecondsSpan=JulianDate.secondsDifference(this._endJulian,this._startJulian)):s<0&&(this._startJulian=JulianDate.addSeconds(this._startJulian,s,new JulianDate),this._endJulian=r,this._timeBarSecondsSpan=JulianDate.secondsDifference(this._endJulian,this._startJulian))}this._makeTics();const n=document.createEvent("Event");n.initEvent("setzoom",!0,!0),n.startJulian=this._startJulian,n.endJulian=this._endJulian,n.epochJulian=this._epochJulian,n.totalSpan=this._timeBarSecondsSpan,n.mainTicSpan=this._mainTicSpan,this._topDiv.dispatchEvent(n)};Timeline.prototype.zoomFrom=function(e){let t=JulianDate.secondsDifference(this._scrubJulian,this._startJulian);e>1||t<0||t>this._timeBarSecondsSpan?t=this._timeBarSecondsSpan*.5:t+=t-this._timeBarSecondsSpan*.5;const n=this._timeBarSecondsSpan-t;this.zoomTo(JulianDate.addSeconds(this._startJulian,t-t*e,new JulianDate),JulianDate.addSeconds(this._endJulian,n*e-n,new JulianDate))};function twoDigits(e){return e<10?`0${e.toString()}`:e.toString()}Timeline.prototype.makeLabel=function(e){const t=JulianDate.toGregorianDate(e),n=t.millisecond;let i=" UTC";if(n>0&&this._timeBarSecondsSpan<3600){for(i=Math.floor(n).toString();i.length<3;)i=`0${i}`;i=`.${i}`}return`${timelineMonthNames[t.month-1]} ${t.day} ${t.year} ${twoDigits(t.hour)}:${twoDigits(t.minute)}:${twoDigits(t.second)}${i}`};Timeline.prototype.smallestTicInPixels=7;Timeline.prototype._makeTics=function(){const e=this._timeBarEle,t=JulianDate.secondsDifference(this._scrubJulian,this._startJulian),n=Math.round(t*this._topDiv.clientWidth/this._timeBarSecondsSpan),i=n-8;let r;const o=this;this._needleEle.style.left=`${n.toString()}px`;let a="";const s=.01,l=31536e6,c=1e-10;let d=0,h=this._timeBarSecondsSpan;h<s?(h=s,this._timeBarSecondsSpan=s,this._endJulian=JulianDate.addSeconds(this._startJulian,s,new JulianDate)):h>l&&(h=l,this._timeBarSecondsSpan=l,this._endJulian=JulianDate.addSeconds(this._startJulian,l,new JulianDate));let f=this._timeBarEle.clientWidth;f<10&&(f=10);const p=this._startJulian,u=Math.min(h/f*1e-5,.4);let m;const g=JulianDate.toGregorianDate(p);h>31536e4?m=JulianDate.fromDate(new Date(Date.UTC(Math.floor(g.year/100)*100,0))):h>31536e3?m=JulianDate.fromDate(new Date(Date.UTC(Math.floor(g.year/10)*10,0))):h>86400?m=JulianDate.fromDate(new Date(Date.UTC(g.year,0))):m=JulianDate.fromDate(new Date(Date.UTC(g.year,g.month,g.day)));const _=JulianDate.secondsDifference(this._startJulian,JulianDate.addSeconds(m,u,new JulianDate));let C=_+h;this._epochJulian=m;function A(w){return Math.floor(_/w)*w}function S(w,U){return Math.ceil(w/U+.5)*U}function v(w){return(w-_)/h}function b(w,U){return w-U*Math.round(w/U)}this._rulerEle.innerHTML=this.makeLabel(JulianDate.addSeconds(this._endJulian,-s,new JulianDate));let D=this._rulerEle.offsetWidth+20;D<30&&(D=180);const I=d;d-=c;const L={startTime:_,startJulian:p,epochJulian:m,duration:h,timeBarWidth:f,getAlpha:v};this._highlightRanges.forEach(function(w){a+=w.render(L)});let N=0,y=0,x=0,T=D/f;T>1&&(T=1),T*=this._timeBarSecondsSpan;let E=-1,P=-1;const M=timelineTicScales.length;let O;for(O=0;O<M;++O){const w=timelineTicScales[O];if(++E,N=w,w>T&&w>d)break;P<0&&f*(w/this._timeBarSecondsSpan)>=this.smallestTicInPixels&&(P=E)}if(E>0){for(;E>0;)if(--E,Math.abs(b(N,timelineTicScales[E]))<1e-5){timelineTicScales[E]>=d&&(y=timelineTicScales[E]);break}if(P>=0)for(;P<E;){if(Math.abs(b(y,timelineTicScales[P]))<1e-5&&timelineTicScales[P]>=d){x=timelineTicScales[P];break}++P}}d=I,d>c&&x<1e-5&&Math.abs(d-N)>c&&(x=d,d<=N+c&&(y=0));let V=-999999,R;if(f*(x/this._timeBarSecondsSpan)>=3)for(r=A(x);r<=C;r=S(r,x))a+=`<span class="cesium-timeline-ticTiny" style="left: ${Math.round(f*v(r)).toString()}px;"></span>`;if(f*(y/this._timeBarSecondsSpan)>=3)for(r=A(y);r<=C;r=S(r,y))a+=`<span class="cesium-timeline-ticSub" style="left: ${Math.round(f*v(r)).toString()}px;"></span>`;if(f*(N/this._timeBarSecondsSpan)>=2){this._mainTicSpan=N,C+=N,r=A(N);const w=JulianDate.computeTaiMinusUtc(m);for(;r<=C;){let U=JulianDate.addSeconds(p,r-_,new JulianDate);if(N>2.1){const G=JulianDate.computeTaiMinusUtc(U);Math.abs(G-w)>.1&&(r+=G-w,U=JulianDate.addSeconds(p,r-_,new JulianDate))}const k=Math.round(f*v(r)),H=this.makeLabel(U);this._rulerEle.innerHTML=H,R=this._rulerEle.offsetWidth,R<10&&(R=D);const F=k-(R/2-1);F>V?(V=F+R+5,a+=`<span class="cesium-timeline-ticMain" style="left: ${k.toString()}px;"></span><span class="cesium-timeline-ticLabel" style="left: ${F.toString()}px;">${H}</span>`):a+=`<span class="cesium-timeline-ticSub" style="left: ${k.toString()}px;"></span>`,r=S(r,N)}}else this._mainTicSpan=-1;a+=`<span class="cesium-timeline-icon16" style="left:${i}px;bottom:0;background-position: 0 0;"></span>`,e.innerHTML=a,this._scrubElement=e.lastChild,this._context.clearRect(0,0,this._trackListEle.width,this._trackListEle.height),L.y=0,this._trackList.forEach(function(w){w.render(o._context,L),L.y+=w.height})};Timeline.prototype.updateFromClock=function(){this._scrubJulian=this._clock.currentTime;const e=this._scrubElement;if(defined(this._scrubElement)){const t=JulianDate.secondsDifference(this._scrubJulian,this._startJulian),n=Math.round(t*this._topDiv.clientWidth/this._timeBarSecondsSpan);this._lastXPos!==n&&(this._lastXPos=n,e.style.left=`${n-8}px`,this._needleEle.style.left=`${n}px`)}defined(this._timelineDragLocation)&&(this._setTimeBarTime(this._timelineDragLocation,this._timelineDragLocation*this._timeBarSecondsSpan/this._topDiv.clientWidth),this.zoomTo(JulianDate.addSeconds(this._startJulian,this._timelineDrag,new JulianDate),JulianDate.addSeconds(this._endJulian,this._timelineDrag,new JulianDate)))};Timeline.prototype._setTimeBarTime=function(e,t){if(e=Math.round(e),this._scrubJulian=JulianDate.addSeconds(this._startJulian,t,new JulianDate),this._scrubElement){const i=e-8;this._scrubElement.style.left=`${i.toString()}px`,this._needleEle.style.left=`${e.toString()}px`}const n=document.createEvent("Event");n.initEvent("settime",!0,!0),n.clientX=e,n.timeSeconds=t,n.timeJulian=this._scrubJulian,n.clock=this._clock,this._topDiv.dispatchEvent(n)};function createMouseDownCallback(e){return function(t){e._mouseMode!==timelineMouseMode.touchOnly&&(t.button===0?(e._mouseMode=timelineMouseMode.scrub,e._scrubElement&&(e._scrubElement.style.backgroundPosition="-16px 0"),e._onMouseMove(t)):(e._mouseX=t.clientX,t.button===2?e._mouseMode=timelineMouseMode.zoom:e._mouseMode=timelineMouseMode.slide)),t.preventDefault()}}function createMouseUpCallback(e){return function(t){e._mouseMode=timelineMouseMode.none,e._scrubElement&&(e._scrubElement.style.backgroundPosition="0 0"),e._timelineDrag=0,e._timelineDragLocation=void 0}}function createMouseMoveCallback(e){return function(t){let n;if(e._mouseMode===timelineMouseMode.scrub){t.preventDefault();const i=t.clientX-e._topDiv.getBoundingClientRect().left;i<0?(e._timelineDragLocation=0,e._timelineDrag=-.01*e._timeBarSecondsSpan):i>e._topDiv.clientWidth?(e._timelineDragLocation=e._topDiv.clientWidth,e._timelineDrag=.01*e._timeBarSecondsSpan):(e._timelineDragLocation=void 0,e._setTimeBarTime(i,i*e._timeBarSecondsSpan/e._topDiv.clientWidth))}else if(e._mouseMode===timelineMouseMode.slide){if(n=e._mouseX-t.clientX,e._mouseX=t.clientX,n!==0){const i=n*e._timeBarSecondsSpan/e._topDiv.clientWidth;e.zoomTo(JulianDate.addSeconds(e._startJulian,i,new JulianDate),JulianDate.addSeconds(e._endJulian,i,new JulianDate))}}else e._mouseMode===timelineMouseMode.zoom&&(n=e._mouseX-t.clientX,e._mouseX=t.clientX,n!==0&&e.zoomFrom(Math.pow(1.01,n)))}}function createMouseWheelCallback(e){return function(t){let n=t.wheelDeltaY||t.wheelDelta||-t.detail;timelineWheelDelta=Math.max(Math.min(Math.abs(n),timelineWheelDelta),1),n/=timelineWheelDelta,e.zoomFrom(Math.pow(1.05,-n))}}function createTouchStartCallback(e){return function(t){const n=t.touches.length;let i,r;const o=e._topDiv.getBoundingClientRect().left;t.preventDefault(),e._mouseMode=timelineMouseMode.touchOnly,n===1?(i=JulianDate.secondsDifference(e._scrubJulian,e._startJulian),r=Math.round(i*e._topDiv.clientWidth/e._timeBarSecondsSpan+o),Math.abs(t.touches[0].clientX-r)<50?(e._touchMode=timelineTouchMode.scrub,e._scrubElement&&(e._scrubElement.style.backgroundPosition=n===1?"-16px 0":"0 0")):(e._touchMode=timelineTouchMode.singleTap,e._touchState.centerX=t.touches[0].clientX-o)):n===2?(e._touchMode=timelineTouchMode.slideZoom,e._touchState.centerX=(t.touches[0].clientX+t.touches[1].clientX)*.5-o,e._touchState.spanX=Math.abs(t.touches[0].clientX-t.touches[1].clientX)):e._touchMode=timelineTouchMode.ignore}}function createTouchEndCallback(e){return function(t){const n=t.touches.length,i=e._topDiv.getBoundingClientRect().left;e._touchMode===timelineTouchMode.singleTap?(e._touchMode=timelineTouchMode.scrub,e._onTouchMove(t)):e._touchMode===timelineTouchMode.scrub&&e._onTouchMove(t),e._mouseMode=timelineMouseMode.touchOnly,n!==1?e._touchMode=n>0?timelineTouchMode.ignore:timelineTouchMode.none:e._touchMode===timelineTouchMode.slideZoom&&(e._touchState.centerX=t.touches[0].clientX-i),e._scrubElement&&(e._scrubElement.style.backgroundPosition="0 0")}}function createTouchMoveCallback(e){return function(t){let n,i,r,o,a,s,l=1;const c=e._topDiv.getBoundingClientRect().left;e._touchMode===timelineTouchMode.singleTap&&(e._touchMode=timelineTouchMode.slideZoom),e._mouseMode=timelineMouseMode.touchOnly,e._touchMode===timelineTouchMode.scrub?(t.preventDefault(),t.changedTouches.length===1&&(i=t.changedTouches[0].clientX-c,i>=0&&i<=e._topDiv.clientWidth&&e._setTimeBarTime(i,i*e._timeBarSecondsSpan/e._topDiv.clientWidth))):e._touchMode===timelineTouchMode.slideZoom&&(r=t.touches.length,r===2?(o=(t.touches[0].clientX+t.touches[1].clientX)*.5-c,a=Math.abs(t.touches[0].clientX-t.touches[1].clientX)):r===1&&(o=t.touches[0].clientX-c,a=0),defined(o)&&(a>0&&e._touchState.spanX>0?(l=e._touchState.spanX/a,s=JulianDate.addSeconds(e._startJulian,(e._touchState.centerX*e._timeBarSecondsSpan-o*e._timeBarSecondsSpan*l)/e._topDiv.clientWidth,new JulianDate)):(n=e._touchState.centerX-o,s=JulianDate.addSeconds(e._startJulian,n*e._timeBarSecondsSpan/e._topDiv.clientWidth,new JulianDate)),e.zoomTo(s,JulianDate.addSeconds(s,e._timeBarSecondsSpan*l,new JulianDate)),e._touchState.centerX=o,e._touchState.spanX=a))}}Timeline.prototype.resize=function(){const e=this.container.clientWidth,t=this.container.clientHeight;if(e===this._lastWidth&&t===this._lastHeight)return;this._trackContainer.style.height=`${t}px`;let n=1;this._trackList.forEach(function(i){n+=i.height}),this._trackListEle.style.height=`${n.toString()}px`,this._trackListEle.width=this._trackListEle.clientWidth,this._trackListEle.height=n,this._makeTics(),this._lastXPos=void 0,this._lastWidth=e,this._lastHeight=t};var media={webm:"data:video/webm;base64,GkXfowEAAAAAAAAfQoaBAUL3gQFC8oEEQvOBCEKChHdlYm1Ch4EEQoWBAhhTgGcBAAAAAAAVkhFNm3RALE27i1OrhBVJqWZTrIHfTbuMU6uEFlSua1OsggEwTbuMU6uEHFO7a1OsghV17AEAAAAAAACkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmAQAAAAAAAEUq17GDD0JATYCNTGF2ZjU1LjMzLjEwMFdBjUxhdmY1NS4zMy4xMDBzpJBlrrXf3DCDVB8KcgbMpcr+RImIQJBgAAAAAAAWVK5rAQAAAAAAD++uAQAAAAAAADLXgQFzxYEBnIEAIrWcg3VuZIaFVl9WUDiDgQEj44OEAmJaAOABAAAAAAAABrCBsLqBkK4BAAAAAAAPq9eBAnPFgQKcgQAitZyDdW5khohBX1ZPUkJJU4OBAuEBAAAAAAAAEZ+BArWIQOdwAAAAAABiZIEgY6JPbwIeVgF2b3JiaXMAAAAAAoC7AAAAAAAAgLUBAAAAAAC4AQN2b3JiaXMtAAAAWGlwaC5PcmcgbGliVm9yYmlzIEkgMjAxMDExMDEgKFNjaGF1ZmVudWdnZXQpAQAAABUAAABlbmNvZGVyPUxhdmM1NS41Mi4xMDIBBXZvcmJpcyVCQ1YBAEAAACRzGCpGpXMWhBAaQlAZ4xxCzmvsGUJMEYIcMkxbyyVzkCGkoEKIWyiB0JBVAABAAACHQXgUhIpBCCGEJT1YkoMnPQghhIg5eBSEaUEIIYQQQgghhBBCCCGERTlokoMnQQgdhOMwOAyD5Tj4HIRFOVgQgydB6CCED0K4moOsOQghhCQ1SFCDBjnoHITCLCiKgsQwuBaEBDUojILkMMjUgwtCiJqDSTX4GoRnQXgWhGlBCCGEJEFIkIMGQcgYhEZBWJKDBjm4FITLQagahCo5CB+EIDRkFQCQAACgoiiKoigKEBqyCgDIAAAQQFEUx3EcyZEcybEcCwgNWQUAAAEACAAAoEiKpEiO5EiSJFmSJVmSJVmS5omqLMuyLMuyLMsyEBqyCgBIAABQUQxFcRQHCA1ZBQBkAAAIoDiKpViKpWiK54iOCISGrAIAgAAABAAAEDRDUzxHlETPVFXXtm3btm3btm3btm3btm1blmUZCA1ZBQBAAAAQ0mlmqQaIMAMZBkJDVgEACAAAgBGKMMSA0JBVAABAAACAGEoOogmtOd+c46BZDppKsTkdnEi1eZKbirk555xzzsnmnDHOOeecopxZDJoJrTnnnMSgWQqaCa0555wnsXnQmiqtOeeccc7pYJwRxjnnnCateZCajbU555wFrWmOmkuxOeecSLl5UptLtTnnnHPOOeecc84555zqxekcnBPOOeecqL25lpvQxTnnnE/G6d6cEM4555xzzjnnnHPOOeecIDRkFQAABABAEIaNYdwpCNLnaCBGEWIaMulB9+gwCRqDnELq0ehopJQ6CCWVcVJKJwgNWQUAAAIAQAghhRRSSCGFFFJIIYUUYoghhhhyyimnoIJKKqmooowyyyyzzDLLLLPMOuyssw47DDHEEEMrrcRSU2011lhr7jnnmoO0VlprrbVSSimllFIKQkNWAQAgAAAEQgYZZJBRSCGFFGKIKaeccgoqqIDQkFUAACAAgAAAAABP8hzRER3RER3RER3RER3R8RzPESVREiVREi3TMjXTU0VVdWXXlnVZt31b2IVd933d933d+HVhWJZlWZZlWZZlWZZlWZZlWZYgNGQVAAACAAAghBBCSCGFFFJIKcYYc8w56CSUEAgNWQUAAAIACAAAAHAUR3EcyZEcSbIkS9IkzdIsT/M0TxM9URRF0zRV0RVdUTdtUTZl0zVdUzZdVVZtV5ZtW7Z125dl2/d93/d93/d93/d93/d9XQdCQ1YBABIAADqSIymSIimS4ziOJElAaMgqAEAGAEAAAIriKI7jOJIkSZIlaZJneZaomZrpmZ4qqkBoyCoAABAAQAAAAAAAAIqmeIqpeIqoeI7oiJJomZaoqZoryqbsuq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq4LhIasAgAkAAB0JEdyJEdSJEVSJEdygNCQVQCADACAAAAcwzEkRXIsy9I0T/M0TxM90RM901NFV3SB0JBVAAAgAIAAAAAAAAAMybAUy9EcTRIl1VItVVMt1VJF1VNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVN0zRNEwgNWQkAkAEAkBBTLS3GmgmLJGLSaqugYwxS7KWxSCpntbfKMYUYtV4ah5RREHupJGOKQcwtpNApJq3WVEKFFKSYYyoVUg5SIDRkhQAQmgHgcBxAsixAsiwAAAAAAAAAkDQN0DwPsDQPAAAAAAAAACRNAyxPAzTPAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAA0DwP8DwR8EQRAAAAAAAAACzPAzTRAzxRBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA0jRA8zxA8zwAAAAAAAAAsDwP8EQR0DwRAAAAAAAAACzPAzxRBDzRAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEOAAABBgIRQasiIAiBMAcEgSJAmSBM0DSJYFTYOmwTQBkmVB06BpME0AAAAAAAAAAAAAJE2DpkHTIIoASdOgadA0iCIAAAAAAAAAAAAAkqZB06BpEEWApGnQNGgaRBEAAAAAAAAAAAAAzzQhihBFmCbAM02IIkQRpgkAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAGHAAAAgwoQwUGrIiAIgTAHA4imUBAIDjOJYFAACO41gWAABYliWKAABgWZooAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAYcAAACDChDBQashIAiAIAcCiKZQHHsSzgOJYFJMmyAJYF0DyApgFEEQAIAAAocAAACLBBU2JxgEJDVgIAUQAABsWxLE0TRZKkaZoniiRJ0zxPFGma53meacLzPM80IYqiaJoQRVE0TZimaaoqME1VFQAAUOAAABBgg6bE4gCFhqwEAEICAByKYlma5nmeJ4qmqZokSdM8TxRF0TRNU1VJkqZ5niiKommapqqyLE3zPFEURdNUVVWFpnmeKIqiaaqq6sLzPE8URdE0VdV14XmeJ4qiaJqq6roQRVE0TdNUTVV1XSCKpmmaqqqqrgtETxRNU1Vd13WB54miaaqqq7ouEE3TVFVVdV1ZBpimaaqq68oyQFVV1XVdV5YBqqqqruu6sgxQVdd1XVmWZQCu67qyLMsCAAAOHAAAAoygk4wqi7DRhAsPQKEhKwKAKAAAwBimFFPKMCYhpBAaxiSEFEImJaXSUqogpFJSKRWEVEoqJaOUUmopVRBSKamUCkIqJZVSAADYgQMA2IGFUGjISgAgDwCAMEYpxhhzTiKkFGPOOScRUoox55yTSjHmnHPOSSkZc8w556SUzjnnnHNSSuacc845KaVzzjnnnJRSSuecc05KKSWEzkEnpZTSOeecEwAAVOAAABBgo8jmBCNBhYasBABSAQAMjmNZmuZ5omialiRpmud5niiapiZJmuZ5nieKqsnzPE8URdE0VZXneZ4oiqJpqirXFUXTNE1VVV2yLIqmaZqq6rowTdNUVdd1XZimaaqq67oubFtVVdV1ZRm2raqq6rqyDFzXdWXZloEsu67s2rIAAPAEBwCgAhtWRzgpGgssNGQlAJABAEAYg5BCCCFlEEIKIYSUUggJAAAYcAAACDChDBQashIASAUAAIyx1lprrbXWQGettdZaa62AzFprrbXWWmuttdZaa6211lJrrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmuttdZaa6211lprrbXWWmstpZRSSimllFJKKaWUUkoppZRSSgUA+lU4APg/2LA6wknRWGChISsBgHAAAMAYpRhzDEIppVQIMeacdFRai7FCiDHnJKTUWmzFc85BKCGV1mIsnnMOQikpxVZjUSmEUlJKLbZYi0qho5JSSq3VWIwxqaTWWoutxmKMSSm01FqLMRYjbE2ptdhqq7EYY2sqLbQYY4zFCF9kbC2m2moNxggjWywt1VprMMYY3VuLpbaaizE++NpSLDHWXAAAd4MDAESCjTOsJJ0VjgYXGrISAAgJACAQUooxxhhzzjnnpFKMOeaccw5CCKFUijHGnHMOQgghlIwx5pxzEEIIIYRSSsaccxBCCCGEkFLqnHMQQgghhBBKKZ1zDkIIIYQQQimlgxBCCCGEEEoopaQUQgghhBBCCKmklEIIIYRSQighlZRSCCGEEEIpJaSUUgohhFJCCKGElFJKKYUQQgillJJSSimlEkoJJYQSUikppRRKCCGUUkpKKaVUSgmhhBJKKSWllFJKIYQQSikFAAAcOAAABBhBJxlVFmGjCRcegEJDVgIAZAAAkKKUUiktRYIipRikGEtGFXNQWoqocgxSzalSziDmJJaIMYSUk1Qy5hRCDELqHHVMKQYtlRhCxhik2HJLoXMOAAAAQQCAgJAAAAMEBTMAwOAA4XMQdAIERxsAgCBEZohEw0JweFAJEBFTAUBigkIuAFRYXKRdXECXAS7o4q4DIQQhCEEsDqCABByccMMTb3jCDU7QKSp1IAAAAAAADADwAACQXAAREdHMYWRobHB0eHyAhIiMkAgAAAAAABcAfAAAJCVAREQ0cxgZGhscHR4fICEiIyQBAIAAAgAAAAAggAAEBAQAAAAAAAIAAAAEBB9DtnUBAAAAAAAEPueBAKOFggAAgACjzoEAA4BwBwCdASqwAJAAAEcIhYWIhYSIAgIABhwJ7kPfbJyHvtk5D32ych77ZOQ99snIe+2TkPfbJyHvtk5D32ych77ZOQ99YAD+/6tQgKOFggADgAqjhYIAD4AOo4WCACSADqOZgQArADECAAEQEAAYABhYL/QACIBDmAYAAKOFggA6gA6jhYIAT4AOo5mBAFMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAGSADqOFggB6gA6jmYEAewAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAj4AOo5mBAKMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAKSADqOFggC6gA6jmYEAywAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIAz4AOo4WCAOSADqOZgQDzADECAAEQEAAYABhYL/QACIBDmAYAAKOFggD6gA6jhYIBD4AOo5iBARsAEQIAARAQFGAAYWC/0AAiAQ5gGACjhYIBJIAOo4WCATqADqOZgQFDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggFPgA6jhYIBZIAOo5mBAWsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAXqADqOFggGPgA6jmYEBkwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIBpIAOo4WCAbqADqOZgQG7ADECAAEQEAAYABhYL/QACIBDmAYAAKOFggHPgA6jmYEB4wAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIB5IAOo4WCAfqADqOZgQILADECAAEQEAAYABhYL/QACIBDmAYAAKOFggIPgA6jhYICJIAOo5mBAjMAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAjqADqOFggJPgA6jmYECWwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYICZIAOo4WCAnqADqOZgQKDADECAAEQEAAYABhYL/QACIBDmAYAAKOFggKPgA6jhYICpIAOo5mBAqsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCArqADqOFggLPgA6jmIEC0wARAgABEBAUYABhYL/QACIBDmAYAKOFggLkgA6jhYIC+oAOo5mBAvsAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCAw+ADqOZgQMjADECAAEQEAAYABhYL/QACIBDmAYAAKOFggMkgA6jhYIDOoAOo5mBA0sAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA0+ADqOFggNkgA6jmYEDcwAxAgABEBAAGAAYWC/0AAiAQ5gGAACjhYIDeoAOo4WCA4+ADqOZgQObADECAAEQEAAYABhYL/QACIBDmAYAAKOFggOkgA6jhYIDuoAOo5mBA8MAMQIAARAQABgAGFgv9AAIgEOYBgAAo4WCA8+ADqOFggPkgA6jhYID+oAOo4WCBA+ADhxTu2sBAAAAAAAAEbuPs4EDt4r3gQHxghEr8IEK",mp4:"data:video/mp4;base64,AAAAHGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMQAAAAhmcmVlAAAGF21kYXTeBAAAbGliZmFhYyAxLjI4AABCAJMgBDIARwAAArEGBf//rdxF6b3m2Ui3lizYINkj7u94MjY0IC0gY29yZSAxNDIgcjIgOTU2YzhkOCAtIEguMjY0L01QRUctNCBBVkMgY29kZWMgLSBDb3B5bGVmdCAyMDAzLTIwMTQgLSBodHRwOi8vd3d3LnZpZGVvbGFuLm9yZy94MjY0Lmh0bWwgLSBvcHRpb25zOiBjYWJhYz0wIHJlZj0zIGRlYmxvY2s9MTowOjAgYW5hbHlzZT0weDE6MHgxMTEgbWU9aGV4IHN1Ym1lPTcgcHN5PTEgcHN5X3JkPTEuMDA6MC4wMCBtaXhlZF9yZWY9MSBtZV9yYW5nZT0xNiBjaHJvbWFfbWU9MSB0cmVsbGlzPTEgOHg4ZGN0PTAgY3FtPTAgZGVhZHpvbmU9MjEsMTEgZmFzdF9wc2tpcD0xIGNocm9tYV9xcF9vZmZzZXQ9LTIgdGhyZWFkcz02IGxvb2thaGVhZF90aHJlYWRzPTEgc2xpY2VkX3RocmVhZHM9MCBucj0wIGRlY2ltYXRlPTEgaW50ZXJsYWNlZD0wIGJsdXJheV9jb21wYXQ9MCBjb25zdHJhaW5lZF9pbnRyYT0wIGJmcmFtZXM9MCB3ZWlnaHRwPTAga2V5aW50PTI1MCBrZXlpbnRfbWluPTI1IHNjZW5lY3V0PTQwIGludHJhX3JlZnJlc2g9MCByY19sb29rYWhlYWQ9NDAgcmM9Y3JmIG1idHJlZT0xIGNyZj0yMy4wIHFjb21wPTAuNjAgcXBtaW49MCBxcG1heD02OSBxcHN0ZXA9NCB2YnZfbWF4cmF0ZT03NjggdmJ2X2J1ZnNpemU9MzAwMCBjcmZfbWF4PTAuMCBuYWxfaHJkPW5vbmUgZmlsbGVyPTAgaXBfcmF0aW89MS40MCBhcT0xOjEuMDAAgAAAAFZliIQL8mKAAKvMnJycnJycnJycnXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXiEASZACGQAjgCEASZACGQAjgAAAAAdBmjgX4GSAIQBJkAIZACOAAAAAB0GaVAX4GSAhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGagC/AySEASZACGQAjgAAAAAZBmqAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZrAL8DJIQBJkAIZACOAAAAABkGa4C/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmwAvwMkhAEmQAhkAI4AAAAAGQZsgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGbQC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm2AvwMkhAEmQAhkAI4AAAAAGQZuAL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGboC/AySEASZACGQAjgAAAAAZBm8AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZvgL8DJIQBJkAIZACOAAAAABkGaAC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmiAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZpAL8DJIQBJkAIZACOAAAAABkGaYC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBmoAvwMkhAEmQAhkAI4AAAAAGQZqgL8DJIQBJkAIZACOAIQBJkAIZACOAAAAABkGawC/AySEASZACGQAjgAAAAAZBmuAvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZsAL8DJIQBJkAIZACOAAAAABkGbIC/AySEASZACGQAjgCEASZACGQAjgAAAAAZBm0AvwMkhAEmQAhkAI4AhAEmQAhkAI4AAAAAGQZtgL8DJIQBJkAIZACOAAAAABkGbgCvAySEASZACGQAjgCEASZACGQAjgAAAAAZBm6AnwMkhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AhAEmQAhkAI4AAAAhubW9vdgAAAGxtdmhkAAAAAAAAAAAAAAAAAAAD6AAABDcAAQAAAQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAzB0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAABAAAAAAAAA+kAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAALAAAACQAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAPpAAAAAAABAAAAAAKobWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAB1MAAAdU5VxAAAAAAALWhkbHIAAAAAAAAAAHZpZGUAAAAAAAAAAAAAAABWaWRlb0hhbmRsZXIAAAACU21pbmYAAAAUdm1oZAAAAAEAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAhNzdGJsAAAAr3N0c2QAAAAAAAAAAQAAAJ9hdmMxAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAALAAkABIAAAASAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP//AAAALWF2Y0MBQsAN/+EAFWdCwA3ZAsTsBEAAAPpAADqYA8UKkgEABWjLg8sgAAAAHHV1aWRraEDyXyRPxbo5pRvPAyPzAAAAAAAAABhzdHRzAAAAAAAAAAEAAAAeAAAD6QAAABRzdHNzAAAAAAAAAAEAAAABAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAABAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADDwAAAAsAAAALAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAACgAAAAoAAAAKAAAAiHN0Y28AAAAAAAAAHgAAAEYAAANnAAADewAAA5gAAAO0AAADxwAAA+MAAAP2AAAEEgAABCUAAARBAAAEXQAABHAAAASMAAAEnwAABLsAAATOAAAE6gAABQYAAAUZAAAFNQAABUgAAAVkAAAFdwAABZMAAAWmAAAFwgAABd4AAAXxAAAGDQAABGh0cmFrAAAAXHRraGQAAAADAAAAAAAAAAAAAAACAAAAAAAABDcAAAAAAAAAAAAAAAEBAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAkZWR0cwAAABxlbHN0AAAAAAAAAAEAAAQkAAADcAABAAAAAAPgbWRpYQAAACBtZGhkAAAAAAAAAAAAAAAAAAC7gAAAykBVxAAAAAAALWhkbHIAAAAAAAAAAHNvdW4AAAAAAAAAAAAAAABTb3VuZEhhbmRsZXIAAAADi21pbmYAAAAQc21oZAAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAADT3N0YmwAAABnc3RzZAAAAAAAAAABAAAAV21wNGEAAAAAAAAAAQAAAAAAAAAAAAIAEAAAAAC7gAAAAAAAM2VzZHMAAAAAA4CAgCIAAgAEgICAFEAVBbjYAAu4AAAADcoFgICAAhGQBoCAgAECAAAAIHN0dHMAAAAAAAAAAgAAADIAAAQAAAAAAQAAAkAAAAFUc3RzYwAAAAAAAAAbAAAAAQAAAAEAAAABAAAAAgAAAAIAAAABAAAAAwAAAAEAAAABAAAABAAAAAIAAAABAAAABgAAAAEAAAABAAAABwAAAAIAAAABAAAACAAAAAEAAAABAAAACQAAAAIAAAABAAAACgAAAAEAAAABAAAACwAAAAIAAAABAAAADQAAAAEAAAABAAAADgAAAAIAAAABAAAADwAAAAEAAAABAAAAEAAAAAIAAAABAAAAEQAAAAEAAAABAAAAEgAAAAIAAAABAAAAFAAAAAEAAAABAAAAFQAAAAIAAAABAAAAFgAAAAEAAAABAAAAFwAAAAIAAAABAAAAGAAAAAEAAAABAAAAGQAAAAIAAAABAAAAGgAAAAEAAAABAAAAGwAAAAIAAAABAAAAHQAAAAEAAAABAAAAHgAAAAIAAAABAAAAHwAAAAQAAAABAAAA4HN0c3oAAAAAAAAAAAAAADMAAAAaAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAACMc3RjbwAAAAAAAAAfAAAALAAAA1UAAANyAAADhgAAA6IAAAO+AAAD0QAAA+0AAAQAAAAEHAAABC8AAARLAAAEZwAABHoAAASWAAAEqQAABMUAAATYAAAE9AAABRAAAAUjAAAFPwAABVIAAAVuAAAFgQAABZ0AAAWwAAAFzAAABegAAAX7AAAGFwAAAGJ1ZHRhAAAAWm1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAALWlsc3QAAAAlqXRvbwAAAB1kYXRhAAAAAQAAAABMYXZmNTUuMzMuMTAw"};const{webm,mp4}=media,oldIOS=()=>typeof navigator<"u"&&parseFloat((""+(/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent)||[0,""])[1]).replace("undefined","3_2").replace("_",".").replace("_",""))<10&&!window.MSStream,nativeWakeLock=()=>"wakeLock"in navigator;class NoSleep{constructor(){if(this.enabled=!1,nativeWakeLock()){this._wakeLock=null;const t=()=>{this._wakeLock!==null&&document.visibilityState==="visible"&&this.enable()};document.addEventListener("visibilitychange",t),document.addEventListener("fullscreenchange",t)}else oldIOS()?this.noSleepTimer=null:(this.noSleepVideo=document.createElement("video"),this.noSleepVideo.setAttribute("title","No Sleep"),this.noSleepVideo.setAttribute("playsinline",""),this._addSourceToVideo(this.noSleepVideo,"webm",webm),this._addSourceToVideo(this.noSleepVideo,"mp4",mp4),this.noSleepVideo.addEventListener("loadedmetadata",()=>{this.noSleepVideo.duration<=1?this.noSleepVideo.setAttribute("loop",""):this.noSleepVideo.addEventListener("timeupdate",()=>{this.noSleepVideo.currentTime>.5&&(this.noSleepVideo.currentTime=Math.random())})}))}_addSourceToVideo(t,n,i){var r=document.createElement("source");r.src=i,r.type=`video/${n}`,t.appendChild(r)}get isEnabled(){return this.enabled}enable(){return nativeWakeLock()?navigator.wakeLock.request("screen").then(t=>{this._wakeLock=t,this.enabled=!0,console.log("Wake Lock active."),this._wakeLock.addEventListener("release",()=>{console.log("Wake Lock released.")})}).catch(t=>{throw this.enabled=!1,console.error(`${t.name}, ${t.message}`),t}):oldIOS()?(this.disable(),console.warn(`
        NoSleep enabled for older iOS devices. This can interrupt
        active or long-running network requests from completing successfully.
        See https://github.com/richtr/NoSleep.js/issues/15 for more details.
      `),this.noSleepTimer=window.setInterval(()=>{document.hidden||(window.location.href=window.location.href.split("#")[0],window.setTimeout(window.stop,0))},15e3),this.enabled=!0,Promise.resolve()):this.noSleepVideo.play().then(n=>(this.enabled=!0,n)).catch(n=>{throw this.enabled=!1,n})}disable(){nativeWakeLock()?(this._wakeLock&&this._wakeLock.release(),this._wakeLock=null):oldIOS()?this.noSleepTimer&&(console.warn(`
          NoSleep now disabled for older iOS devices.
        `),window.clearInterval(this.noSleepTimer),this.noSleepTimer=null):this.noSleepVideo.pause(),this.enabled=!1}}var src=NoSleep;const NoSleep$1=getDefaultExportFromCjs(src);function lockScreen(e){let t=!1;const n=window.screen;return defined(n)&&(defined(n.lockOrientation)?t=n.lockOrientation(e):defined(n.mozLockOrientation)?t=n.mozLockOrientation(e):defined(n.msLockOrientation)?t=n.msLockOrientation(e):defined(n.orientation&&n.orientation.lock)&&(t=n.orientation.lock(e))),t}function unlockScreen(){const e=window.screen;defined(e)&&(defined(e.unlockOrientation)?e.unlockOrientation():defined(e.mozUnlockOrientation)?e.mozUnlockOrientation():defined(e.msUnlockOrientation)?e.msUnlockOrientation():defined(e.orientation&&e.orientation.unlock)&&e.orientation.unlock())}function toggleVR(e,t,n,i){i()||(n()?(t.useWebVR=!1,e._locked&&(unlockScreen(),e._locked=!1),e._noSleep.disable(),Fullscreen.exitFullscreen(),n(!1)):(Fullscreen.fullscreen||Fullscreen.requestFullscreen(e._vrElement),e._noSleep.enable(),e._locked||(e._locked=lockScreen("landscape")),t.useWebVR=!0,n(!0)))}function VRButtonViewModel(e,t){if(!defined(e))throw new DeveloperError("scene is required.");const n=this,i=knockout.observable(Fullscreen.enabled),r=knockout.observable(!1);this.isVRMode=void 0,knockout.defineProperty(this,"isVRMode",{get:function(){return r()}}),this.isVREnabled=void 0,knockout.defineProperty(this,"isVREnabled",{get:function(){return i()},set:function(a){i(a&&Fullscreen.enabled)}}),this.tooltip=void 0,knockout.defineProperty(this,"tooltip",function(){return i()?r()?"Exit VR mode":"Enter VR mode":"VR mode is unavailable"});const o=knockout.observable(!1);this._isOrthographic=void 0,knockout.defineProperty(this,"_isOrthographic",{get:function(){return o()}}),this._eventHelper=new EventHelper,this._eventHelper.add(e.preRender,function(){o(e.camera.frustum instanceof OrthographicFrustum)}),this._locked=!1,this._noSleep=new NoSleep$1,this._command=createCommand(function(){toggleVR(n,e,r,o)},knockout.getObservable(this,"isVREnabled")),this._vrElement=defaultValue(getElement(t),document.body),this._callback=function(){!Fullscreen.fullscreen&&r()&&(e.useWebVR=!1,n._locked&&(unlockScreen(),n._locked=!1),n._noSleep.disable(),r(!1))},document.addEventListener(Fullscreen.changeEventName,this._callback)}Object.defineProperties(VRButtonViewModel.prototype,{vrElement:{get:function(){return this._vrElement},set:function(e){if(!(e instanceof Element))throw new DeveloperError("value must be a valid Element.");this._vrElement=e}},command:{get:function(){return this._command}}});VRButtonViewModel.prototype.isDestroyed=function(){return!1};VRButtonViewModel.prototype.destroy=function(){this._eventHelper.removeAll(),document.removeEventListener(Fullscreen.changeEventName,this._callback),destroyObject(this)};const enterVRPath="M 5.3125 6.375 C 4.008126 6.375 2.96875 7.4141499 2.96875 8.71875 L 2.96875 19.5 C 2.96875 20.8043 4.008126 21.875 5.3125 21.875 L 13.65625 21.875 C 13.71832 20.0547 14.845166 18.59375 16.21875 18.59375 C 17.592088 18.59375 18.71881 20.0552 18.78125 21.875 L 27.09375 21.875 C 28.398125 21.875 29.4375 20.8043 29.4375 19.5 L 29.4375 8.71875 C 29.4375 7.4141499 28.398125 6.375 27.09375 6.375 L 5.3125 6.375 z M 9.625 10.4375 C 11.55989 10.4375 13.125 12.03385 13.125 13.96875 C 13.125 15.90365 11.55989 17.46875 9.625 17.46875 C 7.69011 17.46875 6.125 15.90365 6.125 13.96875 C 6.125 12.03385 7.69011 10.4375 9.625 10.4375 z M 22.46875 10.4375 C 24.40364 10.4375 25.96875 12.03385 25.96875 13.96875 C 25.96875 15.90365 24.40364 17.46875 22.46875 17.46875 C 20.53386 17.46875 18.96875 15.90365 18.96875 13.96875 C 18.96875 12.03385 20.53386 10.4375 22.46875 10.4375 z",exitVRPath="M 25.770585,2.4552065 C 15.72282,13.962707 10.699956,19.704407 8.1768352,22.580207 c -1.261561,1.4379 -1.902282,2.1427 -2.21875,2.5 -0.141624,0.1599 -0.208984,0.2355 -0.25,0.2813 l 0.6875,0.75 c 10e-5,-10e-5 0.679191,0.727 0.6875,0.7187 0.01662,-0.016 0.02451,-0.024 0.03125,-0.031 0.01348,-0.014 0.04013,-0.038 0.0625,-0.062 0.04474,-0.05 0.120921,-0.1315 0.28125,-0.3126 0.320657,-0.3619 0.956139,-1.0921 2.2187499,-2.5312 2.5252219,-2.8781 7.5454589,-8.6169 17.5937499,-20.1250005 l -1.5,-1.3125 z m -20.5624998,3.9063 c -1.304375,0 -2.34375,1.0391 -2.34375,2.3437 l 0,10.8125005 c 0,1.3043 1.039375,2.375 2.34375,2.375 l 2.25,0 c 1.9518039,-2.2246 7.4710958,-8.5584 13.5624998,-15.5312005 l -15.8124998,0 z m 21.1249998,0 c -1.855467,2.1245 -2.114296,2.4005 -3.59375,4.0936995 1.767282,0.1815 3.15625,1.685301 3.15625,3.500001 0,1.9349 -1.56511,3.5 -3.5,3.5 -1.658043,0 -3.043426,-1.1411 -3.40625,-2.6875 -1.089617,1.2461 -2.647139,2.9988 -3.46875,3.9375 0.191501,-0.062 0.388502,-0.094 0.59375,-0.094 1.373338,0 2.50006,1.4614 2.5625,3.2812 l 8.3125,0 c 1.304375,0 2.34375,-1.0707 2.34375,-2.375 l 0,-10.8125005 c 0,-1.3046 -1.039375,-2.3437 -2.34375,-2.3437 l -0.65625,0 z M 9.5518351,10.423906 c 1.9348899,0 3.4999999,1.596401 3.4999999,3.531301 0,1.9349 -1.56511,3.5 -3.4999999,3.5 -1.9348899,0 -3.4999999,-1.5651 -3.4999999,-3.5 0,-1.9349 1.56511,-3.531301 3.4999999,-3.531301 z m 4.2187499,10.312601 c -0.206517,0.2356 -0.844218,0.9428 -1.03125,1.1562 l 0.8125,0 c 0.01392,-0.4081 0.107026,-0.7968 0.21875,-1.1562 z";function VRButton(e,t,n){if(!defined(e))throw new DeveloperError("container is required.");if(!defined(t))throw new DeveloperError("scene is required.");e=getElement(e);const i=new VRButtonViewModel(t,n);i._exitVRPath=exitVRPath,i._enterVRPath=enterVRPath;const r=document.createElement("button");r.type="button",r.className="cesium-button cesium-vrButton",r.setAttribute("data-bind",'css: { "cesium-button-disabled" : _isOrthographic }, attr: { title: tooltip },click: command,enable: isVREnabled,cesiumSvgPath: { path: isVRMode ? _exitVRPath : _enterVRPath, width: 32, height: 32 }'),e.appendChild(r),knockout.applyBindings(i,r),this._container=e,this._viewModel=i,this._element=r}Object.defineProperties(VRButton.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});VRButton.prototype.isDestroyed=function(){return!1};VRButton.prototype.destroy=function(){return this._viewModel.destroy(),knockout.cleanNode(this._element),this._container.removeChild(this._element),destroyObject(this)};const boundingSphereScratch=new BoundingSphere;function onTimelineScrubfunction(e){const t=e.clock;t.currentTime=e.timeJulian,t.shouldAnimate=!1}function getCesium3DTileFeatureDescription(e){const t=e.getPropertyIds();let n="";return t.forEach(function(i){const r=e.getProperty(i);defined(r)&&(n+=`<tr><th>${i}</th><td>${r}</td></tr>`)}),n.length>0&&(n=`<table class="cesium-infoBox-defaultTable"><tbody>${n}</tbody></table>`),n}function getCesium3DTileFeatureName(e){let t;const n=[],i=e.getPropertyIds();for(t=0;t<i.length;t++){const o=i[t];/^name$/i.test(o)?n[0]=e.getProperty(o):/name/i.test(o)?n[1]=e.getProperty(o):/^title$/i.test(o)?n[2]=e.getProperty(o):/^(id|identifier)$/i.test(o)?n[3]=e.getProperty(o):/element/i.test(o)?n[4]=e.getProperty(o):/(id|identifier)$/i.test(o)&&(n[5]=e.getProperty(o))}const r=n.length;for(t=0;t<r;t++){const o=n[t];if(defined(o)&&o!=="")return o}return"Unnamed Feature"}function pickEntity(e,t){const n=e.scene.pick(t.position);if(defined(n)){const i=defaultValue(n.id,n.primitive.id);if(i instanceof Entity)return i;if(n instanceof Cesium3DTileFeature)return new Entity({name:getCesium3DTileFeatureName(n),description:getCesium3DTileFeatureDescription(n),feature:n})}if(defined(e.scene.globe))return pickImageryLayerFeature(e,t.position)}const scratchStopTime=new JulianDate;function trackDataSourceClock(e,t,n){if(defined(n)){const i=n.clock;if(defined(i)&&(i.getValue(t),defined(e))){const r=i.startTime;let o=i.stopTime;JulianDate.equals(r,o)&&(o=JulianDate.addSeconds(r,CesiumMath.EPSILON2,scratchStopTime)),e.updateFromClock(),e.zoomTo(r,o)}}}const cartesian3Scratch=new Cartesian3;function pickImageryLayerFeature(e,t){const n=e.scene,i=n.camera.getPickRay(t),r=n.imageryLayers.pickImageryLayerFeatures(i,n);if(!defined(r))return;const o=new Entity({id:"Loading...",description:"Loading feature information..."});return r.then(function(a){if(e.selectedEntity!==o)return;if(!defined(a)||a.length===0){e.selectedEntity=createNoFeaturesEntity();return}const s=a[0],l=new Entity({id:s.name,description:s.description});if(defined(s.position)){const c=e.scene.ellipsoid.cartographicToCartesian(s.position,cartesian3Scratch);l.position=new ConstantPositionProperty(c)}e.selectedEntity=l},function(){e.selectedEntity===o&&(e.selectedEntity=createNoFeaturesEntity())}),o}function createNoFeaturesEntity(){return new Entity({id:"None",description:"No features found."})}function enableVRUI(e,t){const n=e._geocoder,i=e._homeButton,r=e._sceneModePicker,o=e._projectionPicker,a=e._baseLayerPicker,s=e._animation,l=e._timeline,c=e._fullscreenButton,d=e._infoBox,h=e._selectionIndicator,f=t?"hidden":"visible";if(defined(n)&&(n.container.style.visibility=f),defined(i)&&(i.container.style.visibility=f),defined(r)&&(r.container.style.visibility=f),defined(o)&&(o.container.style.visibility=f),defined(a)&&(a.container.style.visibility=f),defined(s)&&(s.container.style.visibility=f),defined(l)&&(l.container.style.visibility=f),defined(c)&&c.viewModel.isFullscreenEnabled&&(c.container.style.visibility=f),defined(d)&&(d.container.style.visibility=f),defined(h)&&(h.container.style.visibility=f),e._container){const p=t||!defined(c)?0:c.container.clientWidth;e._vrButton.container.style.right=`${p}px`,e.forceResize()}}function Viewer(e,t){if(!defined(e))throw new DeveloperError("container is required.");e=getElement(e),t=defaultValue(t,defaultValue.EMPTY_OBJECT);const n=(!defined(t.globe)||t.globe!==!1)&&(!defined(t.baseLayerPicker)||t.baseLayerPicker!==!1);if(!n&&defined(t.selectedImageryProviderViewModel))throw new DeveloperError("options.selectedImageryProviderViewModel is not available when not using the BaseLayerPicker widget. Either specify options.baseLayer instead or set options.baseLayerPicker to true.");if(!n&&defined(t.selectedTerrainProviderViewModel))throw new DeveloperError("options.selectedTerrainProviderViewModel is not available when not using the BaseLayerPicker widget. Either specify options.terrainProvider instead or set options.baseLayerPicker to true.");const i=this,r=document.createElement("div");r.className="cesium-viewer",e.appendChild(r);const o=document.createElement("div");o.className="cesium-viewer-cesiumWidgetContainer",r.appendChild(o);const a=document.createElement("div");a.className="cesium-viewer-bottom",r.appendChild(a);const s=defaultValue(t.scene3DOnly,!1);let l,c,d=!1;defined(t.clockViewModel)?(c=t.clockViewModel,l=c.clock):(l=new Clock,c=new ClockViewModel(l),d=!0),defined(t.shouldAnimate)&&(l.shouldAnimate=t.shouldAnimate);const h=new CesiumWidget(o,{baseLayer:n&&defined(t.selectedImageryProviderViewModel)||defined(t.baseLayer)||defined(t.imageryProvider)?!1:void 0,clock:l,skyBox:t.skyBox,skyAtmosphere:t.skyAtmosphere,sceneMode:t.sceneMode,ellipsoid:t.ellipsoid,mapProjection:t.mapProjection,globe:t.globe,orderIndependentTranslucency:t.orderIndependentTranslucency,contextOptions:t.contextOptions,useDefaultRenderLoop:t.useDefaultRenderLoop,targetFrameRate:t.targetFrameRate,showRenderLoopErrors:t.showRenderLoopErrors,useBrowserRecommendedResolution:t.useBrowserRecommendedResolution,creditContainer:defined(t.creditContainer)?t.creditContainer:a,creditViewport:t.creditViewport,scene3DOnly:s,shadows:t.shadows,terrainShadows:t.terrainShadows,mapMode2D:t.mapMode2D,blurActiveElementOnCanvasFocus:t.blurActiveElementOnCanvasFocus,requestRenderMode:t.requestRenderMode,maximumRenderTimeChange:t.maximumRenderTimeChange,depthPlaneEllipsoidOffset:t.depthPlaneEllipsoidOffset,msaaSamples:t.msaaSamples});let f=t.dataSources,p=!1;defined(f)||(f=new DataSourceCollection,p=!0);const u=h.scene,m=new DataSourceDisplay({scene:u,dataSourceCollection:f}),g=new EventHelper;g.add(l.onTick,Viewer.prototype._onTick,this),g.add(u.morphStart,Viewer.prototype._clearTrackedObject,this);let _;if(!defined(t.selectionIndicator)||t.selectionIndicator!==!1){const k=document.createElement("div");k.className="cesium-viewer-selectionIndicatorContainer",r.appendChild(k),_=new SelectionIndicator(k,u)}let C;if(!defined(t.infoBox)||t.infoBox!==!1){const k=document.createElement("div");k.className="cesium-viewer-infoBoxContainer",r.appendChild(k),C=new InfoBox(k);const H=C.viewModel;g.add(H.cameraClicked,Viewer.prototype._onInfoBoxCameraClicked,this),g.add(H.closeClicked,Viewer.prototype._onInfoBoxClockClicked,this)}const A=document.createElement("div");A.className="cesium-viewer-toolbar",r.appendChild(A);let S;if(!defined(t.geocoder)||t.geocoder!==!1){const k=document.createElement("div");k.className="cesium-viewer-geocoderContainer",A.appendChild(k);let H;defined(t.geocoder)&&typeof t.geocoder!="boolean"&&(H=Array.isArray(t.geocoder)?t.geocoder:[t.geocoder]),S=new Geocoder({container:k,geocoderServices:H,scene:u}),g.add(S.viewModel.search.beforeExecute,Viewer.prototype._clearObjects,this)}let v;if((!defined(t.homeButton)||t.homeButton!==!1)&&(v=new HomeButton(A,u),defined(S)&&g.add(v.viewModel.command.afterExecute,function(){const k=S.viewModel;k.searchText="",k.isSearchInProgress&&k.search()}),g.add(v.viewModel.command.beforeExecute,Viewer.prototype._clearTrackedObject,this)),t.sceneModePicker===!0&&s)throw new DeveloperError("options.sceneModePicker is not available when options.scene3DOnly is set to true.");let b;!s&&(!defined(t.sceneModePicker)||t.sceneModePicker!==!1)&&(b=new SceneModePicker(A,u));let D;t.projectionPicker&&(D=new ProjectionPicker(A,u));let I,L;if(n){const k=defaultValue(t.imageryProviderViewModels,createDefaultImageryProviderViewModels()),H=defaultValue(t.terrainProviderViewModels,createDefaultTerrainProviderViewModels());I=new BaseLayerPicker(A,{globe:u.globe,imageryProviderViewModels:k,selectedImageryProviderViewModel:t.selectedImageryProviderViewModel,terrainProviderViewModels:H,selectedTerrainProviderViewModel:t.selectedTerrainProviderViewModel}),L=A.getElementsByClassName("cesium-baseLayerPicker-dropDown")[0]}if(defined(t.baseLayer)&&t.baseLayer!==!1&&(n&&(I.viewModel.selectedImagery=void 0),u.imageryLayers.removeAll(),u.imageryLayers.add(t.baseLayer)),defined(t.terrainProvider)&&(n&&(I.viewModel.selectedTerrain=void 0),u.terrainProvider=t.terrainProvider),defined(t.terrain)){if(defined(t.terrainProvider))throw new DeveloperError("Specify either options.terrainProvider or options.terrain.");n&&(u.globe.depthTestAgainstTerrain=!0),u.setTerrain(t.terrain)}let N;if(!defined(t.navigationHelpButton)||t.navigationHelpButton!==!1){let k=!0;try{if(defined(window.localStorage)){const H=window.localStorage.getItem("cesium-hasSeenNavHelp");defined(H)&&H?k=!1:window.localStorage.setItem("cesium-hasSeenNavHelp","true")}}catch{}N=new NavigationHelpButton({container:A,instructionsInitiallyVisible:defaultValue(t.navigationInstructionsInitiallyVisible,k)})}let y;if(!defined(t.animation)||t.animation!==!1){const k=document.createElement("div");k.className="cesium-viewer-animationContainer",r.appendChild(k),y=new Animation(k,new AnimationViewModel(c))}let x;if(!defined(t.timeline)||t.timeline!==!1){const k=document.createElement("div");k.className="cesium-viewer-timelineContainer",r.appendChild(k),x=new Timeline(k,l),x.addEventListener("settime",onTimelineScrubfunction,!1),x.zoomTo(l.startTime,l.stopTime)}let T,E,P;(!defined(t.fullscreenButton)||t.fullscreenButton!==!1)&&(P=document.createElement("div"),P.className="cesium-viewer-fullscreenContainer",r.appendChild(P),T=new FullscreenButton(P,t.fullscreenElement),E=subscribeAndEvaluate(T.viewModel,"isFullscreenEnabled",function(k){P.style.display=k?"block":"none",defined(x)&&(x.container.style.right=`${P.clientWidth}px`,x.resize())}));let M,O,V;if(t.vrButton){const k=document.createElement("div");k.className="cesium-viewer-vrContainer",r.appendChild(k),M=new VRButton(k,u,t.fullScreenElement),O=subscribeAndEvaluate(M.viewModel,"isVREnabled",function(H){k.style.display=H?"block":"none",defined(T)&&(k.style.right=`${P.clientWidth}px`),defined(x)&&(x.container.style.right=`${k.clientWidth}px`,x.resize())}),V=subscribeAndEvaluate(M.viewModel,"isVRMode",function(H){enableVRUI(i,H)})}this._baseLayerPickerDropDown=L,this._fullscreenSubscription=E,this._vrSubscription=O,this._vrModeSubscription=V,this._dataSourceChangedListeners={},this._automaticallyTrackDataSourceClocks=defaultValue(t.automaticallyTrackDataSourceClocks,!0),this._container=e,this._bottomContainer=a,this._element=r,this._cesiumWidget=h,this._selectionIndicator=_,this._infoBox=C,this._dataSourceCollection=f,this._destroyDataSourceCollection=p,this._dataSourceDisplay=m,this._clockViewModel=c,this._destroyClockViewModel=d,this._toolbar=A,this._homeButton=v,this._sceneModePicker=b,this._projectionPicker=D,this._baseLayerPicker=I,this._navigationHelpButton=N,this._animation=y,this._timeline=x,this._fullscreenButton=T,this._vrButton=M,this._geocoder=S,this._eventHelper=g,this._lastWidth=0,this._lastHeight=0,this._allowDataSourcesToSuspendAnimation=!0,this._entityView=void 0,this._enableInfoOrSelection=defined(C)||defined(_),this._clockTrackedDataSource=void 0,this._trackedEntity=void 0,this._needTrackedEntityUpdate=!1,this._selectedEntity=void 0,this._zoomIsFlight=!1,this._zoomTarget=void 0,this._zoomPromise=void 0,this._zoomOptions=void 0,this._selectedEntityChanged=new Event,this._trackedEntityChanged=new Event,knockout.track(this,["_trackedEntity","_selectedEntity","_clockTrackedDataSource"]),g.add(f.dataSourceAdded,Viewer.prototype._onDataSourceAdded,this),g.add(f.dataSourceRemoved,Viewer.prototype._onDataSourceRemoved,this),g.add(u.postUpdate,Viewer.prototype.resize,this),g.add(u.postRender,Viewer.prototype._postRender,this);const R=f.length;for(let k=0;k<R;k++)this._dataSourceAdded(f,f.get(k));this._dataSourceAdded(void 0,m.defaultDataSource),g.add(f.dataSourceAdded,Viewer.prototype._dataSourceAdded,this),g.add(f.dataSourceRemoved,Viewer.prototype._dataSourceRemoved,this);function w(k){const H=pickEntity(i,k);defined(H)?Property.getValueOrUndefined(H.position,i.clock.currentTime)?i.trackedEntity=H:i.zoomTo(H):defined(i.trackedEntity)&&(i.trackedEntity=void 0)}function U(k){i.selectedEntity=pickEntity(i,k)}h.screenSpaceEventHandler.setInputAction(U,ScreenSpaceEventType.LEFT_CLICK),h.screenSpaceEventHandler.setInputAction(w,ScreenSpaceEventType.LEFT_DOUBLE_CLICK)}Object.defineProperties(Viewer.prototype,{container:{get:function(){return this._container}},creditDisplay:{get:function(){return this._cesiumWidget.creditDisplay}},bottomContainer:{get:function(){return this._bottomContainer}},cesiumWidget:{get:function(){return this._cesiumWidget}},selectionIndicator:{get:function(){return this._selectionIndicator}},infoBox:{get:function(){return this._infoBox}},geocoder:{get:function(){return this._geocoder}},homeButton:{get:function(){return this._homeButton}},sceneModePicker:{get:function(){return this._sceneModePicker}},projectionPicker:{get:function(){return this._projectionPicker}},baseLayerPicker:{get:function(){return this._baseLayerPicker}},navigationHelpButton:{get:function(){return this._navigationHelpButton}},animation:{get:function(){return this._animation}},timeline:{get:function(){return this._timeline}},fullscreenButton:{get:function(){return this._fullscreenButton}},vrButton:{get:function(){return this._vrButton}},dataSourceDisplay:{get:function(){return this._dataSourceDisplay}},entities:{get:function(){return this._dataSourceDisplay.defaultDataSource.entities}},dataSources:{get:function(){return this._dataSourceCollection}},canvas:{get:function(){return this._cesiumWidget.canvas}},scene:{get:function(){return this._cesiumWidget.scene}},shadows:{get:function(){return this.scene.shadowMap.enabled},set:function(e){this.scene.shadowMap.enabled=e}},terrainShadows:{get:function(){return this.scene.globe.shadows},set:function(e){this.scene.globe.shadows=e}},shadowMap:{get:function(){return this.scene.shadowMap}},imageryLayers:{get:function(){return this.scene.imageryLayers}},terrainProvider:{get:function(){return this.scene.terrainProvider},set:function(e){this.scene.terrainProvider=e}},camera:{get:function(){return this.scene.camera}},ellipsoid:{get:function(){return this._scene.ellipsoid}},postProcessStages:{get:function(){return this.scene.postProcessStages}},clock:{get:function(){return this._clockViewModel.clock}},clockViewModel:{get:function(){return this._clockViewModel}},screenSpaceEventHandler:{get:function(){return this._cesiumWidget.screenSpaceEventHandler}},targetFrameRate:{get:function(){return this._cesiumWidget.targetFrameRate},set:function(e){this._cesiumWidget.targetFrameRate=e}},useDefaultRenderLoop:{get:function(){return this._cesiumWidget.useDefaultRenderLoop},set:function(e){this._cesiumWidget.useDefaultRenderLoop=e}},resolutionScale:{get:function(){return this._cesiumWidget.resolutionScale},set:function(e){this._cesiumWidget.resolutionScale=e}},useBrowserRecommendedResolution:{get:function(){return this._cesiumWidget.useBrowserRecommendedResolution},set:function(e){this._cesiumWidget.useBrowserRecommendedResolution=e}},allowDataSourcesToSuspendAnimation:{get:function(){return this._allowDataSourcesToSuspendAnimation},set:function(e){this._allowDataSourcesToSuspendAnimation=e}},trackedEntity:{get:function(){return this._trackedEntity},set:function(e){if(this._trackedEntity!==e){this._trackedEntity=e,cancelZoom(this);const t=this.scene,n=t.mode;!defined(e)||!defined(e.position)?(this._needTrackedEntityUpdate=!1,(n===SceneMode.COLUMBUS_VIEW||n===SceneMode.SCENE2D)&&(t.screenSpaceCameraController.enableTranslate=!0),(n===SceneMode.COLUMBUS_VIEW||n===SceneMode.SCENE3D)&&(t.screenSpaceCameraController.enableTilt=!0),this._entityView=void 0,this.camera.lookAtTransform(Matrix4.IDENTITY)):this._needTrackedEntityUpdate=!0,this._trackedEntityChanged.raiseEvent(e),this.scene.requestRender()}}},selectedEntity:{get:function(){return this._selectedEntity},set:function(e){if(this._selectedEntity!==e){this._selectedEntity=e;const t=defined(this._selectionIndicator)?this._selectionIndicator.viewModel:void 0;defined(e)?defined(t)&&t.animateAppear():defined(t)&&t.animateDepart(),this._selectedEntityChanged.raiseEvent(e)}}},selectedEntityChanged:{get:function(){return this._selectedEntityChanged}},trackedEntityChanged:{get:function(){return this._trackedEntityChanged}},clockTrackedDataSource:{get:function(){return this._clockTrackedDataSource},set:function(e){this._clockTrackedDataSource!==e&&(this._clockTrackedDataSource=e,trackDataSourceClock(this._timeline,this.clock,e))}}});Viewer.prototype.extend=function(e,t){if(!defined(e))throw new DeveloperError("mixin is required.");e(this,t)};Viewer.prototype.resize=function(){const e=this._cesiumWidget,t=this._container,n=t.clientWidth,i=t.clientHeight,r=defined(this._animation),o=defined(this._timeline);if(e.resize(),n===this._lastWidth&&i===this._lastHeight)return;const a=i-125,s=this._baseLayerPickerDropDown;if(defined(s)&&(s.style.maxHeight=`${a}px`),defined(this._geocoder)){const u=this._geocoder.searchSuggestionsContainer;u.style.maxHeight=`${a}px`}defined(this._infoBox)&&(this._infoBox.viewModel.maxHeight=a);const l=this._timeline;let c,d=0,h=5,f=3,p=0;if(r&&window.getComputedStyle(this._animation.container).visibility!=="hidden"){const u=this._lastWidth;c=this._animation.container,n>900?(d=169,u<=900&&(c.style.width="169px",c.style.height="112px",this._animation.resize())):n>=600?(d=136,(u<600||u>900)&&(c.style.width="136px",c.style.height="90px",this._animation.resize())):(d=106,(u>600||u===0)&&(c.style.width="106px",c.style.height="70px",this._animation.resize())),h=d+5}if(o&&window.getComputedStyle(this._timeline.container).visibility!=="hidden"){const u=this._fullscreenButton,m=this._vrButton,g=l.container,_=g.style;f=g.clientHeight+3,_.left=`${d}px`;let C=0;defined(u)&&(C+=u.container.clientWidth),defined(m)&&(C+=m.container.clientWidth),_.right=`${C}px`,l.resize()}!o&&defined(this._fullscreenButton)&&(p=this._fullscreenButton.container.clientWidth),this._bottomContainer.style.left=`${h}px`,this._bottomContainer.style.bottom=`${f}px`,this._bottomContainer.style.right=`${p}px`,this._lastWidth=n,this._lastHeight=i};Viewer.prototype.forceResize=function(){this._lastWidth=0,this.resize()};Viewer.prototype.render=function(){this._cesiumWidget.render()};Viewer.prototype.isDestroyed=function(){return!1};Viewer.prototype.destroy=function(){let e;defined(this.screenSpaceEventHandler)&&!this.screenSpaceEventHandler.isDestroyed()&&(this.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_CLICK),this.screenSpaceEventHandler.removeInputAction(ScreenSpaceEventType.LEFT_DOUBLE_CLICK));const t=this.dataSources,n=t.length;for(e=0;e<n;e++)this._dataSourceRemoved(t,t.get(e));return this._dataSourceRemoved(void 0,this._dataSourceDisplay.defaultDataSource),this._container.removeChild(this._element),this._element.removeChild(this._toolbar),this._eventHelper.removeAll(),defined(this._geocoder)&&(this._geocoder=this._geocoder.destroy()),defined(this._homeButton)&&(this._homeButton=this._homeButton.destroy()),defined(this._sceneModePicker)&&(this._sceneModePicker=this._sceneModePicker.destroy()),defined(this._projectionPicker)&&(this._projectionPicker=this._projectionPicker.destroy()),defined(this._baseLayerPicker)&&(this._baseLayerPicker=this._baseLayerPicker.destroy()),defined(this._animation)&&(this._element.removeChild(this._animation.container),this._animation=this._animation.destroy()),defined(this._timeline)&&(this._timeline.removeEventListener("settime",onTimelineScrubfunction,!1),this._element.removeChild(this._timeline.container),this._timeline=this._timeline.destroy()),defined(this._fullscreenButton)&&(this._fullscreenSubscription.dispose(),this._element.removeChild(this._fullscreenButton.container),this._fullscreenButton=this._fullscreenButton.destroy()),defined(this._vrButton)&&(this._vrSubscription.dispose(),this._vrModeSubscription.dispose(),this._element.removeChild(this._vrButton.container),this._vrButton=this._vrButton.destroy()),defined(this._infoBox)&&(this._element.removeChild(this._infoBox.container),this._infoBox=this._infoBox.destroy()),defined(this._selectionIndicator)&&(this._element.removeChild(this._selectionIndicator.container),this._selectionIndicator=this._selectionIndicator.destroy()),this._destroyClockViewModel&&(this._clockViewModel=this._clockViewModel.destroy()),this._dataSourceDisplay=this._dataSourceDisplay.destroy(),this._cesiumWidget=this._cesiumWidget.destroy(),this._destroyDataSourceCollection&&(this._dataSourceCollection=this._dataSourceCollection.destroy()),destroyObject(this)};Viewer.prototype._dataSourceAdded=function(e,t){t.entities.collectionChanged.addEventListener(Viewer.prototype._onEntityCollectionChanged,this)};Viewer.prototype._dataSourceRemoved=function(e,t){const n=t.entities;n.collectionChanged.removeEventListener(Viewer.prototype._onEntityCollectionChanged,this),defined(this.trackedEntity)&&n.getById(this.trackedEntity.id)===this.trackedEntity&&(this.trackedEntity=void 0),defined(this.selectedEntity)&&n.getById(this.selectedEntity.id)===this.selectedEntity&&(this.selectedEntity=void 0)};Viewer.prototype._onTick=function(e){const t=e.currentTime,n=this._dataSourceDisplay.update(t);this._allowDataSourcesToSuspendAnimation&&(this._clockViewModel.canAnimate=n);const i=this._entityView;if(defined(i)){const d=this._trackedEntity;this._dataSourceDisplay.getBoundingSphere(d,!1,boundingSphereScratch)===BoundingSphereState$1.DONE&&i.update(t,boundingSphereScratch)}let r,o=!1;const a=this.selectedEntity,s=defined(a)&&this._enableInfoOrSelection;s&&a.isShowing&&a.isAvailable(t)&&(this._dataSourceDisplay.getBoundingSphere(a,!0,boundingSphereScratch)!==BoundingSphereState$1.FAILED?r=boundingSphereScratch.center:defined(a.position)&&(r=a.position.getValue(t,r)),o=defined(r));const l=defined(this._selectionIndicator)?this._selectionIndicator.viewModel:void 0;defined(l)&&(l.position=Cartesian3.clone(r,l.position),l.showSelection=s&&o,l.update());const c=defined(this._infoBox)?this._infoBox.viewModel:void 0;defined(c)&&(c.showInfo=s,c.enableCamera=o,c.isCameraTracking=this.trackedEntity===this.selectedEntity,s?(c.titleText=defaultValue(a.name,a.id),c.description=Property.getValueOrDefault(a.description,t,"")):(c.titleText="",c.description=""))};Viewer.prototype._onEntityCollectionChanged=function(e,t,n){const i=n.length;for(let r=0;r<i;r++){const o=n[r];this.trackedEntity===o&&(this.trackedEntity=void 0),this.selectedEntity===o&&(this.selectedEntity=void 0)}};Viewer.prototype._onInfoBoxCameraClicked=function(e){if(e.isCameraTracking&&this.trackedEntity===this.selectedEntity)this.trackedEntity=void 0;else{const n=this.selectedEntity.position;defined(n)?this.trackedEntity=this.selectedEntity:this.zoomTo(this.selectedEntity)}};Viewer.prototype._clearTrackedObject=function(){this.trackedEntity=void 0};Viewer.prototype._onInfoBoxClockClicked=function(e){this.selectedEntity=void 0};Viewer.prototype._clearObjects=function(){this.trackedEntity=void 0,this.selectedEntity=void 0};Viewer.prototype._onDataSourceChanged=function(e){this.clockTrackedDataSource===e&&trackDataSourceClock(this.timeline,this.clock,e)};Viewer.prototype._onDataSourceAdded=function(e,t){this._automaticallyTrackDataSourceClocks&&(this.clockTrackedDataSource=t);const n=t.entities.id,i=this._eventHelper.add(t.changedEvent,Viewer.prototype._onDataSourceChanged,this);this._dataSourceChangedListeners[n]=i};Viewer.prototype._onDataSourceRemoved=function(e,t){const n=this.clockTrackedDataSource===t,i=t.entities.id;if(this._dataSourceChangedListeners[i](),this._dataSourceChangedListeners[i]=void 0,n){const r=e.length;this._automaticallyTrackDataSourceClocks&&r>0?this.clockTrackedDataSource=e.get(r-1):this.clockTrackedDataSource=void 0}};Viewer.prototype.zoomTo=function(e,t){return zoomToOrFly(this,e,{offset:t},!1)};Viewer.prototype.flyTo=function(e,t){return zoomToOrFly(this,e,t,!0)};function zoomToOrFly(e,t,n,i){if(!defined(t))throw new DeveloperError("zoomTarget is required.");cancelZoom(e);const r=new Promise(o=>{e._completeZoom=function(a){o(a)}});return e._zoomPromise=r,e._zoomIsFlight=i,e._zoomOptions=n,Promise.resolve(t).then(function(o){if(e._zoomPromise===r){if(o instanceof ImageryLayer){let a;defined(o.imageryProvider)?a=Promise.resolve(o.getImageryRectangle()):a=new Promise(s=>{const l=o.readyEvent.addEventListener(()=>{l(),s(o.getImageryRectangle())})}),a.then(function(s){return computeFlyToLocationForRectangle(s,e.scene)}).then(function(s){e._zoomPromise===r&&(e._zoomTarget=s)});return}if(o instanceof Cesium3DTileset||o instanceof TimeDynamicPointCloud||o instanceof VoxelPrimitive){e._zoomTarget=o;return}if(o.isLoading&&defined(o.loadingEvent)){const a=o.loadingEvent.addEventListener(function(){a(),e._zoomPromise===r&&(e._zoomTarget=o.entities.values.slice(0))});return}if(Array.isArray(o)){e._zoomTarget=o.slice(0);return}o=defaultValue(o.values,o),defined(o.entities)&&(o=o.entities.values),Array.isArray(o)?e._zoomTarget=o.slice(0):e._zoomTarget=[o]}}),e.scene.requestRender(),r}function clearZoom(e){e._zoomPromise=void 0,e._zoomTarget=void 0,e._zoomOptions=void 0}function cancelZoom(e){const t=e._zoomPromise;defined(t)&&(clearZoom(e),e._completeZoom(!1))}Viewer.prototype._postRender=function(){updateZoomTarget(this),updateTrackedEntity(this)};function updateZoomTarget(e){const t=e._zoomTarget;if(!defined(t)||e.scene.mode===SceneMode.MORPHING)return;const n=e.scene,i=n.camera,r=defaultValue(e._zoomOptions,{});let o;function a(d){defined(r.offset)||(r.offset=new HeadingPitchRange(0,-.5,d.radius)),o={offset:r.offset,duration:r.duration,maximumHeight:r.maximumHeight,complete:function(){e._completeZoom(!0)},cancel:function(){e._completeZoom(!1)}},e._zoomIsFlight?i.flyToBoundingSphere(t.boundingSphere,o):(i.viewBoundingSphere(d,r.offset),i.lookAtTransform(Matrix4.IDENTITY),e._completeZoom(!0)),clearZoom(e)}if(t instanceof TimeDynamicPointCloud){if(defined(t.boundingSphere)){a(t.boundingSphere);return}const d=t.frameChanged.addEventListener(function(h){a(h.boundingSphere),d()});return}if(t instanceof Cesium3DTileset||t instanceof VoxelPrimitive){a(t.boundingSphere);return}if(t instanceof Cartographic){o={destination:n.ellipsoid.cartographicToCartesian(t),duration:r.duration,maximumHeight:r.maximumHeight,complete:function(){e._completeZoom(!0)},cancel:function(){e._completeZoom(!1)}},e._zoomIsFlight?i.flyTo(o):(i.setView(o),e._completeZoom(!0)),clearZoom(e);return}const s=t,l=[];for(let d=0,h=s.length;d<h;d++){const f=e._dataSourceDisplay.getBoundingSphere(s[d],!1,boundingSphereScratch);if(f===BoundingSphereState$1.PENDING)return;f!==BoundingSphereState$1.FAILED&&l.push(BoundingSphere.clone(boundingSphereScratch))}if(l.length===0){cancelZoom(e);return}e.trackedEntity=void 0;const c=BoundingSphere.fromBoundingSpheres(l);e._zoomIsFlight?(clearZoom(e),i.flyToBoundingSphere(c,{duration:r.duration,maximumHeight:r.maximumHeight,complete:function(){e._completeZoom(!0)},cancel:function(){e._completeZoom(!1)},offset:r.offset})):(i.viewBoundingSphere(c,r.offset),i.lookAtTransform(Matrix4.IDENTITY),clearZoom(e),e._completeZoom(!0))}function updateTrackedEntity(e){if(!e._needTrackedEntityUpdate)return;const t=e._trackedEntity,n=e.clock.currentTime,i=Property.getValueOrUndefined(t.position,n);if(!defined(i))return;const r=e.scene,o=e._dataSourceDisplay.getBoundingSphere(t,!1,boundingSphereScratch);if(o===BoundingSphereState$1.PENDING)return;const a=r.mode;(a===SceneMode.COLUMBUS_VIEW||a===SceneMode.SCENE2D)&&(r.screenSpaceCameraController.enableTranslate=!1),(a===SceneMode.COLUMBUS_VIEW||a===SceneMode.SCENE3D)&&(r.screenSpaceCameraController.enableTilt=!1);const s=o!==BoundingSphereState$1.FAILED?boundingSphereScratch:void 0;e._entityView=new EntityView(t,r,r.ellipsoid),e._entityView.update(n,s),e._needTrackedEntityUpdate=!1}function viewerCesium3DTilesInspectorMixin(e){Check.typeOf.object("viewer",e);const t=document.createElement("div");t.className="cesium-viewer-cesium3DTilesInspectorContainer",e.container.appendChild(t);const n=new Cesium3DTilesInspector(t,e.scene);Object.defineProperties(e,{cesium3DTilesInspector:{get:function(){return n}}})}function viewerCesiumInspectorMixin(e){if(!defined(e))throw new DeveloperError("viewer is required.");const t=document.createElement("div");t.className="cesium-viewer-cesiumInspectorContainer",e.container.appendChild(t);const n=new CesiumInspector(t,e.scene);Object.defineProperties(e,{cesiumInspector:{get:function(){return n}}})}function viewerDragDropMixin(e,t){if(!defined(e))throw new DeveloperError("viewer is required.");if(e.hasOwnProperty("dropTarget"))throw new DeveloperError("dropTarget is already defined by another mixin.");if(e.hasOwnProperty("dropEnabled"))throw new DeveloperError("dropEnabled is already defined by another mixin.");if(e.hasOwnProperty("dropError"))throw new DeveloperError("dropError is already defined by another mixin.");if(e.hasOwnProperty("clearOnDrop"))throw new DeveloperError("clearOnDrop is already defined by another mixin.");if(e.hasOwnProperty("flyToOnDrop"))throw new DeveloperError("flyToOnDrop is already defined by another mixin.");t=defaultValue(t,defaultValue.EMPTY_OBJECT);let n=!0,i=defaultValue(t.flyToOnDrop,!0);const r=new Event;let o=defaultValue(t.clearOnDrop,!0),a=defaultValue(t.dropTarget,e.container),s=defaultValue(t.clampToGround,!0),l=t.proxy;a=getElement(a),Object.defineProperties(e,{dropTarget:{get:function(){return a},set:function(d){if(!defined(d))throw new DeveloperError("value is required.");unsubscribe(a,c),a=d,subscribe(a,c)}},dropEnabled:{get:function(){return n},set:function(d){d!==n&&(d?subscribe(a,c):unsubscribe(a,c),n=d)}},dropError:{get:function(){return r}},clearOnDrop:{get:function(){return o},set:function(d){o=d}},flyToOnDrop:{get:function(){return i},set:function(d){i=d}},proxy:{get:function(){return l},set:function(d){l=d}},clampToGround:{get:function(){return s},set:function(d){s=d}}});function c(d){stop(d),o&&(e.entities.removeAll(),e.dataSources.removeAll());const h=d.dataTransfer.files,f=h.length;for(let p=0;p<f;p++){const u=h[p],m=new FileReader;m.onload=createOnLoadCallback(e,u,l,s),m.onerror=createDropErrorCallback(e,u),m.readAsText(u)}}subscribe(a,c),e.destroy=wrapFunction(e,e.destroy,function(){e.dropEnabled=!1}),e._handleDrop=c}function stop(e){e.stopPropagation(),e.preventDefault()}function unsubscribe(e,t){const n=e;defined(n)&&(n.removeEventListener("drop",t,!1),n.removeEventListener("dragenter",stop,!1),n.removeEventListener("dragover",stop,!1),n.removeEventListener("dragexit",stop,!1))}function subscribe(e,t){e.addEventListener("drop",t,!1),e.addEventListener("dragenter",stop,!1),e.addEventListener("dragover",stop,!1),e.addEventListener("dragexit",stop,!1)}function createOnLoadCallback(e,t,n,i){const r=e.scene;return function(o){const a=t.name;try{let s;if(/\.czml$/i.test(a))s=CzmlDataSource.load(JSON.parse(o.target.result),{sourceUri:a});else if(/\.geojson$/i.test(a)||/\.json$/i.test(a)||/\.topojson$/i.test(a))s=GeoJsonDataSource.load(JSON.parse(o.target.result),{sourceUri:a,clampToGround:i});else if(/\.(kml|kmz)$/i.test(a))s=KmlDataSource.load(t,{sourceUri:a,proxy:n,camera:r.camera,canvas:r.canvas,clampToGround:i,screenOverlayContainer:e.container});else if(/\.gpx$/i.test(a))s=GpxDataSource.load(t,{sourceUri:a,proxy:n});else{e.dropError.raiseEvent(e,a,`Unrecognized file: ${a}`);return}defined(s)&&e.dataSources.add(s).then(function(l){e.flyToOnDrop&&e.flyTo(l)}).catch(function(l){e.dropError.raiseEvent(e,a,l)})}catch(s){e.dropError.raiseEvent(e,a,s)}}}function createDropErrorCallback(e,t){return function(n){e.dropError.raiseEvent(e,t.name,n.target.error)}}function viewerPerformanceWatchdogMixin(e,t){if(!defined(e))throw new DeveloperError("viewer is required.");t=defaultValue(t,defaultValue.EMPTY_OBJECT);const n=new PerformanceWatchdog({scene:e.scene,container:e.bottomContainer,lowFrameRateMessage:t.lowFrameRateMessage});Object.defineProperties(e,{performanceWatchdog:{get:function(){return n}}})}function formatShaderString(e){const t=e.split(`
`);let n;for(n=0;n<t.length&&!t[n].match(/\S/);n++);if(n===t.length)return"";let i="";const r=/^\s*/,a=t[n].match(r)[0].length;for(let s=n;s<t.length;s++){let l=t[s];l.match(r)[0].length>=a&&(l=l.slice(a)),i+=`${l}
`}return i}function VoxelInspectorViewModel(e){Check.typeOf.object("scene",e),this._scene=e,this._voxelPrimitive=void 0,this._customShaderCompilationRemoveCallback=void 0,this._definedProperties=[],this._getPrimitiveFunctions=[],this._modelMatrixReady=!1;const t=this;function n(r){const{name:o,initialValue:a}=r;t._definedProperties.push(o);let s=r.setPrimitiveFunction;s===!0&&(s=function(d){t._voxelPrimitive[o]=d});let l=r.getPrimitiveFunction;l===!0&&(l=function(){t[o]=t._voxelPrimitive[o]}),defined(l)&&t._getPrimitiveFunctions.push(l);const c=knockout.observable();return knockout.defineProperty(t,o,{get:function(){return c()},set:function(d){typeof a=="number"&&typeof d=="string"&&(d=Number(d),isNaN(d)&&(d=a)),typeof a=="boolean"&&typeof d=="number"&&(d=d===1),c(d),defined(s)&&defined(t._voxelPrimitive)&&(s(d),e.requestRender())}}),t[o]=a,c}function i(r,o){return function(a){const s=t._voxelPrimitive[r].clone();s[o]=a,t._voxelPrimitive[r]=s}}n({name:"inspectorVisible",initialValue:!0}),n({name:"displayVisible",initialValue:!1}),n({name:"transformVisible",initialValue:!1}),n({name:"boundsVisible",initialValue:!1}),n({name:"clippingVisible",initialValue:!1}),n({name:"shaderVisible",initialValue:!1}),n({name:"shaderString",initialValue:"",getPrimitiveFunction:function(){const r=t._voxelPrimitive.customShader.fragmentShaderText;t.shaderString=formatShaderString(r)}}),n({name:"shaderCompilationMessage",initialValue:""}),n({name:"shaderCompilationSuccess",initialValue:!0}),n({name:"depthTest",initialValue:!1,setPrimitiveFunction:!0,getPrimitiveFunction:!0}),n({name:"show",initialValue:!0,setPrimitiveFunction:!0,getPrimitiveFunction:!0}),n({name:"disableUpdate",initialValue:!1,setPrimitiveFunction:!0,getPrimitiveFunction:!0}),n({name:"debugDraw",initialValue:!1,setPrimitiveFunction:!0,getPrimitiveFunction:!0}),n({name:"jitter",initialValue:!0,setPrimitiveFunction:!0,getPrimitiveFunction:!0}),n({name:"nearestSampling",initialValue:!0,setPrimitiveFunction:!0,getPrimitiveFunction:!0}),n({name:"screenSpaceError",initialValue:4,setPrimitiveFunction:!0,getPrimitiveFunction:!0}),n({name:"stepSize",initialValue:1,setPrimitiveFunction:!0,getPrimitiveFunction:!0}),n({name:"shapeIsBox",getPrimitiveFunction:function(){const r=t._voxelPrimitive.shape;t.shapeIsBox=r===VoxelShapeType$1.BOX}}),n({name:"shapeIsEllipsoid",getPrimitiveFunction:function(){const r=t._voxelPrimitive.shape;t.shapeIsEllipsoid=r===VoxelShapeType$1.ELLIPSOID}}),n({name:"shapeIsCylinder",getPrimitiveFunction:function(){const r=t._voxelPrimitive.shape;t.shapeIsCylinder=r===VoxelShapeType$1.CYLINDER}}),n({name:"boundsBoxMaxX",initialValue:0,setPrimitiveFunction:i("maxBounds","x"),getPrimitiveFunction:function(){t.boundsBoxMaxX=t._voxelPrimitive.maxBounds.x}}),n({name:"boundsBoxMinX",initialValue:0,setPrimitiveFunction:i("minBounds","x"),getPrimitiveFunction:function(){t.boundsBoxMinX=t._voxelPrimitive.minBounds.x}}),n({name:"boundsBoxMaxY",initialValue:0,setPrimitiveFunction:i("maxBounds","y"),getPrimitiveFunction:function(){t.boundsBoxMaxY=t._voxelPrimitive.maxBounds.y}}),n({name:"boundsBoxMinY",initialValue:0,setPrimitiveFunction:i("minBounds","y"),getPrimitiveFunction:function(){t.boundsBoxMinY=t._voxelPrimitive.minBounds.y}}),n({name:"boundsBoxMaxZ",initialValue:0,setPrimitiveFunction:i("maxBounds","z"),getPrimitiveFunction:function(){t.boundsBoxMaxZ=t._voxelPrimitive.maxBounds.z}}),n({name:"boundsBoxMinZ",initialValue:0,setPrimitiveFunction:i("minBounds","z"),getPrimitiveFunction:function(){t.boundsBoxMinZ=t._voxelPrimitive.minBounds.z}}),n({name:"boundsEllipsoidMaxLongitude",initialValue:0,setPrimitiveFunction:i("maxBounds","x"),getPrimitiveFunction:function(){t.boundsEllipsoidMaxLongitude=t._voxelPrimitive.maxBounds.x}}),n({name:"boundsEllipsoidMinLongitude",initialValue:0,setPrimitiveFunction:i("minBounds","x"),getPrimitiveFunction:function(){t.boundsEllipsoidMinLongitude=t._voxelPrimitive.minBounds.x}}),n({name:"boundsEllipsoidMaxLatitude",initialValue:0,setPrimitiveFunction:i("maxBounds","y"),getPrimitiveFunction:function(){t.boundsEllipsoidMaxLatitude=t._voxelPrimitive.maxBounds.y}}),n({name:"boundsEllipsoidMinLatitude",initialValue:0,setPrimitiveFunction:i("minBounds","y"),getPrimitiveFunction:function(){t.boundsEllipsoidMinLatitude=t._voxelPrimitive.minBounds.y}}),n({name:"boundsEllipsoidMaxHeight",initialValue:0,setPrimitiveFunction:i("maxBounds","z"),getPrimitiveFunction:function(){t.boundsEllipsoidMaxHeight=t._voxelPrimitive.maxBounds.z}}),n({name:"boundsEllipsoidMinHeight",initialValue:0,setPrimitiveFunction:i("minBounds","z"),getPrimitiveFunction:function(){t.boundsEllipsoidMinHeight=t._voxelPrimitive.minBounds.z}}),n({name:"boundsCylinderMaxRadius",initialValue:0,setPrimitiveFunction:i("maxBounds","x"),getPrimitiveFunction:function(){t.boundsCylinderMaxRadius=t._voxelPrimitive.maxBounds.x}}),n({name:"boundsCylinderMinRadius",initialValue:0,setPrimitiveFunction:i("minBounds","x"),getPrimitiveFunction:function(){t.boundsCylinderMinRadius=t._voxelPrimitive.minBounds.x}}),n({name:"boundsCylinderMaxHeight",initialValue:0,setPrimitiveFunction:i("maxBounds","y"),getPrimitiveFunction:function(){t.boundsCylinderMaxHeight=t._voxelPrimitive.maxBounds.y}}),n({name:"boundsCylinderMinHeight",initialValue:0,setPrimitiveFunction:i("minBounds","y"),getPrimitiveFunction:function(){t.boundsCylinderMinHeight=t._voxelPrimitive.minBounds.y}}),n({name:"boundsCylinderMaxAngle",initialValue:0,setPrimitiveFunction:i("maxBounds","z"),getPrimitiveFunction:function(){t.boundsCylinderMaxAngle=t._voxelPrimitive.maxBounds.z}}),n({name:"boundsCylinderMinAngle",initialValue:0,setPrimitiveFunction:i("minBounds","z"),getPrimitiveFunction:function(){t.boundsCylinderMinAngle=t._voxelPrimitive.minBounds.z}}),n({name:"clippingBoxMaxX",initialValue:0,setPrimitiveFunction:i("maxClippingBounds","x"),getPrimitiveFunction:function(){t.clippingBoxMaxX=t._voxelPrimitive.maxClippingBounds.x}}),n({name:"clippingBoxMinX",initialValue:0,setPrimitiveFunction:i("minClippingBounds","x"),getPrimitiveFunction:function(){t.clippingBoxMinX=t._voxelPrimitive.minClippingBounds.x}}),n({name:"clippingBoxMaxY",initialValue:0,setPrimitiveFunction:i("maxClippingBounds","y"),getPrimitiveFunction:function(){t.clippingBoxMaxY=t._voxelPrimitive.maxClippingBounds.y}}),n({name:"clippingBoxMinY",initialValue:0,setPrimitiveFunction:i("minClippingBounds","y"),getPrimitiveFunction:function(){t.clippingBoxMinY=t._voxelPrimitive.minClippingBounds.y}}),n({name:"clippingBoxMaxZ",initialValue:0,setPrimitiveFunction:i("maxClippingBounds","z"),getPrimitiveFunction:function(){t.clippingBoxMaxZ=t._voxelPrimitive.maxClippingBounds.z}}),n({name:"clippingBoxMinZ",initialValue:0,setPrimitiveFunction:i("minClippingBounds","z"),getPrimitiveFunction:function(){t.clippingBoxMinZ=t._voxelPrimitive.minClippingBounds.z}}),n({name:"clippingEllipsoidMaxLongitude",initialValue:0,setPrimitiveFunction:i("maxClippingBounds","x"),getPrimitiveFunction:function(){t.clippingEllipsoidMaxLongitude=t._voxelPrimitive.maxClippingBounds.x}}),n({name:"clippingEllipsoidMinLongitude",initialValue:0,setPrimitiveFunction:i("minClippingBounds","x"),getPrimitiveFunction:function(){t.clippingEllipsoidMinLongitude=t._voxelPrimitive.minClippingBounds.x}}),n({name:"clippingEllipsoidMaxLatitude",initialValue:0,setPrimitiveFunction:i("maxClippingBounds","y"),getPrimitiveFunction:function(){t.clippingEllipsoidMaxLatitude=t._voxelPrimitive.maxClippingBounds.y}}),n({name:"clippingEllipsoidMinLatitude",initialValue:0,setPrimitiveFunction:i("minClippingBounds","y"),getPrimitiveFunction:function(){t.clippingEllipsoidMinLatitude=t._voxelPrimitive.minClippingBounds.y}}),n({name:"clippingEllipsoidMaxHeight",initialValue:0,setPrimitiveFunction:i("maxClippingBounds","z"),getPrimitiveFunction:function(){t.clippingEllipsoidMaxHeight=t._voxelPrimitive.maxClippingBounds.z}}),n({name:"clippingEllipsoidMinHeight",initialValue:0,setPrimitiveFunction:i("minClippingBounds","z"),getPrimitiveFunction:function(){t.clippingEllipsoidMinHeight=t._voxelPrimitive.minClippingBounds.z}}),n({name:"clippingCylinderMaxRadius",initialValue:0,setPrimitiveFunction:i("maxClippingBounds","x"),getPrimitiveFunction:function(){t.clippingCylinderMaxRadius=t._voxelPrimitive.maxClippingBounds.x}}),n({name:"clippingCylinderMinRadius",initialValue:0,setPrimitiveFunction:i("minClippingBounds","x"),getPrimitiveFunction:function(){t.clippingCylinderMinRadius=t._voxelPrimitive.minClippingBounds.x}}),n({name:"clippingCylinderMaxHeight",initialValue:0,setPrimitiveFunction:i("maxClippingBounds","y"),getPrimitiveFunction:function(){t.clippingCylinderMaxHeight=t._voxelPrimitive.maxClippingBounds.y}}),n({name:"clippingCylinderMinHeight",initialValue:0,setPrimitiveFunction:i("minClippingBounds","y"),getPrimitiveFunction:function(){t.clippingCylinderMinHeight=t._voxelPrimitive.minClippingBounds.y}}),n({name:"clippingCylinderMaxAngle",initialValue:0,setPrimitiveFunction:i("maxClippingBounds","z"),getPrimitiveFunction:function(){t.clippingCylinderMaxAngle=t._voxelPrimitive.maxClippingBounds.z}}),n({name:"clippingCylinderMinAngle",initialValue:0,setPrimitiveFunction:i("minClippingBounds","z"),getPrimitiveFunction:function(){t.clippingCylinderMinAngle=t._voxelPrimitive.minClippingBounds.z}}),n({name:"translationX",initialValue:0,setPrimitiveFunction:function(){t._modelMatrixReady&&setModelMatrix(t)},getPrimitiveFunction:function(){t.translationX=Matrix4.getTranslation(t._voxelPrimitive.modelMatrix,new Cartesian3).x}}),n({name:"translationY",initialValue:0,setPrimitiveFunction:function(){t._modelMatrixReady&&setModelMatrix(t)},getPrimitiveFunction:function(){t.translationY=Matrix4.getTranslation(t._voxelPrimitive.modelMatrix,new Cartesian3).y}}),n({name:"translationZ",initialValue:0,setPrimitiveFunction:function(){t._modelMatrixReady&&setModelMatrix(t)},getPrimitiveFunction:function(){t.translationZ=Matrix4.getTranslation(t._voxelPrimitive.modelMatrix,new Cartesian3).z}}),n({name:"scaleX",initialValue:1,setPrimitiveFunction:function(){t._modelMatrixReady&&setModelMatrix(t)},getPrimitiveFunction:function(){t.scaleX=Matrix4.getScale(t._voxelPrimitive.modelMatrix,new Cartesian3).x}}),n({name:"scaleY",initialValue:1,setPrimitiveFunction:function(){t._modelMatrixReady&&setModelMatrix(t)},getPrimitiveFunction:function(){t.scaleY=Matrix4.getScale(t._voxelPrimitive.modelMatrix,new Cartesian3).y}}),n({name:"scaleZ",initialValue:1,setPrimitiveFunction:function(){t._modelMatrixReady&&setModelMatrix(t)},getPrimitiveFunction:function(){t.scaleZ=Matrix4.getScale(t._voxelPrimitive.modelMatrix,new Cartesian3).z}}),n({name:"angleX",initialValue:0,setPrimitiveFunction:function(){t._modelMatrixReady&&setModelMatrix(t)}}),n({name:"angleY",initialValue:0,setPrimitiveFunction:function(){t._modelMatrixReady&&setModelMatrix(t)}}),n({name:"angleZ",initialValue:0,setPrimitiveFunction:function(){t._modelMatrixReady&&setModelMatrix(t)}})}const scratchTranslation=new Cartesian3,scratchScale=new Cartesian3,scratchHeadingPitchRoll=new HeadingPitchRoll,scratchRotation=new Matrix3;function setModelMatrix(e){const t=Cartesian3.fromElements(e.translationX,e.translationY,e.translationZ,scratchTranslation),n=Cartesian3.fromElements(e.scaleX,e.scaleY,e.scaleZ,scratchScale),i=scratchHeadingPitchRoll;i.heading=e.angleX,i.pitch=e.angleY,i.roll=e.angleZ;const r=Matrix3.fromHeadingPitchRoll(i,scratchRotation),o=Matrix3.multiplyByScale(r,n,r);e._voxelPrimitive.modelMatrix=Matrix4.fromRotationTranslation(o,t,e._voxelPrimitive.modelMatrix)}Object.defineProperties(VoxelInspectorViewModel.prototype,{scene:{get:function(){return this._scene}},voxelPrimitive:{get:function(){return this._voxelPrimitive},set:function(e){if(defined(this._customShaderCompilationRemoveCallback)&&this._customShaderCompilationRemoveCallback(),defined(e)){this._voxelPrimitive=e;const t=this;t._customShaderCompilationRemoveCallback=t._voxelPrimitive.customShaderCompilationEvent.addEventListener(function(n){const i=t._voxelPrimitive.customShader.fragmentShaderText;t.shaderString=formatShaderString(i),defined(n)?(t.shaderCompilationMessage=n.message,t.shaderCompilationSuccess=!1):(t.shaderCompilationMessage="Shader compiled successfully!",t.shaderCompilationSuccess=!0)}),t._modelMatrixReady=!1;for(let n=0;n<t._getPrimitiveFunctions.length;n++)t._getPrimitiveFunctions[n]();t._modelMatrixReady=!0,setModelMatrix(t)}}}});VoxelInspectorViewModel.prototype.toggleInspector=function(){this.inspectorVisible=!this.inspectorVisible};VoxelInspectorViewModel.prototype.toggleDisplay=function(){this.displayVisible=!this.displayVisible};VoxelInspectorViewModel.prototype.toggleTransform=function(){this.transformVisible=!this.transformVisible};VoxelInspectorViewModel.prototype.toggleBounds=function(){this.boundsVisible=!this.boundsVisible};VoxelInspectorViewModel.prototype.toggleClipping=function(){this.clippingVisible=!this.clippingVisible};VoxelInspectorViewModel.prototype.toggleShader=function(){this.shaderVisible=!this.shaderVisible};VoxelInspectorViewModel.prototype.compileShader=function(){defined(this._voxelPrimitive)&&(this._voxelPrimitive.customShader=new CustomShader({fragmentShaderText:this.shaderString,uniforms:this._voxelPrimitive.customShader.uniforms}))};VoxelInspectorViewModel.prototype.shaderEditorKeyPress=function(e,t){if(t.keyCode===9){t.preventDefault();const n=t.target,i=n.selectionStart,r=n.selectionEnd;let o=r;const s=n.value.slice(i,r).split(`
`),l=s.length;let c;if(t.shiftKey)for(c=0;c<l;++c)s[c][0]===" "&&(s[c][1]===" "?(s[c]=s[c].substr(2),o-=2):(s[c]=s[c].substr(1),o-=1));else for(c=0;c<l;++c)s[c]=`  ${s[c]}`,o+=2;const d=s.join(`
`);n.value=n.value.slice(0,i)+d+n.value.slice(r),n.selectionStart=i!==r?i:o,n.selectionEnd=o}else t.ctrlKey&&(t.keyCode===10||t.keyCode===13)&&this.compileShader();return!0};VoxelInspectorViewModel.prototype.isDestroyed=function(){return!1};VoxelInspectorViewModel.prototype.destroy=function(){const e=this;return this._definedProperties.forEach(function(t){knockout.getObservable(e,t).dispose()}),destroyObject(this)};function VoxelInspector(e,t){Check.defined("container",e),Check.typeOf.object("scene",t),e=getElement(e);const n=document.createElement("div"),i=new VoxelInspectorViewModel(t);this._viewModel=i,this._container=e,this._element=n;const r=document.createElement("div");r.textContent="Voxel Inspector",r.className="cesium-cesiumInspector-button",r.setAttribute("data-bind","click: toggleInspector"),n.appendChild(r),n.className="cesium-cesiumInspector cesium-VoxelInspector",n.setAttribute("data-bind",'css: { "cesium-cesiumInspector-visible" : inspectorVisible, "cesium-cesiumInspector-hidden" : !inspectorVisible}'),e.appendChild(n);const o=document.createElement("div");o.className="cesium-cesiumInspector-dropDown",n.appendChild(o);const a=InspectorShared$1.createSection,s=InspectorShared$1.createCheckbox,l=InspectorShared$1.createRangeInput,c=InspectorShared$1.createButton,d=a(o,"Display","displayVisible","toggleDisplay"),h=a(o,"Transform","transformVisible","toggleTransform"),f=a(o,"Bounds","boundsVisible","toggleBounds"),p=a(o,"Clipping","clippingVisible","toggleClipping"),u=a(o,"Shader","shaderVisible","toggleShader");d.appendChild(s("Depth Test","depthTest")),d.appendChild(s("Show","show")),d.appendChild(s("Disable Update","disableUpdate")),d.appendChild(s("Debug Draw","debugDraw")),d.appendChild(s("Jitter","jitter")),d.appendChild(s("Nearest Sampling","nearestSampling")),d.appendChild(l("Screen Space Error","screenSpaceError",0,128)),d.appendChild(l("Step Size","stepSize",0,2));const m=10,g=10,_=CesiumMath.PI;h.appendChild(l("Translation X","translationX",-m,+m)),h.appendChild(l("Translation Y","translationY",-m,+m)),h.appendChild(l("Translation Z","translationZ",-m,+m)),h.appendChild(l("Scale X","scaleX",0,+g)),h.appendChild(l("Scale Y","scaleY",0,+g)),h.appendChild(l("Scale Z","scaleZ",0,+g)),h.appendChild(l("Heading","angleX",-_,+_)),h.appendChild(l("Pitch","angleY",-_,+_)),h.appendChild(l("Roll","angleZ",-_,+_));const C=VoxelShapeType$1.getMinBounds(VoxelShapeType$1.BOX),A=VoxelShapeType$1.getMaxBounds(VoxelShapeType$1.BOX),S=Cartesian3.fromElements(VoxelShapeType$1.getMinBounds(VoxelShapeType$1.ELLIPSOID).x,VoxelShapeType$1.getMinBounds(VoxelShapeType$1.ELLIPSOID).y,-Ellipsoid.WGS84.maximumRadius,new Cartesian3),v=Cartesian3.fromElements(VoxelShapeType$1.getMaxBounds(VoxelShapeType$1.ELLIPSOID).x,VoxelShapeType$1.getMaxBounds(VoxelShapeType$1.ELLIPSOID).y,1e7,new Cartesian3),b=VoxelShapeType$1.getMinBounds(VoxelShapeType$1.CYLINDER),D=VoxelShapeType$1.getMaxBounds(VoxelShapeType$1.CYLINDER);makeCoordinateRange("Max X","Min X","Max Y","Min Y","Max Z","Min Z","boundsBoxMaxX","boundsBoxMinX","boundsBoxMaxY","boundsBoxMinY","boundsBoxMaxZ","boundsBoxMinZ",C,A,"shapeIsBox",f),makeCoordinateRange("Max Longitude","Min Longitude","Max Latitude","Min Latitude","Max Height","Min Height","boundsEllipsoidMaxLongitude","boundsEllipsoidMinLongitude","boundsEllipsoidMaxLatitude","boundsEllipsoidMinLatitude","boundsEllipsoidMaxHeight","boundsEllipsoidMinHeight",S,v,"shapeIsEllipsoid",f),makeCoordinateRange("Max Radius","Min Radius","Max Height","Min Height","Max Angle","Min Angle","boundsCylinderMaxRadius","boundsCylinderMinRadius","boundsCylinderMaxHeight","boundsCylinderMinHeight","boundsCylinderMaxAngle","boundsCylinderMinAngle",b,D,"shapeIsCylinder",f),makeCoordinateRange("Max X","Min X","Max Y","Min Y","Max Z","Min Z","clippingBoxMaxX","clippingBoxMinX","clippingBoxMaxY","clippingBoxMinY","clippingBoxMaxZ","clippingBoxMinZ",C,A,"shapeIsBox",p),makeCoordinateRange("Max Longitude","Min Longitude","Max Latitude","Min Latitude","Max Height","Min Height","clippingEllipsoidMaxLongitude","clippingEllipsoidMinLongitude","clippingEllipsoidMaxLatitude","clippingEllipsoidMinLatitude","clippingEllipsoidMaxHeight","clippingEllipsoidMinHeight",S,v,"shapeIsEllipsoid",p),makeCoordinateRange("Max Radius","Min Radius","Max Height","Min Height","Max Angle","Min Angle","clippingCylinderMaxRadius","clippingCylinderMinRadius","clippingCylinderMaxHeight","clippingCylinderMinHeight","clippingCylinderMaxAngle","clippingCylinderMinAngle",b,D,"shapeIsCylinder",p);const I=document.createElement("div");u.appendChild(I);const L=document.createElement("textarea");L.setAttribute("data-bind","textInput: shaderString, event: { keydown: shaderEditorKeyPress }"),I.className="cesium-cesiumInspector-styleEditor",I.appendChild(L);const N=c("Compile (Ctrl+Enter)","compileShader");I.appendChild(N);const y=document.createElement("label");y.style.display="block",y.setAttribute("data-bind","text: shaderCompilationMessage, style: {color: shaderCompilationSuccess ? 'green' : 'red'}"),I.appendChild(y),knockout.applyBindings(i,n)}Object.defineProperties(VoxelInspector.prototype,{container:{get:function(){return this._container}},viewModel:{get:function(){return this._viewModel}}});VoxelInspector.prototype.isDestroyed=function(){return!1};VoxelInspector.prototype.destroy=function(){return knockout.cleanNode(this._element),this._container.removeChild(this._element),this.viewModel.destroy(),destroyObject(this)};function makeCoordinateRange(e,t,n,i,r,o,a,s,l,c,d,h,f,p,u,m){const g=InspectorShared$1.createRangeInput,_=f,C=p,A=m.appendChild(document.createElement("div"));A.setAttribute("data-bind",`if: ${u}`),A.appendChild(g(e,a,_.x,C.x)),A.appendChild(g(t,s,_.x,C.x)),A.appendChild(g(n,l,_.y,C.y)),A.appendChild(g(i,c,_.y,C.y)),A.appendChild(g(r,d,_.z,C.z)),A.appendChild(g(o,h,_.z,C.z))}function viewerVoxelInspectorMixin(e){Check.typeOf.object("viewer",e);const t=document.createElement("div");t.className="cesium-viewer-voxelInspectorContainer",e.container.appendChild(t);const n=new VoxelInspector(t,e.scene);Object.defineProperties(e,{voxelInspector:{get:function(){return n}}})}const VERSION="1.119";export{tt as AlphaMode,nt as AlphaPipelineStage,Animation,AnimationViewModel,Appearance,ApproximateTerrainHeights,ArcGISTiledElevationTerrainProvider,ArcGisBaseMapType,ArcGisMapServerImageryProvider,it as ArcGisMapService,ArcType,rt as ArticulationStageType,AssociativeArray,Atmosphere,ot as AtmospherePipelineStage,AttributeCompression,at as AttributeType,AutoExposure,st as AutomaticUniforms,Axis,AxisAlignedBoundingBox,ct as B3dmLoader,lt as B3dmParser,BaseLayerPicker,BaseLayerPickerViewModel,dt as BatchTable,ut as BatchTableHierarchy,ht as BatchTexture,ft as BatchTexturePipelineStage,Billboard,BillboardCollection,BillboardGraphics,BillboardVisualizer,BingMapsGeocoderService,pt as BingMapsImageryProvider,mt as BingMapsStyle,BlendEquation,BlendFunction,BlendOption,BlendingState,BoundingRectangle,BoundingSphere,BoundingSphereState$1 as BoundingSphereState,gt as BoundingVolumeSemantics,BoxEmitter,BoxGeometry,BoxGeometryUpdater,BoxGraphics,BoxOutlineGeometry,BrdfLutGenerator,Buffer,_t as BufferLoader,BufferUsage,yt as CPUStylingPipelineStage,CallbackProperty,Camera,CameraEventAggregator,CameraEventType$1 as CameraEventType,CameraFlightPath$1 as CameraFlightPath,Cartesian2,Cartesian3,Cartesian4,Cartographic,CartographicGeocoderService,CatmullRomSpline,Ct as Cesium3DContentGroup,Cesium3DTile,Cesium3DTileBatchTable,Cesium3DTileColorBlendMode,Cesium3DTileContent,At as Cesium3DTileContentFactory,St as Cesium3DTileContentState,xt as Cesium3DTileContentType,Cesium3DTileFeature,Tt as Cesium3DTileFeatureTable,vt as Cesium3DTileOptimizationHint,Et as Cesium3DTileOptimizations,Cesium3DTilePass,Cesium3DTilePassState,bt as Cesium3DTilePointFeature,Pt as Cesium3DTileRefine,Cesium3DTileStyle,wt as Cesium3DTileStyleEngine,Cesium3DTilesInspector,Cesium3DTilesInspectorViewModel,Cesium3DTilesVoxelProvider,Cesium3DTileset,Dt as Cesium3DTilesetBaseTraversal,Mt as Cesium3DTilesetCache,Cesium3DTilesetGraphics,It as Cesium3DTilesetHeatmap,Cesium3DTilesetMetadata,Rt as Cesium3DTilesetMostDetailedTraversal,Ot as Cesium3DTilesetSkipTraversal,Lt as Cesium3DTilesetStatistics,Nt as Cesium3DTilesetTraversal,Cesium3DTilesetVisualizer,CesiumInspector,CesiumInspectorViewModel,CesiumTerrainProvider,CesiumWidget,Check,CheckerboardMaterialProperty,CircleEmitter,CircleGeometry,CircleOutlineGeometry,Ft as ClassificationModelDrawCommand,Vt as ClassificationPipelineStage,zl as ClassificationPrimitive,ClassificationType,ClearCommand,kt as ClippingPlane,ClippingPlaneCollection,Bt as ClippingPolygon,ClippingPolygonCollection,Clock,ClockRange$1 as ClockRange,ClockStep$1 as ClockStep,ClockViewModel,CloudCollection,CloudType$1 as CloudType,Color,ColorBlendMode,ColorGeometryInstanceAttribute,ColorMaterialProperty,Command,ComponentDatatype,Ut as Composite3DTileContent,CompositeEntityCollection,CompositeMaterialProperty,CompositePositionProperty,CompositeProperty,Gt as CompressedTextureBuffer,ComputeCommand,ComputeEngine,ConditionsExpression,ConeEmitter,ConstantPositionProperty,ConstantProperty,Ht as ConstantSpline,zt as ContentMetadata,Context,ContextLimits,CoplanarPolygonGeometry,CoplanarPolygonGeometryLibrary,CoplanarPolygonOutlineGeometry,CornerType$1 as CornerType,CorridorGeometry,CorridorGeometryLibrary$1 as CorridorGeometryLibrary,CorridorGeometryUpdater,CorridorGraphics,CorridorOutlineGeometry,Credit,CreditDisplay,CubeMap,$t as CubeMapFace,Wt as CubicRealPolynomial,CullFace,CullingVolume,CumulusCloud,CustomDataSource,CustomHeightmapTerrainProvider,CustomShader,CustomShaderMode,qt as CustomShaderPipelineStage,CustomShaderTranslucencyMode,CylinderGeometry,CylinderGeometryLibrary$1 as CylinderGeometryLibrary,CylinderGeometryUpdater,CylinderGraphics,CylinderOutlineGeometry,CzmlDataSource,DataSource,DataSourceClock,DataSourceCollection,DataSourceDisplay,DebugAppearance,DebugCameraPrimitive,DebugInspector,DebugModelMatrixPrimitive,DefaultProxy,DepthFunction,DepthPlane,jt as DequantizationPipelineStage,DerivedCommand,DeveloperError,DeviceOrientationCameraController,DirectionalLight,Xt as DiscardEmptyTileImagePolicy,Yt as DiscardMissingTileImagePolicy,DistanceDisplayCondition,DistanceDisplayConditionGeometryInstanceAttribute,DoubleEndedPriorityQueue,Qt as DoublyLinkedList,DracoLoader,DrawCommand,DynamicAtmosphereLightingType$1 as DynamicAtmosphereLightingType,DynamicGeometryBatch,DynamicGeometryUpdater$1 as DynamicGeometryUpdater,Kt as EarthOrientationParameters,Zt as EarthOrientationParametersSample,EasingFunction$1 as EasingFunction,EllipseGeometry,EllipseGeometryLibrary$1 as EllipseGeometryLibrary,EllipseGeometryUpdater,EllipseGraphics,EllipseOutlineGeometry,Ellipsoid,EllipsoidGeodesic,EllipsoidGeometry,EllipsoidGeometryUpdater,EllipsoidGraphics,EllipsoidOutlineGeometry,EllipsoidPrimitive,Jt as EllipsoidRhumbLine,EllipsoidSurfaceAppearance,EllipsoidTangentPlane,EllipsoidTerrainProvider,EllipsoidalOccluder,en as Empty3DTileContent,EncodedCartesian3,Entity,EntityCluster,EntityCollection,EntityView,Event,EventHelper,Expression,tn as ExpressionNodeType,ExtrapolationType,FeatureDetection,nn as FeatureIdPipelineStage,Fog,rn as ForEach,FrameRateMonitor,FrameState,Framebuffer,FramebufferManager,FrustumCommands,FrustumGeometry,FrustumOutlineGeometry,Fullscreen,FullscreenButton,FullscreenButtonViewModel,GeoJsonDataSource,on as GeoJsonLoader,GeocodeType$1 as GeocodeType,Geocoder,GeocoderService,GeocoderViewModel,GeographicProjection,GeographicTilingScheme,Geometry,an as Geometry3DTileContent,GeometryAttribute,GeometryAttributes,GeometryFactory,GeometryInstance,$l as GeometryInstanceAttribute,GeometryOffsetAttribute,GeometryPipeline,sn as GeometryPipelineStage,GeometryType,GeometryUpdater,GeometryUpdaterSet,GeometryVisualizer,cn as GetFeatureInfoFormat,Globe,GlobeDepth,GlobeSurfaceShaderSet,GlobeSurfaceTile,GlobeSurfaceTileProvider,GlobeTranslucency,GlobeTranslucencyFramebuffer,GlobeTranslucencyState,ln as GltfBufferViewLoader,dn as GltfDracoLoader,un as GltfImageLoader,hn as GltfIndexBufferLoader,fn as GltfJsonLoader,pn as GltfLoader,mn as GltfLoaderUtil,gn as GltfStructuralMetadataLoader,_n as GltfTextureLoader,yn as GltfVertexBufferLoader,GoogleEarthEnterpriseImageryProvider,Cn as GoogleEarthEnterpriseMapsProvider,GoogleEarthEnterpriseMetadata,GoogleEarthEnterpriseTerrainData,GoogleEarthEnterpriseTerrainProvider,GoogleEarthEnterpriseTileInformation,GoogleMaps$1 as GoogleMaps,GpxDataSource,An as GregorianDate,GridImageryProvider,GridMaterialProperty,GroundGeometryUpdater,GroundPolylineGeometry,GroundPolylinePrimitive,GroundPrimitive,Sn as GroupMetadata,HeadingPitchRange,HeadingPitchRoll,xn as Heap,HeightReference,HeightmapEncoding$1 as HeightmapEncoding,HeightmapTerrainData,HeightmapTessellator$1 as HeightmapTessellator,HermitePolynomialApproximation$1 as HermitePolynomialApproximation,HermiteSpline,Tn as HilbertOrder,HomeButton,HomeButtonViewModel,HorizontalOrigin,I3SBuildingSceneLayerExplorer,I3SBuildingSceneLayerExplorerViewModel,I3SDataProvider,I3SDecoder,I3SFeature,I3SField,I3SGeometry,I3SLayer,I3SNode,I3SStatistics,I3SSublayer,I3SSymbology,vn as I3dmLoader,En as I3dmParser,Iau2000Orientation$1 as Iau2000Orientation,bn as Iau2006XysData,Pn as Iau2006XysSample,IauOrientationAxes,IauOrientationParameters,wn as ImageBasedLighting,Dn as ImageBasedLightingPipelineStage,ImageMaterialProperty,Mn as Imagery,ImageryLayer,ImageryLayerCollection,In as ImageryLayerFeatureInfo,Rn as ImageryProvider,ImageryState,On as Implicit3DTileContent,Ln as ImplicitAvailabilityBitstream,Nn as ImplicitMetadataView,Fn as ImplicitSubdivisionScheme,ImplicitSubtree,ImplicitSubtreeCache,Vn as ImplicitSubtreeMetadata,ImplicitTileCoordinates,ImplicitTileset,IndexDatatype,InfoBox,InfoBoxViewModel,InspectorShared$1 as InspectorShared,kn as InstanceAttributeSemantic,Bn as InstancingPipelineStage,InterpolationAlgorithm$1 as InterpolationAlgorithm,Un as InterpolationType,Intersect,IntersectionTests,Intersections2D$1 as Intersections2D,Interval,InvertClassification,Ion,IonGeocoderService,IonImageryProvider,IonResource,IonWorldImageryStyle,Iso8601,JobScheduler,JobType,Gn as JsonMetadataTable,JulianDate,Hn as KTX2Transcoder,KeyboardEventModifier,KeyframeNode,KmlCamera,KmlDataSource,KmlLookAt,KmlTour,KmlTourFlyTo,KmlTourWait,Label,LabelCollection,LabelGraphics,LabelStyle,LabelVisualizer,LagrangePolynomialApproximation$1 as LagrangePolynomialApproximation,zn as LeapSecond,Light,$n as LightingModel,Wn as LightingPipelineStage,LinearApproximation,qn as LinearSpline,jn as ManagedArray,MapMode2D$1 as MapMode2D,MapProjection,Xn as MapboxImageryProvider,MapboxStyleImageryProvider,Material,MaterialAppearance,Yn as MaterialPipelineStage,MaterialProperty,CesiumMath as Math,Matrix2,Matrix3,Matrix4,Megatexture,Qn as MetadataClass,Kn as MetadataClassProperty,MetadataComponentType,Zn as MetadataEntity,Jn as MetadataEnum,ei as MetadataEnumValue,ti as MetadataPipelineStage,ni as MetadataSchema,ii as MetadataSchemaLoader,MetadataSemantic,MetadataTable,ri as MetadataTableProperty,MetadataType,oi as MipmapHint,Model,ai as Model3DTileContent,si as ModelAlphaOptions,ci as ModelAnimation,li as ModelAnimationChannel,di as ModelAnimationCollection,ModelAnimationLoop,ui as ModelAnimationState,hi as ModelArticulation,fi as ModelArticulationStage,pi as ModelClippingPlanesPipelineStage,mi as ModelClippingPolygonsPipelineStage,gi as ModelColorPipelineStage,_i as ModelComponents,yi as ModelDrawCommand,Ci as ModelFeature,Ai as ModelFeatureTable,ModelGraphics,Si as ModelLightingOptions,xi as ModelMatrixUpdateStage,Ti as ModelNode,vi as ModelRenderResources,Ei as ModelRuntimeNode,bi as ModelRuntimePrimitive,Pi as ModelSceneGraph,wi as ModelSilhouettePipelineStage,Di as ModelSkin,Mi as ModelSplitterPipelineStage,Ii as ModelStatistics,Ri as ModelType,Oi as ModelUtility,ModelVisualizer,Moon,Li as MorphTargetsPipelineStage,MorphWeightSpline,Ni as MortonOrder,Fi as Multiple3DTileContent,Vi as MultisampleFramebuffer,NavigationHelpButton,NavigationHelpButtonViewModel,NearFarScalar,NeverTileDiscardPolicy,ki as NodeRenderResources,Bi as NodeStatisticsPipelineStage,NodeTransformationProperty,OIT,Occluder,OctahedralProjectedCubeMap,OffsetGeometryInstanceAttribute,OpenCageGeocoderService,OpenStreetMapImageryProvider,OrderedGroundPrimitiveCollection,OrientedBoundingBox,OrthographicFrustum,OrthographicOffCenterFrustum,Packable$1 as Packable,PackableForInterpolation$1 as PackableForInterpolation,Particle,ParticleBurst,ParticleEmitter,ParticleSystem,Pass,PassState,PathGraphics,PathVisualizer,PeliasGeocoderService,PerInstanceColorAppearance,PerformanceDisplay,PerformanceWatchdog,PerformanceWatchdogViewModel,PerspectiveFrustum,PerspectiveOffCenterFrustum,PickDepth,PickDepthFramebuffer,PickFramebuffer,Picking,Ui as PickingPipelineStage,PinBuilder,PixelDatatype,PixelFormat,Plane,PlaneGeometry,PlaneGeometryUpdater,Wl as PlaneGraphics,PlaneOutlineGeometry,Gi as PntsLoader,PntsParser,PointCloud,PointCloudEyeDomeLighting,PointCloudShading,Hi as PointCloudStylingPipelineStage,PointGraphics,PointPrimitive,PointPrimitiveCollection,PointVisualizer,PolygonGeometry,PolygonGeometryLibrary,PolygonGeometryUpdater,PolygonGraphics,PolygonHierarchy,PolygonOutlineGeometry,PolygonPipeline,zi as Polyline,PolylineArrowMaterialProperty,PolylineCollection,PolylineColorAppearance,PolylineDashMaterialProperty,PolylineGeometry,PolylineGeometryUpdater,PolylineGlowMaterialProperty,PolylineGraphics,PolylineMaterialAppearance,PolylineOutlineMaterialProperty,PolylinePipeline,PolylineVisualizer,PolylineVolumeGeometry,PolylineVolumeGeometryLibrary$1 as PolylineVolumeGeometryLibrary,PolylineVolumeGeometryUpdater,PolylineVolumeGraphics,PolylineVolumeOutlineGeometry,PositionProperty,PositionPropertyArray,PostProcessStage,PostProcessStageCollection,PostProcessStageComposite,PostProcessStageLibrary$1 as PostProcessStageLibrary,PostProcessStageSampleMode$1 as PostProcessStageSampleMode,PostProcessStageTextureCache,Primitive,PrimitiveCollection,$i as PrimitiveLoadPlan,Wi as PrimitiveOutlineGenerator,qi as PrimitiveOutlinePipelineStage,ji as PrimitivePipeline,Xi as PrimitiveRenderResources,Yi as PrimitiveState,Qi as PrimitiveStatisticsPipelineStage,PrimitiveType,ProjectionPicker,ProjectionPickerViewModel,Property,PropertyArray,Ki as PropertyAttribute,Zi as PropertyAttributeProperty,PropertyBag,Ji as PropertyTable,er as PropertyTexture,tr as PropertyTextureProperty,ProviderViewModel,Proxy,nr as QuadraticRealPolynomial,QuadtreeOccluders,QuadtreePrimitive,QuadtreeTile,QuadtreeTileLoadState$1 as QuadtreeTileLoadState,QuadtreeTileProvider,QuantizedMeshTerrainData,ir as QuarticRealPolynomial,Quaternion,rr as QuaternionSpline,Queue,Ray,Rectangle,RectangleCollisionChecker,RectangleGeometry,RectangleGeometryLibrary,RectangleGeometryUpdater,RectangleGraphics,RectangleOutlineGeometry,ReferenceFrame,ReferenceProperty,RenderState,Renderbuffer,RenderbufferFormat,Request,or as RequestErrorEvent,RequestScheduler,RequestState,RequestType,Resource,ResourceCache,ar as ResourceCacheKey,sr as ResourceCacheStatistics,cr as ResourceLoader,lr as ResourceLoaderState,Rotation$1 as Rotation,RuntimeError,dr as S2Cell,ur as SDFSettings,SampledPositionProperty,SampledProperty,Sampler,ScaledPositionProperty,Scene,SceneFramebuffer,SceneMode,hr as SceneMode2DPipelineStage,SceneModePicker,SceneModePickerViewModel,SceneTransforms,SceneTransitioner,ScreenSpaceCameraController,ScreenSpaceEventHandler,ScreenSpaceEventType,fr as SelectedFeatureIdPipelineStage,SelectionIndicator,SelectionIndicatorViewModel,SensorVolumePortionToDisplay$1 as SensorVolumePortionToDisplay,ShaderBuilder,ShaderCache,ShaderDestination,pr as ShaderFunction,ShaderProgram,ShaderSource,mr as ShaderStruct,ShadowMap,ShadowMapShader,ShadowMode,ShadowVolumeAppearance,ShowGeometryInstanceAttribute,Simon1994PlanetaryPositions$1 as Simon1994PlanetaryPositions,SimplePolylineGeometry,gr as SingleTileImageryProvider,_r as SkinningPipelineStage,SkyAtmosphere,SkyBox,SpatialNode,SphereEmitter,SphereGeometry,SphereOutlineGeometry,Spherical,Spline,SplitDirection,Splitter$1 as Splitter,StaticGeometryColorBatch,StaticGeometryPerMaterialBatch,StaticGroundGeometryColorBatch,StaticGroundGeometryPerMaterialBatch,StaticGroundPolylinePerMaterialBatch,StaticOutlineGeometryBatch,StencilConstants,StencilFunction,StencilOperation,yr as SteppedSpline,Cr as Stereographic,StripeMaterialProperty,StripeOrientation$1 as StripeOrientation,Ar as StructuralMetadata,Sr as StyleCommandsNeeded,StyleExpression,Sun,SunLight,SunPostProcess,xr as SupportedImageFormats,SvgPathBindingHandler$1 as SvgPathBindingHandler,TaskProcessor,Terrain,TerrainData,TerrainEncoding,TerrainFillMesh,TerrainMesh,TerrainOffsetProperty,TerrainProvider,TerrainQuantization$1 as TerrainQuantization,TerrainState$2 as TerrainState,Texture,Tr as TextureAtlas,TextureCache,TextureMagnificationFilter,TextureManager,TextureMinificationFilter,TextureUniform,TextureWrap,TileAvailability,TileBoundingRegion,vr as TileBoundingS2Cell,Er as TileBoundingSphere,TileBoundingVolume,TileCoordinatesImageryProvider,TileDiscardPolicy,TileEdge$1 as TileEdge,br as TileImagery,TileMapServiceImageryProvider,Pr as TileMetadata,wr as TileOrientedBoundingBox,TileProviderError,TileReplacementQueue,TileSelectionResult$1 as TileSelectionResult,TileState$1 as TileState,Dr as Tileset3DTileContent,Mr as TilesetMetadata,Ir as TilesetPipelineStage,TilingScheme,TimeConstants,Rr as TimeDynamicImagery,TimeDynamicPointCloud,TimeInterval,TimeIntervalCollection,TimeIntervalCollectionPositionProperty,TimeIntervalCollectionProperty,TimeStandard,Timeline,TimelineHighlightRange,TimelineTrack,Or as Tipsify,ToggleButtonViewModel,Tonemapper$1 as Tonemapper,Transforms,Lr as TranslationRotationScale,TranslucentTileClassification,Nr as TridiagonalSystemSolver,Fr as TrustedServers,TweenCollection,UniformState,UniformType$1 as UniformType,UrlTemplateImageryProvider,VERSION,VRButton,VRButtonViewModel,VRTheWorldTerrainProvider,VaryingType$1 as VaryingType,Vr as Vector3DTileBatch,kr as Vector3DTileClampedPolylines,Br as Vector3DTileContent,Ur as Vector3DTileGeometry,Gr as Vector3DTilePoints,Hr as Vector3DTilePolygons,zr as Vector3DTilePolylines,$r as Vector3DTilePrimitive,VelocityOrientationProperty,VelocityVectorProperty,VertexArray,VertexArrayFacade,Wr as VertexAttributeSemantic,VertexFormat,VerticalExaggeration,qr as VerticalExaggerationPipelineStage,VerticalOrigin,VideoSynchronizer,View,Viewer,ViewportQuad,Visibility$1 as Visibility,Visualizer,VoxelBoxShape,VoxelCell,VoxelContent,VoxelCylinderShape,VoxelEllipsoidShape,VoxelInspector,VoxelInspectorViewModel,VoxelPrimitive,VoxelProvider,VoxelRenderResources,VoxelShape,VoxelShapeType$1 as VoxelShapeType,VoxelTraversal,VulkanConstants$1 as VulkanConstants,WallGeometry,WallGeometryLibrary$1 as WallGeometryLibrary,WallGeometryUpdater,WallGraphics,WallOutlineGeometry,WebGLConstants,jr as WebMapServiceImageryProvider,Xr as WebMapTileServiceImageryProvider,WebMercatorProjection,WebMercatorTilingScheme,WindingOrder,Yr as WireframeIndexGenerator,Qr as WireframePipelineStage,AcesTonemapping as _shadersAcesTonemappingStage,AdditiveBlend as _shadersAdditiveBlend,AdjustTranslucentFS as _shadersAdjustTranslucentFS,AllMaterialAppearanceFS as _shadersAllMaterialAppearanceFS,AllMaterialAppearanceVS as _shadersAllMaterialAppearanceVS,AmbientOcclusionGenerate as _shadersAmbientOcclusionGenerate,AmbientOcclusionModulate as _shadersAmbientOcclusionModulate,Kr as _shadersAspectRampMaterial,AtmosphereCommon as _shadersAtmosphereCommon,Zr as _shadersAtmosphereStageFS,Jr as _shadersAtmosphereStageVS,BasicMaterialAppearanceFS as _shadersBasicMaterialAppearanceFS,BasicMaterialAppearanceVS as _shadersBasicMaterialAppearanceVS,eo as _shadersBillboardCollectionFS,to as _shadersBillboardCollectionVS,BlackAndWhite as _shadersBlackAndWhite,BloomComposite as _shadersBloomComposite,BrdfLutGeneratorFS as _shadersBrdfLutGeneratorFS,BrightPass as _shadersBrightPass,Brightness as _shadersBrightness,no as _shadersBumpMapMaterial,io as _shadersCPUStylingStageFS,ro as _shadersCPUStylingStageVS,oo as _shadersCheckerboardMaterial,CloudCollectionFS as _shadersCloudCollectionFS,CloudCollectionVS as _shadersCloudCollectionVS,CloudNoiseFS as _shadersCloudNoiseFS,CloudNoiseVS as _shadersCloudNoiseVS,CompareAndPackTranslucentDepth as _shadersCompareAndPackTranslucentDepth,CompositeOITFS as _shadersCompositeOITFS,CompositeTranslucentClassification as _shadersCompositeTranslucentClassification,ContrastBias as _shadersContrastBias,ao as _shadersCustomShaderStageFS,so as _shadersCustomShaderStageVS,co as _shadersCzmBuiltins,DepthOfField as _shadersDepthOfField,DepthPlaneFS as _shadersDepthPlaneFS,DepthPlaneVS as _shadersDepthPlaneVS,DepthView as _shadersDepthView,DepthViewPacked as _shadersDepthViewPacked,lo as _shadersDotMaterial,EdgeDetection as _shadersEdgeDetection,uo as _shadersElevationBandMaterial,ho as _shadersElevationContourMaterial,fo as _shadersElevationRampMaterial,EllipsoidFS as _shadersEllipsoidFS,EllipsoidSurfaceAppearanceFS as _shadersEllipsoidSurfaceAppearanceFS,EllipsoidSurfaceAppearanceVS as _shadersEllipsoidSurfaceAppearanceVS,EllipsoidVS as _shadersEllipsoidVS,FXAA as _shadersFXAA,FXAA3_11 as _shadersFXAA3_11,po as _shadersFadeMaterial,mo as _shadersFeatureIdStageFS,go as _shadersFeatureIdStageVS,FilmicTonemapping as _shadersFilmicTonemapping,GaussianBlur1D as _shadersGaussianBlur1D,_o as _shadersGeometryStageFS,yo as _shadersGeometryStageVS,GlobeFS as _shadersGlobeFS,GlobeVS as _shadersGlobeVS,Co as _shadersGridMaterial,GroundAtmosphere as _shadersGroundAtmosphere,Ao as _shadersHSBToRGB,So as _shadersHSLToRGB,xo as _shadersImageBasedLightingStageFS,To as _shadersInstancingStageCommon,vo as _shadersInstancingStageVS,IntersectBox as _shadersIntersectBox,IntersectClippingPlanes as _shadersIntersectClippingPlanes,IntersectCylinder as _shadersIntersectCylinder,IntersectDepth as _shadersIntersectDepth,IntersectEllipsoid as _shadersIntersectEllipsoid,IntersectLongitude as _shadersIntersectLongitude,Intersection as _shadersIntersection,IntersectionUtils as _shadersIntersectionUtils,Eo as _shadersLegacyInstancingStageVS,LensFlare as _shadersLensFlare,bo as _shadersLightingStageFS,Po as _shadersMaterialStageFS,Megatexture$1 as _shadersMegatexture,wo as _shadersMetadataStageFS,Do as _shadersMetadataStageVS,Mo as _shadersModelClippingPlanesStageFS,Io as _shadersModelClippingPolygonsStageFS,Ro as _shadersModelClippingPolygonsStageVS,Oo as _shadersModelColorStageFS,Lo as _shadersModelFS,No as _shadersModelSilhouetteStageFS,Fo as _shadersModelSilhouetteStageVS,Vo as _shadersModelSplitterStageFS,Bo as _shadersModelVS,ModifiedReinhardTonemapping as _shadersModifiedReinhardTonemapping,Uo as _shadersMorphTargetsStageVS,NightVision as _shadersNightVision,Go as _shadersNormalMapMaterial,Ho as _shadersOctahedralProjectionAtlasFS,zo as _shadersOctahedralProjectionFS,$o as _shadersOctahedralProjectionVS,Octree as _shadersOctree,PassThrough as _shadersPassThrough,PassThroughDepth as _shadersPassThroughDepth,Wo as _shadersPerInstanceColorAppearanceFS,qo as _shadersPerInstanceColorAppearanceVS,jo as _shadersPerInstanceFlatColorAppearanceFS,Xo as _shadersPerInstanceFlatColorAppearanceVS,Yo as _shadersPointCloudEyeDomeLighting,Qo as _shadersPointCloudStylingStageVS,PointPrimitiveCollectionFS as _shadersPointPrimitiveCollectionFS,PointPrimitiveCollectionVS as _shadersPointPrimitiveCollectionVS,Ko as _shadersPolygonSignedDistanceFS,Zo as _shadersPolylineArrowMaterial,ql as _shadersPolylineColorAppearanceVS,Jo as _shadersPolylineCommon,ea as _shadersPolylineDashMaterial,ta as _shadersPolylineFS,na as _shadersPolylineGlowMaterial,jl as _shadersPolylineMaterialAppearanceVS,ia as _shadersPolylineOutlineMaterial,Xl as _shadersPolylineShadowVolumeFS,Yl as _shadersPolylineShadowVolumeMorphFS,Ql as _shadersPolylineShadowVolumeMorphVS,Kl as _shadersPolylineShadowVolumeVS,ra as _shadersPolylineVS,oa as _shadersPrimitiveOutlineStageFS,aa as _shadersPrimitiveOutlineStageVS,sa as _shadersRGBToHSB,ca as _shadersRGBToHSL,la as _shadersRGBToXYZ,ReinhardTonemapping as _shadersReinhardTonemapping,da as _shadersReprojectWebMercatorFS,ua as _shadersReprojectWebMercatorVS,ha as _shadersRimLightingMaterial,fa as _shadersSelectedFeatureIdStageCommon,Zl as _shadersShadowVolumeAppearanceFS,Jl as _shadersShadowVolumeAppearanceVS,pa as _shadersShadowVolumeFS,Silhouette as _shadersSilhouette,ma as _shadersSkinningStageVS,SkyAtmosphereCommon as _shadersSkyAtmosphereCommon,SkyAtmosphereFS as _shadersSkyAtmosphereFS,SkyAtmosphereVS as _shadersSkyAtmosphereVS,SkyBoxFS as _shadersSkyBoxFS,SkyBoxVS as _shadersSkyBoxVS,ga as _shadersSlopeRampMaterial,_a as _shadersStripeMaterial,SunFS as _shadersSunFS,SunTextureFS as _shadersSunTextureFS,SunVS as _shadersSunVS,TexturedMaterialAppearanceFS as _shadersTexturedMaterialAppearanceFS,TexturedMaterialAppearanceVS as _shadersTexturedMaterialAppearanceVS,ya as _shadersVector3DTileClampedPolylinesFS,Ca as _shadersVector3DTileClampedPolylinesVS,Aa as _shadersVector3DTilePolylinesVS,Sa as _shadersVectorTileVS,xa as _shadersVerticalExaggerationStageVS,ViewportQuadFS as _shadersViewportQuadFS,ViewportQuadVS as _shadersViewportQuadVS,VoxelFS as _shadersVoxelFS,VoxelUtils as _shadersVoxelUtils,VoxelVS as _shadersVoxelVS,Ta as _shadersWater,va as _shadersXYZToRGB,Ea as _shadersacesTonemapping,ba as _shadersalphaWeight,Pa as _shadersantialias,wa as _shadersapplyHSBShift,Da as _shadersapproximateSphericalCoordinates,Ma as _shadersapproximateTanh,Ia as _shadersbackFacing,Ra as _shadersbranchFreeTernary,Oa as _shaderscascadeColor,La as _shaderscascadeDistance,Na as _shaderscascadeMatrix,Fa as _shaderscascadeWeights,Va as _shadersclipPolygons,ka as _shaderscolumbusViewMorph,Ba as _shaderscomputeAtmosphereColor,Ua as _shaderscomputeGroundAtmosphereScattering,Ga as _shaderscomputePosition,Ha as _shaderscomputeScattering,convertUvToBox as _shadersconvertUvToBox,convertUvToCylinder as _shadersconvertUvToCylinder,convertUvToEllipsoid as _shadersconvertUvToEllipsoid,za as _shaderscosineAndSine,$a as _shadersdecompressTextureCoordinates,Wa as _shadersdegreesPerRadian,qa as _shadersdepthClamp,ja as _shadersdepthRange,Xa as _shadersdepthRangeStruct,Ya as _shaderseastNorthUpToEyeCoordinates,Qa as _shadersellipsoidContainsPoint,Ka as _shadersellipsoidTextureCoordinates,Za as _shadersepsilon1,Ja as _shadersepsilon2,es as _shadersepsilon3,ts as _shadersepsilon4,ns as _shadersepsilon5,is as _shadersepsilon6,rs as _shadersepsilon7,os as _shadersequalsEpsilon,as as _shaderseyeOffset,ss as _shaderseyeToWindowCoordinates,cs as _shadersfastApproximateAtan,ls as _shadersfog,ds as _shadersgammaCorrect,us as _shadersgeodeticSurfaceNormal,hs as _shadersgetDefaultMaterial,fs as _shadersgetDynamicAtmosphereLightDirection,ps as _shadersgetLambertDiffuse,ms as _shadersgetSpecular,gs as _shadersgetWaterNoise,_s as _shadershue,ys as _shadersinfinity,Cs as _shadersinverseGamma,As as _shadersisEmpty,Ss as _shadersisFull,xs as _shaderslatitudeToWebMercatorFraction,Ts as _shaderslineDistance,vs as _shaderslinearToSrgb,Es as _shadersluminance,bs as _shadersmaterial,Ps as _shadersmaterialInput,ws as _shadersmaximumComponent,Ds as _shadersmetersPerPixel,Ms as _shadersmodelMaterial,Is as _shadersmodelToWindowCoordinates,Rs as _shadersmodelVertexOutput,Os as _shadersmultiplyWithColorBalance,Ls as _shadersnearFarScalar,Ns as _shadersoctDecode,Fs as _shadersoneOverPi,Vs as _shadersoneOverTwoPi,ks as _shaderspackDepth,Bs as _shaderspassCesium3DTile,Us as _shaderspassCesium3DTileClassification,Gs as _shaderspassCesium3DTileClassificationIgnoreShow,Hs as _shaderspassClassification,zs as _shaderspassCompute,$s as _shaderspassEnvironment,Ws as _shaderspassGlobe,qs as _shaderspassOpaque,js as _shaderspassOverlay,Xs as _shaderspassTerrainClassification,Ys as _shaderspassTranslucent,Qs as _shaderspassVoxels,Ks as _shaderspbrLighting,Zs as _shadersphong,Js as _shaderspi,ec as _shaderspiOverFour,tc as _shaderspiOverSix,nc as _shaderspiOverThree,ic as _shaderspiOverTwo,rc as _shadersplaneDistance,oc as _shaderspointAlongRay,ac as _shadersradiansPerDegree,sc as _shadersray,cc as _shadersrayEllipsoidIntersectionInterval,lc as _shadersraySegment,dc as _shadersraySphereIntersectionInterval,uc as _shadersreadDepth,hc as _shadersreadNonPerspective,fc as _shadersreverseLogDepth,pc as _shadersround,mc as _shaderssampleOctahedralProjection,gc as _shaderssaturation,_c as _shaderssceneMode2D,yc as _shaderssceneMode3D,Cc as _shaderssceneModeColumbusView,Ac as _shaderssceneModeMorphing,Sc as _shadersshadowDepthCompare,xc as _shadersshadowParameters,Tc as _shadersshadowVisibility,vc as _shaderssignNotZero,Ec as _shaderssolarRadius,bc as _shaderssphericalHarmonics,Pc as _shaderssrgbToLinear,wc as _shaderstangentToEyeSpaceMatrix,Dc as _shaderstextureCube,Mc as _shadersthreePiOver2,Ic as _shaderstransformPlane,Rc as _shaderstranslateRelativeToEye,Oc as _shaderstranslucentPhong,Lc as _shaderstranspose,Nc as _shaderstwoPi,Fc as _shadersunpackClippingExtents,Vc as _shadersunpackDepth,kc as _shadersunpackFloat,Bc as _shadersunpackUint,Uc as _shadersvalueTransform,Gc as _shadersvertexLogDepth,Hc as _shaderswebMercatorMaxLatitude,zc as _shaderswindowToEyeCoordinates,$c as _shaderswriteDepthClamp,Wc as _shaderswriteLogDepth,qc as _shaderswriteNonPerspective,jc as addBuffer,Xc as addDefaults,Yc as addExtensionsRequired,Qc as addExtensionsUsed,Kc as addPipelineExtras,Zc as addToArray,Jc as appendForwardSlash,arrayRemoveDuplicates,barycentricCoordinates,binarySearch,el as buildDrawCommand,buildModuleUrl,buildVoxelDrawCommands,clone,combine$2 as combine,computeFlyToLocationForRectangle,createBillboardPointCallback,createCommand,createDefaultImageryProviderViewModels,createDefaultTerrainProviderViewModels,createElevationBandMaterial,createGooglePhotorealistic3DTileset,createGuid,ed as createMaterialPropertyDescriptor,createOsmBuildingsAsync,createPropertyDescriptor,createRawPropertyDescriptor,createTangentSpaceDebugPrimitive,createTaskProcessorWorker,tl as createUniform,nl as createUniformArray,createWorldBathymetryAsync,createWorldImageryAsync,createWorldTerrainAsync,decodeGoogleEarthEnterpriseData,il as decodeVectorPolylinePositions,defaultValue,defer,defined,rl as demodernizeShader,deprecationWarning,destroyObject,td as exportKml,ol as findAccessorMinMax,al as findContentMetadata,sl as findGroupMetadata,cl as findTileMetadata,ll as forEachTextureInMaterial,formatError,dl as freezeRenderState,ul as getAbsoluteUri,hl as getAccessorByteStride,fl as getBaseUri,pl as getBinaryAccessor,getClipAndStyleCode,getClippingFunction,ml as getComponentReader,getElement,getExtensionFromUri,getFilenameFromUri,getImageFromTypedArray,getImagePixels,getJsonFromTypedArray,gl as getMagic,_l as getStringFromTypedArray,getTimestamp,hasExtension,heightReferenceOnEntityPropertyChanged,isBitSet,yl as isBlobUri,Cl as isCrossOriginUrl,Al as isDataUri,Sl as isLeapYear,knockout,knockout as knockout_3_5_1,knockout_es5,loadAndExecuteScript,loadCubeMap,loadImageFromTypedArray,loadKTX2,mergeSort,xl as moveTechniqueRenderStates,Tl as moveTechniquesToExtension,vl as numberOfComponentsForType,objectToQuery,oneTimeWarning,El as parseBatchTable,bl as parseFeatureMetadataLegacy,Pl as parseGlb,wl as parseResponseHeaders,Dl as parseStructuralMetadata,Ml as pickModel,pointInsideTriangle,preprocess3DTileContent,processVoxelProperties,queryToObject,Il as readAccessorPacked,Rl as removeExtension,Ol as removeExtensionsRequired,Ll as removeExtensionsUsed,Nl as removePipelineExtras,Fl as removeUnusedElements,resizeImageToNextPowerOfTwo,sampleTerrain,sampleTerrainMostDetailed,Vl as scaleToGeodeticSurface,srgbToLinear,kl as subdivideArray,subscribeAndEvaluate,Bl as updateAccessorComponentTypes,Ul as updateVersion,Gl as usesExtension,viewerCesium3DTilesInspectorMixin,viewerCesiumInspectorMixin,viewerDragDropMixin,viewerPerformanceWatchdogMixin,viewerVoxelInspectorMixin,webGLConstantToGlslType,wrapFunction,writeTextToCanvas};
//# sourceMappingURL=Cesium-IcF9fkAD.js.map
